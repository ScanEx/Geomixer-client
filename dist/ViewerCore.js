/** Загрузчик модулей ГеоМиксера
Позволяет загружать модули из разных файлов. 
Модуль - единица кода, имеющая уникальное имя и зависящая от других модулей и скриптов.
@namespace
*/

var gmxCore = function() 
{
    var _callbacks = [];
    var _modules = {}; //null - файл модуля уже загружается, но сам модуль пока не доступен
    var _globalNamespace = this;
	var _modulesDefaultHost = "";
	var _modulePathes = {/*#buildinclude<modules_path.txt>*/};
	var _moduleFiles = {/*#buildinclude<module_files.txt>*/};
    
    var getScriptURL = function(scriptName)
	{
        scriptName = scriptName.toLowerCase();
		var scripts1 = document.getElementsByTagName("script");
		for (var i = 0; i < scripts1.length; i++)
		{
			var src = scripts1[i].getAttribute("src");
			if (src && (src.toLowerCase().indexOf(scriptName) != -1))
				return src;
		}
		return false;
	}
    
    //производится регистронезависимое сравнение
	var getScriptBase = function(scriptName)
	{
        scriptName = scriptName.toLowerCase();
		var url = getScriptURL(scriptName);
		return url ? url.toLowerCase().substring(0, url.toLowerCase().indexOf(scriptName)) : "";
	}
    
    var invokeCallbacks = function()
    {
        for (var k = 0; k < _callbacks.length; k++)
        {
            var isAllModules = true;
            var curModules = _callbacks[k].modules;
			var modules = [];
            for (var m = 0; m < curModules.length; m++)
			{
                if ( !_modules[curModules[m]] )
                {
                    isAllModules = false;
                    break;
                }
				modules.push(_modules[curModules[m]]);
			}
                
            if (isAllModules)
            {
                var curCallback = _callbacks[k].callback;
                
                //first delete, then callback!
                _callbacks.splice(k, 1);
                k = k - 1;
                curCallback.apply(null, modules);
            }
        }
    }
    var LABjsDeferred = null;
    var lazyLoadLABjs = function()
    {
        if (!LABjsDeferred) {
            LABjsDeferred = $.Deferred();
            
            //load LAB.js (snippest from its website)
            (function(g,b,d){var c=b.head||b.getElementsByTagName("head"),D="readyState",E="onreadystatechange",F="DOMContentLoaded",G="addEventListener",H=setTimeout;
            H(function(){if("item"in c){if(!c[0]){H(arguments.callee,25);return}c=c[0]}var a=b.createElement("script"),e=false;a.onload=a[E]=function(){if((a[D]&&a[D]!=="complete"&&a[D]!=="loaded")||e){return false}a.onload=a[E]=null;e=true;LABjsDeferred.resolve()};

            a.src = ( getScriptBase('gmxcore.js') || window.gmxJSHost || "" ) + 'LAB.min.js';

            c.insertBefore(a,c.firstChild)},0);if(b[D]==null&&b[G]){b[D]="loading";b[G](F,d=function(){b.removeEventListener(F,d,false);b[D]="complete"},false)}})(this,document);
        
        }
        
        return LABjsDeferred.promise();
    }
    
    var cssLoader = null;
    
    var withCachePostfix = function(filename) {
        var sym = filename.indexOf('?') === -1 ? '?' : '&';
        if (window.gmxDropBrowserCache) {
            filename += sym + Math.random();
        } else if (window.nsGmx && nsGmx.buildGUID){
            filename += sym + nsGmx.buildGUID;
        }
        
        return filename;
    }
    
    var publicInterface = 
    /** @lends gmxCore */
    {
        /** Добавить новый модуль
        * @param {String} moduleName Уникальное имя модуля
        * @param {Object|Function} moduleObj Тело модуля или ф-ция, возвращающая тело. Аргумент ф-ции - путь к модулю. Будет вызвана после загрузки всех зависимостей.
        * @param {Object} [options] Дополнительные параметры модуля
        * @param {String[]} [options.require] Какие модули должны быть загрежены перед данным
        * @param {Function} [options.init] Ф-ция для инициализации модуля. Сигнатура: function (moduleObj, modulePath)->{void|{@link jQuery.Deferred}}. Если ф-ция возвращает {@link jQuery.Deferred}, загрузчик будет ждать его для окончания инициализации.
        * @param {String|String[]} [options.css] CSS файлы для загрузки. Пути к CSS указываются относительно файла текущего модуля.
        */
        addModule: function(moduleName, moduleObj, options)
        {
            var requiredModules = (options && 'require' in options) ? options.require : [];
            var initDeferred = null;
            var _this = this;
            
            for (var r = 0; r < requiredModules.length; r++)
                this.loadModule( requiredModules[r] );
                
            this.addModulesCallback( requiredModules, function()
            {

                if (options && 'init' in options)
				{
                    initDeferred = options.init(moduleObj, _modulePathes[moduleName]);
				}
                
                if (options && 'css' in options)
				{
                    var cssFiles = typeof options.css === 'string' ? [options.css] : options.css;
                    var path = _modulePathes[moduleName] || window.gmxJSHost || "";
                    
                    for (var iF = 0; iF < cssFiles.length; iF++)
                        _this.loadCSS(withCachePostfix(path + cssFiles[iF]));
				}

                var doAdd = function() {
                    if (typeof moduleObj === 'function') {
                        moduleObj = moduleObj( _modulePathes[moduleName] );
                    }
                    _modules[moduleName] = moduleObj;
                    invokeCallbacks();
                }
                
                if (initDeferred) {
                    initDeferred.done(doAdd);
                } else {
                    doAdd();
                }
            });
        },
        
        /** Загрузить модуль
        * @param { String } moduleName Имя модуля для загрузки
        * @param { String } [moduleSource] Имя файла, откуда загружать модуль. Если не указан, будет сформирован в виде (defaultHost + moduleName + '.js')
        * @param { Function } [callback] Ф-ция, которая будет вызвана после загрузки и инициализации. В ф-цию первым параметром передаётся тело модуля
        * @return { jQuery.Deferred } Promise, который будет resolve при загрузке модуля (параметр - модуль).
        */
        loadModule: function(moduleName, moduleSource, callback)
        {
            var def = $.Deferred();
            
            if (typeof moduleSource === 'function') {
                callback = moduleSource;
                moduleSource = undefined;
            }
            
            this.addModulesCallback([moduleName], function(module)
            {
                callback && callback(module);
                def.resolve(module);
            });
            
            if ( ! (moduleName in _modules) )
            {
                _modules[moduleName] = null;
                
                var headElem = document.getElementsByTagName("head")[0];
                var newScript = document.createElement('script');
                
                var path;
                if (typeof moduleSource != 'undefined')
                {
                    path = moduleSource.match(/^http:\/\//i) ? moduleSource : (window.gmxJSHost || "") + moduleSource;
                }
                else
                {
                    path = (moduleName in _moduleFiles) ? _moduleFiles[moduleName] : (_modulesDefaultHost || window.gmxJSHost || "") + moduleName + '.js';
                }

                var pathRegexp = /(.*)\/[^\/]+/;
                if ( typeof _modulePathes[moduleName] === 'undefined' )
                    _modulePathes[moduleName] = pathRegexp.test(path) ? path.match(pathRegexp)[1] + "/" : "";
				
                var pathPostfix = "";
                
                newScript.onerror = function() {
                    def.reject();
                }
                
                newScript.type = 'text/javascript';
                newScript.src = withCachePostfix(path);
                newScript.charset = "utf-8";
                headElem.appendChild(newScript);
            }
            
            return def;
        },
        
        /** Добавить callback, который будет вызван после загрузки моделей
        *
        * Если модули уже загружены, callback будет вызван сразу же
        *
        * @param {Array} moduleNames Массив имён модулей
        * @param {Function} callback Ф-ция, которую нужно вызвать после загрузки. В качестве аргументов в ф-цию передаются загруженные модули
        */
        addModulesCallback: function( moduleNames, callback )
        {
            _callbacks.push({modules: moduleNames, callback: callback});
            invokeCallbacks();
        },
        
        /** Получить модуль по имени.
        *
        * @param {String} moduleName Имя модуля
        * @return {Object} Тело модуля. Если модуль не загружен, вернётся null.
        */
        getModule: function(moduleName)
        {
            return _modules[moduleName] || null;
        },
		
        /** Установить дефольный путь к модулям. Используется если указан локальный файл модуля.
        * @param {String} defaultHost Дефолтный путь у модулям.
        */
		setDefaultModulesHost: function( defaultHost )
		{
			_modulesDefaultHost = defaultHost;
		},
        
        /** Явно задать полный путь к модулю
        * @param {String} moduleName Имя модуля
        * @param {String} defaultHost Путь к файлу модулю. При загрузке модуля будет загружен файл по указанному пути
        */
        setModuleFile: function(moduleName, moduleFile)
        {
            _moduleFiles[moduleName] = moduleFile;
        },
		
        pushModule2GlobalNamespace: function(moduleName)
        {
            if ( !_modules[moduleName] ) return;
            var module = _modules[moduleName];
            
            for (var p in module)
                _globalNamespace[p] = module[p];
        },
		
        /** Получить путь к директории, из которой был загружен модуль.
        * @param {String} moduleName Имя модуля
        * @returns {String} Путь к директории, из которой был загружен модуль. Для не загруженных модулей ничего не возвращает
        */
		getModulePath: function(moduleName)
		{
			return _modulePathes[moduleName];
		},
        
        /** Возвращает ф-цию, которая делает следующее:
        *
        *  - Если модуль moduleName не загружен, загружает его
        *  - Потом просто вызывает ф-цию с именем functionName из этого модуля, передав ей все свои параметры
        *
        *  - Возвращённая ф-ция при вызове возвращает jQuery.Promise, который будет resolve с параметрами, возвращёнными исходной ф-цией из модуля
        * @param {String} moduleName Имя модуля
        * @param {String} functionName Название ф-ции внутри модуля
        * @param {Function} callback Ф-ция, которая будет вызвана после того, как отработает ф-ция модуля. В callback будет передан ответ исходной ф-ции.
        */
        createDeferredFunction: function(moduleName, functionName, callback)
        {
            var _this = this;
            return function()
            {
                var deferred = $.Deferred();
                var args = arguments;
                _this.loadModule(moduleName).done(function(module)
                {
                    var res = module[functionName].apply(this, args);
                    callback && callback(res);
                    deferred.resolve(res);
                });
                
                return deferred.promise();
            }
        },
        
        /** Загружает скрипт после предвариетельной проверки условий.
        *
        * @param {Array} filesInfo Массив объектов со следующими свойствами:
        *
        *   * check: function() -> Bool. Если возвращает true, ни js ни css не будет загружены
        *   * script: String. Не обязательно. Скрипт для загрузки, если провалится проверка
        *   * css: String | String[]. Не обязательно. CSS файл(ы) для загрузки, если провалится проверка
        *   @returns {jQuery.Deferred} Deferred, который будет разрешён когда все скрипты выполнятся (окончание загрузки css не отслеживается)
        */
        loadScriptWithCheck: function(filesInfo)
        {
            var _this = this;
            var localFilesInfo = filesInfo.slice(0);
            var def = $.Deferred();
            
            var doLoad = function(info)
            {
                if (localFilesInfo.length > 0)
                {
                    var curInfo = localFilesInfo.shift();
                    if (curInfo.check())
                        doLoad()
                    else
                    {
                        var css = curInfo.css || [];
                        if (typeof css === 'string') {
                            css = [css];
                        }
                        css.forEach(_this.loadCSS);
                        
                        if (curInfo.script)
                            _this.loadScript(curInfo.script).then(doLoad);
                        else
                            doLoad();
                    }
                }
                else
                    def.resolve();
            }
            
            doLoad();
            return def.promise();
        },
        
        /**
        * Загружает отдельный скрипт
        * @param {String} fileName Имя файла скрипта
        * @param {function} [callback] Ф-ция, которая будет вызвана после загрузки
        * @param {String} [charset=utf-8] Кодировка загружаемого файла
        * @returns {jQuery.Deferred}
        */
        loadScript: function(fileName, callback, charset)
        {
            var def = $.Deferred();
            lazyLoadLABjs().done(function()
            {
                var descr = {src: withCachePostfix(fileName)};
                if (charset) {
                    descr.charset = charset;
                }
                
                $LAB.script(descr).wait(function()
                {
                    def.resolve();
                    callback && callback();
                })
            })
            return def.promise();
        }, 
        
        /** Загрузить отдельный css файл
        * @param {String} cssFilename Имя css файла.
        */
        loadCSS: function(cssFilename)
        {
            var doLoadCss = function()
            {
                $.getCSS(withCachePostfix(cssFilename));
            }
            
            if ('getCSS' in $)
            {
                doLoadCss()
            }
            else
            {
                if (!cssLoader)
                {
                    var path = getScriptBase('gmxcore.js') || window.gmxJSHost || "";
                    cssLoader = $.getScript(path + "jquery/jquery.getCSS.js");
                }
                
                cssLoader.done(doLoadCss);
            }
        }
    }
    
    return publicInterface;
}();
window.nsGmx = window.nsGmx || {};
nsGmx._defaultPlugins =
[
    {pluginName: 'Media Plugin',         file: 'plugins/external/GMXPluginMedia/MediaPlugin2.js',        module: 'MediaPlugin2',       mapPlugin: false, isPublic: true},
    {pluginName: 'Timeline Vectors', file: 'plugins/external/GMXPluginTimeLine/L.Control.gmxTimeLine.js', module: 'gmxTimeLine', mapPlugin: false, isPublic: false, lazyLoad: true},
        { pluginName: 'AISSearch', file: 'plugins/AIS/AISSearch/AISSearch.js', module: 'AISSearch', mapPlugin: true },
        // { pluginName: 'FieldsTablePlugin', file: 'plugins/agro_plugins_api_v2/fieldsTable/main.js', module: 'FieldsTablePlugin' },
    // {pluginName: 'TimeSlider', file: 'plugins/TimeSlider/TimeSlider.js', module: 'TimeSlider', mapPlugin: true, isPublic: true},
    // {pluginName: 'AttributionMenu', file: 'plugins/AttributionMenu/AttributionMenu.js', module: 'AttributionMenu', mapPlugin: true, isPublic: true},
    // {pluginName: 'Fire Plugin',          file: 'plugins/fireplugin/FirePlugin.js',                               module: 'FirePlugin',        mapPlugin: true,  isPublic: true},
    // {pluginName: 'Shift Rasters Plugin', file: 'plugins/shiftrasters/ShiftRasterPlugin.js',              module: 'ShiftRastersPlugin', mapPlugin: true,  isPublic: true},
    {pluginName: 'Cadastre',             file: 'plugins/external/GMXPluginCadastre/cadastre.js',         module: 'cadastre',           mapPlugin: true,  isPublic: true, params: {notHideDrawing: true}},
    // {pluginName: 'ScanEx catalog',       file: '../GeoMixerModules/catalog/CatalogPlugin.js',            module: 'Catalog',            mapPlugin: true,  isPublic: true},
    // {pluginName: 'GIBS Plugin',          file: 'plugins/gibs/GIBSPlugin.js',                             module: 'GIBSPlugin',         mapPlugin: true,  isPublic: true},
    // {pluginName: 'BufferPlugin',         file: 'plugins/external/GMXPluginBuffer/BufferPlugin.js',       module: 'BufferPlugin',       mapPlugin: true,  isPublic: true},
    // {pluginName: 'Wind Plugin',       file: 'plugins/windplugin/WindPlugin.js',                 module: 'WindPlugin',      mapPlugin: true,  isPublic: true},
    // {pluginName: 'Weather Grid Plugin',  file: 'plugins/weathergridplugin/WeatherGridPlugin.js',         module: 'WeatherGridPlugin',  mapPlugin: false,  isPublic: true},
    // {pluginName: 'HelloWorld',            file: 'plugins/HelloWorld/HelloWorld.js', module: 'HelloWorld',    mapPlugin: true,  isPublic: true},
    // {pluginName: 'Wikimapia',            file: 'plugins/external/GMXPluginWikimapia/WikimapiaPlugin.js', module: 'WikimapiaPlugin',    mapPlugin: true,  isPublic: true,
        // params: {key: "A132989D-3AE8D94D-5EEA7FC1-E4D5F8D9-4A59C8A4-7CF68948-338BD8A8-611ED12", proxyUrl:""}
    // }
];

(function(){

//внутреннее представление плагина
var Plugin = function(moduleName, file, body, params, pluginName, mapPlugin, isPublic, lazyLoad)
{
    var usageState = mapPlugin && !lazyLoad ? 'unknown' : 'used'; //used, notused, unknown
    var _this = this;

    var doLoad = function()
    {
        if (_this.body || _this.isLoading)
            return;

        _this.isLoading = true;
        gmxCore.loadModule(moduleName, file).then(function()
        {
            _this.body = gmxCore.getModule(moduleName);
            _this.isLoading = false;
            _this.pluginName = _this.pluginName || _this.body.pluginName;
            _this.def.resolve();
        }, function() {
            _this.isLoading = false;
            _this.def.reject();
        });
    }

    this.body = body;
    this.moduleName = moduleName;
    this.params = params || {};
    this.def = $.Deferred(); //будет resolve когда плагин загрузится
    this.isLoading = false;
    this.mapPlugin = mapPlugin || (body && body.pluginName);
    this.pluginName = pluginName || (this.body && this.body.pluginName);
    this.isPublic = isPublic;
    this.lazyLoad = lazyLoad;
    this.file = file;

    if (this.body)
        this.def.resolve();

    //мы не будем пока загружать плагин только если он не глобальный и имеет имя
    // и только если специально не указана загрузка по требованию
    if (!mapPlugin || !pluginName) {
        if (!lazyLoad) {
            doLoad();
        }
    }

    this.setUsage = function(usage)
    {
        usageState = usage;
        if (usageState === 'used') {
            doLoad();
        }
    }

    this.isUsed = function()
    {
        return usageState === 'used';
    }

    this.updateParams = function (newParams) {
        $.extend(true, _this.params, newParams);
    }
}

/**
  @name IGeomixerPlugin
  @desc Интерфейс плагинов ГеоМиксера
  @class
  @abstract
  @property {String} pluginName Имя плагина для списка плагинов
*/

/**
  @memberOf IGeomixerPlugin.prototype
  @method
  @name beforeMap
  @desc Вызывется сразу после загрузки всех модулей ядра вьюера (до инициализации карты, проверки пользователя и т.п.).
        Ещё нет информации о пользователе, но пока можно сменить карту для загрузки.
  @param {Object} params Параметры плагина
*/

/**
  @memberOf IGeomixerPlugin.prototype
  @method
  @name preloadMap
  @desc Вызывется непосредственно перед началом создания слоёв по загруженной информации о карте.
        Карту сменить уже нельзя, но можно как-нибудь повлиять на процесс создания слоёв (например, добавить новые классы слоёв)
  @param {Object} params Параметры плагина
*/

/**
  @memberOf IGeomixerPlugin.prototype
  @method
  @name beforeViewer
  @desc вызовется до начала инициализации ГеоМиксера, но сразу после инициализации карты
  @param {Object} params Параметры плагина
  @param {gmxAPI.Map} map Основная карта
*/

/**
  @memberOf IGeomixerPlugin.prototype
  @method
  @name afterViewer
  @desc вызовется после окончания инициализации ГеоМиксера
  @param {Object} params Параметры плагина
  @param {gmxAPI.Map} map Основная карта
*/

/** Менеджер плагинов. Загружает плагины из конфигурационного файла
*
* Загрузка плагинов происходит из массива window.gmxPlugins.
*
* Каждый элемент этого массива - объект со следующими свойствами:
*
*   * module (имя модуля)
*   * file (из какого файла подгружать модуль, может отсутствовать). Только если указано module
*   * plugin (сам плагин). Если указано, плагин подгружается в явном виде, иначе используется module (и file)
*   * params - объект параметров, будет передаваться в методы модуля
*   * pluginName - имя плагина. Должно быть уникальным. Заменяет IGeomixerPlugin.pluginName. Не рекомендуется использовать без особых причин
*   * mapPlugin {bool, default: true} - является ли плагин плагином карт. Если является, то не будет грузиться по умолчанию.
*   * isPublic {bool, default: false} - нужно ли показывать плагин в списках плагинов (для некоторых плагинов хочется иметь возможность подключать их к картам, но не показывать всем пользователям)
*
* Если очередной элемент массива просто строка (например, "name"), то это эквивалентно {module: "name", file: "plugins/name.js"}
*
* Каждый плагин хранится в отдельном модуле (через свойство module) или подгружается в явном виде (через свойство plugin). Модуль должен реализовывать интерфейс IGeomixerPlugin.
*  @class PluginsManager
*/
var PluginsManager = function()
{
    var _plugins = [];
    var _pluginsWithName = {};

    var joinedPluginInfo = {};

    //сначала загружаем инфу о плагинах из переменной nsGmx._defaultPlugins - плагины по умолчанию
    window.nsGmx && nsGmx._defaultPlugins && $.each(nsGmx._defaultPlugins, function(i, info) {
        if (typeof info === 'string') {
            info = { module: info, file: 'plugins/' + info + '.js' };
        }
        joinedPluginInfo[info.module] = info;
    })

    //дополняем её инфой из window.gmxPlugins с возможностью перезаписать
    window.gmxPlugins && $.each(window.gmxPlugins, function(i, info) {
        if (typeof info === 'string') {
            info = { module: info, file: 'plugins/' + info + '.js' };
        }
        joinedPluginInfo[info.module] = $.extend(true, joinedPluginInfo[info.module], info);
    })

    $.each(joinedPluginInfo, function(key, info) {
        if (typeof info === 'string')
            info = { module: info, file: 'plugins/' + info + '.js' };

        var plugin = new Plugin(
            info.module,
            info.file,
            info.plugin,
            info.params,
            info.pluginName,
            info.mapPlugin,
            info.isPublic || false,
            info.lazyLoad || false
        );

        _plugins.push(plugin);

        if (plugin.pluginName) {
            _pluginsWithName[ plugin.pluginName ] = plugin;
        }
        else
        {
            plugin.def.done(function()
            {
                if (plugin.pluginName) {
                    _pluginsWithName[ plugin.pluginName ] = plugin;
                }
            })
        }
    })

    var _genIterativeFunction = function(funcName)
    {
        return function(map)
        {
            for (var p = 0; p < _plugins.length; p++)
                if ( _plugins[p].isUsed() && _plugins[p].body && _plugins[p].body[funcName]) {
                    //передаём в плагин deep clone параметров, чтобы плагин не мог их менять in-place
                    var params = $.extend(true, {}, _plugins[p].params);
                    try {
                        _plugins[p].body[funcName]( params, map || nsGmx.leafletMap );
                    } catch (e) {
                        console && console.error('Error in function ' + funcName + '() of plugin ' + _plugins[p].moduleName + ': ' + e);
                        console && console.error(e.stack);
                    }
                }
        }
    }

    //public interface

    /**
    Вызывет callback когда будут загружены все плагины, загружаемые в данный момент
    @memberOf PluginsManager
     @name done
     @method
     @param {Function} callback Ф-ция, которую нужно будет вызвать
    */

    this.done = function(f) {
        //не можем использовать $.when, так как при первой ошибке результирующий promise сразу же reject'ится, а нам нужно дождаться загрузки всех плагинов
        var loadingPlugins = _.where(_plugins, {isLoading: true}),
            count = loadingPlugins.length;

        count || f();

        loadingPlugins.forEach(function(plugin) {
            plugin.def.always(function() {
                --count || f();
            })
        })
    }

    /**
     Вызывает beforeMap() у всех плагинов
     @memberOf PluginsManager
     @name beforeMap
     @method
    */
    this.beforeMap = _genIterativeFunction('beforeMap');

    /**
     Вызывает preloadMap() у всех плагинов
     @memberOf PluginsManager
     @name preloadMap
     @method
    */
    this.preloadMap = _genIterativeFunction('preloadMap');

    /**
     Вызывает beforeViewer() у всех плагинов
     @memberOf PluginsManager
     @name beforeViewer
     @method
    */
    this.beforeViewer = _genIterativeFunction('beforeViewer');

    /**
     Вызывает afterViewer() у всех плагинов
     @memberOf PluginsManager
     @name afterViewer
     @method
    */
    this.afterViewer = _genIterativeFunction('afterViewer');

    /**
     Добавляет пункты меню всех плагинов к меню upMenu
     Устарело! Используйте непосредственное добавление элемента к меню из afterViewer()
     @method
     @ignore
    */
    this.addMenuItems = function( upMenu )
    {
        for (var p = 0; p < _plugins.length; p++) {
            if ( _plugins[p].isUsed() && _plugins[p].body && _plugins[p].body.addMenuItems) {
                var menuItems = _plugins[p].body.addMenuItems();
                for (var i = 0; i < menuItems.length; i++)
                    upMenu.addChildItem(menuItems[i].item, menuItems[i].parentID);
            }
        }
    };

    /**
     Вызывает callback(plugin) для каждого плагина
     @memberOf PluginsManager
     @name forEachPlugin
     @method
     @param {Function} callback Ф-ция для итерирования. Первый аргумент ф-ции - модуль плагина.
    */
    this.forEachPlugin = function(callback)
    {
        //if (!_initDone) return;
        for (var p = 0; p < _plugins.length; p++)
            callback(_plugins[p]);
    }

    /**
     Задаёт, нужно ли в дальнейшем использовать данный плагин
     @memberOf PluginsManager
     @name setUsePlugin
     @method
     @param {String} pluginName Имя плагина
     @param {Bool} isInUse Использовать ли его для карты
    */
    this.setUsePlugin = function(pluginName, isInUse)
    {
        if (pluginName in _pluginsWithName)
            _pluginsWithName[pluginName].setUsage(isInUse ? 'used' : 'notused');
    }

    /**
     Получить плагин по имени
     @memberOf PluginsManager
     @name getPluginByName
     @method
     @param {String} pluginName Имя плагина
     @returns {IGeomixerPlugin} Модуль плагина, ничего не возвращает, если плагина нет
    */
    this.getPluginByName = function(pluginName)
    {
        return _pluginsWithName[pluginName];
    }

    /**
     Проверка публичности плагина (можно ли его показывать в различных списках с перечислением подключенных плагинов)
     @memberOf PluginsManager
     @name isPublic
     @method
     @param {String} pluginName Имя плагина
     @returns {Bool} Является ли плагин публичным
    */
    this.isPublic = function(pluginName)
    {
        return _pluginsWithName[pluginName] && _pluginsWithName[pluginName].isPublic;
    }

    /**
     Обновление параметров плагина
     @memberOf PluginsManager
     @name updateParams
     @method
     @param {String} pluginName Имя плагина
     @param {Object} newParams Новые параметры плагина. Параметры с совпадающими именами будут перезатёрты
    */
    this.updateParams = function(pluginName, newParams) {
        _pluginsWithName[pluginName] && _pluginsWithName[pluginName].updateParams(newParams);
    }
}

var publicInterface = {PluginsManager : PluginsManager};
gmxCore.addModule('PluginsManager', publicInterface);

})();

!function(){
var translationsHash = function()
{
	this.hash = {};
	
	this.flags = {};
	
	this.titles = {};
    
    this._errorHandlers = [];
}

var DEFAULT_LANGUAGE = 'rus';

//Для запоминания выбора языка пользователем используются куки. 
//Запоминается выбор для каждого pathname, а не только для домена целиком
//Формат куки: pathname1=lang1&pathname2=lang2&...
var _parseLanguageCookie = function()
{
    var text = readCookie("language");
    
    if (!text) 
        return {};
    
    var items = text.split('&');

    //поддержка старого формата кук (просто названия взыка для всех pathname)
    if (items % 2) items = [];
    
    var langs = {};
    for (var i = 0; i < items.length; i++)
    {
        var elems = items[i].split('=');
        langs[decodeURIComponent(elems[0])] = decodeURIComponent(elems[1]);
    }
    
    return langs;
}

var _saveLanguageCookie = function(langs)
{
    var cookies = [];
    
    for (var h in langs)
    {
        cookies.push(encodeURIComponent(h) + '=' + encodeURIComponent(langs[h]));
    }
    
    eraseCookie("language");
    createCookie("language", cookies.join('&'));
}

var TranslationsManager = function() {
    this.flags = {};
    this.titles = {};
    this.hash = {};
    this._errorHandlers = [];
}

TranslationsManager.prototype._language = null;

TranslationsManager.prototype._addTextWithPrefix = function(prefix, lang, newHash) {
    var res = true,
        hash = this.hash;

    if (!(lang in hash)) {
        hash[lang] = {};
    }

    for (var k in newHash) {
        var fullKey = prefix + k;
        if (fullKey in hash[lang]) {
            res = false;
        } else {
            if (typeof newHash[k] === 'string') {
                hash[lang][fullKey] = newHash[k];
            } else {
                this._addTextWithPrefix(fullKey + '.', lang, newHash[k]);
            }
        }
    }

    return res;
}

/** Добавить строки в словарь локализации
 @func addText
 @memberOf nsGmx.Translations
 @param {String} lang Язык, к которому добавляются строки
 @param {Object} strings Список добавляемых строк. Должен быть объектом, в котором атрибуты являются ключами перевода.
                 Если значение атрибута - строка, то она записывается как результат локализации данного ключа.
                 Если значение атрибута - другой объект, то название текущего атрибута будет добавлено с точкой 
                 к названию атрибутов в этом объекте. Например: {a: {b: 'бэ', c: 'це'}} сформируют ключи локализации 'a.b' и 'a.c'.
*/
TranslationsManager.prototype.addText = function(lang, newHash) {
    this._addTextWithPrefix('', lang, newHash);
}

/** Получить локализованный текст по ключу для текущего языка
 @func getText
 @memberOf nsGmx.Translations
 @param {String} key Ключ локализации
 @return {String} Локализованный текст
*/
TranslationsManager.prototype.getText = function(dictKey) {
    var lang = this.getLanguage(),
        args = arguments,
        getArg = function(i) {
            return args[i + 1] || '';
        };

    if (!this.hash[lang] || !this.hash[lang][dictKey]) {
        this._errorHandlers.forEach(function(handler) {handler(dictKey, lang);});
        return '';
    } else {
        return this.hash[lang][dictKey].replace(/\[value(\d)\]/g, function(match, argIndex) {
            return getArg(Number(argIndex))
        })
    }
}

/** Установить текущий язык
 @func setLanguage
 @memberOf nsGmx.Translations
 @param {String} lang Текущий язык (eng/rus/...)
*/
TranslationsManager.prototype.setLanguage = function(lang) {
    TranslationsManager.prototype._language = lang;
}

/** Получить текущий язык локализации
 @func getLanguage
 @memberOf nsGmx.Translations
 @return {String} Текущий язык (eng/rus/...)
*/
TranslationsManager.prototype.getLanguage = function() {
    return TranslationsManager.prototype._language || 
           (typeof window !== 'undefined' && window.language) || 
           DEFAULT_LANGUAGE;
}

/** Добавить обработчик ошибок локализации. 
    При возникновении ошибок (не определён язык, не найден перевод) будет вызываться каждый из обработчиков
 @func addErrorHandler
 @memberOf nsGmx.Translations
 @param {function(text, lang)} Обработчик ошибки. В ф-цию передаётся текст и язык
*/
TranslationsManager.prototype.addErrorHandler = function(handler) {
    this._errorHandlers.push(handler);
}

/** Считать из кук текущий язык локализации.
 * В куках отдельно записываются языки для каждого pathname, а не только для домена целиком
 @func getLanguageFromCookies
 @memberOf nsGmx.Translations
 @param {String} [pathname] Идентификатор проекта, для которого нужно запомнить куку. По умолчанию `window.location.pathname`.
 @return {String} Язык, записанный в куках для данного pathname
*/
TranslationsManager.prototype.getLanguageFromCookies = function(pathname) {
    return _parseLanguageCookie()[pathname || window.location.pathname];
}

/** Записать в куки текущий язык локализации.
 * В куках отдельно записываются языки для каждого pathname, а не только для домена целиком
 @func updateLanguageCookies
 @memberOf nsGmx.Translations
 @param {String} lang Язык, который нужно записать в куку
 @param {String} [pathname] Идентификатор проекта, для которого нужно запомнить куку. По умолчанию `window.location.pathname`.
*/
TranslationsManager.prototype.updateLanguageCookies = function(lang, pathname) {
    var langs = _parseLanguageCookie();
    langs[pathname || window.location.pathname] = lang;
    _saveLanguageCookie(langs);
}

/** Ф-ции для локализации пользовательского интерфейса
 @namespace nsGmx.Translations
*/

var commonTranslationsManager = new TranslationsManager();
TranslationsManager.commonManager = commonTranslationsManager;

//хелпер для вставки локализованных констант в шаблоны. Например: {{i "layerEditor.dialogTitle"}}
var addHanlebarsHelper = function(Handlebars) {
    Handlebars && Handlebars.registerHelper('i', function(dictKey) {
        return commonTranslationsManager.getText(dictKey);
    });
}

if (typeof define === 'function' && define.amd) {
    define(['handlebars'], function(Handlebars) {
        addHanlebarsHelper(Handlebars);
        return TranslationsManager;
    });
} else {
    addHanlebarsHelper(window.Handlebars);
}

window.nsGmx = window.nsGmx || {};
window.nsGmx.Translations = commonTranslationsManager;

//Поддерживаем обратную совместимость - глобальные объекты _gtxt, _translationsHash, translationsHash
var prev_gtxt = window._gtxt,
    prev_translationsHash = window._translationsHash,
    prevTranslationsHash = window.translationsHash;
    
/** Убирает из глобальной видимости все объекты и ф-ции, связанные с локализацией
 @name noConflicts
 @memberOf nsGmx.Translations
*/
TranslationsManager.prototype.noConflicts = function() {
    window._gtxt = prev_gtxt;
    window._translationsHash = prev_translationsHash;
    window.translationsHash = prevTranslationsHash;
}

//Явно добавляем объекты в глобальную видимость
var DumpClass = function(){};
DumpClass.prototype = commonTranslationsManager;

window._translationsHash = new DumpClass();
_translationsHash.gettext = commonTranslationsManager.getText.bind(commonTranslationsManager),
_translationsHash.addtext = commonTranslationsManager.addText.bind(commonTranslationsManager),
_translationsHash.showLanguages = function() {
    var langCanvas = _div(null, [['dir','className','floatRight'],['css','margin',' 7px 10px 0px 0px']]);
    
    for (var lang in this.hash)
    {
        if (lang != window.language)
        {
            var button = makeLinkButton(_translationsHash.titles[lang]);
            
            button.style.marginLeft = '5px';
            button.style.fontSize = '11px';

            button.onclick = function(lang) {
                window.translationsHash.updateLanguageCookies(lang);

                if (window.nsGmx && window.nsGmx.GeomixerFramework) {
                    window.language = lang;
                    _mapHelper.reloadMap();
                } else {
                    window.location.reload();
                }
            }.bind(null, lang);
            
            _title(button, this.titles[lang]);
            
            langCanvas.appendChild(button);
        }
        else 
        {
            langCanvas.appendChild(_span([_t(_translationsHash.titles[lang])], [['css','marginLeft','5px'], ['css','color','#fc830b']]));
        }
    }

    document.getElementById("headerLinks").appendChild(langCanvas);
}

window._gtxt = function() {
    return commonTranslationsManager.getText.apply(commonTranslationsManager, arguments);
};

window.translationsHash = {
    getLanguageFromCookies: commonTranslationsManager.getLanguageFromCookies.bind(commonTranslationsManager),
    updateLanguageCookies: commonTranslationsManager.updateLanguageCookies.bind(commonTranslationsManager)
};

window.gmxCore && gmxCore.addModule('translations',
{
    _translationsHash: window._translationsHash
})

}();
_translationsHash.flags["rus"] = "img/flag_ru.png";

_translationsHash.titles["rus"] = "Русский";

_translationsHash.hash["rus"] = {
	"Да": "Да",
	"Нет": "Нет",
	"Карта" : "Карта",
	"Создать" : "Создать",
	"Создать карту" : "Создать карту",
	"Сохранить" : "Сохранить",
	"Сохранить как" : "Сохранить как",
	"Сохранить карту как" : "Сохранить карту как",
	"Сохранить карту" : "Сохранить карту",
	"Экспорт" : "Экспорт",
	"Ссылки" : "Ссылки",

    "Карта пожаров": "Карта пожаров",
    "Поиск снимков": "Поиск снимков",
    "Платформа Геомиксер": "Веб-ГИС GeoMixer",
    "http://fires.ru": "http://fires.ru",
    "http://search.kosmosnimki.ru": "http://search.kosmosnimki.ru",

    "Данные": "Данные",
    "Сервисы": "Сервисы",
    "Поделиться": "Поделиться",
    "Открыть слой": "Открыть слой",
    "Создать слой": "Создать слой",
    "Растровый": "Растровый",
    "Векторный": "Векторный",
    "Создать группу": "Создать группу",
    "Базовые слои": "Базовые слои",
    "Подключить WMS": "Подключить WMS",
    "Подключить WFS": "Подключить WFS",
    "Объекты": "Объекты",
    "Результаты поиска": "Результаты поиска",
    "Буфер": "Буфер",
    "Ручная привязка растров": "Ручная привязка растров",
    "Поиск слоев на карте": "Поиск слоев на карте",
    "Краудсорсинг данных": "Краудсорсинг данных",
    "Пакетный геокодинг": "Пакетный геокодинг",
    "Маршруты": "Маршруты",
    "Кадастр Росреестра": "Кадастр Росреестра",
    "Выбрать кадастровый объект": "Выбрать кадастровый объект",
    "Викимапиа": "Викимапиа",
    "Каталог СКАНЭКС": "Поиск снимков",
    "Космоснимки-пожары": "Космоснимки-пожары",
    "GIBS NASA": "Съёмка MODIS (NASA)",
    "Руководство пользователя": "Документация",
    "Руководство": "Руководство пользователя",
    "GeoMixer API": "GeoMixer API",
    "Использование плагинов": "Использование плагинов",
	"копия": "копия",

	"Открыть" : "Открыть",
	"Слой" : "Слой",
	"Создать векторный слой" : "Создать векторный слой",
	"Создать растровый слой" : "Создать растровый слой",
	"Создать мультислой" : "Создать мультислой",
	"Вид" : "Вид",
	"Дерево слоев" : "Дерево слоев",
	"Объекты на карте" : "Объекты на карте",
	"Результаты поиска" : "Результаты поиска",
	"Координатная сетка" : "Координатная сетка",
	"Индексная сетка" : "Индексная сетка",
	"Панель оверлеев" : "Панель оверлеев",
	"Сервисы" : "Сервисы",
	"Загрузить объекты" : "Загрузить объекты",
	"Загрузить фотографии" : "Загрузить фотографии",
	"Загрузить данные" : "Загрузить данные",
		"WFS сервер" : "WFS сервер",
		"WMS сервер" : "WMS сервер",
		"Кадастровые данные" : "Кадастровые данные",
	"Ссылка на карту" : "Ссылка на карту",
	"Код для вставки" : "Код для вставки карты",
	"Печать" : "Печать",
	"Привязать изображение" : "Привязать изображение",
	"Сообщить об ошибке на карте" : "Сообщить об ошибке на карте",
	"Справка" : "Справка",
	"Использование" : "Использование",
	"Сервисы" : "Сервисы",
	"О проекте" : "О проекте/Контакты",
	"$$phrase$$_1" : "Укажите карту в параметре defaultMapID в файле config.js",
	"У вас нет прав на просмотр данной карты" : "У вас нет прав на просмотр данной карты",
	"Access error" : "У вас нет прав на просмотр данной карты",
	"Map not found" : "Данная карта не существует",
	"Unable to locate EXIF content" : "отсутствуют координаты в EXIF",
	"Развернуть карту" : "Развернуть карту",
	"Свернуть карту" : "Свернуть карту",
	"Точки на изображении:" : "Точки на изображении:",
	"Точки на карте:" : "Точки на карте:",
	"Координаты" : "Координаты",
	"Нарисовать" : "Нарисовать",
	"Восстановить" : "Восстановить",
	"Прозрачность" : "Прозрачность",
	"Видимость" : "Видимость",
	"Привязка изображения" : "Привязка изображения",
	"$$phrase$$_2" : "Точка [value0] находится за пределами изображения",
	"$$phrase$$_3" : "Не задана точка [value0] на карте",
	"Соответствие точек" : "Соответствие точек",
	"$$phrase$$_4" : "Точки 1 и 2 на изображении совпадают",
	"$$phrase$$_5" : "Точки 1 и 3 на изображении совпадают",
	"$$phrase$$_6" : "Точки 2 и 3 на изображении совпадают",
	"$$phrase$$_7" : "Точки 1 и 2 на карте совпадают",
	"$$phrase$$_8" : "Точки 1 и 3 на карте совпадают",
	"$$phrase$$_9" : "Точки 2 и 3 на карте совпадают",
	"$$phrase$$_10" : "Точки на изображении лежат на одной прямой",
	"Создать экскурсию" : "Создать экскурсию",
	"Чтобы пользоваться этим сайтом, установите Flash Player" : "Чтобы пользоваться этим сайтом, установите Flash Player",
	"из Интернет" : "из Интернет",
	"или с локального диска " : "или с локального диска ",
	"для Internet Explorer" : "для Internet Explorer",
	" или " : " или ",
	"для Internet Firefox" : "для Internet Firefox",
	"Скачать shp-файл" : "Скачать shp-файл",
	"shp-файл" : "shp-файл",
	"gpx-файл" : "gpx-файл",
	"Скачать фрагмент растра" : "Скачать фрагмент растра",
	"Очистить" : "Очистить",
	"точка" : "точка",
	"линия" : "линия",
	"прямоугольник" : "прямоугольник",
	"многоугольник" : "многоугольник",
	"Скачать" : "Скачать",
	"Введите имя файла для скачивания" : "Введите имя файла для скачивания",
	"Выберите область рамкой на карте" : "Выберите область рамкой на карте",
	"Вырезать фрагмент растра" : "Вырезать фрагмент растра",
	"К прямоугольнику не подходит ни одного растрового слоя" : "К прямоугольнику не подходит ни одного растрового слоя",
	"Загруженный shp-файл пуст" : "Загруженный shp-файл пуст",
	"Ошибка скачивания" : "Ошибка скачивания",
	"Обновить" : "Обновить",
	"Домашняя директория" : "Директория проекта",
	"Имя папки" : "Имя папки",
	"Имя" : "Имя",
	"Тип" : "Тип",
	"Размер" : "Размер",
	"Дата" : "Дата",
    "Дата создания": "Дата создания",
	"Снять выделение" : "Снять выделение",
	"Скопировать" : "Скопировать",
	"Удалить" : "Удалить",
	"Извлечь" : "Извлечь",
	"Упаковать" : "Упаковать",
	"Загрузить" : "Загрузить",
    "Параметр" : "Параметр",
    "Значение" : "Значение",
    "VALUE" : "VALUE",
    "WHERE" : "WHERE",
    "Колонки" : "Колонки",
    "Операторы" : "Операторы",
    "Функции" : "Функции",
    "Метаданные": "Метаданные",
    "Редактировать колонки": "Редактировать колонки",
	"URL сервера" : "URL сервера",
	"Формат изображения" : "Формат изображения",
	"Введите имя gml-файла для скачивания:" : "Введите имя gml-файла для скачивания:",
	"точки" : "точки",
	"линии" : "линии",
	"полигоны" : "полигоны",
	"(ссылка)" : "(ссылка)",
	"Сохранить состояние карты" : "Сохранить состояние карты",
	"Ссылка на текущее состояние карты" : "Ссылка на текущее состояние карты",
	"Добавить стиль" : "Добавить стиль",
	"Атрибут >" : "Атрибут >",
	"Значение >" : "Значение >",
	"Операция >" : "Операция >",
	"Накладываемое изображение" : "Накладываемое изображение",
	"Цвет" : "Цвет",
	"Прозрачность" : "Прозрачность",
	"Авторизуйтесь для редактирования фильтров" : "Авторизуйтесь для редактирования фильтров",
	"Имя фильтра" : "Имя фильтра",
	"Переместить фильтр вверх" : "Переместить фильтр вверх",
	"Переместить фильтр вниз" : "Переместить фильтр вниз",
	"Удалить фильтр" : "Удалить фильтр",
	"Размер шрифта" : "Размер шрифта",
	"Смещение" : "Смещение",
	"Смещение по x" : "Смещение по x",
	"Смещение по y" : "Смещение по y",
	"Имя атрибута" : "Имя атрибута",
	"Граница обрезки" : "Граница обрезки",
	"Граница" : "Граница",
	"Толщина линии" : "Толщина линии",
	"Заливка" : "Заливка",
    "Заливка цветом": "Заливка цветом",
    "Заливка штриховкой": "Заливка штриховкой",
    "Заливка рисунком": "Заливка рисунком",
    "Ширина паттерна": "Ширина паттерна",
    "Ширина отступа": "Ширина отступа",
    "URL рисунка": "URL рисунка",
	"Маркер URL" : "Маркер URL",
	"URL изображения" : "URL изображения",
    "Изображение" : "Изображение",
	"Размер точек" : "Размер точек",
	"Редактировать стили" : "Редактировать стили",
	"Авторизуйтесь для редактирования настроек слоя" : "Авторизуйтесь для редактирования настроек слоя",
	"Недостаточно прав для редактирования настроек слоя" : "Недостаточно прав для редактирования настроек слоя",
	"Недостаточно прав для редактирования объектов слоя" : "Недостаточно прав для редактирования объектов слоя",
	"ID" : "ID",
	"Описание" : "Описание",
	"Файл" : "Файл",
	"Таблица" : "Таблица",
	"Каталог с тайлами" : "Каталог с тайлами",
	"Каталог растров" : "Каталог растров",
    "Источник": "Источник",
    "Данные с датой": "Разбить по датам",

    "Дополнительно": "Дополнительно",
    "Шаблон названий объектов": "Шаблон названий объектов",
	"Y (широта)" : "Y (широта)",
	"X (долгота)" : "X (долгота)",
	"Каталог" : "Каталог",
	"Изменить" : "Изменить",
	"Создать" : "Создать",
	"Вид вложенных элементов" : "Вид вложенных элементов",
	"Использовать KosmosnimkiAPI" : "Загрузить подложки Kosmosnimki",
	"Использовать OpenStreetMap" : "Использовать OpenStreetMap",
	"Язык по умолчанию" : "Язык по умолчанию",
    "Единицы длины": "Единицы длины",
    "Единицы площади": "Единицы площади",
	"Формат координат": "Формат координат",
    "units.auto": "авто",
    "units.m": "м",
    "units.km": "км",
    "units.nm": "м. мили",
    "units.m2": "м<sup>2",
    "units.ha": "га",
    "units.km2": "км<sup>2",
	"coords.dd" : "dd.dddd",
	"coords.dms" : "dd°mm′ss″",
	"Генерализация" : "Генерализация",
	"gereralization.on": "включить",
	"gereralization.off": "выключить",
	"gereralization.disable": "использовать настройки слоев",
	"Количество информационных окошек" : "Количество информационных окошек",
    "layerOrder.title": "Порядок слоёв",
    "layerOrder.native": "Стандартный",
    "layerOrder.vectorOnTop": "Вектора сверху",
	"Разрешить поиск в векторных слоях" : "Разрешить поиск в векторных слоях",
	"Начальная позиция" : "Начальная позиция",
	"Широта" : "Широта",
	"Долгота" : "Долгота",
	"placeholder degrees": "dd.dddd",
	"placeholder zoom": "1-21",
	"placeholder minZoom": "1",
	"placeholder maxZoom": "21",
	"Зум" : "Зум",
	"Ссылка (permalink)" : "Ссылка (permalink)",
	"Разрешить скачивание" : "Разрешить скачивание",
	"Векторных слоев" : "Векторных слоев",
	"Растровых слоев" : "Растровых слоев",
	"Масштабирование в миникарте" : "Масштабирование в миникарте",
	"Показывать всплывающие подсказки" : "Показывать всплывающие подсказки",
	"Свойства" : "Свойства",
	"Стили" : "Стили",
	"Изображение на карте" : "Изображение на карте",
	"Слой [value0]" : "Слой [value0]",
    "Стили слоя [value0]" : "Стили слоя [value0]",
	"Мультислой [value0]" : "Мультислой [value0]",
	"Группа [value0]" : "Группа [value0]",
	"Карта [value0]" : "Карта [value0]",
	"Редактировать стиль" : "Редактировать стиль",
	"Редактирование стилей объекта" : "Редактирование стилей объекта",
	"Стили слоя" : "Стили слоя",
	"Навигация по карте и инструменты" : "Навигация по карте и инструменты",
	"Список слоев" : "Список слоев",
	"Стиль векторного слоя" : "Стиль векторного слоя",
	"Управление содержанием карты" : "Управление содержанием карты",
	"Пользовательские инструменты" : "Пользовательские инструменты",
	"$$help$$_1" : "Держите нажатой левую клавишу мыши – перетаскивайте карту курсором. Для приближения и удаления используйте колесико мыши (карта зуммируется к точке под курсором). Для перецентровки по координатам – введите их в строке поиска.",
	"$$help$$_2" : "В левой панели отображается список слоев в виде дерева. Для перецентровки карты по экстенту слоя – кликните по его названию в списке. Если данная опция включена администратором карты, вы можете скачивать векторные слои и вырезать и скачивать фрагменты растровых слоев.",
	"$$help$$_3" : "Для редактирования стиля векторного слоя кликните на иконку перед названием слоя.",
	"$$help$$_4" : "Карта представляет собой набор слоев, отображение которого задается с помощью списка слоев. Чтобы иметь возможность редактировать набор слоев (создавать группы, изменять порядок отображения и т.д.) и сохранять изменения – необходимо авторизоваться. Более подробно см ",
	" - Руководство пользователя" : " - Руководство пользователя",
	"$$help$$_5" : "Пользовательские инструменты одновременно служат для создания объектов на карте, которые затем можно сохранять через «ссылку на карту», и для выполнения простых аналитических функций. ",
	"В режиме маркеров: " : "В режиме маркеров: ",
	"$$help$$_6" : "одиночный клик - добавить маркер. Двойной клик по маркеру - удалить. Клик на маркер – открыть всплывающее окошко (балун), клик по балуну – добавить надпись.",
	"В режиме линейка/измерения расстояния, полигон/измерение площади: " : "В режиме линейка/измерения расстояния, полигон/измерение площади: ",
	"$$help$$_7" : "одиночный клик - добавить вершину. Двойной клик - завершить фигуру. Клик на линию - добавить вершину. Двойной клик по вершине - удалить.",
	"$$help$$_8" : "Кликните по объекту в списке «объектов на карте», чтобы перецентровать карту на него. Вы можете скачать контуры объектов в shp/tab/kml формате.",
	"$$about$$_1" : "это веб-приложение для интерактивного просмотра геоданных и доступа к источникам базовых геоданных в интернете, таким как: ",
	"$$about$$_2" : "С помощью GeoMixer можно публиковать собственные геоданные во внутренней сети предприятий или в интернет, накладывать их поверх базовых источников и предоставлять к ним доступ для совместной работы сколь угодно большому числу пользователей, разграничивая права доступа.",
	"$$about$$_3" : "GeoMixer также включает компонент API, который позволяет встраивать созданные проекты в сторонние веб-сайты и приложения и программно управлять фукционалом интерактивной карты.",
	" - Общее описание" : " - Общее описание",
	" - Руководство разработчика" : " - Руководство разработчика",
	"Создать" : "Создать",
	"Получить API-ключ" : "Получить API-ключ",
	"Введите API-ключ" : "Введите API-ключ",
	"Печать карты" : "Печать карты",
	"$$serviceHelp$$_1" : "Позволяет на лету загрузить shp/tab/kml файл небольшого размера в виде пользовательских объектов. После загрузки пользователь может редактировать геометрию объектов и скачивать объекты в том же наборе форматов.",
	"$$serviceHelp$$_2" : "По ссылке запоминается текущее положение карты, а так же пользовательские объекты и надписи.",
	"$$serviceHelp$$_3" : "Отправляет на печать текущий фрагмент карты.",
	"Редактировать" : "Редактировать",
    "Удалить объект?": "Удалить объект?",
    "Удалить отмеченные объекты?": "Удалить отмеченные объекты?",
	"Координаты" : "Координаты",
	"Длина" : "Длина",
	"Площадь" : "Площадь",
	"Добавить подгруппу" : "Добавить группу",
	"Введите имя группы" : "Создание новой группы",
	"Имя группы" : "Имя группы",
	"Включая вложенные слои" : "Включая вложенные слои",
	"Удаление группы [value0]" : "Удаление группы [value0]",
	"Сохранено" : "Сохранено",
	"Прозрачность выбранного слоя/группы/карты" : "Прозрачность выбранного слоя/группы/карты",
	"$$updateInfo$$_1" : "Для отображения нового слоя необходимо сохранить и перезагрузить карту",
	"Любой" : "Любой",
	"Векторный" : "Векторный",
	"Растровый" : "Растровый",
	"Название" : "Название",
	"Владелец" : "Владелец",
	"Последнее изменение": "Последнее изменение",
	"Список слоев" : "Список слоев",
	"Вы действительно хотите удалить этот слой?" : "Вы действительно хотите удалить этот слой?",
	"Ошибка!" : "Ошибка!",
	"Ошибка" : "Ошибка",
	"Выберите колонку" : "Выберите колонку",
	"Список карт" : "Список карт",
	"Показать" : "Показать",
	"загрузка..." : "загрузка...",
	"удаление..." : "удаление...",
	"Вы действительно хотите удалить эту карту?" : "Вы действительно хотите удалить эту карту?",
    "maplist.hint": "Группы и слои можно перетащить в текущую карту",
	"Слоя нет в базе" : "Слоя нет в базе",
	"ScanEx Web Geomixer - просмотр карты" : "ScanEx Web Geomixer - просмотр карты",
	"Изменить параметры поиска" : "Изменить параметры поиска",
	"$$search$$_1" : "Поиск по векторным слоям и адресной базе",
	"$$search$$_2" : "Поиск по адресной базе",
	"Поиск не дал результатов" : "Поиск не дал результатов",
	"Очистить" : "Очистить",
	"Регистрация" : "Регистрация",
	"Восстановление пароля" : "Восстановление пароля",
	"Вход" : "Вход",
	"Выход" : "Выход",
	"Логин" : "Логин",
	"Пароль" : "Пароль",
	"пароль" : "пароль",
    "Псевдоним": "Псевдоним",
    "Полное имя": "Полное имя",
	"Пожалуйста, авторизуйтесь" : "Пожалуйста, авторизуйтесь",
    "адрес электронной почты": "адрес электронной почты",
	"Ошибка сервера" : "Ошибка сервера",
	"Папка" : "Папка",
	" и " : " и ",
	"Название" : "Название",
	"Рейтинг" : "Рейтинг",
	"Автор" : "Автор",
	"Тематика" : "Тематика",
	"Развлекательная" : "Развлекательная",
	"Спортивная" : "Спортивная",
	"Историческая" : "Историческая",
	"Экологическая" : "Экологическая",
	"Любая" : "Любая",
	"Создать новую тему" : "Создать новую тему",
	"Начало периода" : "Начало периода",
	"Окончание периода" : "Окончание периода",
	"Накладываемые тайлы" : "Накладываемые тайлы",
	"Отображать с зума" : "Отображать с зума",
	"По" : "по",
	"Фильтр" : "Фильтр",
	"Подпись" : "Подпись",
	"Балун" : "Подсказка при наведении и клике",
	"По умолчанию" : "По умолчанию",
	"Показывать при клике": "Показывать при клике",
	"Показывать при наведении": "Показывать при наведении",
	"Символика" : "Символика",
    "Библиотека стилей": "Библиотека стилей",
    "Настройка стилей": "Настройка стилей",
	"скопировать": "скопировать",
	"применить везде": "применить везде",
	"Применить": "Применить",
	"Кластеризация" : "Кластеризация",
	"Минимальный" : "Минимальный",
	"Максимальный" : "Максимальный",
	"Мин. зум" : "Мин. зум",
	"Макс. зум" : "Макс. зум",
	"Тип" : "Тип",
	"Пешеходная" : "Пешеходная",
	"Велосипедная" : "Велосипедная",
	"Автомобильная" : "Автомобильная",
	"Речная" : "Речная",
	"Места" : "Места",
	"Маршрут" : "Маршрут",
	"Редактировать экскурсию" : "Редактировать экскурсию",
	"Добавьте маршрут" : "Добавьте маршрут",
	"Выберете темы на пути следования" : "Выберете темы на пути следования",
	"$$phrase$$_11" : "Добавьте маршрут при помощи инструмента \"Линия\" на панели инструментов",
	"$$phrase$$_12" : "Нет подходящих объектов на карте",
	"Выбор маршрута" : "Выбор маршрута",
	"Выбор мест" : "Выбор мест",
	"$$phrase$$_13" : "У вас нет опубликованных тем на карте. Вы можете добавить тему в разделе Вид-Обсуждения",
	"Обсуждения" : "Обсуждения",
	"Экскурсии" : "Экскурсии",
	"$$phrase$$_14" : "Невозможно удалить карту, использующуюся в качестве карты по умолчанию",
	"$$phrase$$_15" : "Невозможно удалить загруженную карту",
	"Назад" : "Назад",
	"Вперед" : "Вперед",
	"$$phrase$$_16" : "Альбома с указанным ID изображения не существует",
	"Редактировать альбом" : "Редактировать альбом",
	"Оценить" : "Оценить",
	"Поставьте маркер" : "Поставьте маркер",
	"на карту и переместите его в нужное место." : "на карту и переместите его в нужное место.",
	"Недостаточно прав для совершения операции" : "Недостаточно прав для совершения операции",
	"Новая папка" : "Новая папка",
	"Выбрать" : "Выбрать",
	"Добавить" : "Добавить",
	"$$serviceHelp$$_4" : "Пользователь может встроить созданную карту в другой сайт, скопировав код и вставив его внутрь HTML. Требуется указать api-ключ для сайта, на котором будет использоваться данный код.",
	"Масштаб" : "Масштаб",
	"Угол поворота" : "Угол поворота",
	"Диаграммы" : "Диаграммы",
	"График по времени" : "График по времени",
	"Круговая" : "Круговая",
	"Маска атрибутов" : "Маска атрибутов",
	"Закладки" : "Закладки",
	"Добавить закладку" : "Добавить закладку",
	"Имя закладки" : "Имя закладки",
	"Дерево" : "Дерево",
	"Поиск слоев" : "Поиск слоев",
	"Пример выражения": "[Атрибут1]\n[Атрибут2]\nпроизвольный текст",
	"Шкала прозрачности" : "Шкала прозрачности",
	"Цвет заливки" : "Цвет заливки",
	"Цвет обводки" : "Цвет обводки",
	"Цвет шрифта" : "Цвет шрифта",
	"Легенда" : "Легенда",
	"Событие загрузки карты" : "Событие загрузки карты",
	"Мин" : "Мин",
	"Макс" : "Макс",
	"График" : "График",
	"Гистограмма" : "Гистограмма",
	"Столбчатая" : "Столбчатая",
	"Временная" : "Временная",
	"Круговая" : "Круговая",
	"Копировать стиль" : "Копировать стиль",
	"Применить стиль" : "Применить стиль",
	"Не выбран стиль" : "Не выбран стиль",
	"Невозможно применить стиль к другому типу геометрии" : "Невозможно применить стиль к другому типу геометрии",
	"Общие" : "Общие",
	"Доступ" : "Доступ",
	"Окно карты" : "Окно карты",
	"Загрузка" : "Загрузка",
	"Копирайт" : "Копирайт",
	"Инструменты" : "Инструменты",
	"Загрузить KML" : "Загрузить KML",
	"URL файла" : "URL файла",
	"Поиск" : "Поиск",
    "Подложки": "Подложки",
    "Доступные подложки": "Доступные подложки",
    "Подложки карты": "Подложки карты",
    "Выберите слои для поиска по атрибутам": "Выберите слои для поиска по атрибутам",
	"Включить синхронизацию слоев": "Включить синхронизацию слоев",
	"Выключить синхронизацию слоев": "Выключить синхронизацию слоев",

	"Редактирование прав доступа карты [value0]" : "Редактирование прав доступа карты [value0]",
	"Редактирование прав доступа слоя [value0]" : "Редактирование прав доступа слоя [value0]",
	"Редактирование прав доступа слоев карты [value0]" : "Редактирование прав доступа слоев карты [value0]",
	"Состав группы [value0]" : "Состав группы [value0]",
	"Роль" : "Роль",
	"Добавить пользователя" : "Добавить пользователя",
	"Права доступа" : "Права доступа",
	"Права доступа к слоям" : "Права доступа к слоям",
	"Пользователи без прав доступа:" : "Пользователи без прав доступа:",
	"Пользователи с правами доступа:" : "Пользователи с правами доступа:",
	"Выберите нового владельца" : "Выберите нового владельца",
	"Сменить владельца" : "Сменить владельца",

	"Объекты RuMap" : "Данные RuMap",
	"Объекты пользователей" : "Данные пользователей",


	"Контакты" : "Контакты",
	"Фотографии" : "Фотографии",
	"Момент съемки" : "Момент съемки",
	"Видео" : "Видео",
	"Сообщения" : "Сообщения",
	"Ссылка на место" : "Ссылка на место",
	"Ссылка на экскурсию" : "Ссылка на экскурсию",
	"Ссылка на событие" : "Ссылка на событие",
	"Создать новое событие" : "Создать новое событие",
	"События" : "События",
	"Календарь" : "Календарь",
	"Новости" : "Новости",
	"Мероприятия" : "Мероприятия",
	"Отмена" : "Отмена",
	"Пропустить" : "Пропустить",
	"Время" : "Время",
	"Альбом OpenPhotoVR" : "Фотоальбом",
	"Встраиваемый код" : "Встраиваемое видео",

	"Объекты экологического риска" : "Объекты экологического риска",
		"Санкционированные свалки" : "Санкционированные свалки",
		"Несанкционированные свалки" : "Несанкционированные свалки",
		"Полигоны отходов" : "Полигоны отходов",
		"Предприятия переработки отходов" : "Предприятия переработки отходов",
		"Факельные установки, ТЭЦ, трубы" : "Факельные установки, ТЭЦ, трубы",
		"Закрытые свалки" : "Закрытые свалки",
		"Пункты приема отходов" : "Пункты приема отходов",
		"Оползни" : "Оползни",
		"Карстовые явления" : "Карстовые явления",
		"Суффозионные явления" : "Суффозионные явления",

	"Государство и общество" : "Государство и общество",
		"Радио" : "Радиостанции",
		"Правительственные учреждения" : "Правительственные учреждения",
		"Оптики" : "Оптики",
		"Охранные агенства" : "Охранные агенства",
		"Травмпункты" : "Травмпункты",
		"Таможня" : "Таможня",
		"Ветеринарные клиники" : "Ветеринарные клиники",
		"ЗАГС" : "ЗАГС",
		"Больницы" : "Больницы",
		"Аптеки" : "Аптеки",
		"Поликлиники" : "Поликлиники",
		"Колледжи" : "Колледжи",
		"Университеты" : "Университеты",
		"ОВИР" : "ОВИР",
		"Посольства" : "Посольства",
		"Почтовые отделения" : "Почтовые отделения",
		"Суды" : "Суды",
		"Банки" : "Банки",
		"Родильные дома" : "Родильные дома",
		"Дома престарелых" : "Дома престарелых",
		"Детские сады" : "Детские сады",
		"Школы" : "Школы",
		"Инспекции" : "Инспекции",
		"Адвокаты" : "Адвокаты",
		"МЧС" : "МЧС",
		"Муниципальные учреждения" : "Муниципальные учреждения",
		"Администрация" : "Администрация",

	"Культура и отдых" : "Культура и отдых",
		"Боулинг" : "Боулинг",
		"Аквапарки" : "Аквапарки",
		"Парки развлечений" : "Парки развлечений",
		"Библиотеки" : "Библиотеки",
		"Памятники" : "Памятники",
		"Лагери отдыха" : "Лагери отдыха",
		"Кинотеатры" : "Кинотеатры",
		"Цирки" : "Цирки",
		"Галереи" : "Галереи",
		"Отели" : "Отели",
		"Мотели" : "Мотели",
		"Музеи" : "Музеи",
		"Концертные залы" : "Концертные залы",
		"Ночные клубы" : "Ночные клубы",
		"Театры" : "Театры",
		"Санатории" : "Санатории",
		"Зоопарки" : "Зоопарки",

	"Общественное питание" : "Общественное питание",
		"Кафе" : "Кафе",
		"Фастфуды" : "Фастфуды",
		"Рестораны" : "Рестораны",
		"Кафе-мороженое" : "Кафе-мороженое",
		"Столовые" : "Столовые",

	"Природные достопримечательности" : "Природные достопримечательности",
		"Ботанический сад" : "Ботанические сады",
		"Пещеры" : "Пещеры",
		"Водопады" : "Водопады",
		"Парки" : "Парки",
		"Источники" : "Источники",
		"Заповедники" : "Заповедники",
		"Прочие архитектурные и природные достопримечательности" : "Архитектурные достопримечательности",

	"Религия" : "Религия",
		"Культовые сооружения" : "Культовые сооружения",
		"Мечети" : "Мечети",
		"Монастыри" : "Монастыри",
		"Церкви других христианских конфессий" : "Церкви других христианских конфессий",
		"Православные церкви" : "Православные церкви",
		"Синагоги" : "Синагоги",

	"Спорт" : "Спорт",
		"Стадионы" : "Стадионы",
		"Теннисные корты" : "Теннисные корты",
		"Катки" : "Катки",
		"Ипподромы" : "Ипподромы",
		"Фитнес" : "Фитнес",
		"Бассейны" : "Бассейны",
		"Прокат спортинвентаря" : "Прокат спортинвентаря",

	"Торговля и услуги" : "Торговля и услуги",
		"Солярии" : "Солярии",
		"Интернет-кафе" : "Интернет-кафе",
		"Рынки" : "Рынки",
		"Стоматологические клиники" : "Стоматологические клиники",
		"Магазины одежды" : "Магазины одежды",
		"Парикмахерские" : "Парикмахерские",
		"Бани" : "Бани",
		"Магазины обуви" : "Магазины обуви",
		"Магазины" : "Магазины",
		"Ателье" : "Ателье",
		"Такси" : "Такси",
		"Туризм" : "Туризм",

	"Транспорт и услуги" : "Транспорт и услуги",
		"Аэропорты" : "Аэропорты",
		"Автосервисы" : "Автосервисы",
		"Автовокзалы" : "Автовокзалы",
		"ДПС" : "ДПС",
		"ГИБДД" : "ГИБДД",
		"Шиномонтаж" : "Шиномонтаж",
		"Парковки бесплатные" : "Парковки бесплатные",
		"Парковки платные" : "Парковки платные",
		"АЗС" : "АЗС",
		"Автомойки" : "Автомойки",

	"Экстренные службы" : "Экстренные службы",
		"Пожарные/спасатели" : "Пожарные/спасатели",
		"Милиция" : "Милиция",
		"Скорая помощь" : "Скорая помощь",

	"Другие темы" : "Другие темы",
		"Разное" : "Разное",

	"Изменение пароля" : "Изменение пароля",
	"Новый пароль" : "Новый пароль",
	"Старый пароль" : "Старый пароль",
	"Подтвердите пароль" : "Подтвердите пароль",
	"Контур" : "Контур",
	"$$phrase$$_17" : "Добавьте контур при помощи инструмента \"Полигон\" на панели инструментов",
	"Выбор контура" : "Выбор контура",
	"Таблица атрибутов слоя [value0]" : "Таблица атрибутов слоя [value0]",
	"Показать параметры поиска" : "Показать параметры поиска",
	"Скрыть параметры поиска" : "Скрыть параметры поиска",
	"Скрыть" : "Скрыть",
	"SQL-условие WHERE" : "SQL-условие WHERE",
    "Искать внутри полигона" : "Искать внутри полигона",
    "Искать по пересечению с объектом" : "Искать по пересечению с объектом",
	"Колонки" : "Колонки",
	"Показывать колонки" : "Показывать колонки",
	"Найти" : "Найти",
	"Нет полей" : "Нет полей",
	"Нет данных" : "Нет данных",
	"Таблица атрибутов" : "Таблица атрибутов",
	"Разрешить поиск" : "Разрешить поиск",
	"Произвольный" : "Произвольный",
	"День" : "День",
	"Неделя" : "Неделя",
	"Месяц" : "Месяц",
	"Год" : "Год",
	"Ежегодно" : "Ежегодно",
	"Облачность" : "Облачность",
	"Период" : "Период",
	"Спутниковые покрытия" : "Спутниковые покрытия",
	"Редактировать объект слоя [value0]" : "Редактировать объект слоя [value0]",
	"Создать объект слоя [value0]" : "Создать объект слоя [value0]",
	"Геометрия" : "Геометрия",
	"Найти объекты" : "Найти объекты",
	"Добавить объекты" : "Добавить объекты",
	"Обновить объекты" : "Обновить объекты",
	"Изменить колонки" : "Изменить колонки",
	"Обновить колонку" : "Обновить колонку",
	"Очистить поиск" : "Очистить поиск",
    "Скачать shp": "Скачать shp",
    "Скачать gpx": "Скачать gpx",
    "Скачать csv": "Скачать csv",
    "Скачать geojson": "Скачать geojson",
    "Рассчитать площадь": "Суммарная площадь",
	"Создать столбец" : "Создать столбец",
	"Мультислой" : "Мультислой",
	"В дереве слоев остались несохраненные изменения!" : "В дереве слоев остались несохраненные изменения!",
	"файл версии отсутствует" : "файл версии отсутствует",
	"оверлеи отсутствуют" : "оверлеи отсутствуют",
	"Хост" : "Хост",
	"Дополнительные карты" : "Дополнительные карты",
	"Добавить карту" : "Добавить карту",
	"Добавить в таймлайн" : "Добавить в таймлайн",
	"Удалить из таймлайна" : "Удалить из таймлайна",
	"Невозможно загрузить карту [value0] с домена [value1]" : "Невозможно загрузить карту [value0] с домена [value1]",
	"Показывать" : "Показывать",
	"Поиск снимков" : "Поиск снимков",
	"Принудительно обновить тайлы" : "Принудительно обновить тайлы",
	"Обводка" : "Обводка",
	"Карта имеет более новую версию. Сохранить?" : "Карта имеет более новую версию. Сохранить?",
	"Кодировка": "Кодировка",
	"helpPostfix": "_rus.html",
	"Показывать чекбокс видимости": "Чекбокс видимости",
	"Разворачивать автоматически": "Разворачивать автоматически",
	"Другая": "Другая",
	"Временнóй слой": "Мультивременнóй слой",
	"Колонка даты": "Колонка даты",
	"Минимальный период": "Мин. период (дни)",
	"Максимальный период": "Макс. период (дни)",
    "Отсутствует временной атрибут": "Отсутствует атрибут типа 'Дата'",
    "Период 1 день": "Период 1 день",
    "Показывать на карте данные за": "Показывать на карте данные за",
    "1 день": "1 день",
    "произвольный период" : "произвольный период",
	"По границе экрана": "По границе экрана",
	"По центру экрана": "По центру экрана",
	"Пересечение": "Пересечение",
	"Пролистывать слои": "Пролистывать слои",
	"Следующий слой": "Следующий слой",
	"Предыдущий слой": "Предыдущий слой",
    "Геометрия не сохранена. Эта возможность будет реализована в будущих версиях Геомиксера.": "Геометрия не сохранена. Эта возможность будет реализована в будущих версиях Геомиксера.",
    "WMS доступ": "WMS/WFS доступ",
    "ссылка": "ссылка",
    "Слой '[value0]' уже есть в карте": "Слой '[value0]' уже есть в карте",
    "Группа '[value0]' уже есть в карте": "Группа '[value0]' уже есть в карте",
    "Плагины": "Плагины",
    "Вручную": "Вручную",
    "Добавить атрибут": "Добавить поле",
    "Проекция": "Проекция",
    "Широта/Долгота (EPSG:4326)": "Широта/Долгота (EPSG:4326)",
    "Меркатор (EPSG:3395)": "Меркатор (EPSG:3395)",
    "Из файла": "Из файла",
    "Мультиполигон": "Мультиполигон",
    "Мультилиния": "Мультилиния",
    "Мультиточка": "Мультиточка",
    "Администрирование": "Администрирование",
    "Системные настройки": "Системные настройки",
    "Управление группами": "Управление группами",
    "Управление группами пользователей": "Управление группами пользователей",
    "Добавить снимки": "Добавить растры",
    "Существующие слои": "Существующие слои",
    "Слои из карты": "Слои из карты",
    "Слои из КР": "Слои из КР",
    "Новый слой": "Новый слой",
    "С экрана": "С экрана",
    "Добавлен растр": "Добавлен растр",
    "Добавлены растры": "Добавлены растры",
    "Выбранный объект не имеет растра": "Выбранный объект не имеет растра",
    "Этот растр уже был выбран": "Этот растр уже был выбран",
    "Каталог Растров": "Каталог растров",
    "Растр": "Растр",
    "Добавить выбранные растры": "Добавить выбранные растры",
    "EditObject.menuTitle" : "Добавить объект",
    "FileBrowser.ExceedLimitMessage" : "Размер файла превышает 500 Мб. Используйте GeoMixerFileBrowser для загрузки больших файлов.",
    "FileBrowser.DropInfo" : "Перетащите файлы сюда",
    "EditObject.drawingMenuTitle" : "Добавить объект в активный слой",
    "Поставить маркер": "Поставить маркер",
    "Центрировать": "Центрировать",
    "Пароль изменён": "Пароль изменён",
	"портретная": "портретная",
	"альбомная": "альбомная",
	"gmx_geometry": "gmx_geometry"
};


_translationsHash.flags["eng"] = "img/flag_en.png";

_translationsHash.titles["eng"] = "English";

_translationsHash.hash["eng"] = {
	"Да": "Yes",
	"Нет": "No",
	"Карта" : "Map",
	"Создать" : "Create",
	"Создать карту" : "Create map",
	"Сохранить" : "Save",
	"Сохранить как" : "Save as",
	"Сохранить карту как" : "Save map as",
	"Сохранить карту" : "Save map",
	"Экспорт" : "Export",
	"Ссылки" : "Links",

    "Карта пожаров": "Fires map",
    "Поиск снимков": "Search Imagery",
    "Платформа Геомиксер": "GeoMixer Web-GIS",
    "http://fires.ru": "http://fires-map.com",
    "http://search.kosmosnimki.ru": "http://search.kosmosnimki.ru/index_eng.html",

    "Данные": "Datasets",
    "Сервисы": "Services",
    "Поделиться": "Share",
    "Открыть слой": "Open layer",
    "Создать слой": "Create layer",
    "Растровый": "Raster",
    "Векторный": "Vector",
    "Создать группу": "Create group",
    "Базовые слои": "Base layers",
    "Подключить WMS": "Add WMS",
    "Подключить WFS": "Add WFS",
    "Объекты": "User objects",
    "Результаты поиска": "Search results",
    "Буфер": "Buffer",
    "Ручная привязка растров": "Manual rasters shift",
    "Поиск слоев на карте": "Search layers on map",
    "Краудсорсинг данных": "Crowdsourcing",
    "Пакетный геокодинг": "Batch geocode",
    "Маршруты": "Directions",
    "Кадастр Росреестра": "Cadastre data of Rosreestr",
    "Выбрать кадастровый объект": "Select Cadastre item",
    "Викимапиа": "Wikimapia",
    "Каталог СКАНЭКС": "Search imagery",
    "Космоснимки-пожары": "Kosmosnimki-fires",
    "GIBS NASA": "MODIS Images (NASA)",
    "Руководство пользователя": "Documentation",
    "Руководство": "User guide",
    "GeoMixer API": "GeoMixer API",
    "Использование плагинов": "Plugins usage",
	"копия": "копия",

	"Открыть" : "Open",
	"Слой" : "Layer",
	"Создать векторный слой" : "Create vector layer",
	"Создать растровый слой" : "Create raster layer",
    "Создать мультислой" : "Create multilayer",
	"Вид" : "View",
	"Дерево слоев" : "Layers tree",
	"Объекты на карте" : "Objects on map",
	"Результаты поиска" : "Search results",
	"Координатная сетка" : "Coordinate grid",
	"Индексная сетка" : "Index grid",
	"Панель оверлеев" : "Overlays panel",
	"Сервисы" : "Services",
	"Загрузить объекты" : "Upload objects",
	"Загрузить фотографии" : "Upload photos",
	"Загрузить данные" : "Load data",
		"WFS сервер" : "WFS server",
		"WMS сервер" : "WMS server",
		"Кадастровые данные" : "Cadastre data",
	"Ссылка на карту" : "Link to the map",
	"Код для вставки" : "Embed code",
	"Печать" : "Print",
	"Привязать изображение" : "Bind image",
	"Сообщить об ошибке на карте" : "Report a map error",
	"Справка" : "Help",
	"Использование" : "Usage",
	"Сервисы" : "Services",
	"О проекте" : "About/Contacts",
	"$$phrase$$_1" : "Choose parameter defaultMapID in config.js file",
	"У вас нет прав на просмотр данной карты" : "Sorry, you don’t have permission to view this map",
	"Access error" : "Sorry, you don’t have permission to view this map",
	"Map not found" : "Sorry, this map not found",
	"Unable to locate EXIF content" : "Unable to locate EXIF content",
	"Развернуть карту" : "Unfold map",
	"Свернуть карту" : "Fold map",
	"Точки на изображении:" : "Points on image:",
	"Точки на карте:" : "Points on map:",
	"Координаты" : "Coordinates",
	"Нарисовать" : "Draw",
	"Восстановить" : "Restore",
	"Прозрачность" : "Transparency",
	"Видимость" : "Visibility",
	"Привязка изображения" : "Image binding",
	"$$phrase$$_2" : "Point [value0] is outside the limits of image",
	"$$phrase$$_3" : "Point [value0] is not specified on a map",
	"Соответствие точек" : "Point correspondence",
	"$$phrase$$_4" : "Points 1 and 2 coincide at the image",
	"$$phrase$$_5" : "Points 1 and 3 coincide at the image",
	"$$phrase$$_6" : "Points 2 and 3 coincide at the image",
	"$$phrase$$_7" : "Points 1 and 2 coincide at the map",
	"$$phrase$$_8" : "Points 1 and 3 coincide at the map ",
	"$$phrase$$_9" : "Points 2 and 3 coincide at the map ",
	"$$phrase$$_10" : "Points lie on a straight line at the image ",
	"Создать экскурсию" : "Create guide",
	"Чтобы пользоваться этим сайтом, установите Flash Player" : "To use this web site, please, install Flash Player",
	"из Интернет" : "from Internet",
	"или с локального диска " : "or from local disc",
	"для Internet Explorer" : "for Internet Explorer",
	" или " : " or ",
	"для Firefox" : "for Firefox",
	"Скачать shp-файл" : "Download shp-file",
	"shp-файл" : "shp-file",
	"gpx-файл" : "gpx-file",
	"Скачать фрагмент растра" : "Download fragment of raster",
	"Очистить" : "Delete",
	"точка" : "point",
	"линия" : "line",
	"прямоугольник" : "rectangle",
	"многоугольник" : "polygon",
	"Скачать" : "Download",
	"Введите имя файла для скачивания" : "Enter file name to download",
	"Выберите область рамкой на карте" : "Select region using frame",
	"Вырезать фрагмент растра" : "Cut fragment of raster",
	"К прямоугольнику не подходит ни одного растрового слоя" : "No one raster layer fit the rectangle",
	"Загруженный shp-файл пуст" : "The uploaded shp-file is empty",
	"Ошибка скачивания" : "Download error",
	"Обновить" : "Update",
	"Домашняя директория" : "Project directory",
	"Имя папки" : "Folder name",
	"Имя" : "Name",
	"Тип" : "Type",
	"Размер" : "Size",
	"Дата" : "Date",
    "Дата создания": "Дата создания",
	"Снять выделение" : "Clear selection",
	"Скопировать" : "Copy",
	"Удалить" : "Delete",
	"Извлечь" : "Extract",
	"Упаковать" : "Add to archive",
	"Загрузить" : "Download",
    "Параметр" : "Parameter",
    "Значение" : "Value",
	"VALUE" : "VALUE",
	"WHERE" : "WHERE",
	"Колонки" : "Columns",
	"Операторы" : "Operators",
	"Функции" : "Functions",
    "Метаданные": "Metadata",
    "Редактировать колонки": "Edit columns",
	"URL сервера" : "Server URL",
	"Формат изображения" : "Image format",
	"Введите имя gml-файла для скачивания:" : "Enter gml-file name to download:",
	"точки" : "points",
	"линии" : "lines",
	"полигоны" : "polygons",
	"(ссылка)" : "(link)",
	"Сохранить состояние карты" : "Save map state",
	"Ссылка на текущее состояние карты" : "Link to the map",
	"Добавить стиль" : "Add style",
	"Атрибут >" : "Attribute >",
	"Значение >" : "Value >",
	"Операция >" : "Operation >",
	"Накладываемое изображение" : "Ground overlay",
	"Цвет" : "Color",
	"Авторизуйтесь для редактирования фильтров" : "Authorize to edit filters",
	"Имя фильтра" : "Filter name",
	"Переместить фильтр вверх" : "Move filter up",
	"Переместить фильтр вниз" : "Move filter down",
	"Удалить фильтр" : "Delete filter",
	"Размер шрифта" : "Typesize",
	"Смещение" : "Shift",
	"Смещение по x" : "X shift",
	"Смещение по y" : "Y shift",
	"Имя атрибута" : "Attribute name",
	"Граница обрезки" : "Clip region",
	"Граница" : "Outline",
	"Толщина линии" : "Line thickness",
	"Заливка" : "Fill",
    "Заливка цветом": "Color fill",
    "Заливка штриховкой": "Pattern fill",
    "Заливка рисунком": "Image fill",
    "Ширина паттерна": "Pattern width",
    "Ширина отступа": "Indent width",
    "URL рисунка": "Image URL",
	"Маркер URL" : "Icon URL ",
	"URL изображения" : "Image URL",
    "Изображение" : "Image",
	"Размер точек" : "Point size",
	"Редактировать стили" : "Edit styles",
	"Авторизуйтесь для редактирования настроек слоя" : " Authorize to edit layer properties",
	"Недостаточно прав для редактирования настроек слоя" : "You have not enough permission to edit layer properties ",
	"Недостаточно прав для редактирования объектов слоя" : "You have not enough permission to edit layer objects ",
	"ID" : "ID",
	"Описание" : "Description",
	"Файл" : "File",
	"Таблица" : "Table",
	"Каталог с тайлами" : "Tile catalogue",
    "Каталог растров" : "Raster catalogue",
    "Данные с датой": "Split through time",
    "Источник": "Source",
    "Дополнительно": "Advanced options",
    "Шаблон названий объектов": "Objects title template",
	"Y (широта)" : "Y (latitude)",
	"X (долгота)" : "X (longitude)",
	"Каталог" : "Catalogue",
	"Изменить" : "Change",
	"Вид вложенных элементов" : "Form of attached elements",
	"Использовать KosmosnimkiAPI" : "Load Kosmosnimki base layers",
	"Использовать OpenStreetMap" : "Use OpenStreetMap",
	"Язык по умолчанию" : "Default language",
    "Единицы длины": "Distance unit",
    "Единицы площади": "Square unit",
	"Формат координат": "Coordinates format",
    "units.auto": "auto",
    "units.m": "m",
    "units.km": "km",
    "units.nm": "nmi",
    "units.m2": "m<sup>2</sup>",
    "units.ha": "ha",
    "units.km2": "km<sup>2</sup>",
	"coords.dd" : "dd.dddd",
	"coords.dms" : "dd°mm′ss″",
	"Генерализация" : "Generalization",
	"gereralization.on": "on",
	"gereralization.off": "off",
	"gereralization.disable": "use layers settings",
	"Количество информационных окошек" : "Max popup count",
    "layerOrder.title": "Layers order",
    "layerOrder.native": "Native",
    "layerOrder.vectorOnTop": "Vector on top",
	"Разрешить поиск в векторных слоях" : "Allow search vector layers",
	"Начальная позиция" : "Start position",
	"Широта" : "Latitude",
	"Долгота" : "Longitude",
	"placeholder degrees": "dd.dddd",
	"placeholder zoom": "1-21",
	"placeholder minZoom": "1",
	"placeholder maxZoom": "21",
	"Зум" : "Zoom",
	"Ссылка (permalink)" : "Permalink",
	"Разрешить скачивание" : "Allow to download",
	"Векторных слоев" : "Vector layers",
	"Растровых слоев" : "Raster layers",
	"Масштабирование в миникарте" : "Minimap zoom delta",
	"Показывать всплывающие подсказки" : "Show tooltips",
	"Свойства" : "Properties",
	"Стили" : "Styles",
	"Изображение на карте" : "Ground overlay",
	"Слой [value0]" : "Layer [value0]",
	"Стили слоя [value0]" : "Styles of layer [value0]",
	"Мультислой [value0]" : "Multilayer [value0]",
	"Группа [value0]" : "Group [value0]",
	"Карта [value0]" : "Map [value0]",
	"Редактировать стиль" : "Edit style",
	"Редактирование стилей объекта" : "Object styles editing",
	"Стили слоя" : "Layer styles",
	"Навигация по карте и инструменты" : "Map navigation and tools",
	"Список слоев" : "List of layers",
	"Стиль векторного слоя" : "Vector layer style",
	"Управление содержанием карты" : "Map content management",
	"Пользовательские инструменты" : "Users tools",
	"$$help$$_1" : "Hold mouse left button – move map with cursor. To zoom in or out use mouse wheel (or map zoom slider to zoom to the cursor position). In order to move map center to specified coordinates – enter coordinates in search line.",
	"$$help$$_2" : "Layer tree is represented in the left panel. To change map center according to layer extent – click its title in the list. If this option was activated by map administrator, you can download vector layers and cut and download raster layers fragments.",
	"$$help$$_3" : "To edit vector layer style click icon near layer name.",
	"$$help$$_4" : "Map is a collection of layers, which is displayed using layer tree. It is necessary to authorize to be able to edit the collection of layers (create groups, change display order etc.) and save changes. For more information see ",
	" - Руководство пользователя" : " – User guide",
	"$$help$$_5" : "User tools serve the purpose of creation of objects on map, which can be saved via «save link to the map», and, at the same time, simple analytic functions fulfillment.",
	"В режиме маркеров: " : "Creating markers: ",
	"$$help$$_6" : "single click – add marker. Double click on marker – delete. Click on marker – open pop-up window (balloon), click on balloon – add text.",
	"В режиме линейка/измерения расстояния, полигон/измерение площади: " : "Drawing lines/distance measurement, polygon/area measurement: ",
	"$$help$$_7" : "single click – add vertex. Double click – complete figure. Click on line – add vertex. Double click on vertex – delete.",
	"$$help$$_8" : "Click on object in list of «objects on map» to move map center to it. You can download object in shp/tab/kml format.",
	"$$about$$_1" : "this web application for interactive geodata view and access to basic data sources in the Internet, such as: ",
	"$$about$$_2" : " Using GeoMixer you can publish own geodata in intranet or in the Internet, put them over basic data coverages and give access to them for however large number of users, changing access permissions.",
	"$$about$$_3" : "GeoMixer also includes API component, which enables integrating the created projects into other web sites and applications and carry out program control over interactive map functional.",
	" - Общее описание" : " – General manual",
	" - Руководство разработчика" : " – Developer’s gudie",
	"Получить API-ключ" : "Get API-key",
	"Введите API-ключ" : "Enter API-key",
	"$$serviceHelp$$_1" : "Allows to upload small shp/tab/kml file on the fly in the form of user objects. After uploading user can edit geometry of objects and download objects in the same format kit.",
	"$$serviceHelp$$_2" : "Link saves current map state, and also user objects and texts.",
	"$$serviceHelp$$_3" : "Print current map fragment.",
	"Редактировать" : "Edit",
    "Удалить объект?": "Delete object?",
    "Удалить отмеченные объекты?": "Delete selected objects?",
	"Длина" : "Length",
	"Площадь" : "Area",
	"Добавить подгруппу" : "Create group",
	"Введите имя группы" : "New group creation",
	"Имя группы" : "Group name",
	"Включая вложенные слои" : "Including attached layers",
	"Удаление группы [value0]" : "Delete group [value0]",
	"Сохранено" : "Saved",
	"Прозрачность выбранного слоя/группы/карты" : "Transparency of the selected layer/group/map",
	"$$updateInfo$$_1" : "To display new layer it is necessary to save and reload map",
	"Любой" : "Any",
	"Векторный" : "Vector",
	"Растровый" : "Raster",
	"Название" : "Name",
	"Владелец" : "Owner",
	"Последнее изменение": "Last modification",
	"Список слоев" : "Layers list",
	"Вы действительно хотите удалить этот слой?" : "Do you really want to delete the selected layer?",
	"Ошибка!" : "Error!",
	"Ошибка" : "Error",
	"Выберите колонку" : "Select column",
	"Список карт" : "Maps list",
	"Показать" : "Show",
	"загрузка..." : "loading...",
	"удаление..." : "deleting...",
	"Вы действительно хотите удалить эту карту?" : " Do you really want to delete the selected map?",
    "maplist.hint": "You can drag layers and folders from here to current map",
	"Слоя нет в базе" : "Layer is not in base",
	"ScanEx Web Geomixer - просмотр карты" : "ScanEx Web Geomixer – map view",
	"Изменить параметры поиска" : "Change search parameters",
	"$$search$$_1" : "Search vector layers and address base",
	"$$search$$_2" : "Search address base",
	"Поиск не дал результатов" : "There are no search results",
	"Регистрация" : "Registration",
	"Восстановление пароля" : "Restore password",
	"Вход" : "Login",
	"Выход" : "Logout",
	"Логин" : "User name",
	"Пароль" : "Password",
	"пароль" : "password",
    "Псевдоним": "Nickname",
    "Полное имя": "Full name",
	"Пожалуйста, авторизуйтесь" : "Please, authorize",
    "адрес электронной почты": "enter your e-mail",
	"Ошибка сервера" : "Server error",
	"Папка" : "Folder",
	" и " : " and ",
	"Название" : "Title",
	"Рейтинг" : "Rating",
	"Автор" : "Author",
	"Тематика" : "Theme",
	"Развлекательная" : "Fun",
	"Спортивная" : "Sport",
	"Историческая" : "History",
	"Экологическая" : "Ecology",
	"Любая" : "All",
	"Создать новую тему" : "Create topic",
	"Начало периода" : "Since",
	"Окончание периода" : "Till",
	"Накладываемые тайлы" : "Ground tiles",
	"Отображать с зума" : "Show with zoom",
	"По" : "to",
	"Фильтр" : "Filter",
	"Подпись" : "Label",
	"Балун" : "Balloon",
	"По умолчанию" : "Default",
	"Показывать при клике": "Show on click",
	"Показывать при наведении": "Show on mouse over",
	"Символика" : "Shown style",
    "Библиотека стилей": "Style library",
    "Настройка стилей": "Style settings",
	"скопировать": "copy style",
	"применить везде": "apply to all",
	"Применить": "Apply",
    "Кластеризация" : "Clustering",
	"Минимальный" : "Mininmal",
	"Максимальный" : "Maximal",
	"Мин. зум" : "Min. zoom",
	"Макс. зум" : "Max. zoom",
	"Пешеходная" : "Footpath",
	"Велосипедная" : "Bicycle",
	"Автомобильная" : "Automobile",
	"Места" : "Places",
	"Маршрут" : "Route",
	"Редактировать экскурсию" : "Edit excursion",
	"Добавьте маршрут" : "Add route",
	"Выберете темы на пути следования" : "Choose places throughout the journey",
	"$$phrase$$_11" : "Add route by clicking \"Line\" tool on toolbar",
	"$$phrase$$_12" : "There are no corresponding objects on the map",
	"Выбор маршрута" : "Routes choice",
	"Выбор мест" : "Places choice",
	"$$phrase$$_13" : "You haven't places om map. You can add place in View-Forum tab",
	"Обсуждения" : "Forum",
	"Экскурсии" : "Excursions",
	"$$phrase$$_14" : "Unable to delete default map",
	"$$phrase$$_15" : "Unable to delete current map",
	"Назад" : "Back",
	"Вперед" : "Forward",
	"$$phrase$$_16" : "There is no album with given image ID",
	"Редактировать альбом" : "Edit album",
	"Оценить" : "Vote",
	"Поставьте маркер" : "Add marker",
	"на карту и переместите его в нужное место." : "to map and move it to choosen place.",
	"Недостаточно прав для совершения операции" : "Insufficient rights to perform operation",
	"Новая папка" : "New folder",
	"Выбрать" : "Choose",
	"Добавить" : "Add",
	"$$serviceHelp$$_4" : "Embedding the map: the user can embed a map window into their site by copying and pasting an HTML snippet. An API key for the site's domain is required.",
	"Масштаб" : "Scale",
	"Угол поворота" : "Angle",
	"Диаграммы" : "Charts",
	"График по времени" : "Time chart",
	"Круговая" : "Pie chart",
	"Маска атрибутов" : "Attributes mask",
	"Закладки" : "Bookmarks",
	"Добавить закладку" : "Add bookmark",
	"Имя закладки" : "Bookmark name",
	"Дерево" : "Tree view",
	"Поиск слоев" : "Layers search",
	"Пример выражения": "[Field1]\n[Field2]\nsimple text",
	"Шкала прозрачности" : "Transparency bar",
	"Цвет заливки" : "Fill color",
	"Цвет обводки" : "Outline color",
	"Цвет шрифта" : "Font color",
	"Легенда" : "Legend",
	"Событие загрузки карты" : "Событие загрузки карты",
	"Мин" : "Min",
	"Макс" : "Max",
	"График" : "График",
	"Гистограмма" : "Гистограмма",
	"Столбчатая" : "Столбчатая",
	"Временная" : "Временная",
	"Круговая" : "Круговая",
	"Копировать стиль" : "Copy style",
	"Применить стиль" : "Apply style",
	"Не выбран стиль" : "There is no copied style",
	"Невозможно применить стиль к другому типу геометрии" : "Can't apply style to different geometry type",
	"Общие" : "Common",
	"Доступ" : "Policy",
	"Окно карты" : "View",
	"Загрузка" : "Onload",
	"Копирайт" : "Copyright",
	"Инструменты" : "Tools",
	"Загрузить KML" : "Load KML",
	"URL файла" : "File URL",
    "Поиск" : "Search",
    "Подложки": "Base Layers",
    "Доступные подложки": "Available base layers",
    "Подложки карты": "Base layers on map",
    "Выберите слои для поиска по атрибутам": "Select layers for attributes search",
	"Включить синхронизацию слоев": "Enable sync layers",
	"Выключить синхронизацию слоев": "Disable sync layers",

	"Редактирование прав доступа карты [value0]" : "Map [value0] access editor",
	"Редактирование прав доступа слоя [value0]" : "Layer [value0] access editor",
	"Редактирование прав доступа слоев карты [value0]" : "Map [value0] layers access editor",
	"Состав группы [value0]" : "Users of group [value0]",
	"Роль" : "Role",
	"Добавить пользователя" : "Add user",
	"Права доступа" : "Access permissions",
	"Права доступа к слоям" : "Layers access permissions",
	"Пользователи без прав доступа:" : "Users wihout access:",
	"Пользователи с правами доступа:" : "Users with access:",
	"Выберите нового владельца" : "Select new owner",
	"Сменить владельца" : "Change owner",

	"Объекты RuMap" : "RuMap objects",
	"Объекты пользователей" : "User objects",

	"Контакты" : "Contacts",
	"Фотографии" : "Photo",
	"Момент съемки" : "Image date",
	"Видео" : "Video",
	"Сообщения" : "Messages",
	"Ссылка на место" : "Ссылка на место",
	"Ссылка на экскурсию" : "Ссылка на экскурсию",
	"Ссылка на событие" : "Ссылка на событие",
	"Создать новое событие" : "Создать новое событие",
	"События" : "События",
	"Календарь" : "Календарь",
	"Новости" : "Новости",
	"Мероприятия" : "Мероприятия",
	"Отмена" : "Отмена",
	"Пропустить" : "Skip",
	"Время" : "Время",
	"Альбом OpenPhotoVR" : "Фотоальбом",
	"Встраиваемый код" : "Embed video",

	"Объекты экологического риска" : "Объекты экологического риска",
		"Санкционированные свалки" : "Санкционированные свалки",
		"Несанкционированные свалки" : "Несанкционированные свалки",
		"Полигоны отходов" : "Полигоны отходов",
		"Предприятия переработки отходов" : "Предприятия переработки отходов",
		"Факельные установки, ТЭЦ, трубы" : "Факельные установки, ТЭЦ, трубы",
		"Закрытые свалки" : "Закрытые свалки",
		"Пункты приема отходов" : "Пункты приема отходов",
		"Оползни" : "Оползни",
		"Карстовые явления" : "Карстовые явления",
		"Суффозионные явления" : "Суффозионные явления",

	"Государство и общество" : "Государство и общество",
		"Радио" : "Радио",
		"Правительственные учреждения" : "Правительственные учреждения",
		"Оптики" : "Оптики",
		"Охранные агенства" : "Охранные агенства",
		"Травмпункты" : "Травмпункты",
		"Таможня" : "Таможня",
		"Ветеринарные клиники" : "Ветеринарные клиники",
		"ЗАГС" : "ЗАГС",
		"Больницы" : "Больницы",
		"Аптеки" : "Аптеки",
		"Поликлиники" : "Поликлиники",
		"Колледжи" : "Колледжи",
		"Университеты" : "Университеты",
		"ОВИР" : "ОВИР",
		"Посольства" : "Посольства",
		"Почтовые отделения" : "Почтовые отделения",
		"Суды" : "Суды",
		"Банки" : "Банки",
		"Родильные дома" : "Родильные дома",
		"Дома престарелых" : "Дома престарелых",
		"Детские сады" : "Детские сады",
		"Школы" : "Школы",
		"Инспекции" : "Инспекции",
		"Адвокаты" : "Адвокаты",
		"МЧС" : "МЧС",
		"Муниципальные учреждения" : "Муниципальные учреждения",
		"Администрация" : "Администрация",

	"Культура и отдых" : "Культура и отдых",
		"Боулинг" : "Боулинг",
		"Аквапарки" : "Аквапарки",
		"Парки развлечений" : "Парки развлечений",
		"Библиотеки" : "Библиотеки",
		"Памятники" : "Памятники",
		"Лагери отдыха" : "Лагери отдыха",
		"Кинотеатры" : "Кинотеатры",
		"Цирки" : "Цирки",
		"Галереи" : "Галереи",
		"Отели" : "Отели",
		"Мотели" : "Мотели",
		"Музеи" : "Музеи",
		"Концертные залы" : "Концертные залы",
		"Ночные клубы" : "Ночные клубы",
		"Театры" : "Театры",
		"Санатории" : "Санатории",
		"Зоопарки" : "Зоопарки",

	"Общественное питание" : "Общественное питание",
		"Кафе" : "Кафе",
		"Фастфуды" : "Фастфуды",
		"Рестораны" : "Рестораны",
		"Кафе-мороженое" : "Кафе-мороженое",
		"Столовые" : "Столовые",

	"Природные достопримечательности" : "Природные достопримечательности",
		"Ботанический сад" : "Ботанические сады",
		"Пещеры" : "Пещеры",
		"Водопады" : "Водопады",
		"Парки" : "Парки",
		"Источники" : "Источники",
		"Заповедники" : "Заповедники",
		"Прочие архитектурные и природные достопримечательности" : "Архитектурные достопримечательности",

	"Религия" : "Религия",
		"Культовые сооружения" : "Культовые сооружения",
		"Мечети" : "Мечети",
		"Монастыри" : "Монастыри",
		"Церкви других христианских конфессий" : "Церкви других христианских конфессий",
		"Православные церкви" : "Православные церкви",
		"Синагоги" : "Синагоги",

	"Спорт" : "Спорт",
		"Стадионы" : "Стадионы",
		"Теннисные корты" : "Теннисные корты",
		"Катки" : "Катки",
		"Ипподромы" : "Ипподромы",
		"Фитнес" : "Фитнес",
		"Бассейны" : "Бассейны",
		"Прокат спортинвентаря" : "Прокат спортинвентаря",

	"Торговля и услуги" : "Торговля и услуги",
		"Солярии" : "Солярии",
		"Интернет-кафе" : "Интернет-кафе",
		"Рынки" : "Рынки",
		"Стоматологические клиники" : "Стоматологические клиники",
		"Магазины одежды" : "Магазины одежды",
		"Парикмахерские" : "Парикмахерские",
		"Бани" : "Бани",
		"Магазины обуви" : "Магазины обуви",
		"Магазины" : "Магазины",
		"Ателье" : "Ателье",
		"Такси" : "Такси",
		"Туризм" : "Туризм",

	"Транспорт и услуги" : "Транспорт и услуги",
		"Аэропорты" : "Аэропорты",
		"Автосервисы" : "Автосервисы",
		"Автовокзалы" : "Автовокзалы",
		"ДПС" : "ДПС",
		"ГИБДД" : "ГИБДД",
		"Шиномонтаж" : "Шиномонтаж",
		"Парковки бесплатные" : "Парковки бесплатные",
		"Парковки платные" : "Парковки платные",
		"АЗС" : "АЗС",
		"Автомойки" : "Автомойки",

	"Экстренные службы" : "Экстренные службы",
		"Пожарные/спасатели" : "Пожарные/спасатели",
		"Милиция" : "Милиция",
		"Скорая помощь" : "Скорая помощь",

	"Другие темы" : "Другие темы",
		"Разное" : "Разное",

	"Изменение пароля" : "Password change",
	"Новый пароль" : "New password",
	"Старый пароль" : "Old password",
	"Подтвердите пароль" : "Confirm password",
	"Контур" : "Border",
	"$$phrase$$_17" : "Add border by clicking \"Polygon\" tool on toolbar",
	"Выбор контура" : "Border select",
	"Таблица атрибутов слоя [value0]" : "[value0] attributes table",
	"Показать параметры поиска" : "Show search params",
	"Скрыть параметры поиска" : "Hide search params",
	"Скрыть" : "Hide",
	"Искать внутри полигона" : "Search inside polygon",
	"Искать по пересечению с объектом" : "Search by geometry",
	"SQL-условие WHERE" : "WHERE SQL expression",
	"Колонки" : "Columns",
	"Показывать колонки" : "Show columns",
	"Найти" : "Search",
	"Нет полей" : "Empty fields",
	"Нет данных" : "Empty data",
	"Таблица атрибутов" : "Attributes table",
	"Разрешить поиск" : "Allow search",
	"Произвольный" : "Any",
	"День" : "Day",
	"Неделя" : "Week",
	"Месяц" : "Month",
	"Год" : "Year",
	"Ежегодно" : "Every year",
	"Облачность" : "Clouds",
	"Период" : "Period",
	"Спутниковые покрытия" : "Satellite cover",
	"Редактировать объект слоя [value0]" : "Edit layer [value0] object",
	"Создать объект слоя [value0]" : "Add layer [value0] object",
	"Геометрия" : "Geometry",
	"Найти объекты" : "Find objects",
	"Добавить объекты" : "Add objects",
	"Обновить объекты" : "Update objects",
	"Изменить колонки" : "Update columns",
	"Обновить колонку" : "Update column",
	"Очистить поиск" : "Clean search",
    "Скачать shp": "Download shp",
    "Скачать gpx": "Download gpx",
    "Скачать csv": "Download csv",
    "Скачать geojson": "Download geojson",
    "Рассчитать площадь": "Total square",
	"Создать столбец" : "Create column",
	"Мультислой" : "Multilayer",
	"В дереве слоев остались несохраненные изменения!" : "There are unsaved changes on layers tree!",
	"файл версии отсутствует" : "version file doesn't exists",
	"оверлеи отсутствуют" : "no overlays present",
	"Хост" : "Host",
	"Дополнительные карты" : "Additional maps",
	"Добавить карту" : "Add map",
	"Добавить в таймлайн" : "Add to timeLine",
	"Удалить из таймлайна" : "Remove from timeline",
	"Невозможно загрузить карту [value0] с домена [value1]" : "Unable to load map [value0] from domain [value1]",
	"Показывать" : "Show",
	"Поиск снимков" : "Search imagery",
	"Принудительно обновить тайлы" : "Forced retiling",
	"Обводка" : "Outline",
	"Карта имеет более новую версию. Сохранить?" : "The map has a newer version. Save anyway?",
	"Кодировка": "Encoding",
	"helpPostfix": "_eng.html",
	"Показывать чекбокс видимости": "Visibility checkbox",
	"Разворачивать автоматически": "Expand automatically",
	"Другая": "Another",
	"Временнóй слой": "Multitemporal layer",
	"Колонка даты": "Date column",
	"Минимальный период": "Min. period (days)",
	"Максимальный период": "Max. period (days)",
    "Отсутствует временной атрибут": "Missing attribute with type 'Date'",
    "Период 1 день": "Period 1 day",
    "Показывать на карте данные за": "Show data on map within",
    "1 день": "single day",
    "произвольный период" : "arbitrary period",
	"По границе экрана": "Screen border",
	"По центру экрана": "Screen center",
	"Пересечение": "Intersection",
	"Пролистывать слои": "Scroll layers",
	"Следующий слой": "Next layer",
	"Предыдущий слой": "Previous layer",
    "Геометрия не сохранена. Эта возможность будет реализована в будущих версиях Геомиксера.": "Geometry is not saved. This feature will be implemented in future Geomixer versions",
    "WMS доступ": "WMS/WFS access",
    "ссылка": "link",
    "Слой '[value0]' уже есть в карте": "Layer '[value0]' already exists in this map",
    "Группа '[value0]' уже есть в карте": "Group '[value0]' already exists in this map",
    "Плагины": "Plugins",
    "Вручную": "Manually",
    "Добавить атрибут": "Add attribute",
    "Проекция": "Projection",
    "Широта/Долгота (EPSG:4326)": "Lat/Lon (EPSG:4326)",
    "Меркатор (EPSG:3395)": "Mercator (EPSG:3395)",
    "Из файла": "From file",
    "Мультиполигон": "Multipolygon",
    "Мультилиния": "Multipolyline",
    "Мультиточка": "Multipoint",
    "Администрирование": "Administration",
    "Системные настройки": "System settings",
    "Управление группами": "User group management",
    "Управление группами пользователей": "User group management",
    "Добавить снимки": "Add rasters",
    "Существующие слои": "Existing layers",
    "Слои из карты": "Layers from map",
    "Слои из КР": "Layers from RC",
    "Новый слой": "New layer",
    "С экрана": "Select on map",
    "Добавлен растр": "Raster is added",
    "Добавлены растры": "Rasters are added",
    "Выбранный объект не имеет растра": "Selected object has no raster",
    "Этот растр уже был выбран": "This raster is already selected",
    "Каталог Растров": "Raster catalog",
    "Растр": "Raster",
    "Добавить выбранные растры": "Add selected rasters",
    "EditObject.menuTitle" : "Add object",
    "FileBrowser.ExceedLimitMessage" : "File size exceeds 500 Mb. Use GeoMixerFileBrowser tool to upload large files.",
    "FileBrowser.DropInfo" : "Drop files here",
    "EditObject.drawingMenuTitle" : "Add object to active layer",
    "Поставить маркер": "Add marker",
    "Центрировать": "Set center",
    "Пароль изменён": "Password has been changed",
	"портретная": "portrait view",
	"альбомная": "layout view",
	"gmx_geometry": "gmx_geometry"
};

var nsGmx = nsGmx || {};
nsGmx.Utils = nsGmx.Utils || {};

(function()
{
    var domManipulation = {
        // _el(nodeName, [childs], [attrs])
        _el: function(str, childs, attributes)
        {
            var el = document.createElement(str),
                children = childs,
                attrs = attributes;

            if (children)
                domManipulation._childs(el, children)

            if (attrs && attrs.length)
                domManipulation._attr(el, attrs)

            return el;
        },
        // _t("some text")
        _t: function(str)
        {
            return document.createTextNode(String(str));
        },
        // children - всегда массив
        _childs: function(el, children)
        {
            for (var i = 0; i < children.length; ++i)
                el.appendChild(children[i]);
        },
        //[['css','width','100%']]
        //[['dir','className','name']]
        //[['attr','colSpan',2]]
        _attr: function(el, attrs)
        {
            for (var i = 0; i < attrs.length; ++i)
            {
                var atr = attrs[i],
                    type = atr[0];

                switch(type)
                {
                    case 'css':
                        (el.style[atr[1]] = atr[2]);
                        break;
                    case 'dir':
                        el[atr[1]] = atr[2];
                        break;
                    case 'attr':
                        el.setAttribute(atr[1], atr[2]);
                        break;
                }
            }
        },
        _table: function(children,attrs){return _el('TABLE',children,attrs)},
        _caption: function(children,attrs){return _el('CAPTION',children,attrs)},
        _thead: function(children,attrs){return _el('THEAD',children,attrs)},
        _tbody: function(children,attrs){return _el('TBODY',children,attrs)},
        _tfoot: function(children,attrs){return _el('TFOOT',children,attrs)},
        _textarea: function(children,attrs){return _el('TEXTAREA',children,attrs)},
        _th: function(children,attrs){return _el('TH',children,attrs);} ,
        _tr: function(children,attrs){return _el('TR',children,attrs);},
        _td: function(children,attrs){return _el('TD',children,attrs);},
        _span: function(children,attrs){return _el('SPAN',children,attrs);},
        _label: function(children,attrs){return _el('LABEL',children,attrs);},
        _li: function(children,attrs){return _el('LI',children,attrs);},
        _ul: function(children,attrs){return _el('UL',children,attrs);},
        _div: function(children,attrs){return _el('DIV',children,attrs);},
        _radio: function(attrs){return _el('INPUT',null,(attrs&&attrs.concat([['attr','type','radio']]))||[['attr','type','radio']])},
        _button: function(children,attrs){return _el('BUTTON',children,attrs)},
        _a: function(children,attrs){return _el('A',children,attrs)},
        _select: function(children,attrs){return _el('SELECT',children,attrs)},
        _option: function(children,attrs){return _el('OPTION',children,attrs);},
        _form: function(children,attrs){return _el('FORM',children,attrs)},
        _iframe: function(children,attrs){return _el('IFRAME',children,attrs)},
        _image: function(children,attrs){return _el('IMG',children,attrs)},
        _img: function(children,attrs){return _el('IMG',children,attrs)},
        _br: function(){return _el('BR')},
        _hr: function(){return _el('HR')},
        _p: function(children,attrs){return _el('P',children,attrs)},
        _b: function(children,attrs){return _el('B',children,attrs)},
        _i: function(children,attrs){return _el('I',children,attrs)},
        _input: function(children,attrs){return _el('INPUT',children,attrs)}
    }

    var _el = domManipulation._el;

    // _(elem, [childs], [attrs])
    var _ = function(ent,childs,attributes)
    {
        var el = ent,
            children = childs,
            attrs = attributes;

        if (children)
            domManipulation._childs(el, children)

        if (attrs && attrs.length)
            domManipulation._attr(el, attrs)

        return el;
    };

    var prevGlobals = {};
    for (var k in domManipulation) {
        prevGlobals[k] = window[k];
    }

    /** Удаляет из глобальной видимости часть методов, записанных туда при загрузке utilities.js
    * @memberOf nsGmx.Utils
    */
    nsGmx.Utils.noConflicts = function() {
        for (var k in domManipulation) {
            window[k] = prevGlobals[k];
        }
        return nsGmx.Utils;
    }

    jQuery.extend(window, domManipulation);      //для обратной совместимости
    jQuery.extend(nsGmx.Utils, domManipulation);
    nsGmx.Utils._ = _;
})();

if (window.Node && window.Node.prototype)
{
	Node.prototype.removeNode = function()
	{
		var parent = this.parentNode;
		parent && parent.removeChild(this);
	}
}

function getkey(e)
{
	if (window.event)
		return window.event.keyCode;
	else if (e)
		return e.which;
	else
		return null;
}

function show(elem)
{
	elem.style.display = '';
}
function hide(elem)
{
	elem.style.display = 'none';
}
function hidden(elem)
{
	elem.style.visibility = 'hidden';
}
function visible(elem)
{
	elem.style.visibility = 'visible';
}
function switchSelect(sel, value)
{
	if (!sel.options || !sel.options.length)
		return sel;

	for (var i = 0; i < sel.options.length; i++)
	{
		if (value == sel.options[i].value)
		{
			sel.options[i].selected = true;

			sel.selectedIndex = i;

			break;
		}
	}

	return sel;
}
function objLength(obj)
{
	var cnt = 0;
	for (var field in obj) cnt++;

	return cnt;
}
function valueInArray(arr, value)
{
	for (var i = 0; i < arr.length; i++)
		if (arr[i] == value)
			return true;

	return false;
}
function getOffsetRect(elem)
{
    var box = elem.getBoundingClientRect(),
    	body = document.body,
    	docElem = document.documentElement,
    	scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
    	scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
    	clientTop = docElem.clientTop || body.clientTop || 0,
    	clientLeft = docElem.clientLeft || body.clientLeft || 0,
    	top  = box.top +  scrollTop - clientTop,
    	left = box.left + scrollLeft - clientLeft;

    return { top: Math.round(top), left: Math.round(left) }
}
function attachEffects(elem, className)
{
	elem.onmouseover = function()
	{
		jQuery(this).addClass(className)
	}
	elem.onmouseout = function(e)
	{
		var evt = e || window.event,
			target = evt.srcElement || evt.target,
			relTarget = evt.relatedTarget || evt.toElement;

		try
		{
			while (relTarget)
			{
				if (relTarget == elem)
					return;
				relTarget = relTarget.parentNode;
			}

			jQuery(elem).removeClass(className)
		}
		catch (e)
		{
			jQuery(elem).removeClass(className)
		}
	}
}
function makeButton(value, id)
{
	var inp = _input(null, [['dir','className','btn'],['attr','type','submit'],['attr','value',value]]);
	if (typeof id != 'undefined' && id != null)
		inp.id = id;

	inp.style.padding = '0px 5px';

	return inp;
}
function makeImageButton(url, urlHover)
{
	var btn = _img();
	btn.setAttribute('src',url)
	btn.style.cursor = 'pointer';
	btn.style.border = 'none';

	if (urlHover)
	{
		btn.onmouseover = function()
		{
			this.setAttribute('src', urlHover);
		}
		btn.onmouseout = function()
		{
			this.setAttribute('src', url);
		}
	}

	return btn;
}
function makeLinkButton(text)
{
	var span = _span([_t(String(text))],[['dir','className','buttonLink']]);

	attachEffects(span, 'buttonLinkHover')

	return span;
}
function makeHelpButton(helpText){
	var btn = makeImageButton(getAPIHostRoot() + 'api/img/help.gif');
	btn.setAttribute('title', helpText)
	btn.onclick = function(){
		showDialog('', _t(helpText), 300, 150);
	}
	return btn;
}

function getOwnChildNumber(elem)
{
	for (var i = 0; i < elem.parentNode.childNodes.length; i++)
		if (elem == elem.parentNode.childNodes[i])
			return i;
}
function stopEvent(e)
{
	if(!e) var e = window.event;

	//e.cancelBubble is supported by IE - this will kill the bubbling process.
	e.cancelBubble = true;
	e.returnValue = false;

	//e.stopPropagation works only in Firefox.
	if (e.stopPropagation)
	{
		e.stopPropagation();
		e.preventDefault();
	}
	return false;
}

//Показывает диалог (на основе jQuery UI dialog)
//Параметры можно передавать явно и в виде объекта params:
//1. showDialog(title, content, width, height, ?posX, ?posY, ?resizeFunc, ?closeFunc)
//2. showDialog(title, content, params)
//Параметры:
// - title {string} Заголовок диалога
// - content {HTMLDomElement} контент диалога
// - width, height {int} высота и ширина диалога (обязательные параметры!)
// - posX, posY {int} положение диалога относительно экрана. Если не задано - по центру
// - resizeFunc {function} будет вызываться при изменении размера диалога. Аргумент ф-ции - объект с атриубтами width и height
// - closeFunc {function} будет вызываться при закрытии диалога
// - setMinSize {bool} если true (по умолчанию), будут заданы минимальная ширина и высота, равные начальным размерам (width, height)
function showDialog(title, content, width, height, posX, posY, resizeFunc, closeFunc)
{
    var params = null;
    if (arguments.length == 3)
    {
        params = $.extend({
            posX: false,
            posY: false,
            setMinSize: true
        }, width);
    }
    else
    {
        params = {
            width: width,
            height: height,
            posX: posX,
            posY: posY,
            resizeFunc: resizeFunc,
            closeFunc: closeFunc,
            setMinSize: true
        }
    }
	var canvas = _div([content]);

	document.body.appendChild(canvas);

	var dialogParams = {
        width: params.width,
        height: params.height,
        title: title,
        position: params.posX == false ? 'center' : [params.posX, params.posY],
        resizable: true,
        resize: function(event, ui)
        {
            params.resizeFunc && params.resizeFunc(ui.size);
        },
        close: function(ev, ui)
        {
            if (params.closeFunc && params.closeFunc())
                return;

            removeDialog(canvas);
        },
        open: function (ev, ui) {
        },
        closeText: null
    };

    if (params.setMinSize)
    {
        dialogParams.minWidth = params.width;
        dialogParams.minHeight = params.height;
    }

    jQuery(canvas).dialog(dialogParams);

	var dialog = canvas.parentNode;
	dialog.style.overflow = '';

    $(dialog).focusout(function (event) {

        event.stopImmediatePropagation();
        event.stopPropagation();
        event.preventDefault();
        jQuery.support.focusinBubbles = false;
        var ui = $('.ui-dialog-content', this);
            ui.context.st = $(ui).scrollTop();

    });

    $(dialog).focusin(function() {
        var uis = $('.ui-dialog-content');

        $(uis).each(function(index) {
            var st = $(this).context.st;
            $(this).scrollTop(st);
        });

    });


	jQuery(dialog).children("div.ui-resizable-se").removeClass("ui-icon")
				.removeClass("ui-icon-gripsmall-diagonal-se")
				.removeClass("ui-icon-grip-diagonal-se");

	return canvas;
}

function removeDialog(canvas)
{
	jQuery(canvas).dialog('destroy').remove();
}

function showErrorMessage(message, removeFlag, title)
{
	var canvas = _div([_t(message)],[['dir','className','errorDialog']]);
        jQueryDiv = showDialog(title || "Ошибка!", canvas, {
            width: 250,
            height: 150,
            closeFunc: function(){
                canvas = null;
            }
        });

	if (removeFlag)
	{
		setTimeout(function()
		{
			if (canvas)
			{
                jQuery(jQueryDiv).dialog("destroy");
				jQuery(canvas.parentNode).remove();
			}
		}, 2500)
	}
}

function _checkbox(flag, type, name)
{
	var box = _input(null, [['attr','type',type]]);
    box.checked = flag;

    if (name)
        box.setAttribute('name', name);

	return box;
}

function insertAtCursor(myField, myValue, sel)
{
    if (myField.id && window.tinyMCE && tinyMCE.get(myField.id)) {
        tinyMCE.execInstanceCommand(myField.id, "mceInsertContent", false, myValue);
        return;
    }

	if (document.selection)
	{
		if (typeof sel != 'undefined')
			sel.text = myValue;
		else
		{
			myField.focus();
			var sel = document.selection.createRange();
			sel.text = myValue;
		}
	}
	else if (myField.selectionStart || myField.selectionStart == '0')
	{
		var startPos = myField.selectionStart,
			endPos = myField.selectionEnd;

		myField.value = myField.value.substring(0, startPos) + myValue + myField.value.substring(endPos, myField.value.length);
	}
	else
		myField.value += myValue;
}

/* ----------------------------- */
function sendRequest(url, callback, body)
{
	var xmlhttp;
	if (typeof XMLHttpRequest != 'undefined')
		xmlhttp = new XMLHttpRequest();
	else
		try { xmlhttp = new ActiveXObject("Msxml2.XMLHTTP"); }
		catch (e) { try {xmlhttp = new ActiveXObject("Microsoft.XMLHTTP"); } catch (E) {}}

	xmlhttp.open(body ? "POST" : "GET", url, true);
	if (body)
	{
		xmlhttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
		xmlhttp.setRequestHeader('Content-length', body.length);
	}
	xmlhttp.onreadystatechange = function() { if (xmlhttp.readyState == 4) callback(xmlhttp); }
	xmlhttp.send(body || "");
}

function sendJSONRequest(url, callback)
{
	sendRequest(url, function(xmlhttp)
	{
		var text = xmlhttp.responseText;
		callback(JSON.parse(text));
	});
}

nsGmx.Utils.uniqueGlobalName = (function()
{
    var freeid = 0;
    return function(thing)
    {
        var id = 'gmx_unique_' + freeid++;
        window[id] = thing;
        return id;
    }
})();

/** Посылает кросс-доменный GET запрос к серверу с использованием транспорта JSONP.
 *
 * @memberOf nsGmx.Utils
 * @param {String} url URL сервера.
 * @param {Function} callback Ф-ция, которая будет вызвана при получении от сервера результата.
 * @param {String} [callbackParamName=CallbackName] Имя параметра для задания имени ф-ции ответа.
 * @param {Function} [errorCallback] Ф-ция, которая будет вызвана в случае ошибки запроса к серверу
 */
function sendCrossDomainJSONRequest(url, callback, callbackParamName, errorCallback)
{
	callbackParamName = callbackParamName || 'CallbackName';

    var script = document.createElement("script");
	script.setAttribute("charset", "UTF-8");
	var callbackName = nsGmx.Utils.uniqueGlobalName(function(obj)
	{
		callback && callback(obj);
		window[callbackName] = false;
		document.getElementsByTagName("head").item(0).removeChild(script);
	});

    var sepSym = url.indexOf('?') == -1 ? '?' : '&';

    if (errorCallback) {
        script.onerror = errorCallback;
    }

	script.setAttribute("src", url + sepSym + callbackParamName + "=" + callbackName + "&" + Math.random());
	document.getElementsByTagName("head").item(0).appendChild(script);
}
nsGmx.Utils.sendCrossDomainJSONRequest = sendCrossDomainJSONRequest;

function createCookie(name, value, days)
{
	if (days)
	{
		var date = new Date();
		date.setTime(date.getTime() + (days*24*60*60*1000));
		var expires = "; expires=" + date.toGMTString();
	}
	else
		var expires = "";
	document.cookie = name + "=" + value + expires + "; path=/";
}

function readCookie(name)
{
	var nameEQ = name + "=";
	var ca = document.cookie.split(';');
	for(var i = 0; i < ca.length; i++)
	{
		var c = ca[i];
		while (c.charAt(0)==' ')
			c = c.substring(1, c.length);
		if (c.indexOf(nameEQ) == 0)
			return c.substring(nameEQ.length, c.length);
	}
	return null;
}

function eraseCookie(name)
{
	createCookie(name, "", -1);
}

function getWindowWidth()
{
	var myWidth = 0;

	if (typeof (window.innerWidth) == 'number')
		myWidth = window.innerWidth;
	else if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight))
		myWidth = document.documentElement.clientWidth;
	else if (document.body && (document.body.clientWidth || document.body.clientHeight))
	{
		myWidth = document.body.clientWidth;
	}

	return myWidth;
}

function getWindowHeight()
{
	var myHeight = 0;

	if (typeof (window.innerWidth) == 'number' )
		myHeight = window.innerHeight;
	else if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight))
		myHeight = document.documentElement.clientHeight;
	else if (document.body && (document.body.clientWidth || document.body.clientHeight))
		myHeight = document.body.clientHeight;

	return myHeight;
}

function strip(s)
{
	return s.replace(/^\s*/, "").replace(/\s*$/, "");
}

(function() {
    var replacements = {};
    for (var rus in (temp = {
        "qwertyuiopasdfghjklzxcvbnm_1234567890" :
        "qwertyuiopasdfghjklzxcvbnm_1234567890",
        "абвгдезийклмнопрстуфыэ ":
        "abvgdeziyklmnoprstufye_",
        "ёжчхцшщюя":
        "yozhchkhtsshshyuya",
        "ьъ":
        "",
        ".":
        "."
    }))
    {
        var eng = temp[rus],
            k = eng.length/rus.length;
        for (var i = 0; i < rus.length; i++)
        {
            var r = rus.substring(i, i + 1),
                e = eng.substring(i*k, (i + 1)*k);
            replacements[r] = e;
            replacements[r.toUpperCase()] = e.toUpperCase();
        }
    }

    nsGmx.Utils.translit = function(name)
    {
        var result = "";
        for (var i = 0; i < name.length; i++)
            result += (replacements[name.substring(i, i + 1)] || "");

        return result;
    }
})();

function loadFunc(iframe, callback)
{
	var win = iframe.contentWindow;

    //skip first onload in safari
    if ( jQuery.browser.safari && !iframe.safariSkipped)
    {
        iframe.safariSkipped = true;
        return;
    }

	if (iframe.loaded)
	{
		var data = decodeURIComponent(win.name.replace(/\n/g,'\n\\'));
        jQuery(iframe).remove();

		var parsedData;
		try
		{
			parsedData = JSON.parse(data)
		}
		catch(e)
		{
			parsedData = {Status:"error",ErrorInfo: {ErrorMessage: "JSON.parse exeption", ExceptionType:"JSON.parse", StackTrace: data}}
		}

		callback && callback(parsedData);
	}
	else
	{
		win.location = 'about:blank';
        iframe.loaded = true;
	}

}

function createPostIframe(id, callback)
{
	var userAgent = navigator.userAgent.toLowerCase(),
		callbackName = nsGmx.Utils.uniqueGlobalName(function()
		{
			loadFunc(iframe, callback);
		}),
		iframe;

	try {
		iframe = document.createElement('<iframe style="display:none" onload="' + callbackName + '()" src="javascript:true" id="' + id + '" name="' + id + '"></iframe>');
    }
	catch(e)
	{
		iframe = document.createElement("iframe");
		iframe.style.display = 'none';
		iframe.setAttribute('id', id);
		iframe.setAttribute('name', id);
		iframe.src = 'javascript:true';
		iframe.onload = window[callbackName];
	}

	return iframe;
}

!function() {
    var requests = {},
        lastRequestId = 0,
        uniquePrefix = 'id' + Math.random();

    var processMessage = function(e) {
        if (!(e.origin in requests)) {
            return;
        }

        var dataStr = decodeURIComponent(e.data.replace(/\n/g,'\n\\'));
        try {
            var dataObj = JSON.parse(dataStr);
        } catch (e) {
            request.callback && request.callback({Status:"error", ErrorInfo: {ErrorMessage: "JSON.parse exeption", ExceptionType: "JSON.parse", StackTrace: dataStr}});
        }

        // console.log(dataObj);
        var request = requests[e.origin][dataObj.CallbackName];
        if(!request) return;    // message от других запросов

        delete requests[e.origin][dataObj.CallbackName];
        delete dataObj.CallbackName;

        request.iframe.parentNode.removeChild(request.iframe);
        request.callback && request.callback(dataObj);
    }

    //совместимость с IE8
    if (window.addEventListener) {
        window.addEventListener('message', processMessage);
    } else {
        window.attachEvent('onmessage', processMessage);
    }

    //скопирована из API для обеспечения независимости от него
    var parseUri = function (str) {
        var	o   = parseUri.options,
            m   = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str),
            uri = {},
            i   = 14;

        while (i--) {
            uri[o.key[i]] = m[i] || '';
        }

        uri[o.q.name] = {};
        uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
            if ($1) { uri[o.q.name][$1] = $2; }
        });

        uri.hostOnly = uri.host;
        uri.host = uri.authority; // HACK

        return uri;
    };

    parseUri.options = {
        strictMode: false,
        key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
        q:   {
            name:   'queryKey',
            parser: /(?:^|&)([^&=]*)=?([^&]*)/g
        },
        parser: {
            strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
            loose:  /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
        }
    };

    function createPostIframe2(id, callback, url)
    {
        var uniqueId = uniquePrefix + (lastRequestId++);

        iframe = document.createElement("iframe");
        iframe.style.display = 'none';
        iframe.setAttribute('id', id);
        iframe.setAttribute('name', id);
        iframe.src = 'javascript:true';
        iframe.callbackName = uniqueId;
        //iframe.onload = window[callbackName];

        var parsedURL = parseUri(url);
        var origin = (parsedURL.protocol ? (parsedURL.protocol + ':') : window.location.protocol) + '//' + (parsedURL.host || window.location.host);

        requests[origin] = requests[origin] || {};
        requests[origin][uniqueId] = {callback: callback, iframe: iframe};

        return iframe;
    }

    window.createPostIframe2 = createPostIframe2;

}();

/** Посылает кроссдоменный POST запрос
*
* @memberOf nsGmx.Utils
* @param {String} url URL запроса
* @param {Object} params Хэш параметров-запросов
* @param {Function} [callback] Callback, который вызывается при приходе ответа с сервера. Единственный параметр ф-ции - собственно данные
* @param {DOMElement} [baseForm] базовая форма запроса. Используется, когда нужно отправить на сервер файл.
*                                В функции эта форма будет модифицироваться, но после отправления запроса будет приведена к исходному виду.
*/
function sendCrossDomainPostRequest(url, params, callback, baseForm)
{
	var form,
		rnd = String(Math.random()),
		id = '$$iframe_' + url + rnd;

	var iframe = createPostIframe2(id, callback, url),
        originalFormAction;

	if (baseForm)
	{
		form = baseForm;
        originalFormAction = form.getAttribute('action');
		form.setAttribute('action', url);
		form.target = id;

	}
	else
	{
		try {
			form = document.createElement('<form id=' + id + '" enctype="multipart/form-data" style="display:none" target="' + id + '" action="' + url + '" method="post"></form>');
        }
		catch (e)
		{
			form = document.createElement("form");
			form.style.display = 'none';
			form.setAttribute('enctype', 'multipart/form-data');
			form.target = id;
			form.setAttribute('method', 'POST');
			form.setAttribute('action', url);
			form.id = id;
		}
	}

    var hiddenParamsDiv = document.createElement("div");
    hiddenParamsDiv.style.display = 'none';

    if (params.WrapStyle === 'window') {
        params.WrapStyle = 'message';
    }

    if (params.WrapStyle === 'message') {
        params.CallbackName = iframe.callbackName;
    }

	for (var paramName in params)
	{
		var input = document.createElement("input");

        var value = typeof params[paramName] !== 'undefined' ? params[paramName] : '';

		input.setAttribute('type', 'hidden');
		input.setAttribute('name', paramName);
		input.setAttribute('value', value);

		hiddenParamsDiv.appendChild(input)
	}

    form.appendChild(hiddenParamsDiv);

	if (!baseForm)
		document.body.appendChild(form);

	document.body.appendChild(iframe);

	form.submit();

    if (baseForm)
    {
        form.removeChild(hiddenParamsDiv);
        if (originalFormAction !== null)
            form.setAttribute('action', originalFormAction);
        else
            form.removeAttribute('action');
    }
    else
    {
        form.parentNode.removeChild(form);
    }
}

(function() {

    var hooks = {};

    /** Добавляет "хук", который будет вызван при ответе сервера соответвующего типа
    * @param type {object} - тип хука (соответствует полю "Status" ответа сервера) или '*' - добавить к любому ответу
    * @param hookFunction {function(response, customErrorDescriptions)} - собственно хук
    */
    window.addParseResponseHook = function(type, hookFunction) {
        hooks[type] = hooks[type] || [];
        hooks[type].push(hookFunction);
    }

    /** Обрабатывает результат выполнения серверного скрипта.
    * Для выполнения действий вызывает "хуки" соответствующиего типа, добавленные через addParseResponseHook()
    * @function
    * @global
    * @param {object} response JSON, вернувшийся с сервера
    * @param {object} customErrorDescriptions хэш "тип ошибки" -> "кастомное сообщение пользователям".
    * @return true, если статус ответа "ok", иначе false
    */
    window.parseResponse = function(response, customErrorDescriptions)
    {
        var responseHooks = (hooks[response.Status] || []).concat(hooks['*'] || []);
        for (var h = 0; h < responseHooks.length; h++)
            responseHooks[h](response, customErrorDescriptions);

        return response.Status == 'ok';
    }

})();

function _title(elem, title)
{
	elem.setAttribute('title', title);
}

function parseXML(str)
{
	var xmlDoc;
	try
	{
		if (window.DOMParser)
		{
			parser = new DOMParser();
			xmlDoc = parser.parseFromString(str,"text/xml");
		}
		else // Internet Explorer
		{
			xmlDoc = new ActiveXObject("MSXML2.DOMDocument.3.0");
			xmlDoc.validateOnParse = false;
			xmlDoc.async = false;
			xmlDoc.loadXML(str);
		}
	}
	catch(e)
	{
		alert(e)
	}

	return xmlDoc;
}

function disableSelection(target)
{
	if (typeof target.onselectstart != "undefined")
	    target.onselectstart = function(){return false}
	else if (typeof target.style.MozUserSelect != "undefined")
	    target.style.MozUserSelect = "none"
	else
	    target.onmousedown = function(){return false}
}

function parsePropertiesDate(str)
{
	if (str == null || str == "")
		return 0;

	var dateParts = str.split('.');

	if (dateParts.length != 3)
		return 0;

	return new Date(dateParts[2], dateParts[1] - 1, dateParts[0]).valueOf();
}

function stringDate(msec, isUtc)
{
	var date = new Date(msec);
		excDate = isUtc ? date.getUTCDate() : date.getDate(),
		excMonth = (isUtc ? date.getUTCMonth() : date.getMonth()) + 1,
		excYear = isUtc ? date.getUTCFullYear() : date.getFullYear();

	return (excDate < 10 ? '0' + excDate : excDate) + '.' + (excMonth < 10 ? '0' + excMonth : excMonth) + '.' + excYear;
}

function stringTime(msec, isUtc)
{
	var date = new Date(msec);
		excHour = isUtc ? date.getUTCHours() : date.getHours(),
		excMin = isUtc ? date.getUTCMinutes() : date.getMinutes(),
		excSec = isUtc ? date.getUTCSeconds() : date.getSeconds();

	return (excHour < 10 ? '0' + excHour : excHour) + ':' + (excMin < 10 ? '0' + excMin : excMin) + ':' + (excSec < 10 ? '0' + excSec : excSec);
}

function stringDateTime(msec, isUtc)
{
	return stringDate(msec, isUtc) + ' ' + stringTime(msec, isUtc);
}

/** Подсвечивает красным input, убирает подсветку через некоторое время
*
* @param {HTMLDOMElement|Array<HTMLDOMElement>} input - целевой input-элемент или массив таких элементов
* @param {integer} delay - время подсвечивания ошибки в миллисекундах
*/
function inputError(input, delay)
{
    delay = delay || 1000;
    if (!jQuery.isArray(input))
        input = [input];

    for (var k = 0; k < input.length; k++)
        jQuery(input[k]).addClass('error');

	setTimeout(function()
	{
        for (var k = 0; k < input.length; k++)
            if (input[k])
                jQuery(input[k]).removeClass('error');
	}, delay)
}

function equals(x, y)
{
	for(p in y)
	{
	    if(typeof(x[p])=='undefined') {return false;}
	}

	for(p in y)
	{
	    if (y[p])
	    {
	        switch(typeof(y[p]))
	        {
	                case 'object':
	                        if (!equals(x[p], y[p])) { return false }; break;
	                case 'function':
	                        if (typeof(x[p])=='undefined' || (p != 'equals' && y[p].toString() != x[p].toString())) { return false; }; break;
	                default:
	                        if (y[p] != x[p]) { return false; }
	        }
	    }
	    else
	    {
	        if (x[p])
	        {
	            return false;
	        }
	    }
	}

	for(p in x)
	{
	    if(typeof(y[p])=='undefined') {return false;}
	}

	return true;
}

/**
    @namespace nsGmx.Utils
    @description Разнообразные вспомогательные ф-ции
*/
$.extend(nsGmx.Utils, {

    /**
        Возвращает уникальную строку (16 символов из букв и латинских цифр)
        @function
        @memberOf nsGmx.Utils
    */
    generateUniqueID: function()
    {
        var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz",
            randomstring = '';

        for (var i = 0; i < 16; i++)
        {
            var rnum = Math.floor(Math.random() * chars.length);
            randomstring += chars.charAt(rnum);
        }

        return randomstring;
    },
    /**
        Преобразует цвет, заданный в виде числа (0xaabbcc) в строку вида #aabbcc
        @function
        @memberOf nsGmx.Utils
    */
    convertColor: function(intColor)
    {
        var r,g,b;

        b = (intColor % 256).toString(16);
        if (b.length == 1)
            b = '0' + b;

        intColor = Math.floor(intColor / 256);
        g = (intColor % 256).toString(16);
        if (g.length == 1)
            g = '0' + g;

        intColor = Math.floor(intColor / 256);
        r = (intColor % 256).toString(16);
        if (r.length == 1)
            r = '0' + r;

        return '#' + r + g + b;
    },
    /**
        Преобразует цвет, заданный в виде строки rgb(255, 255, 255) в строку вида #aabbcc
        @function
        @memberOf nsGmx.Utils
    */
    rgb2hex: function(intColor)
    {
        var str,
            arr = intColor.substring(4, intColor.length-1).split(', ');

        arr = arr.map(function(c){
            var hex = Number(c).toString(16);
            return hex.length == 1 ? "0" + hex : hex;
        });

        str = "#" + arr.join('');

        return str;
    },

    checkForNumber: function (number) {
        return !(isNaN(number) || typeof(number) === 'undefined' || number === null || number === '');
    },

    isJSON: function(str) {
        try {
            JSON.parse(str);
        } catch (e) {
            return false;
        }
        if (str === '' || str === 'null' || str === 'undefined' || typeof(str) === 'Number') {
            return false;
        } else {
            return true;
        }
    },

	/** Возвращает позицию окна такую, чтобы окно не мешало текущему элементу
        @memberOf nsGmx.Utils
    */
	getDialogPos: function(div, offsetFlag, height)
	{
		var pos = getOffsetRect(div),
			left = pos.left + 30,
			top = pos.top - 10,
			windowHeight = getWindowHeight();

		if (offsetFlag)
		{
			$(div).children('div,img').each(function()
			{
				if (!this.getAttribute('multiStyle'))
					left += this.offsetWidth;
			})
		}

		if (top + 15 + height > windowHeight)
			top -= (top + 15 + height - windowHeight);

		return {left: left, top: top}
	},

	/** Устанавливает обычный стиль и генерит похожий стиль при наведении мышки
    @memberOf nsGmx.Utils
	@param layer {L.gmxVectorLayer} Слой
	@param styleIndex {Number} Номер стиля слоя
	@param templateStyle {Style} Стиль, похожий на который надо установить*/
	setMapObjectStyle: function(layer, styleIndex, templateStyle)
	{
        var hoverStyle = $.extend(true, {}, templateStyle);
        var style = layer.getStyle(styleIndex);

        if (templateStyle.outline && typeof templateStyle.outline.thickness != 'undefined')
            hoverStyle.outline.thickness = Number(templateStyle.outline.thickness) + 1;

        if (templateStyle.fill && typeof templateStyle.fill.opacity != 'undefined' && templateStyle.fill.opacity > 0)
            hoverStyle.fill.opacity = Math.min(Number(templateStyle.fill.opacity + 20), 100);

        var newStyle = $.extend(true, {}, style);
        newStyle.RenderStyle = L.gmxUtil.fromServerStyle(templateStyle);
        newStyle.HoverStyle = L.gmxUtil.fromServerStyle(hoverStyle);

        if (templateStyle.labelTemplate) {
          newStyle.RenderStyle.labelTemplate = templateStyle.labelTemplate;
        }
        if (hoverStyle.labelTemplate) {
          newStyle.HoverStyle.labelTemplate = hoverStyle.labelTemplate;
        }

        if (templateStyle.labelAnchor) {
          newStyle.RenderStyle.labelAnchor = templateStyle.labelAnchor;
        }
        if (hoverStyle.labelAnchor) {
          newStyle.HoverStyle.labelAnchor = hoverStyle.labelAnchor;
        }
        layer.setStyle(newStyle, styleIndex);
	},

    // берёт стиль в формате сервера, добавляет в него hover-подсветку
    // и возвращает этот стиль в новом формате Leafelt-Geomixer
    prepareGmxLayerStyle: function(style)
	{
        var templateStyle = style.RenderStyle,
            newStyle = $.extend(true, {}, style),
            hoverStyle = $.extend(true, {}, templateStyle);


        if (templateStyle.outline && typeof templateStyle.outline.thickness != 'undefined')
            hoverStyle.outline.thickness = Number(templateStyle.outline.thickness) + 1;

        if (templateStyle.fill && typeof templateStyle.fill.opacity != 'undefined' && templateStyle.fill.opacity > 0)
            hoverStyle.fill.opacity = Math.min(Number(templateStyle.fill.opacity + 20), 100);

        newStyle.RenderStyle = L.gmxUtil.fromServerStyle(templateStyle);
        newStyle.HoverStyle = L.gmxUtil.fromServerStyle(hoverStyle);

        return newStyle;
	},
    /** Конвертация данных между форматами сервера и клиента. Используется в тегах слоёв и в атрибутах объектов векторных слоёв.
    *
    * Форматы сервера:
    *
    *  * datetime - unix timestamp
    *  * date - unix timestamp, кратный 24*3600 секунд
    *  * time - кол-во секунд с полуночи
    *
    * Форматы клиента:
    *
    *  * все числа превращаются в строки
    *  * дата - строка в формате dd.mm.yy
    *  * время - строка в формате hh:mm:ss
    *  * дата-время - dd.mm.yy hh:mm:ss
    *
    * @memberOf nsGmx.Utils
    */
    convertFromServer: function(type, value)
    {
        //if (value === null) return "null";

        if (!type) {
            return value;
        }

        var lowerCaseType = type.toLowerCase();

        if (lowerCaseType == 'string')
        {
            return value !== null ? value : ''; //все null интерпретируем как пустые строки!
        }
        else if (lowerCaseType == 'integer' || lowerCaseType == 'float' || lowerCaseType == 'number')
        {
            return value !== null ? String(value) : '';
        }
        else if (lowerCaseType == 'date')
        {
            if (value === null) return '';

            return stringDate(value*1000, true);
        }
        else if (lowerCaseType == 'time')
        {
            if (value === null) return '';
            return stringTime(value*1000, true);
        }
        else if (lowerCaseType == 'datetime')
        {
            if (value === null) return '';
            return stringDateTime(value*1000, true);
        }

        return value;
    },

    /** Конвертация данных между форматами сервера и клиента. Используется в тегах слоёв и в атрибутах объектов векторных слоёв.
    * Описание форматов см. в {@link nsGmx.Utils.convertFromServer}
    * Если конвертация невозможна для данного типа, возвращает null
    * @memberOf nsGmx.Utils
    */
    convertToServer: function(type, value)
    {
        if (!type) {
            return value;
        }

        var lowerCaseType = type.toLowerCase();

        if (lowerCaseType == 'string')
        {
            return value;
        }
        else if (lowerCaseType == 'integer' || lowerCaseType == 'float' || lowerCaseType == 'number')
        {
            if (value === '') return null;
            var num = Number(value);
            return isNaN(num) ? null : num;
        }
        else if (lowerCaseType == 'date')
        {
            var localDateValue = $.datepicker.parseDate('dd.mm.yy', value);
            if (localDateValue === null) return null;

            var localValue = localDateValue.valueOf()/1000;
            var timeOffset = (new Date(localValue*1000)).getTimezoneOffset()*60;
            return localValue - timeOffset;
        }
        else if (lowerCaseType == 'time')
        {
            var resTime = $.datepicker.parseTime('HH:mm:ss', value);
            if (!resTime) return null;

            return resTime.hour*3600 + resTime.minute*60 + resTime.second;
        }
        else if (lowerCaseType == 'datetime')
        {
            var localDateValue = $.datepicker.parseDateTime('dd.mm.yy', 'HH:mm:ss', value);
            if (localDateValue === null) return null;

            var localValue = localDateValue.valueOf()/1000;
            var timeOffset = (new Date(localValue*1000)).getTimezoneOffset()*60;
            return localValue - timeOffset;
        }

        return value;
    },


	login: function(redirect_uri, authServerBase, callback, authServer, isHidden){
		var oAuthServer = authServer || 'MyKosmosnimki';
		window.gmxGetServerBase = function(){
			return authServerBase
		}
		var redirectUri = redirect_uri + (redirect_uri.indexOf('?')>0 ? '&' : '?') + 'authServer=' + oAuthServer;
		window.gmxProcessAuthentication = function(userInfo){
			callback && callback(userInfo);
		}
		var features, w = 600, h = 350, l, t;
		var handlerName = 'LoginDialog';
		if (oAuthServer != 'MyKosmosnimki') {
			handlerName += oAuthServer;
			h = 400;
		}
		var url = authServerBase + handlerName + '.ashx?redirect_uri=' + escape(redirectUri);

		if (!isHidden){
			var top = (screen.height - h)/2, left = (screen.width - w)/2;
			features = 'location=0,menubar=0,resizable=0,status=0,toolbar=0,width='+w+',height='+h+',left='+left+',top='+top ;

			window.open(url, '_blank', features);
		}else{
			$('<iframe />', {
				 'src': url
				,'style': 'display: block !important; position: absolute; left: -99999px;'
			}).appendTo('body'); //стиль такой кривой иначе будет бага в FF
		}
    },

    /** Загружает пользовательский shp файл.
    * Проверяет на ошибки, выводит предупреждения и ошибки в виде стандартных диалогов.
    * @memberof nsGmx.Utils
    * @function
    * @param {File|Form} shpSource Либо форма с полем file, в которой пользователь выбрал файл, либо HTML5 File. Форма должна иметь атрибуты method="post" и enctype="multipart/form-data"
    * @return {jQuery.Deferred} Возвращает promise (аргумент ф-ции - массив объектов из shp файла)
    */
    parseShpFile: (function() //приватные данные
    {
        var translationsAdded = false;
        var addTranslationsLazy = function()
        {
            if (translationsAdded) return;
            _translationsHash.addtext("rus", {
                                "loadShape.Errors.FileTooBigException" : "Файл слишком большой. Ограничение на размер файла 1000 Кб.",
                                "loadShape.Errors.ErrorUploadExeption" : "Произошла ошибка при попытке загрузить файл.",
                                "loadShape.Errors.NoGeometryFile"      : "Загруженный файл не содержит геометрических данных.",
                                "loadShape.Errors.ErrorUploadNoDependentFiles" : "Не найдено необходимых зависимых файлов. Запакуйте все файлы в ZIP архив и повторите загрузку."
                             });

            _translationsHash.addtext("eng", {
                                "loadShape.Errors.FileTooBigException" : "Too big file. File size limit is 1000 Kb.",
                                "loadShape.Errors.ErrorUploadExeption" : "Error during file uploading.",
                                "loadShape.Errors.NoGeometryFile"      : "There are no geometry in uploaded file.",
                                "loadShape.Errors.ErrorUploadNoDependentFiles" : "Not found the necessary dependent files. Add all files in a ZIP archive and upload it again."
                             });

            translationsAdded = true;
        }

        //непосредственно ф-ция
        return function(shpFileForm) {
            var def = $.Deferred();

            addTranslationsLazy();

            var errorMessages = {
                "CommonUtil.FileTooBigException" : _gtxt("loadShape.Errors.FileTooBigException"),
                "CommonUtil.ErrorUploadExeption" : _gtxt("loadShape.Errors.ErrorUploadExeption"),
                "CommonUtil.NoGeometryFile"      : _gtxt("loadShape.Errors.NoGeometryFile"),
                "CommonUtil.ErrorUploadNoDependentFiles": _gtxt("loadShape.Errors.ErrorUploadNoDependentFiles")
            };

            if (window.File && shpFileForm instanceof window.File) {
                if (!window.FormData) {
                    def.reject();
                    return false;
                }

                var formData = new FormData();
                formData.append('file', shpFileForm);
                var xhr = new XMLHttpRequest();
                xhr.open('POST', serverBase + 'ShapeLoader');
                xhr.onload = function () {
                    if (xhr.status === 200) {
                        response = JSON.parse(xhr.responseText.substr(1, xhr.responseText.length-2));

                        if (parseResponse(response, errorMessages)) {
                            def.resolve(response.Result);
                        } else {
                            def.reject(response);
                        }
                    }
                };

                xhr.send(formData);
            } else {
                sendCrossDomainPostRequest(serverBase + "ShapeLoader", {WrapStyle: "window"}, function(response)
                {
                    if (parseResponse(response, errorMessages))
                        def.resolve(response.Result);
                    else
                        def.reject(response);
                }, shpFileForm)
            }

            return def.promise();
        }

    })(),

    /** Позволяет скачать в браузере геометрию в одном из форматов (упакованный в zip архив).
    * @memberof nsGmx.Utils
    * @function
    * @param {Object[]} geoJSONFeatures Массив GeoJSON Features. К сожалению, другие типы GeoJSON объектов не поддерживаются.
    * @param {Object} [options] Доп. параметры
    * @param {String} [options.fileName=markers] Имя файла для скачивания
    * @param {String} [options.format=Shape] В каком формате скачать (Shape, Tab, gpx или несколько через запятую)
    */
    downloadGeometry: function(geoJSONFeatures, options) {
        var objectsByType = {},
            markerIdx = 1;

        options = $.extend({
            fileName: 'markers',
            format: 'Shape'
        }, options);

        geoJSONFeatures.forEach(function(item) {
            var geom = item.geometry,
                type = geom.type;

            objectsByType[type] = objectsByType[type] || [];

            var title = item.properties && item.properties.title || '';

            if (type == "Point" && !title) {
                title = "marker " + markerIdx++;
            }

            objectsByType[type].push({
                geometry: {
                    type: type.toUpperCase(),
                    coordinates: geom.coordinates
                },
                properties: {text: title}
            });
        });

        sendCrossDomainPostRequest(serverBase + "Shapefile", {
            name:     options.fileName,
            format:   options.format,
            points:   JSON.stringify(objectsByType["Point"] || []),
            lines:    JSON.stringify([].concat(objectsByType["LineString"] || [], objectsByType["MultiLineString"] || [])),
            polygons: JSON.stringify([].concat(objectsByType["Polygon"] || [], objectsByType["MultiPolygon"] || []))
        })
    },

    /** Объединяет массив полигонов/мультиполигонов в новый полигон/мультиполигон
    * @memberof nsGmx.Utils
    */
    joinPolygons: function(objs)
    {
        var polygonObjects = [];
        for (var i = 0; i < objs.length; i++)
        {
            var geom = objs[i];
            if (geom.type == 'POLYGON')
            {
                polygonObjects.push(geom.coordinates);
            }
            else if (geom.type == 'MULTIPOLYGON')
            {
                for (var iC = 0; iC < geom.coordinates.length; iC++)
                    polygonObjects.push(geom.coordinates[iC]);
            }
        }

        if (polygonObjects.length > 1)
            return {type: "MULTIPOLYGON", coordinates: polygonObjects}
        else if (polygonObjects.length == 1)
        {
            return {type: "POLYGON", coordinates: polygonObjects[0]}
        }
        else
            return null;
    },

    joinClippedPolygon: function(polygon) {

        if (polygon.type !== 'MULTIPOLYGON') {
            return polygon;
        }

        var origData = [],
            segmentsToJoin = [],
            joinedSegments = [],
            crossPoints = [],
            finalPolygon = [];

        var equal = function(a, b) {return Math.abs(a - b) < 1e-5;}

        var coords = polygon.coordinates;
        for (var c = 0; c < coords.length; c++) {
            for (var r = 0; r < coords[c].length; r++) {
                coords[c][r].length = coords[c][r].length - 1;
            }
        }

        var parseRing = function(origRing) {
            var segments = [],
                ring = origRing.coords,
                len = ring.length;

            var getNextSegment = function(i) {
                var il = (i - 1 + len) % len,
                    points = [];

                while (i != il) {
                    if (equal(Math.abs(ring[i][0]), 180) && equal(Math.abs(ring[(i+1)%len][0]), 180) ) {
                        return [i, points];
                    }

                    points.push(ring[i]);
                    i = (i + 1) % len;
                }

                return [i, points];
            }

            var segment = getNextSegment(0);

            var lastI = segment[0];

            if (!equal(Math.abs(ring[segment[0]][0]), 180)) {
                origRing.regularRing = ring;
                return;
            }

            do {
                startI = (segment[0] + 1) % len;
                segment = getNextSegment((startI + 1) % len);
                var nextSegment = {
                    points: [].concat([ring[startI]], segment[1], [ring[segment[0]]])
                }
                segmentsToJoin.push(nextSegment);
                origRing.segments.push(nextSegment);
            } while (segment[0] !== lastI);
        }

        var findSegment = function(y, joinedSeg) {
            for (var s = 0; s < segmentsToJoin.length; s++) {
                var seg = segmentsToJoin[s];
                if (equal(seg.points[0][1], y) || equal(seg.points[seg.points.length - 1][1], y)) {
                    segmentsToJoin.splice(s, 1);
                    seg.joinedSeg = joinedSeg;
                    var isReg = equal(seg.points[0][1], y);
                    return {
                        points: isReg ? seg.points.slice(1, seg.points.length - 1) : seg.points.slice(1, seg.points.length - 1).reverse(),
                        lastY: isReg ? seg.points[seg.points.length - 1][1] : seg.points[0][1]
                    };
                }
            }
        }

        var joinSegment = function(y0) {
            var res = {},
                seg = findSegment(y0, res),
                points = seg.points,
                crossPoints = [y0];

            while (seg.lastY !== y0) {
                crossPoints.push(seg.lastY);
                seg = findSegment(seg.lastY);
                points = points.concat(seg.points);
            };

            res.points = points,
            res.crossPoints = crossPoints,
            res.minCrossPoint = Math.min.apply(Math, crossPoints)

            return res;
        }

        var parseGeometry = function(geom) {
            for (var c = 0; c < geom.coordinates.length; c++) {
                var origComp = [];
                origData.push(origComp);
                var comp = geom.coordinates[c];
                for (var r = 0; r < comp.length; r++) {
                    var origRing = {
                        coords: comp[r],
                        segments: []
                    }
                    origComp.push(origRing);
                    parseRing(origRing);
                }
            }
        }

        parseGeometry(polygon);

        segmentsToJoin.forEach(function(segment) {
            if (segment.points[0][0] < 0) {
                segment.points = segment.points.map(function(c) { return [c[0] + 360, c[1]];});
            }
        })

        while (segmentsToJoin.length) {
            var y0 = segmentsToJoin[0].points[0][1];
            var joinedSeg = joinSegment(y0);
            joinedSegments.push(joinedSeg);
            crossPoints = crossPoints.concat(joinedSeg.crossPoints);
        }

        crossPoints = crossPoints.sort();

        joinedSegments = joinedSegments.sort(function(s1, s2) {
            return s1.minCrossPoint - s2.minCrossPoint;
        })

        joinedSegments.forEach(function(s, i) {
            s.isExternal = (crossPoints.indexOf(s.minCrossPoint) % 2) === 0;
        })

        //собираем объединённые сегменты в мультиполигон
        joinedSegments.forEach(function(s) {
            if (s.isExternal) {
                finalPolygon.push([s.points]);
            } else {
                finalPolygon[finalPolygon.length-1].push(s.points);
            }
            s.finalComponent = finalPolygon[finalPolygon.length-1];
        })

        //добавляем компоненты, которые не пересекались со 180 градусом
        for (var c = 0; c < origData.length; c++) {
            if (origData[c][0].regularRing) {
                console.log('external component', c)
                var geomToCopy = [];
                for (var r = 0; r < origData[c].length; r++) {
                    geomToCopy.push(origData[c][r].regularRing);
                }
                finalPolygon.push(geomToCopy);
                continue;
            }
            for (var r = 1; r < origData[c].length; r++) {
                if (origData[c][r].regularRing) {
                    console.log('internal component', c, r, origData[c][0].segments);
                    for (var s = 0; s < origData[c][0].segments.length; s++) {
                        var joinedSeg = origData[c][0].segments[s].joinedSeg;
                        if (joinedSeg.isExternal) {
                            joinedSeg.finalComponent.push(origData[c][r].regularRing);
                            break;
                        }
                    }
                }
            }
        }

        if (finalPolygon.length === 1) {
            return {type: 'POLYGON', coordinates: finalPolygon[0]};
        } else {
            return {type: 'MULTIPOLYGON', coordinates: finalPolygon};
        }
    },

    /** Методы для работы с сохранёнными на сервере данными.
    * Сервер позволяет сохранять произвольный текст на сервере и получить ID, по которому можно этот текст получить.
    * Используется для формирования пермалинков (сохранение состояния)
    * @namespace
    * @memberOf nsGmx.Utils
    */
    TinyReference: {
        /** Создать новую ссылку
        * @param {String} data Данные, которые нужно сохранить
        * @return {jQuery.Deferred} Промис, который будет resolve при сохранении данных. Параметр при ресолве: ID, по которому можно получить данные обратно
        */
        create: function(data, tempFlag) {
            var def = $.Deferred();
            sendCrossDomainPostRequest(serverBase + "TinyReference/Create.ashx", {
                WrapStyle: 'message',
                content: JSON.stringify(data),
                temp: tempFlag
            },
            function(response) {
                if (parseResponse(response)) {
                    def.resolve(response.Result);
                } else {
                    def.reject();
                }
            })

            return def.promise();
        },

        /** Получить ранее сохранённые данные по ID
        * @param {String} id полученный при сохранении ID данных
        * @return {jQuery.Deferred} Промис, который будет resolve при получении данных. Параметр при ресолве: данные с сервера
        */
        get: function(id) {
            var def = $.Deferred();
            sendCrossDomainJSONRequest(serverBase + "TinyReference/Get.ashx?id=" + id, function(response){
                //если пермалинк не найден, сервер не возвращает ошибку, а просто пустой результат
                if (parseResponse(response) && response.Result) {
                    def.resolve(JSON.parse(response.Result));
                } else {
                    def.reject();
                }
            });

            return def.promise();
        },

        /** Удалить данные по ID
        * @param {String} id полученный при сохранении ID данных
        * @return {jQuery.Deferred} Промис, который будет resolve при удалении данных
        */
        remove: function(id) {
            var def = $.Deferred();
            sendCrossDomainJSONRequest(serverBase + "TinyReference/Delete.ashx?id=" + id, function(response){
                if (parseResponse(response)) {
                    def.resolve();
                } else {
                    def.reject();
                }
            });

            return def.promise();
        }
    },
    isIpad: function() {
        return navigator.userAgent.match(/iPad/i) != null;
    },

    getLatLngBounds: function (layer) {
        var gmxBounds = layer._gmx.layerID ? L.gmxUtil.getGeometryBounds(layer._gmx.geometry) : layer._gmx.dataManager.getItemsBounds(),
            srs = layer._gmx.srs,
            array = [],
            projection, bounds;

            console.log(gmxBounds);


        if (srs) {
            for (var proj in L.CRS) {
                if (proj.indexOf(srs) !== -1) {
                    projection = L.CRS[proj];
                    break;
                }
            }
        } else {
            projection = L.CRS['EPSG:3395'];
        }

        array.push(L.Projection.Mercator.unproject(gmxBounds.min));
        array.push(L.Projection.Mercator.unproject(gmxBounds.max));
        return L.latLngBounds(array);
    },

    showDialog: showDialog,
	removeDialog: removeDialog,
    makeImageButton: makeImageButton,
	makeLinkButton: makeLinkButton,
	makeButton: makeButton,
	_title: _title,
	_checkbox: _checkbox
});

window.gmxCore && window.gmxCore.addModule('utilities', nsGmx.Utils);

/** Менеджер аудетификационной информации системы. Умеет запрашивать у сервера текущий статус пользователя,
 хранит информацию о ролях и допустимых действиях пользователей с этой ролью.
 @memberOf nsGmx
 @class
 @name AuthManager
*/
var nsGmx = nsGmx || {};
(function($)
{
    $.extend(nsGmx, {
        ROLE_ADMIN        : 'admin', 
        ROLE_USER         : 'user',
        ROLE_GUEST        : 'guest',
        ROLE_UNAUTHORIZED : 'none',
        
        ACTION_CREATE_LAYERS        : 'createData',      // Создавать новые слои (векторные и растровые)
        ACTION_CREATE_MAP           : 'createMap',       // Cоздавать новые карты
        ACTION_SAVE_MAP             : 'saveMap',         // Сохранять карту (нужны права редактирования на карту)
        ACTION_CHANGE_MAP_TYPE      : 'changeType',      // Менять тип карты (публичная/открытая/закрытая и т.п.)
        ACTION_SEE_OPEN_MAP_LIST    : 'openMap',         // Видеть список публичных карт
        ACTION_SEE_PRIVATE_MAP_LIST : 'privateMap',      // Видеть спискок всех карт
        ACTION_SEE_MAP_RIGHTS       : 'seeRights',       // Видеть и редактировать права пользователей (для объектов, владельцем которых является)
        ACTION_SEE_FILE_STRUCTURE   : 'seeFiles',        // Видеть всю файловую структуру сервера, а не только свою дом. директорию
        ACTION_SEE_ALL_USERS        : 'seeUsers',        // Видеть список всех пользователей
        ACTION_SEE_USER_FULLNAME    : 'seeUserFullname', // Видеть полные имена и логины пользователей (а не только псевдонимы)
        ACTION_UPLOAD_FILES         : 'uploadFiles'      // Загружать файлы на сервер через web-интерфейс
    });
    
    var _actions = {};
    _actions[nsGmx.ROLE_ADMIN] = {};    
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_CREATE_LAYERS       ] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_CREATE_MAP          ] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_SAVE_MAP            ] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_SEE_OPEN_MAP_LIST   ] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_SEE_PRIVATE_MAP_LIST] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_CHANGE_MAP_TYPE     ] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_SEE_MAP_RIGHTS      ] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_SEE_FILE_STRUCTURE  ] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_SEE_ALL_USERS       ] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_SEE_USER_FULLNAME   ] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_UPLOAD_FILES        ] = true;
    
    _actions[nsGmx.ROLE_USER] = {};
    _actions[nsGmx.ROLE_USER][nsGmx.ACTION_CREATE_LAYERS     ] = true;
    _actions[nsGmx.ROLE_USER][nsGmx.ACTION_CREATE_MAP        ] = true;
    _actions[nsGmx.ROLE_USER][nsGmx.ACTION_SAVE_MAP          ] = true;
    _actions[nsGmx.ROLE_USER][nsGmx.ACTION_SEE_OPEN_MAP_LIST ] = true;
    _actions[nsGmx.ROLE_USER][nsGmx.ACTION_SEE_MAP_RIGHTS    ] = true;
    _actions[nsGmx.ROLE_USER][nsGmx.ACTION_UPLOAD_FILES      ] = true;
    
    _actions[nsGmx.ROLE_GUEST] = {}
    _actions[nsGmx.ROLE_GUEST][nsGmx.ACTION_SEE_OPEN_MAP_LIST ] = true;
    _actions[nsGmx.ROLE_GUEST][nsGmx.ACTION_SAVE_MAP          ] = true;
    
    nsGmx.AuthManager = new function()
    {
        var _userInfo = null;
        var _this = this;
        
        this.getLogin = function()
        {
            if (!_userInfo) return null;
            return _userInfo.Login || null;
        };
        
        this.getNickname = function()
        {
            if (!_userInfo) return null;
            return _userInfo.Nickname || null;
        };
        
        this.getFullname = function()
        {
            if (!_userInfo) return null;
            return _userInfo.FullName || null;
        };
        
        this.getUserFolder = function()
        {
            if (!_userInfo) return null;
            return _userInfo.Folder;
        };
        
        this.isRole = function(role)
        {
            return _userInfo && _userInfo.Role === role;
        };
        
        this.canDoAction = function(action)
        {
            return _userInfo && _userInfo.Role in _actions && action in _actions[_userInfo.Role];
        };
        
        this.isAccounts = function()
        {
            return _userInfo && _userInfo.IsAccounts;
        };
        
        this.isLogin = function()
        {
            return _userInfo && _userInfo.Login !== false && _userInfo.Role !== this.ROLE_UNAUTHORIZED;
        };
        
        this.setUserInfo = function(userInfo)
        {
            _userInfo = $.extend({}, {IsAccounts: false, Role: this.ROLE_UNAUTHORIZED}, userInfo);
            $(this).triggerHandler('change');
        };        
        
        this.checkUserInfo = function(callback, errorCallback)
        {
            //var isTokenUsed = false;
            var _processResponse = function( response )
            {
                var resOk = parseResponse(response);
                
                !resOk && errorCallback && errorCallback();
                    
                if (response.Result == null || !resOk)
                {
                    // юзер не авторизован
                    _this.setUserInfo({Login: false});
                }
                else
                {
                    _this.setUserInfo(response.Result);
                }
                
                resOk && callback && callback();
            }
            
            
            for (var iProvider = 0; iProvider < checkProviders.length; iProvider++)
            {
                if (checkProviders[iProvider].canAuth())
                {
                    checkProviders[iProvider].doAuth(callback, errorCallback);
                    return;
                }
            }
            
            sendCrossDomainJSONRequest(serverBase + 'User/GetUserInfo.ashx?WrapStyle=func', function(response) {
                if (response.Status === 'ok' && !response.Result && window.mapsSite && window.gmxAuthServer) {
                    var callbackPath = location.href.match(/(.*)\//)[0] + 'oAuthCallback.html';
                    nsGmx.Utils.login(callbackPath, serverBase + 'oAuth/', function(userInfo) {
                        _processResponse({Status: 'ok', Result: userInfo || null});
                    }, null, true);
                } else {
                    doAuthServerLogin(response.Result && response.Result.Token);
                    _processResponse(response);
                }
            })
        }
        
        this.login = function(login, password, callback, errorCallback)
        {
            sendCrossDomainPostRequest(serverBase + "Login.ashx", {WrapStyle: 'message', login: login, pass: password}, function(response)
            {
                if (response.Status == 'ok' && response.Result)
                {
                    _this.setUserInfo(response.Result);
                    
                    doAuthServerLogin(response.Result && response.Result.Token);
                    
                    callback && callback();
                }
                else
                {
                    if (response.Status === 'auth' && ('Result' in response) && (typeof(response.Result) === 'object') && ('ExceptionType' in response.Result) && response.Result.ExceptionType.indexOf('System.ArgumentException') == 0)
                    {
                        errorCallback && errorCallback({emailWarning: true, message: response.Result.Message})
                    }
                    errorCallback && errorCallback({emailWarning: false});
                }
            });
        }
        
        this.logout = function(callback)
        {
            sendCrossDomainJSONRequest(serverBase + "Logout.ashx?WrapStyle=func&WithoutRedirection=1", function(response)
            {
                if (!parseResponse(response))
                    return;
                    
                if (_this.isAccounts() && window.gmxAuthServer)
                {
                    sendCrossDomainJSONRequest(window.gmxAuthServer + "Handler/Logout", function(response)
                    {
                        //TODO: check result
                        _this.setUserInfo({Login: false});
                        callback && callback();
                    }, 'callback');
                }
                else
                {
                    _this.setUserInfo({Login: false});
                    callback && callback();
                }
            });
        }
        
        this.changePassword = function(oldPass, newPass, callback, errorCallback)
        {
            sendCrossDomainJSONRequest(serverBase + "ChangePassword.ashx?WrapStyle=func&old=" + encodeURIComponent(oldPass) + "&new=" + encodeURIComponent(newPass), function(response)
            {
                if (response.Status == 'ok' && response.Result)
                    callback && callback();
                else
                {
                    var msg = response.ErrorInfo && typeof response.ErrorInfo.ErrorMessage != 'undefined' ? response.ErrorInfo.ErrorMessage : null;
                    errorCallback && errorCallback(msg);
                }
            });
        }
    }
    
    var checkProviders = [];
    
    var doAuthServerLogin = function(token) {
        if (token && window.mapsSite && window.gmxAuthServer) {
            sendCrossDomainJSONRequest(gmxAuthServer + 'Handler/Me?token=' + encodeURIComponent(token), function(response) {
                //console.log(response);
            }, 'callback');
        }
    }
    
    //canAuth() -> bool
    //doAuth(callbackSuccess, callbackError)
    nsGmx.AuthManager.addCheckUserMethod = function(provider)
    {
        checkProviders.push(provider);
    }
})(jQuery);
/** Виджет для визуализации информации о текущем статусе пользователя.
* Показывает кнопки Вход/Выход, имя пользователя. Позволяет отослать логин/пароль на сервер, сменить пароль.
 @memberOf nsGmx
 @class
 @name GeoMixerAuthWidget
*/
var nsGmx = nsGmx || {};
(function($, _)
{
    var _dialogCanvas = null;

    function changePasswordDialog()
    {
        if ($('#changePasswordCanvas').length)
            return;

        var oldInput = _input(null, [['dir','className','inputStyle'],['css','width','160px'],['attr','type','password']]),
            newInput = _input(null, [['dir','className','inputStyle'],['css','width','160px'],['attr','type','password']]),
            confirmInput = _input(null, [['dir','className','inputStyle'],['css','width','160px'],['attr','type','password']]),
            changeButton = makeButton(_gtxt("Изменить")),
            canvas = _div([_div([_span([_t(_gtxt("Старый пароль"))]), _br(), oldInput, _br(),
                                _span([_t(_gtxt("Новый пароль"))]), _br(), newInput, _br(),
                                _span([_t(_gtxt("Подтвердите пароль"))]), _br(), confirmInput, _br()],[['css','textAlign','center']]),
                           _div([changeButton],[['css','textAlign','center'],['css','margin','5px']])],[['attr','id','changePasswordCanvas']]),
            checkPassw = function()
            {
                if (newInput.value != confirmInput.value)
                {
                    newInput.value = '';
                    confirmInput.value = '';

                    inputError([newInput, confirmInput], 2000);
                    newInput.focus();

                    return;
                }

                nsGmx.widgets.notifications.startAction('changePassword');
                nsGmx.AuthManager.changePassword(oldInput.value, newInput.value, function()
                {
                    jQuery(canvas.parentNode).dialog("destroy");
                    canvas.parentNode.removeNode(true);

                    nsGmx.widgets.notifications.stopAction('changePassword', 'success', _gtxt('Пароль изменён'));
                }, function( message )
                {
                    message && showErrorMessage(message, true);
                    nsGmx.widgets.notifications.stopAction('changePassword', 'failure');
                })

                oldInput.value = '';
                newInput.value = '';
                confirmInput.value = '';
            };

        showDialog(_gtxt("Изменение пароля"), canvas, 200, 200, false, false);
        canvas.parentNode.style.overflow = 'hidden';

        oldInput.focus();

        changeButton.onclick = function()
        {
            checkPassw();
        }

        $(confirmInput).on('keyup', function(e)
        {
            if (e.keyCode === 13)
            {
                checkPassw();

                return false;
            }

            return true;
        });
    }

    var loginDialogTemplate =
        '<div>' +
            '<div class = "loginMainDiv">' +
                '<form>' +
                    '<div>' +
                        '<span class="loginLabel">{{i "Логин"}}</span><br>' +
                        '<input name="login" class = "inputStyle inputLogin" placeholder = "{{i "адрес электронной почты"}}"><br>' +
                    '</div>' +
                    '<div>' +
                        '<span class="loginLabel">{{i "Пароль"}}</span><br>' +
                        '<input name="password" class = "inputStyle inputPass" type = "password" placeholder = "{{i "пароль"}}"><br>' +
                    '</div>' +
                    '<button class="loginButton">{{i "Вход"}}</button>' +
                '</form>' +
            '</div>' +
            '{{#isMapsSite}}' +
            '<div class="loginLinks">' +
                '<span class = "buttonLink registration">{{i "Регистрация"}}</span><br>' +
                '<span class = "buttonLink passRecovery">{{i "Восстановление пароля"}}</span>' +
            '</div>' +
            '{{/isMapsSite}}' +
        '</div>';

    nsGmx.GeoMixerAuthWidget = function( container, authManager, loginCallback, options )
    {
        var _container = container;
        var _authManager = authManager;
        var _this = this;

        _this.changePasswordDialog = changePasswordDialog;

        options = options || {};

        var _createLogin = function()
        {
            var span = makeLinkButton(_gtxt('Вход'));

            span.onclick = function()
            {
                _this.showLoginDialog( loginCallback );
            }
            _(_container, [_div([span], [['attr','id','log'],['dir','className','log']])]);
        }

        var _createLogout = function()
        {
            var logoutSpan = makeLinkButton(_gtxt('Выход'));

            logoutSpan.onclick = function()
            {
                _authManager.logout(function()
                {
                    if (nsGmx.GeomixerFramework)
                        _mapHelper.reloadMap();
                    else
                        window.location.replace(window.location.href.split("?")[0] + (defaultMapID == globalMapName ? "" : ("&" + globalMapName)));
                });
            }

            var userText = _authManager.getLogin();
            if (_authManager.getFullname() !== null && _authManager.getFullname() !== '')
                userText += ' (' + _authManager.getFullname() + ')';
            var userSpan = _span([_t(userText)], [['css','cursor','pointer']]);

            userSpan.onclick = function()
            {
                if ( _authManager.isAccounts() )
                {
                    if (window.gmxAuthServer)
                        window.open(  window.gmxAuthServer + "Account/ChangePassword", '_blank');
                }
                else
                    changePasswordDialog();
            }

            if ( _authManager.isAccounts() )
                $(userSpan).css('color', '#5555FF');

            _title(userSpan, _gtxt("Изменение пароля"))

            _(_container, [_table([_tr([
                _td([_div([userSpan], [['attr','id','user'],['dir','className','user']])]),
                _td([_div([logoutSpan], [['attr','id','log'],['dir','className','log']])])
            ])])]);
        }

        var _update = function()
        {
            if ( window.gmxViewerUI && window.gmxViewerUI.hideLogin )
                return;

            $(_container).empty();

            if (_authManager.isLogin())
            {
                _createLogout();
            }
            else
            {
                _createLogin();
            }
        }

        $(_authManager).change(_update);
        _update();

        //Показывает диалог с вводом логина/пароля, посылает запрос на сервер.
        this.showLoginDialog = function()
        {
            if (_dialogCanvas) {
                return;
            }

            var isMapsSite = !!window.mapsSite;
            var dialogHeight = isMapsSite ? 210 : 175;

            var canvas = $(Handlebars.compile(loginDialogTemplate)({isMapsSite: isMapsSite})),
                loginInput = canvas.find('.inputLogin')[0],
                passwordInput = canvas.find('.inputPass')[0],
                loginButton = canvas.find('.loginButton')[0];

            var checkLogin = function(){
                _authManager.login(loginInput.value, passwordInput.value, function()
                    { //всё хорошо
                        $(jQueryDialog).dialog("destroy")
                        jQueryDialog.removeNode(true);
                        _dialogCanvas = null;
                        loginCallback && loginCallback();
                    }, function(err)
                    { //ошибка
                        if (err.emailWarning)
                        {
                            var errorDiv = $("<div/>", {'class': 'EmailErrorMessage'}).text(err.message);
                            $(loginButton).after(errorDiv);
                            setTimeout(function(){
                                errorDiv.hide(500, function(){ errorDiv.remove(); });
                            }, 8000)
                        }
                        loginInput.value = '';
                        passwordInput.value = '';
                        inputError([loginInput, passwordInput], 2000);
                        loginInput.focus();
                    }
                );
            };

            _dialogCanvas = canvas;

            var jQueryDialog = showDialog(_gtxt("Пожалуйста, авторизуйтесь"), canvas[0], 248, dialogHeight, false, false, null, function()
            {
                _dialogCanvas = null;
            });

            loginInput.focus();

            loginButton.onclick = checkLogin;

            canvas.find('form').submit(function(e) {
                e.preventDefault();
            })

            canvas.find('.registration').click(options.registrationCallback || function(){
                window.open(window.gmxAuthServer + 'Account/Registration', '_blank');
            });

            canvas.find('.passRecovery').click(function(){
                window.open(window.gmxAuthServer + 'Account/Retrive', '_blank');
            });

            $(passwordInput).on('keyup', function(e)
            {
                if (e.keyCode === 13)
                {
                    checkLogin();

                    return false;
                }

                return true;
            });
        }

        this.getContainer = function()
        {
            return _container;
        }
    }

    // Обратная совместимость. Проверка нужна из-за возможного конфликта с одноимённым классом из общих компонент
    if (!nsGmx.AuthWidget) {
        nsGmx.AuthWidget = nsGmx.GeoMixerAuthWidget;
    }

})(jQuery, nsGmx.Utils._);

(function(){

var tasks = {};
var tasksByName = {};

var UPDATE_INTERVAL = 2000;

var sendGmxRequest = function(requestType, url, params) {
    var def = $.Deferred();
    
    var processResponse = function(response) {
        if (!response.Result || !response.Result.TaskID) {
            if (response.Status === 'ok' && !response.ErrorInfo) {
                def.resolve(response);
            } else {
                parseResponse(response);
                def.reject(response);
            }
            return;
        }
        
        def.notify(response.Result);
        
        var taskID = response.Result.TaskID;
        
        var interval = setInterval(function(){
            sendCrossDomainJSONRequest(serverBase + "AsyncTask.ashx?WrapStyle=func&TaskID=" + taskID, 
                function(response)
                {
                    var res = response.Result;
                    if (response.Status !== 'ok' || res.ErrorInfo)
                    {
                        res.Status = 'error';
                        parseResponse(res);
                        clearInterval(interval);
                        def.reject(res);
                    }
                    else if (res.Completed)
                    {
                        clearInterval(interval);
                        def.resolve(res);
                    }
                    else
                    {
                        def.notify(res);
                    }
                }, null, 
                function() {
                    clearInterval(interval);
                    def.reject();
                }
            );
        }, UPDATE_INTERVAL);
    }
    
    if (requestType === 'get') {
    
        params = params || {};
    
        var paramStrItems = [];
        
        for (var p in params) {
            paramStrItems.push(p + '=' + encodeURIComponent(params[p]));
        }
        
        var sepSym = url.indexOf('?') == -1 ? '?' : '&';
        
        
        sendCrossDomainJSONRequest(
            url + sepSym + paramStrItems.join('&'), 
            processResponse, null, def.reject.bind(def)
        );
    } else if (requestType === 'post') {
        var localParams = $.extend({WrapStyle: 'message'}, params);
        sendCrossDomainPostRequest(url, localParams, processResponse);
    } else {
        throw 'Wrong request type';
    }
    
    return def.promise();
}

nsGmx.asyncTaskManager = {
    sendGmxJSONPRequest: sendGmxRequest.bind(null, 'get'),
    sendGmxPostRequest: sendGmxRequest.bind(null, 'post')
}

})()
var nsGmx = nsGmx || {};

// Делегаты пользовательских объектов - классы, управляющие отображением и сериализацией пользовательских объектов
// Методы:
//   - isHidden(obj) -> Bool
//   - isSerializable(obj) -> Bool
nsGmx.DrawingObjectCustomControllers = (function()
{
	var _delegates = [];
	return {
		addDelegate: function(delegate)
		{
			_delegates.push(delegate);
		},
		
		isHidden: function(obj)
		{
			for (var d = 0; d < _delegates.length; d++)
				if ('isHidden' in _delegates[d] && _delegates[d].isHidden(obj))
					return true;
			return false;
		},
		
		isSerializable: function(obj)
		{
			for (var d = 0; d < _delegates.length; d++)
				if ('isSerializable' in _delegates[d] && !_delegates[d].isSerializable(obj))
					return false;
			return true;
		}
	}
})();
/**
  @class
  @virtual
  @name IMenuElem
  @desc Описание пункта верхнего меню ГеоМиксера
  @property {String} id Уникальный идентификатор элемента меню
  @property {String} title Tекст, который будет показываться пользователю
  @property {Function} func Ф-ция, которую нужно вызвать при клике
  @property {IMenuElem[]} childs Массив элементов подменю
*/

/**
    Верхнее меню ГеоМиксера. Может содержать до 3 уровней вложенности элементов.
    @class
*/
var UpMenu = function()
{

    this.submenus = [];
	this.currSel = null;
	this.currUnSel = null;
	this.refs = {};

	this.parent = null;
    this.loginContainer = null;
    this._isCreated = false;
    this.defaultHash = 'layers';
};

//предполагает, что если callback возвращает true, то итерирование можно прекратить
UpMenu.prototype._iterateMenus = function(elem, callback) {
    if (!elem.childs) {
        return;
    }

    for (var i = 0; i < elem.childs.length; i++) {
        if (elem.childs[i] && (callback(elem.childs[i]) || this._iterateMenus(elem.childs[i], callback))) {
            return true;
        }
    }
}

/** Добавляет к меню новый элемент верхнего уровня
*
* Если меню уже было нарисовано, вызов этой ф-ции приведёт к перерисовке
*
*    @param {IMenuElem} elem Элемент меню
*/
UpMenu.prototype.addItem = function(elem)
{
    this.submenus.push(elem)
    this._isCreated && this.draw();
}

/** Добавляет к меню новый элемент.
*
* Если меню уже было нарисовано, вызов этой ф-ции приведёт к перерисовке
*
*    @param {IMenuElem} newElem Вставляемый элемент меню
*    @param {String} parentID ID элемента меню, к которому добавляется новый элемент
*    @param {String} [insertBeforeID] ID элемента меню, перед которым нужно вставить пункт меню.
*                    Если не указан, пункт меню будет добавлен в конец списка.
*/
UpMenu.prototype.addChildItem = function(newElem, parentID, insertBeforeID)
{
    this._iterateMenus({childs: this.submenus}, function(elem) {
        if (elem.id && elem.id === parentID) {
            elem.childs = elem.childs || [];
            
            var index = elem.childs.length;
            elem.childs.forEach(function(childElem, i) {
                if (childElem.id === insertBeforeID) {
                    index = i;
                }
            })
            
            elem.childs.splice(index, 0, newElem);

            this._isCreated && this.draw();

            return true;
        }
    }.bind(this));
}

/** Задаёт родителя в DOM дереве для меню
* @param {DOMElement} parent Родительский элемент в DOM дереве
*/
UpMenu.prototype.setParent = function(parent)
{
	this.parent = parent;

	if (parent)
    {
		$(parent).empty();
        parent.appendChild(_span());
    }

	this.disabledTabs = {};
}

// Показывает элемент меню
UpMenu.prototype.showmenu = function(elem)
{
	elem.style.visibility = 'visible';
}
// Скрывает элемент меню
UpMenu.prototype.hidemenu = function(elem)
{
	elem.style.visibility = 'hidden';
}

UpMenu.prototype._template = Handlebars.compile(
'<div class="headerContainer">\
{{#childs}}{{#if id}}\
    <div class = "header1{{#unless childs}} menuClickable{{/unless}}" hash = "{{id}}">\
        <div class = "header1Internal">{{title}}</div>\
        {{#if childs}}\
            <ul class = "header2" id="{{id}}">\
            {{#childs}}{{#if id}}\
                <li class = "header2{{#unless childs}} menuClickable{{/unless}}" hash = "{{id}}">\
                    <div class = "header2{{#if disabled}} menuDisabled{{/if}}{{#delimiter}} menuDelimiter{{/delimiter}}">\
                        <div class = "menuMarkerLeft {{#if checked}} ui-icon ui-icon-check{{/if}}"></div>\
                        {{title}}\
                        {{#if childs}}\
                            <div class = "menuMarkerRight"></div>\
                        {{/if}}\
                    </div>\
                    {{#if childs}}\
                        <ul class = "header3" id="{{id}}">\
                        {{#childs}}{{#if id}}\
                            <li class = "header3 menuClickable" hash = "{{id}}">\
                                <div class = "header3{{#if disabled}} menuDisabled{{/if}}{{#delimiter}} menuDelimiter{{/delimiter}}">\
                                    <div class = "menuMarkerLeft {{#if checked}} ui-icon ui-icon-check{{/if}}"></div>\
                                    {{title}}\
                                </div>\
                            </li>\
                        {{/if}}{{/childs}}\
                        </ul>\
                    {{/if}}\
                </li>\
            {{/if}}{{/childs}}\
            </ul>\
        {{/if}}\
    </div>\
    {{/if}}{{/childs}}\
</div>');

/** Основная функция  - рисует меню по заданной структуре
*/
UpMenu.prototype.draw = function()
{
    var ui = $(this._template({
            childs: this.submenus
        })),
        _this = this;

    $(this.parent.firstChild).empty().append(ui);

    $(ui).find('.header1').each(function() {
        _this.attachEventOnMouseover(this, 'menuActive');
        _this.attachEventOnMouseout(this, 'menuActive');
        $(this).width($(this).width() + 10);
    });

    $(ui).find('li.header2').each(function() {
        _this.attachEventOnMouseover(this, 'menu2Active');
        _this.attachEventOnMouseout(this, 'menu2Active');
    });

    $(ui).find('li.header3').each(function() {
        attachEffects(this, 'menu3Active');
    });

    $(ui).find('.menuClickable').each(function() {
        var id = $(this).attr('hash');
        $(this).click(function() {
            _this.refs[id].disabled || _this.openTab(id);
        });
    });

    this._iterateMenus({childs: this.submenus}, function(elem) {
        _this.refs[elem.id] = elem;
    })

    //убираем все скрытые меню
    for (var d in this.disabledTabs)
        this.disableMenus([d]);

    this._isCreated = true;
}

UpMenu.prototype.checkItem = function(id, isChecked) {
    if (this.refs[id]) {
        this.refs[id].checked = isChecked;
        $(this.parent).find('li[hash=' + id + ']').find('.menuMarkerLeft').toggleClass('ui-icon ui-icon-check', isChecked);
    }
}

UpMenu.prototype.removeSelections = function(id)
{
	$('li.menu3Active').removeClass('menu3Active');
	$('li.menu2Active').removeClass('menu2Active');
	$('li.menuActive').removeClass('menuActive');
}
// Закрывает открытые меню
UpMenu.prototype.hideMenus = function()
{
	var _this = this;

	$('ul.header2').each(function()
	{
		_this.hidemenu(this);
	})
	$('ul.header3').each(function()
	{
		_this.hidemenu(this);
	})
}
// Открывает закладку
UpMenu.prototype.openRef = function(hash)
{
	_menuUp.removeSelections();
	_menuUp.hideMenus();
	_menuUp.openTab(hash);
}

UpMenu.prototype.attachEventOnMouseover = function(elem, className)
{
	var _this = this;
	elem.onmouseover = function(e)
	{
		$(this).addClass(className);

		if ($('#' + this.getAttribute('hash'))[0])
			_this.showmenu($('#' + this.getAttribute('hash'))[0]);
	}
}
UpMenu.prototype.attachEventOnMouseout = function(elem, className)
{
	var _this = this;
	elem.onmouseout = function(e)
	{
		var evt = e || window.event,
			target = evt.srcElement || evt.target,
			relTarget = evt.relatedTarget || evt.toElement,
			elem = this;

		try
		{
			while (relTarget)
			{
				if (relTarget == elem)
				{
					stopEvent(e);

					return false;
				}
				relTarget = relTarget.parentNode;
			}

			$(elem).removeClass(className)

			if ($('#' + elem.getAttribute('hash')).length)
				_this.hidemenu($('#' + elem.getAttribute('hash'))[0]);
		}
		catch (e)
		{
			$(elem).removeClass(className)

			if ($('#' + elem.getAttribute('hash')).length)
				_this.hidemenu($('#' + elem.getAttribute('hash'))[0]);
		}
	}
}

UpMenu.prototype.getNavigatePath = function(path) {
	for (var menuIdx = 0; menuIdx < this.submenus.length; menuIdx++)
	{
        var submenu = this.submenus[menuIdx];
        
        if (!submenu) {continue};

		if (path == submenu.id)
		{
            return [submenu.title];
		}

		if (submenu.childs)
		{
			var childsLevel2 = submenu.childs;
			for (var i = 0; i < childsLevel2.length; i++)
			{
                if (!childsLevel2[i]) {continue};
                
				if (childsLevel2[i].childs)
				{
					var childsLevel3 = childsLevel2[i].childs;
					// есть подменю, смотрим там
					for(var j = 0; j < childsLevel3.length; j++)
					{
                        if (!childsLevel3[j]) {continue};
                        
						if (path == childsLevel3[j].id)
						{
                            return [submenu.title, childsLevel2[i].title, childsLevel3[j].title];
						}
					}
				}
				if (path == childsLevel2[i].id)
				{
					// совпадение в меню 2го уровня
                    return [submenu.title, childsLevel2[i].title];
				}
			}
		}
	}

	return [];
}

/** Показывает все ранее скрытые элементы меню
*/
UpMenu.prototype.enableMenus = function()
{
	for (var name in this.disabledTabs)
	{
		$(this.parent).find("li[hash='" + name + "']").children('div').css('display','');

		delete this.disabledTabs[name];
	}
}
/** Скрывает заданные элементы меню
* @param {String[]} arr Массив ID элементов меню, которые нужно скрыть
*/
UpMenu.prototype.disableMenus = function(arr)
{
	for (var i = 0; i < arr.length; i++)
	{
		$(this.parent).find("li[hash='" + arr[i] + "']").children('div').css('display','none');

		this.disabledTabs[arr[i]] = true;
	}
}

UpMenu.prototype.checkView = function()
{
	if (!nsGmx.AuthManager.isLogin())
	{
		this.enableMenus();

		this.disableMenus(['mapCreate', 'mapSave', 'mapSaveAs', 'layersMenu', 'pictureBinding']);
	}
	else if (_queryMapLayers.currentMapRights() != "edit")
	{
		this.enableMenus();

		this.disableMenus(['mapSave', 'mapSaveAs', 'layersVector', 'layersRaster', 'layersMultiRaster']);
	}

    if (!nsGmx.AuthManager.isRole(nsGmx.ROLE_ADMIN)) {
        this.disableMenus(['stileLibrary']);
    }

    if (_queryMapLayers.currentMapRights() !== "edit") {
        this.disableMenus(['mapTabsNew']);
    }

	if (!nsGmx.AuthManager.canDoAction(nsGmx.ACTION_CREATE_LAYERS))
	{
            this.disableMenus(['layersVector', 'layersRaster', 'layersMultiRaster']);
	}

    if (!nsGmx.AuthManager.canDoAction(nsGmx.ACTION_CREATE_MAP))
	{
            this.disableMenus(['mapCreate']);
	}
}

UpMenu.prototype.go = function(container)
{
	this.setParent(container);

	this.createMenu();

	this.draw();

	this.checkView();

	if (window.location.hash)
	{
		this.currUnsel = function(){};
	}

	this.openTab(this.defaultHash);
}

UpMenu.prototype.openTab = function(id)
{
    if (this.disabledTabs[id] || !this.refs[id]) {
        return;
    }

    var item = this.refs[id];

    this.removeSelections();
	this.hideMenus();

    if (item.func) {
        item.func(id);
    } else {
        var func = item[item.checked ? 'onunsel' : 'onsel'];
        this.checkItem(id, !item.checked);
        func && func(id);
    }
}

/** Блок (контейнер с заголовком) левой панели
    @class
    @param {String} canvasID Уникальный идентификатор блока
    @param {Object} options Параметры
    @param {function} [options.closeFunc] Ф-ция, которая будет вызвана при нажатии на иконку закрытия блока. По умолчанию ничего не делается.
    @param {String[]} [options.path] Массив строк для формирования названия блока (см. метод setTitle()).
                      По умолчанию будет сформирован из верхнего меню ГеоМиксера по canvasID.
    @param {Boolean} [options.showCloseButton=true] Показывать ли кнопку закрытия блока
    @param {Boolean} [options.showMinimizeButton=true] Показывать ли кнопку сворачивания блока
*/
nsGmx.LeftPanelItem = function(canvasID, options) {
    /** Изменение видимости контента ("свёрнутости") панели
     * @event nsGmx.LeftPanelItem.changeVisibility
    */

    options = $.extend({
        closeFunc: function(){},
        showCloseButton: true,
        showMinimizeButton: true
    }, options);
    
    //по умолчанию оставляем только последний элемент списка
    if (!options.path) {
        var menuPath = _menuUp.getNavigatePath(canvasID);
        options.path = menuPath.length ? [menuPath[menuPath.length - 1]] : [];
    }

    var getPathHTML = function(path) {
        if (!path) return '';

        return Handlebars.compile(
            '<tr>' +
                '{{#path}}' +
                    '<td class="leftmenu-path-item {{#last}}menuNavigateCurrent{{/last}}">{{name}}</td>' +
                    '{{^last}}<td><div class="markerRight"></div></td>{{/last}}' +
                '{{/path}}' +
            '</tr>')(
            {
                path: path.map(function(item, index, arr) {
                    return {name: item, last: index === arr.length-1};
                })
            }
        );
    }

    var ui = Handlebars.compile(
        '<div class="leftmenu-canvas {{id}}" id="{{id}}">' +
            '{{#isTitle}}<div class="leftTitle">' +
                '{{#showMinimizeButton}}' + 
                    '<div class = "leftmenu-toggle-zone">' + 
                        '<div class="ui-helper-noselect leftmenu-toggle-icon leftmenu-down-icon"></div>' + 
                    '</div>' +
                '{{/showMinimizeButton}}' +
                '<table class="leftmenu-path ui-helper-noselect">{{{pathTR}}}</table>' +
                '{{#showCloseButton}}<div class="gmx-icon-close"></div>{{/showCloseButton}}' +
            '</div>{{/isTitle}}' +
            '<div class = "workCanvas"></div>' +
        '</div>');

    /**HTML элемент с блоком (содержит шапку и рабочую область)*/
    this.panelCanvas = $(ui({
        isTitle: !!(options.path.length || options.showCloseButton || options.showMinimizeButton),
        id: 'left_' + canvasID,
        pathTR: getPathHTML(options.path),
        showCloseButton: options.showCloseButton,
        showMinimizeButton: options.showMinimizeButton
    }))[0];

    /**Рабочая область блока*/
    this.workCanvas = $(this.panelCanvas).find('.workCanvas')[0];

    /** Программная имитация нажатия кнопки закрытия блока
        @function
    */
    this.close = options.closeFunc;

    var isUICollapsed = false,
        _this = this;
    
    var toggleContentVisibility = function(isCollapsed) {
        if (isUICollapsed !== isCollapsed) {
            isUICollapsed = !isUICollapsed;
            $(_this.workCanvas).toggle();
            $(_this.panelCanvas).find('.leftmenu-toggle-zone div').toggleClass('leftmenu-down-icon leftmenu-right-icon');
            $(_this).trigger('changeVisibility');
        }
    }

    $('.leftmenu-toggle-zone, .leftmenu-path', this.panelCanvas).click(function() {
        toggleContentVisibility(!isUICollapsed);
    });
    
    /** Свернуть панель
        @function
    */
    this.hide = toggleContentVisibility.bind(null, true);
    
    /** Развернуть панель
        @function
    */
    this.show = toggleContentVisibility.bind(null, false);
    
    /** Свёрнута ли панель */
    this.isCollapsed = function() {return isUICollapsed};

    $('.leftTitle .gmx-icon-close',  this.panelCanvas).click(options.closeFunc);

    /** Задать новый заголовок окна
     @param {String[]} [path] Массив строк для формирования названия блока.
                      Предполагается, что последний элемент является собственно названием, а предыдущие - названиями категорий.
    */
    this.setTitle = function(path) {
        $('.leftmenu-path', this.panelCanvas).html(getPathHTML(path));
    }
}

/** Основное меню ГеоМиксера
 * @global
 * @type {UpMenu}
 */
var _menuUp = new UpMenu();

// содержит ссылку на рабочую область для текущей вкладки
var leftMenu = function()
{
	this.workCanvas = null;
	this.parentWorkCanvas = null;
}

//варианты вызова:
//    function(canvasID, closeFunc, options) - для обратной совместимости
//    function(canvasID, options)
// options - те же, что и в LeftPanelItem
leftMenu.prototype.createWorkCanvas = function(canvasID, closeFunc, options)
{
    if (typeof closeFunc !== 'function') {
        options = closeFunc || {};
        closeFunc = options.closeFunc;
    } else {
        options = options || {};
    }

    options.closeFunc = function() {
        $(_this.parentWorkCanvas).hide();
        closeFunc && closeFunc();
    }

    var _this = this;
	if (!$('#left_' + canvasID).length)
	{
        var leftPanelItem = new nsGmx.LeftPanelItem(canvasID, options);
        this.parentWorkCanvas = leftPanelItem.panelCanvas;
        this.workCanvas = leftPanelItem.workCanvas;
        this.leftPanelItem = leftPanelItem;
        
        // так как мы используем dom элементы для поиска панелей после первого добавления
        // возможно, лучше сделать полноценный менеджер панелей левой вкладки
        this.parentWorkCanvas.leftPanelItem = leftPanelItem;

        $('#leftContentInner').prepend(this.parentWorkCanvas);

		return false;
	}
	else
	{
		this.parentWorkCanvas = $('#left_' + canvasID)[0];
		this.workCanvas = this.parentWorkCanvas.lastChild;
        this.leftPanelItem = this.parentWorkCanvas.leftPanelItem;
        this.leftPanelItem.close = options.closeFunc;

		$(this.parentWorkCanvas).show();
        
        $('#leftContentInner').prepend(this.parentWorkCanvas);

		return true;
	}
}
!(function($, _) {

var modulePath = "";

//TODO: вынести переключалку страниц в отдельный модуль
var appendTranslations = function()
{
    _translationsHash.addtext("rus", {
        "Следующие [value0] страниц" : "Следующие [value0] страниц",
        "Предыдущие [value0] страниц" : "Предыдущие [value0] страниц",
        "Первая страница" : "Первая страница",
        "Последняя страница" : "Последняя страница"
    });

    _translationsHash.addtext("eng", {
        "Следующие [value0] страниц" : "Next [value0] pages",
        "Предыдущие [value0] страниц" : "Previous [value0] pages",
        "Первая страница" : "First page",
        "Последняя страница" : "Last page"
    });
}

/** Интерфейс провайдера данных таблицы {@link nsGmx.ScrollTable}
 * @class nsGmx.ScrollTable.IDataProvider
 * @abstract
 */

/** Получить общее количество объектов
  @method nsGmx.ScrollTable.IDataProvider#getCount
  @param {function(Number)} callback Ф-ция, которую нужно вызвать с общим количеством объектов
*/

/** Это событие должно генерироваться при любом изменении набора данных. Приведёт к перерисовке таблицы
  @event nsGmx.ScrollTable.IDataProvider#change
*/

/** Получить массив объектов для отрисовки на странице
  @method nsGmx.ScrollTable.IDataProvider#getItems
  @param {Number} page Номер страницы (нумерация с нуля)
  @param {Number} pageSize Размер страницы
  @param {String} sortParam По какому атрибуту сортировать
  @param {Boolean} sortDec Направление сортировки (true - по убыванию)
  @param {function(Array)} callback Ф-ция, которую нужно вызвать с результирующим массивом объектов. Структура самих объектов определяется провайдером
*/

/** Получить массив объектов для отрисовки на страницы и общее количество данных за один запрос.
    Альтернатива раздельным запросам getItems() и getCount(). Можно реализовать либо эту ф-цию, либо две другие
  @method nsGmx.ScrollTable.IDataProvider#getCountAndItems
  @param {Number} page Номер страницы (нумерация с нуля)
  @param {Number} pageSize Размер страницы
  @param {String} sortParam По какому атрибуту сортировать
  @param {Boolean} sortDec Направление сортировки (true - по убыванию)
  @param {function(count:Number, objs:Object[])} callback Ф-ция, которую нужно вызвать с полученным результатом.
         Первый параметр - общее количество объектов, второй - массив объектов для данной страницы.
*/

/** Таблица с разбиением данных по страницам. Сильно кастомизируемый виджет. Поддерживает различные провайдеры данных и рендереры.
 * @class
 * @alias nsGmx.ScrollTable
 */
var scrollTable = function( params )
{
    /** Перед перерисовкой данных
     * @event nsGmx.ScrollTable#beforeRedraw
     */

    /** После перерисовки данных
     * @event nsGmx.ScrollTable#redraw
     */

    /** Изменились параметры сортировки
     * @event nsGmx.ScrollTable#sortChange
     */

    this._params = $.extend(
    {
        limit: 50,
        page: 0,
        pagesCount: 10,
        height: '',
        showFooter: true
    }, params);

	this.limit = this._params.limit;
	this.pagesCount = this._params.pagesCount;

	this.start = 0;
	this.reportStart = 0;

	this.drawFunc = null;

    this._requestID = 0;
    this._pageVals = [];
    this._currValsCount = 0;

    this._dataProvider = null;

	 // Переход на предыдущую страницу
	this.next = function()
	{
		var _this = this,
			button = makeImageButton(modulePath + 'img/next.png', modulePath + 'img/next_a.png');

		button.style.marginBottom = '-7px';

		button.onclick = function()
		{
			_this.start += _this.pagesCount;
			_this.reportStart = _this.start * _this.limit;

			_this._drawPagesRow();

			_this.tableBody.scrollTop = 0;
			_this.tableParent.scrollTop = 0;
		}

		_title(button, _gtxt('Следующие [value0] страниц', _this.pagesCount));

		return button;
	}

	// Переход на следующую страницу
	this.previous = function()
	{
		var _this = this,
			button = makeImageButton(modulePath + 'img/prev.png', modulePath + 'img/prev_a.png');

		button.style.marginBottom = '-7px';

		button.onclick = function()
		{
			_this.start -= _this.pagesCount;
			_this.reportStart = _this.start * _this.limit;

			_this._drawPagesRow();

			_this.tableBody.scrollTop = 0;
			_this.tableParent.scrollTop = 0;
		}

		_title(button, _gtxt('Предыдущие [value0] страниц', _this.pagesCount));

		return button;
	}

	// Переход на первую страницу
	this.first = function()
	{
		var _this = this,
			button = makeImageButton(modulePath + 'img/first.png', modulePath + 'img/first_a.png');

		button.style.marginBottom = '-7px';

		button.onclick = function()
		{
			_this.start = 0;
			_this.reportStart = _this.start * _this.limit;

			_this._drawPagesRow();

			_this.tableBody.scrollTop = 0;
			_this.tableParent.scrollTop = 0;
		}

		_title(button, _gtxt('Первая страница'));

		return button;
	}

	// Переход на последнюю страницу
	this.last = function()
	{
		var _this = this,
			button = makeImageButton(modulePath + 'img/last.png', modulePath + 'img/last_a.png');

		button.style.marginBottom = '-7px';

		button.onclick = function()
		{
			_this.start = Math.floor(_this._currValsCount / (_this.pagesCount * _this.limit)) * _this.pagesCount;
			_this.reportStart = Math.floor(_this._currValsCount / _this.limit) * _this.limit;

			_this._drawPagesRow();

			_this.tableBody.scrollTop = 0;
			_this.tableParent.scrollTop = 0;
		}

		_title(button, _gtxt('Последняя страница'));

		return button;
	}

    var _this = this;
    this._status = {
        _state: false,
        start: function() {
            this._state = true;
            var me = this;
            setTimeout(function() {
                if (me._state) {
                    $(_this.statusContainer).siblings().hide();
                    $(_this.statusContainer).show();
                }
            }, 100);
        },
        stop: function() {
            $(_this.statusContainer).siblings().show();
            $(_this.statusContainer).hide();
            this._state = false;
        }
    }

	this.limitSel = nsGmx.Utils._select([_option([_t("10")], [['attr','value',10]]),
							 _option([_t("20")], [['attr','value',20]]),
							 _option([_t("50")], [['attr','value',50]]),
							 _option([_t("100")], [['attr','value',100]]),
							 _option([_t("200")], [['attr','value',200]]),
							 _option([_t("500")], [['attr','value',500]])], [['dir','className','selectStyle floatRight'], ['css','width','60px']])
}

/** Установка провайдера данных
 @param {nsGmx.ScrollTable.IDataProvider} dataProvider Провайдер данных
 */
scrollTable.prototype.setDataProvider = function( dataProvider )
{
    this._dataProvider = dataProvider;
    this._drawTable();
}

/** Получить текущий провайдер данных
 @return {nsGmx.ScrollTable.IDataProvider} Текущий провайдер данных
 */
scrollTable.prototype.getDataProvider = function()
{
    return this._dataProvider;
}

/** Изменить активность (видимость) колонки в таблице
  @param {String} name имя колонки
  @param {Boolean} isActive активность (видимость) колонки
*/
scrollTable.prototype.activateField = function(name, isActive)
{
    for (var f = 0; f < this._fields.length; f++)
        if (this._fields[f].title == name)
        {
            if (this._fields[f].isActive == isActive)
                return;

            this._fields[f].isActive = isActive;

            this._drawHeader();
            this._drawRows();
        }
}

scrollTable.prototype._getActiveFields = function()
{
    var res = [];
    for (var f = 0; f < this._fields.length; f++)
        if (this._fields[f].isActive)
            res.push(this._fields[f].title);

    return res;
}

scrollTable.prototype._drawRows = function()
{
	var trs = [],
        tr;

    $(this).triggerHandler('beforeRedraw');

	$(this.tableBody).empty();

    var activeFields = this._getActiveFields();

	for (var i = 0; i < this._pageVals.length; i++)
    {
        tr = this.drawFunc(this._pageVals[i], i, activeFields);
		tr && trs.push(tr);
    }

	_(this.tableBody, trs);

	if (this._pageVals.length == 0)
		_(this.tableBody, [_tr(null,[['css','height','1px'],['attr','empty', true]])])

	$(this.tableCount).empty();

    this.statusContainer = _div(null, [['dir', 'className', 'fileBrowser-progress'], ['css', 'display', 'none']]);

	if (this._currValsCount) {
		_(this.tableCount, [_span([
            _t((this.reportStart + 1) + '-' + (Math.min(this.reportStart + this.limit, this._currValsCount))),
            _span([_t(' ')],[['css','margin','0px 3px']]),
            _t("(" + this._currValsCount + ")")
        ]), this.statusContainer]);
    }
	else {
		_(this.tableCount, [_span([_t("0-0"), _span([_t(' ')],[['css','margin','0px 3px']]), _t("(0)")]), this.statusContainer]);
    }

    $(this).triggerHandler('redraw');
}

scrollTable.prototype._drawPages = function(end)
{
	var _this = this;
	for (var i = this.start + 1; i<= end; i++)
	{
		// текущий элемент
 		if (i - 1 == this.reportStart/this.limit)
 		{
		    var el = _span([_t(i.toString())]);
			_(_this.tablePages, [el]);
			$(el).addClass('page');
		}
		else
		{
			var link = makeLinkButton(i.toString());

			link.setAttribute('page', i - 1);
			link.style.margin = '0px 2px';

			_(_this.tablePages, [link]);

			link.onclick = function()
			{
				_this.reportStart = this.getAttribute('page') * _this.limit;

				_this._drawPagesRow();

				// мозилла
				_this.tableBody.scrollTop = 0;
				// ие
				_this.tableParent.scrollTop = 0;
			};
		}
	}
}

scrollTable.prototype._updatePageData = function(callback)
{
    var _this = this;

    if (this._dataProvider.getCountAndItems)
    {
        var requestID = this._requestID++;
        this._status.start();
        _this._dataProvider.getCountAndItems(
            _this.reportStart / _this.limit,
            _this.limit,
            _this.currentSortType,
            _this.currentSortIndex[_this.currentSortType] == 1,
            function(count, values)
            {
                if (requestID !== _this._requestID - 1) {
                    _this._status.stop();
                    return;
                }

                _this._currValsCount = count;


                //если данных стало слишком мало, мы встанем на первую страницу и перезапросим данные ещё раз
                if (_this.reportStart > _this._currValsCount)
                {
                    requestID = _this._requestID++;

                    _this.start = _this.reportStart = 0; //на первую страницу

                    _this._dataProvider.getCountAndItems(
                        _this.reportStart / _this.limit,
                        _this.limit,
                        _this.currentSortType,
                        _this.currentSortIndex[_this.currentSortType] == 1,
                        function(count, values)
                        {
                            _this._status.stop();
                            if (requestID !== _this._requestID - 1)
                                return;

                            _this._pageVals = values;
                            callback();
                        }
                    )
                }
                else
                {
                    _this._status.stop();
                    _this._pageVals = values;
                    callback();
                }
            }
        )
    }
    else
    {
        this._status.start();
        this._dataProvider.getCount(function(count)
        {
            _this._currValsCount = count;

            //вообще-то при обновлении данных мы не изменяем текущей страницы
            //однако если данных стало слишком мало, то текущую страницу сохранить нельзя,
            //и мы переключимся на первую
            if (_this.reportStart >= _this._currValsCount)
            {
                _this.start = _this.reportStart = 0;
            }

            _this._dataProvider.getItems(
                _this.reportStart / _this.limit,
                _this.limit,
                _this.currentSortType,
                _this.currentSortIndex[_this.currentSortType] == 1,
                function(values)
                {
                    _this._status.stop();
                    _this._pageVals = values || [];
                    callback();
                }
            )
        });
    }
}

scrollTable.prototype._drawPagesRow = function()
{
    var _this = this;
    this._updatePageData(function()
    {
        // перерисовывем номера страниц
        $(_this.tablePages).empty();

        if (_this._currValsCount > _this.limit)
        {
            var allPages = Math.ceil(_this._currValsCount / _this.limit);

            var end = (_this.start + _this.pagesCount <= allPages) ? _this.start + _this.pagesCount : allPages;

            if (_this.start - _this.pagesCount >= 0)
                _(_this.tablePages,[_this.first(), _this.previous()]);

            _this._drawPages(end);

            if (end + 1 <= allPages)
                _(_this.tablePages,[_this.next(), _this.last()]);
        }

        _this._drawRows();
    })

}

scrollTable.prototype._drawHeader = function()
{
    var tds = [],
        _this = this;

    var headerElemFactory = this._isWidthScroll ? _th : _td;

    this._fields.forEach(function(field) {
        if (!field.isActive)
            return;

        var title = field.title,
            button;

		if (title != '' && field.isSortable)
		{
			button = makeLinkButton(title);

			button.sortType = title;
		}
		else
			button = _t(title)

        var td = headerElemFactory([button], [['css','width',field.width]]);

        if (field.isSortable) {
            $(td).click(function() {
                _this.setSortParams(title, 1 - _this.currentSortIndex[title]);
            })
        }

		tds.push(td);
    })

    $(this._tableHeaderRow).empty();
    _(this._tableHeaderRow, tds);
}

//Если baseWidth == 0, таблица растягивается на весь контейнер по ширине

/** Нарисовать таблицу
* @param {Object} params
* @param {DOMElement} params.parent Контейнер для помещения результата отрисовки
* @param {String} params.name Уникальное имя таблицы
* @param {Number} [params.baseWidth] Какой ширины должна быть таблица. Если не указано, будет занимать 100% контейнера
* @param {String[]} params.fields массив имён колонок
* @param {String[]} params.fieldsWidths массив с описанием ширины колонок. Описание даётся в терминах css
* @param {function} params.drawFunc Ф-ция отрисовки одной строки таблицы. На вход - объект для отрисовки (полученный от провайдера). На выходе - "tr" элемент
* @param {Object} [params.sortableFields] Хеш для указания возможности сортировки колонок (будет включена для всех ключей хеша)
* @param {Boolean} [params.isWidthScroll] Трубется ли возможность прокрутки данных по горизонтали
*/
scrollTable.prototype.createTable = function(parent, name, baseWidth, fields, fieldsWidths, drawFunc, sortableFields, isWidthScroll)
{
    var params = null
    //передача параметров в виде структуры
    if (arguments.length === 1)
    {
        params = $.extend(true, {
            sortableFields: {}
        }, parent);
    }
    else
    {
        params = {
            parent: parent,
            name: name,
            baseWidth: baseWidth,
            fields: fields,
            fieldsWidths: fieldsWidths,
            drawFunc: drawFunc,
            sortableFields: sortableFields,
            isWidthScroll: isWidthScroll
        }
    }

    var name = params.name;

	var _this = this;
    this._isWidthScroll = params.isWidthScroll;

    this._fields = [];
    for (var f = 0; f < params.fields.length; f++)
        this._fields.push({
            title: params.fields[f],
            width: params.fieldsWidths[f],
            isSortable: params.fields[f] in params.sortableFields,
            isActive: true
        });


	this.limitSel = switchSelect(this.limitSel,  this.limit)

	this.limitSel.onchange = function()
	{
		_this.limit = Number(this.value);

		_this.start = 0;
		_this.reportStart = _this.start * _this.limit;

		_this._drawTable()
	}

	this.tableCount = _div();
	this.tableLimit = _div([this.limitSel]);
	this.tablePages = _div(null,[['dir','className','tablePages']]);

    this.tableBody = _tbody(null,[['attr','id',name + 'TableBody']]);


    this._tableHeaderRow = _tr();
    if (this._isWidthScroll)
    {
        this.tableHeader = _thead([this._tableHeaderRow], [['attr','id',name + 'TableHeader'], ['dir','className','tableHeader']]);
    }
    else
    {
        //как формировать фиксированный заголовок таблицы, зависит от того, будет ли у таблицы фиксированный размер или нет
        //TODO: убрать возможность задавать фиксированный размер
        if ( params.baseWidth )
            this.tableHeader = _tbody([this._tableHeaderRow],[['attr','id',name + 'TableHeader']]);
        else
            this.tableHeader = _tbody([_tr([_td([_table([_tbody([this._tableHeaderRow])])]), _td(null, [['css', 'width', '20px']])])], [['attr','id',name + 'TableHeader']]);
    }

    this._drawHeader();

    if (this._isWidthScroll)
    {
        this.tableParent = _div([_table([this.tableHeader, this.tableBody], [['css', 'width', '100%']])],
                                [['attr','id',name + 'TableParent'],['dir','className','scrollTable'],['css','width', baseWidth ? baseWidth + 'px' : "100%"], ['css', 'height', this._params.height], ['css', 'overflow', 'auto']]);
    }
    else
    {
        this.tableParent = _div([
                                _div([_table([this.tableHeader])],[['dir','className','tableHeader']]),
                                _div([_table([this.tableBody])],[['dir','className','tableBody'],['css', 'height', this._params.height ? (this._params.height - 20) + 'px' : ''], ['css','width', params.baseWidth ? params.baseWidth + 20 + 'px' : "100%"]])
                            ],[['attr','id',name + 'TableParent'],['dir','className','scrollTable'], ['css', 'height', this._params.height ? this._params.height + 'px' : ''], ['css','width', params.baseWidth ? params.baseWidth + 'px' : "100%"]])
    }

	_(params.parent, [this.tableParent])

    if (this._params.showFooter)
        _(params.parent, [_table([_tbody([_tr([_td([this.tableCount], [['css','width','20%']]), _td([this.tablePages]), _td([this.tableLimit], [['css','width','20%']])])])], [['css','width','100%']])]);


	this.drawFunc = params.drawFunc;
	this.start = 0;         //Первый номер страницы, показываемый на экране (это не текущая страница!)
	this.reportStart = 0;   //Первый номер элемента на текущей странице

	this.currentSortType = null;
	// сортировка по умолчанию
	for (var name in params.sortableFields)
	{
		this.currentSortType = name;

		break;
	}

	this.currentSortIndex = {};
	for (var name in params.sortableFields)
	{
		this.currentSortIndex[name] = 0;
	}

    if (!this._dataProvider)
        this.setDataProvider(new scrollTable.StaticDataProvider());

    $(this._dataProvider).change(function()
    {
        _this._drawTable();
    });
    this._drawTable();
}

scrollTable.prototype.updateHeight = function( height )
{
    if (this._isWidthScroll)
    {
        this.tableParent.style.height = (height - 40) + 'px';
    }
    else
    {
        $(this.tableParent).find('.tableBody').height(height - 20);
        $(this.tableParent).height(height);
    }
}

scrollTable.prototype._drawTable = function()
{
    if (!this.tableBody) return; //ещё не создана таблица
    this._drawPagesRow();
}

/** Выбрать страницу для показа
@param {Number} page Номер страницы (нумерация с нуля)
*/
scrollTable.prototype.setPage = function(iPage)
{
	if (this.limit*iPage >= this._currValsCount || iPage < 0 || this.reportStart == iPage * this.limit)
		return;

	this.reportStart = iPage * this.limit;
	this.start = Math.floor(iPage/this.pagesCount) * this.pagesCount;

	this._drawPagesRow();

	this.tableBody.scrollTop = 0;
	this.tableParent.scrollTop = 0;
}

/** Получить массив объектов, которые нарисованы в данный момент
 @return {Array} массив объектов в формате провайдера данных
*/
scrollTable.prototype.getVisibleItems = function()
{
    return this._pageVals;
}

/** Задать параметры сортровки
 @param {String} sortType Имя колонки для сортировки
 @param {Boolean} sortDirection Направление сортровки (false - по возрастанию, true - по убыванию)
*/
scrollTable.prototype.setSortParams = function(sortType, sortDirection)
{
    this.currentSortType = sortType;
    this.currentSortIndex[this.currentSortType] = sortDirection;

    this.start = 0;
    this.reportStart = this.start * this.limit;

    this._drawTable()

    $(this).triggerHandler('sortChange');
}

/** Получить текущее направление сортировки.
 @return {Boolean} false - по возрастанию, true - по убыванию
*/
scrollTable.prototype.getSortDirection = function()
{
    return this.currentSortIndex[this.currentSortType] == 1
}

/** Получить по какой колонке происходит сортровка
 @return Имя колонки
*/
scrollTable.prototype.getSortType = function()
{
    return this.currentSortType;
}

/** Перерисовать текущую страницу без перезапроса данных у провайдера */
scrollTable.prototype.repaint = function()
{
    this._drawRows();
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/** Провайдер данных для {@link nsGmx.ScrollTable}.
* Хранит статический массив данных, умеет их фильтровать и упорядочивать.
* @class
* @extends nsGmx.ScrollTable.IDataProvider
*/
scrollTable.StaticDataProvider = function( originalData )
{
    var _vals = originalData || []; //исходный список элементов
    var _filteredVals = []; //список элементов после фильтрации. Валиден только если _isFiltered == true

    var _isFiltered = false;
    var _predicate = {}; //фильтры. Ф-ции predicate(name, value, items)->filteredItems
    var _filterVals = {}; //значения фильтров

    var _sortFunctions = {};
    var _this = this;

    var _filter = function()
    {
        if (_isFiltered) return;

        _filteredVals = _vals;

        for (var filterElem in _filterVals)
        {
            _filteredVals = _predicate[filterElem](filterElem, _filterVals[filterElem], _filteredVals);
        }

        _isFiltered = true;
    }

    var _update = function()
    {
        _isFiltered = false;
        $(_this).change();
    }

    /** синхронный вариант getCount() */
    this.getCountDirect = function()
    {
        _filter();
        return _filteredVals.length;
    }

    /** синхронный вариант getItems() */
    this.getItemsDirect = function(page, pageSize, sortParam, sortDec)
    {
        var nMin = page*pageSize;
        var nMax = nMin + pageSize;
        _filter();
        var sortDirIndex = sortDec ? 1 : 0;
        var sortedVals;

        if (_sortFunctions[sortParam])
        {
            if (typeof _sortFunctions[sortParam] === 'function') //если нет ф-ции для сортировки в обратном порядке, инвертируем прямую ф-цию
                sortedVals = _filteredVals.sort(function(a, b) { return (1-2*sortDirIndex) * _sortFunctions[sortParam](a, b); });
            else
                sortedVals = _filteredVals.sort(_sortFunctions[sortParam][sortDirIndex]);
        }
        else
            sortedVals = _filteredVals;

        nMin = Math.min(Math.max(nMin, 0), sortedVals.length);
        nMax = Math.min(Math.max(nMax, 0), sortedVals.length);
        return sortedVals.slice(nMin, nMax);
    }

    //IDataProvider interface
    this.getCount = function(callback)
    {
        callback(this.getCountDirect());
    }

    this.getItems = function(page, pageSize, sortParam, sortDec, callback)
    {
        callback(this.getItemsDirect(page, pageSize, sortParam, sortDec, callback));
    }

    /** задание исходных данных */
    this.setOriginalItems = function(items)
    {
        _vals = items;
        _update();
    }

    /** получение исходных данных */
    this.getOriginalItems = function()
    {
        return _vals;
    }

    /** Фильтруем исходные данные
    * @param {function(val:Object):Boolean} filterFunction ф-ция для фильтрации. На вход принимает элемент массива данных, возвращает false, если элемент отфильтровывается, иначе true
    */
    this.filterOriginalItems = function(filterFunction)
    {
        var newOrigData = [];
        for (var i = 0; i < _vals.length; i++)
            if (filterFunction(_vals[i]))
                newOrigData.push(_vals[i]);

        _vals = newOrigData;
        _update();
    }

    /** Добавляем новый элемент в исходные данные */
    this.addOriginalItem = function(item)
    {
        _vals.push(item);
        _update();
    }

    /** Добавляем массив элементов в исходные данные */
    this.addOriginalItems = function(itemArr)
    {
        _vals = _vals.concat(itemArr);
        _update();
    }

    //фильтрация
    this.attachFilterEvents = function(inputField, fieldName, predicate)
    {
        var _this = this;

        _predicate[fieldName] = predicate;

        $(inputField).bind('keyup', function()
        {
            if (_filterVals[fieldName] !== this.value)
            {
                _filterVals[fieldName] = this.value;
                _update();
            }
        })

        _filterVals[fieldName] = inputField.value;
        _update();
    }

    /** Добавить ф-цию фильтрации исходных данных
        @param {String} fieldName Имя фильтра
        @param {function} predicate Ф-ция фильтрации: predicate(name, value, items)->filteredItems
    */
    this.addFilter = function(fieldName, predicate)
    {
        _predicate[fieldName] = predicate;
    }

    /** Установить значение для фильтра
        @param {String} fieldName Имя фильтра
        @param {String} value Значение для фильтрации
    */
    this.setFilterValue = function(fieldName, value)
    {
        _filterVals[fieldName] = value;
        _update();
    }

    this.attachSelectFilterEvents = function(selectField, fieldName, predicate)
    {
        var _this = this;

        _predicate[fieldName] = predicate;

        selectField.onchange = function()
        {
            _filterVals[fieldName] = this.value;
            _update();
        }

        _filterVals[fieldName] = selectField.value;
        _update();
    }

    /** Задать ф-ции сортировки
     @param {Object} sortFunctions Хеш из ф-ций {Имя столбца -> ф-ция или массив из двух ф-ций}.
        Если массив из двух ф-ций, то первая используется для сортировки по возрастанию, вторая - по убыванию.
        Если просто ф-ция, то по убыванию используется инвертная к ней.
        Формат ф-ции совпадает с ф-цией для sort().
    */
    this.setSortFunctions = function(sortFunctions)
    {
        _sortFunctions = sortFunctions;
    }
};

// простое стравнение по атрибутам объекта.
// Использование: genAttrSort(func(a)->value), genAttrSort(attrName), genAttrSort(attrName1, attrName2)
scrollTable.StaticDataProvider.genAttrSort = function(attrName1, attrName2)
{
    if (typeof attrName1 === 'function')
    {
        return function(a, b) {
            var av = attrName1(a),
                bv = attrName1(b);
            if (av > bv)      return 1;
            else if (av < bv) return -1;
            else              return 0;
        }
    }
    else if (attrName2)
    {
        return function(a, b) {
            var av = a[attrName1][attrName2];
            var bv = b[attrName1][attrName2];
            if (av > bv)      return 1;
            else if (av < bv) return -1;
            else              return 0;
        }
    } else {
        return function(a, b) {
            var av = a[attrName1];
            var bv = b[attrName1];
            if (av > bv)      return 1;
            else if (av < bv) return -1;
            else              return 0;
        }
    }
}

//если есть вьюер, добавляем для него переменные в глобальный namespace
if ('nsGmx' in window && 'GeomixerFramework' in window.nsGmx)
{
    window.scrollTable = scrollTable; //Depricated - use nsGmx
    window.nsGmx.ScrollTable = scrollTable;
}

if (typeof window.gmxCore !== 'undefined')
{
    gmxCore.addModule("ScrollTableControl",
        {
            ScrollTable: scrollTable
        },
        {
            require: ['translations', 'utilities'],
            css: 'table.css',
            init: function(module, path)
            {
                modulePath = path || "";
                appendTranslations();
            }
        }
    );
}

})(jQuery, nsGmx.Utils._);

var nsMapCommon = function($){
    var publicInterface = {
        generateWinniePermalink: function() {
            var mapProps = nsGmx.gmxMap.properties,
                lmap = nsGmx.leafletMap,
                center = lmap.getCenter(),
                layersState = {expanded: {}, visible: {}};
                
            _layersTree.treeModel.forEachNode(function(elem) {
                var props = elem.content.properties;
                if (elem.type == 'group') {
                    var groupId = props.GroupID;

                    if ($("div[GroupID='" + groupId + "']").length || props.changedByViewer) {
                        layersState.expanded[groupId] = props.expanded;
                    }
                } else {
                    if (props.changedByViewer) {
                        layersState.visible[props.name] = props.visible;
                    }
                }
            });
            
            var config = {
                app: {
                    gmxMap: {
                        mapID: mapProps.name
                    }
                },
                state: {
                    map: {
                        position: {
                            x: center.lng,
                            y: center.lat,
                            z: lmap.getZoom()
                        }
                    },
                    calendar: nsGmx.widgets.commonCalendar.getDateInterval().saveState(),
                    baseLayersManager: lmap.gmxBaseLayersManager.saveState(),
                    layersTree: layersState
                }
            }

            return nsGmx.Utils.TinyReference.create(config, false);
        },
        /**
        * Выбирает данные из дерева слоёв по описанию слоёв и групп
        * @param {FlashMapObject} map - текущая карта
        * @param {object} mapTree - дерево, в котором нужно искать
        * @param {array} description - массив с описанием нужных слоёв. Каждый элемент массива может быть либо строкой (имя слоя), либо объектом {group: '<groupName>'} - выбрать все слои из группы
        */
        selectLayersFromTree: function(map, mapTree, description)
        {
            var _array = [];
            var _hash = {};
            
            var _getLayersInGroup = function(map, mapTree, groupTitle)
            {
                var res = {};
                var visitor = function(treeElem, isInGroup)
                {
                    if (treeElem.type === "layer" && isInGroup)
                    {
                        res[treeElem.content.properties.name] = map.layers[treeElem.content.properties.name];
                    }
                    else if (treeElem.type === "group")
                    {
                        isInGroup = isInGroup || treeElem.content.properties.title == groupTitle;
                        var a = treeElem.content.children;
                        for (var k = a.length - 1; k >= 0; k--)
                            visitor(a[k], isInGroup);
                    }
                }

                visitor( {type: "group", content: { children: mapTree.children, properties: {} } }, false );
                return res;
            }    
            
            for (var k = 0; k < description.length; k++)
                if ( typeof description[k] === "string" )
                {
                    _hash[description[k]] = map.layers[description[k]];
                    _array.push( map.layers[description[k]] );
                }
                else if ('group' in description[k])
                {
                    var groupHash = _getLayersInGroup(map, mapTree, description[k].group);
                    for (var l in groupHash)
                    {
                        _hash[l] = groupHash[l];
                        _array.push( groupHash[l] );
                    }
                }
                
            return {
                asArray: function() { return _array; },
                asHash: function() { return _hash; },
                names: function()
                {
                    var res = [];
                    
                    for (var l in _hash) 
                        res.push(l);
                        
                    return res;
                }
            }
        }
    };
    
    if (typeof gmxCore !== 'undefined')
    {
        gmxCore.addModule('MapCommon', publicInterface);
    }
    
    return publicInterface;
}(jQuery);
!(function(_) {
/** Разнообразные вспомогательные контролы (базовые элементы GUI)
    @namespace nsGmx.Controls
*/
nsGmx.Controls = {

	/** Создаёт контрол выбора цвета */
	createColorPicker: function(color, showFunc, hideFunc, changeFunc){
		var colorPicker = _div(null, [['dir','className','colorSelector'], ['css','backgroundColor',nsGmx.Utils.convertColor(color)]]);

		$(colorPicker).ColorPicker({
			color: nsGmx.Utils.convertColor(color),
			onShow: showFunc,
			onHide: hideFunc,
			onChange: changeFunc
		});

		_title(colorPicker, _gtxt("Цвет"));

		return colorPicker;
	},

	/** Создаёт иконку по описанию стиля слоя и типа геометрии
    */
	createGeometryIcon: function(parentStyle, type){
		var icon = _div(null, [['css','display','inline-block'],['dir','className','colorIcon'],['attr','styleType','color'],['css','backgroundColor','#FFFFFF']]);

		if (type.indexOf('linestring') < 0)
		{
            if (parentStyle.fill && parentStyle.fill.pattern)
            {
                var opaqueStyle = L.gmxUtil.fromServerStyle($.extend(true, {}, parentStyle, {fill: {opacity: 100}})),
                    patternData = L.gmxUtil.getPatternIcon(null, opaqueStyle);
                icon = patternData ? patternData.canvas : document.createElement('canvas');
                _(icon, [], [['dir','className','icon'],['attr','styleType','icon'],['css','width','13px'],['css','height','13px']]);
            }
            else
            {
                var fill = _div(null, [['dir','className','fillIcon'],['css','backgroundColor',(parentStyle.fill && typeof parentStyle.fill.color != 'undefined') ? nsGmx.Utils.convertColor(parentStyle.fill.color) : "#FFFFFF"]]),
                    border = _div(null, [['dir','className','borderIcon'],['attr','styleType','color'],['css','borderColor',(parentStyle.outline && typeof parentStyle.outline.color != 'undefined') ? nsGmx.Utils.convertColor(parentStyle.outline.color) : "#0000FF"]]),
                    fillOpacity = (parentStyle.fill && typeof parentStyle.fill.opacity != 'undefined') ? parentStyle.fill.opacity : 100,
                    borderOpacity = (parentStyle.outline && typeof parentStyle.outline.opacity != 'undefined') ? parentStyle.outline.opacity : 100;


                fill.style.opacity = fillOpacity / 100;
                border.style.opacity = borderOpacity / 100;

                if (type.indexOf('point') > -1)
                {

                    border.style.height = '5px';
                    fill.style.height = '5px';
                    border.style.width = '5px';
                    fill.style.width = '5px';

                    border.style.top = '3px';
                    fill.style.top = '4px';
                    border.style.left = '1px';
                    fill.style.left = '2px';
                }

                _(icon, [border, fill]);
            }
		}
		else
		{
			var border = _div(null, [['dir','className','borderIcon'],['attr','styleType','color'],['css','borderColor',(parentStyle.outline && typeof parentStyle.outline.color != 'undefined') ? nsGmx.Utils.convertColor(parentStyle.outline.color) : "#0000FF"]]),
				borderOpacity = (parentStyle.outline && typeof parentStyle.outline.opacity != 'undefined') ? parentStyle.outline.opacity : 100;


            border.style.opacity = borderOpacity / 100;

            border.style.width = '4px';
            border.style.height = '13px';

			border.style.borderTop = 'none';
			border.style.borderBottom = 'none';
			border.style.borderLeft = 'none';

			_(icon, [border]);
		}

		icon.oncontextmenu = function(e)
		{
			return false;
		}

		return icon;
	},

	/** Создаёт контрол "слайдер".
    */
	createSlider: function(opacity, changeFunc)	{
		var divSlider = _div(null, [['css','width','86px'],['css','height','8px'],['css','border','1px solid #cdcdcd']]);

		$(divSlider).slider(
			{
				min:0,
				max:100,
				step:1,
				value: opacity,
				slide: function(event, ui)
				{
					changeFunc(event, ui);

					_title(divSlider.firstChild, ui.value)
				}
			});

		divSlider.firstChild.style.zIndex = 1;

		divSlider.style.width = '100px';
		divSlider.style.border = 'none';
		divSlider.style.backgroundImage = 'url(img/slider.png)';

		divSlider.firstChild.style.border = 'none';
		divSlider.firstChild.style.width = '12px';
		divSlider.firstChild.style.height = '14px';
		divSlider.firstChild.style.marginLeft = '-6px';

        divSlider.firstChild.style.top = '-3px';

		divSlider.firstChild.style.background = 'transparent url(img/sliderIcon.png) no-repeat';

		divSlider.firstChild.onmouseover = function()
		{
			divSlider.firstChild.style.backgroundImage = 'url(img/sliderIcon_a.png)';
		}
		divSlider.firstChild.onmouseout = function()
		{
			divSlider.firstChild.style.backgroundImage = 'url(img/sliderIcon.png)';
		}

		_title(divSlider.firstChild, opacity)
		_title(divSlider, _gtxt("Прозрачность"));

		return divSlider;
	},

	createInput: function(value, changeFunc){
		var input = _input(null, [['dir','className','inputStyle'],['css','width','30px'],['attr','value',value]]);
		input.onkeyup = changeFunc;
		return input;
	},

    /** Создаёт диалог, позволяющий выбрать пользователю один из нарисованных на карте объектов
     * @param {String} name Уникальный идентификатор диалога
     * @param {function(gmxAPI.DrawingObject)} callback Ф-ция, которая вызовется при выборе пользователем одного из объектов
     * @param {Object} [params] Дополнительные параметры диалога
     * @param {String} [params.title] Заголовок диалога
     * @param {String} [params.geomType=null] Ограничения на тип геометрии (POINT, LINESTRING, POLYGON). null - без ограничений
     * @param {String} [params.errorTitle] Заголовок диалога с ошибками (например, если нет объектов)
     * @param {String} [params.errorMessage] Текст диалога с ошибками (например, если нет объектов)
     * @param {Number} [params.width=250] Ширина диалога в пикселях
    */
    chooseDrawingBorderDialog: function(name, callback, params)
    {
        var TYPE_CONVERT_DICT = {
            Polyline: 'linestring',
            MultiPolyline: 'linestring',
            Rectangle: 'polygon',
            Polygon: 'polygon',
            MultiPolygon: 'polygon',
            Point: 'point'
        }
        var _params = $.extend({
            title:         _gtxt("Выбор контура"),
            geomType:      null,
            errorTitle:   _gtxt("$$phrase$$_12"),
            errorMessage: _gtxt("$$phrase$$_12"),
			width:        250
        }, params);

        if ($('#drawingBorderDialog' + name).length)
            return;

        var drawingObjs = [],
            _this = this;

        nsGmx.leafletMap.gmxDrawing.getFeatures().forEach(function(obj)
        {
            if (!_params.geomType || TYPE_CONVERT_DICT[obj.getType()] === _params.geomType.toLowerCase()) {
                drawingObjs.push(obj);
            }
        })

        if (!drawingObjs.length)
            showErrorMessage(_params.errorMessage, true, _params.errorTitle);
        else
        {
            gmxCore.loadModule('DrawingObjects').done(function(drawing) {
                var canvas = _div();
                var collection = new drawing.DrawingObjectCollection(nsGmx.leafletMap);

                for (var i = 0; i < drawingObjs.length; i++)
                {
                    collection.Add(drawingObjs[i]);
                }

                var list = new drawing.DrawingObjectList(nsGmx.leafletMap, canvas, collection, {
                    allowDelete: false,
                    editStyle: false,
                    showButtons: false,
                    click: function(drawingObject) {
                        callback && callback(drawingObject);
                        removeDialog(jDialog);
                    }
                });

                var jDialog = nsGmx.Utils.showDialog(
                        _params.title,
                        _div([canvas], [['attr','id','drawingBorderDialog' + name],['dir','className','drawingObjectsCanvas']]),
                        {
                            width: _params.width,
                            height: 180
                        }
                    )
            })
        }
    },
    /**
     Создаёт виджет для управления видимостью (скрытия/показа) других элементов
     Сам виджет представляет из себя изменяющуюся иконку с текстом заголовка рядом с ней
     @class
     @param {String} title - текст заголовка
     @param {DOMElement} titleElem - элемент для размещения самого виджета
     @param {DOMElement|Array[]} managedElems - элементы, видимостью которых будем
     @param {Bool} isCollapsed - начальное состояние виджета
    */
    CollapsibleWidget: function(title, titleElem, managedElems, isCollapsed)
    {
        //var contentTr = _tr([_td([layerTagsParent], [['dir', 'colSpan', '2']])]);
        var collapseTagIcon = $('<div/>').addClass('collabsible-icon');
        var _isCollapsed = !!isCollapsed;

        managedElems = managedElems || [];
        if (!$.isArray(managedElems))
            managedElems = [managedElems];

        var updateElems = function()
        {
            for (var iE = 0; iE < managedElems.length; iE++)
            $(managedElems[iE]).toggle(!_isCollapsed);
        }

        var updateView = function()
        {
            collapseTagIcon
                .toggleClass('collabsible-icon-hidden', _isCollapsed)
                .toggleClass('collabsible-icon-shown', !_isCollapsed);
            updateElems();
        }

        updateView();

        $(titleElem).empty().append(
            collapseTagIcon,
            $('<div/>').addClass('collabsible-title').text(title)
        ).click(function()
        {
            _isCollapsed = !_isCollapsed;
            updateView();
        })

        this.addManagedElements = function(elems)
        {
            managedElems = managedElems.concat(elems);
            updateElems();
        }

        this.isCollapsed = function() { return _isCollapsed; };
    },

    /** Показывает аттрибутивную информацию объекта в виде таблички в отдельном диалоге */
    showLayerInfo: function(layer, obj)
    {
        var trs = [];
        var typeSpans = {};
        for (var key in obj.properties)
        {
            var content = _div(),
                contentText = String(obj.properties[key]);

            if (contentText.indexOf("http://") == 0 || contentText.indexOf("www.") == 0)
                contentText = "<a href=\"" + contentText + "\" target=\"_blank\">" + contentText + "</a>";

            content.innerHTML = contentText;

            var typeSpan = _span([_t(key)]);

            typeSpans[key] = typeSpan;

            trs.push(_tr([_td([typeSpan], [['css','width','30%']]), _td([content], [['css','width','70%']])]));
        }

        var title = _span(null, [['dir','className','title'], ['css','cursor','default']]),
            summary = _span(null, [['dir','className','summary']]),
            div;

        if ($('#layerPropertiesInfo').length)
        {
            div = $('#layerPropertiesInfo')[0];

            if (!trs.length && !layer.properties.Legend)
            {
                $(div.parentNode).dialog('close');

                return;
            }

            $(div).empty();

            _(div, [_table([_tbody(trs)], [['dir','className','vectorInfoParams']])]);

            if (layer.properties.Legend)
            {
                var legend = _div();

                legend.innerHTML = layer.properties.Legend;

                _(div, [legend])
            }

            var dialogTitle = div.parentNode.parentNode.firstChild.firstChild;

            $(dialogTitle).empty();

            _(dialogTitle, [_t(_gtxt("Слой [value0]", layer.properties.title))]);

            $(div.parentNode).dialog('open');
        }
        else
        {
            if (!trs.length && !layer.properties.Legend)
                return;

            div = _div([_table([_tbody(trs)], [['dir','className','vectorInfoParams']])], [['attr','id','layerPropertiesInfo']]);

            if (layer.properties.Legend)
            {
                var legend = _div();

                legend.innerHTML = layer.properties.Legend;

                _(div, [legend])
            }

            showDialog(_gtxt("Слой [value0]", layer.properties.title), div, 360, 'auto', false, false, null, function(){return true});

        }

        //подстраиваем ширину
        setTimeout(function()
        {
            var dialogDiv = $('#layerPropertiesInfo')[0].parentNode;
            var width = $(div).find('.vectorInfoParams').width();
            if (width > 340) {
                $(dialogDiv).dialog('option', 'width', width + 18);
            }
        }, 100)

        nsGmx.TagMetaInfo.loadFromServer(function(tagInfo)
        {
            for (var key in typeSpans)
            {
                if (tagInfo.isTag(key))
                    $(typeSpans[key]).attr('title', tagInfo.getTagDescription(key));
            }
        });
    }
}

gmxCore.addModule('Controls', nsGmx.Controls);

})(nsGmx.Utils._);

var nsGmx = nsGmx || {};

/** Узел дерева слоёв
 * @typedef nsGmx.LayersTree~Node
 * @property {String} type тип узла (`layer` или `group`)
 * @property {Object} content содержимое узла
 * @property {Object} [content.properties] свойства узла
 * @property {Object} [content.children] потомки узла
*/

/** Результат поиска узла в дереве слоёв
 * @typedef nsGmx.LayersTree~SearchResult
 * @property {nsGmx.LayersTree~Node} elem Найденный элемент
 * @property {nsGmx.LayersTree~Node[]} parents Массив родителей. Самый последний элемент массива - сама карта
 * @property {Number} index Индекс найденного элемента в своей группе
*/

/** Visitor при обходе слоёв дерева
 * @callback nsGmx.LayersTree~LayerVisitor
 * @param {Object} layerContent Содержимое узла слоя
 * @param {Boolean} isVisible Видимость слоя с учётом видимости всех родителей
 * @param {Number} nodeDepth Глубина слоя в дереве (начинается с 0)
*/

/** Visitor при обходе узлов дерева слоёв
 * @callback nsGmx.LayersTree~NodeVisitor
 * @param {nsGmx.LayersTree~Node} node Свойства узла
 * @param {Boolean} isVisible Видимость узла с учётом видимости всех родителей
 * @param {Number} nodeDepth Глубина узла в дереве (начинается с 0)
*/

/** Класс для работы с деревом слоёв
 * @class
 * @param {Object} tree Дерево слоёв в формате сервера
*/
nsGmx.LayersTree = function( tree )
{
    /** Изменилась видимость узла дерева. Если изменения касаются нескольких узлов, событие будет 
        генерироваться для каждого узла по отдельности. Кроме того, это же событие генерируется 
        на отдельных узлах дерева.
     * @event nsGmx.LayersTree#nodeVisibilityChange
     * @param {nsGmx.LayersTree~Node} node Узел, видимость которой изменилась
     */
    var _tree = tree;
    var _this = this;
    
    var _findElem = function(elem, propName, propValue, parents)
    {
        var childs = typeof elem.children != 'undefined' ? elem.children : elem.content.children;
        
        for (var i = 0; i < childs.length; i++)
        {
            var props = childs[i].content.properties;
            if (propName in props && props[propName] === propValue) {
                return {elem:childs[i], parents: [elem].concat(parents || []), index: i};
            }
            
            if (typeof childs[i].content.children != 'undefined')
            {
                var res = _findElem(childs[i], propName, propValue, [elem].concat(parents || []));
                
                if (res)
                    return res;
            }
        }
    }
    
    /** Получить исходное дерево слоёв
    */
    this.getRawTree = function() 
    {
        return _tree;
    }
    
    /** Получить свойства карты
    */
    this.getMapProperties = function() 
    {
        return _tree.properties;
    }
    
    /** Поиск узла дерева по значению одного из атрибутов. Ищет как папки, так и слои. Возвращает первый найденный результат
     * @param {String} propName Имя атрибута
     * @param {String} propValue Значение атрибута
     * @return {nsGmx.LayersTree~SearchResult} Результат поиска. undefined если ничего не найденно
    */
    this.findElem = function(propName, propValue)
    {
        return _findElem(_tree, propName, propValue);
    }
    
    this.findElemByGmxProperties = function(gmxProperties)
    {
        if (gmxProperties.type == 'group') //группа
            return this.findElem("GroupID", gmxProperties.content.properties.GroupID);
        else
            return this.findElem("name", gmxProperties.content.properties.name);
    }
    
    /** Итерирование по всем слоям группы дерева
     * @param {nsGmx.LayersTree~LayerVisitor} callback Будет вызвана для каждого слоя внутри группы. Первый аргумент - свойства слоя, второй - видимость слоя
     * @param {nsGmx.LayersTree~Node} [groupNode] Группа, внутри которой проводить поиск. Если не указана, будет проводиться поиск по всему дереву.
     */
    this.forEachLayer = function(callback, groupNode)
    {
        this.forEachNode(function(node, isVisible, nodeDepth) {
            if (node.type === 'layer') {
                callback(node.content, isVisible, nodeDepth);
            }
        }, groupNode)
    }
    
    /** Итерирование по всем под-узлам узла дерева
     * @param {nsGmx.LayersTree~NodeVisitor} callback Будет вызвана для каждого узла внутри группы. Первый аргумент - узел, второй - видимость узла
     * @param {nsGmx.LayersTree~Node} [groupNode] Группа, внутри которой проводить поиск. Если не указана, будет проводиться поиск по всему дереву.
     */
    this.forEachNode = function(callback, groupNode)
    {
        var forEachNodeRec = function(o, isVisible, nodeDepth)
        {
            isVisible = isVisible && !!o.content.properties.visible;
            
            callback(o, isVisible, nodeDepth);
            
            if (o.type === 'group') {
                var a = o.content.children;
                for (var k = a.length - 1; k >= 0; k--)
                    forEachNodeRec(a[k], isVisible, nodeDepth + 1);
            }
        }
        
        var layers = groupNode ? groupNode.content : _tree;
        
        for (var k = layers.children.length - 1; k >= 0; k--) {
            forEachNodeRec(layers.children[k], true, 0);
        }
    }
    
    /** Клонирование дерева с возможностью его модификации
     * @param {function(node):nsGmx.LayersTree~Node|null} filterFunc - ф-ция, которая может модифицировать узлы дерева. 
                Вызывается при клонировании очередного узла. Изменения данных можно делать in-place.
                Для групп вызывается после обработки всех потомков. Если возвращает null, то узел удаляется
     */
    this.cloneRawTree = function(filterFunc) {
        filterFunc = filterFunc || function(node) {return node;};
        var res = {};
        var forEachLayerRec = function(o)
        {
            if (o.type == "layer") {
                return filterFunc($.extend(true, {}, o));
            }
            else if (o.type == "group") {
                var a = o.content.children;
                var newChildren = [];
                for (var k = 0; k < a.length; k++) {
                    var newNode = forEachLayerRec(a[k]);
                    newNode && newChildren.push(newNode);
                }
                return filterFunc({
                    type: 'group', 
                    content: {
                        children: newChildren,
                        properties: $.extend(true, {}, o.content.properties)
                    }
                })
            }
        }
        
        var newFirstLevelGroups = [];
        for (var k = 0; k < _tree.children.length; k++) {
            var newNode = forEachLayerRec(_tree.children[k]);
            newNode && newFirstLevelGroups.push(newNode);
        }
        
        return {
            properties: $.extend(true, {}, _tree.properties),
            children: newFirstLevelGroups
        }
    }
    
    //Методы управления видимостью слоёв в дереве
    
    //проходится по всему поддереву elem и устанавливает видимость isVisible всем узлам включая elem (учитывая ограничения на radio buttons)
    var setSubtreeVisibility = function(elem, isVisible) {
        var props = elem.content.properties;
        if (props.visible != isVisible) {
            props.visible = isVisible;
            $(_this).triggerHandler('nodeVisibilityChange', [elem]);
            $(elem).triggerHandler('nodeVisibilityChange', [elem]);
            
            if (elem.content.children) {
                for (var c = 0; c < elem.content.children.length; c++) {
                    var vis = isVisible && (!props.list || c == 0); //когда делаем видимой группу-список, виден только первый элемент группы
                    setSubtreeVisibility(elem.content.children[c], vis);
                }
            }
        }
    }    
    
    /** Устанавливает видимость узла дерева и всех родительских элементов данного узла в зависимости от видимости его прямых потомков. Узел должен быть группой.
     * При этом разруливаются конфликты с несколькими видимыми узлами в radio-группах.
     * @param {nsGmx.LayersTree~Node} node Узел дерева, видимость которого нужно обновить
     * @param {nsGmx.LayersTree~Node} triggerSubnode один их прямых потомков node, состояние которого должно остаться неизменным (важно для разруливания конфликтов в radio-групп)
     * @param {nsGmx.LayersTree~Node[]} [parents] массив всех родителей, опционально
     */
    this.updateNodeVisibility = function(elem, triggerSubnode, parents) {
        var props = elem.content.properties,
            isList = props.list,
            children = elem.content.children,
            triggerNodeVisible = triggerSubnode ? triggerSubnode.content.properties.visible : false,
            visibleNode = triggerNodeVisible ? triggerSubnode : null;
        
        var isVisible = false;
        for (var c = 0; c < children.length; c++) {
            var child = children[c];
            var childVisible = child.content.properties.visible;
            isVisible = isVisible || childVisible;
            
            if (childVisible && !visibleNode) {
                visibleNode = child;
            }
            
            if (isList && childVisible && child !== visibleNode) {
                setSubtreeVisibility(child, false);
            }
        }
        
        if (isVisible !== props.visible) {
            props.visible = isVisible;
            
            $(this).triggerHandler('nodeVisibilityChange', [elem]);
            $(elem).triggerHandler('nodeVisibilityChange', [elem]);
            
            if (!parents) {
                parents = this.findElemByGmxProperties(elem).parents;
                parents.pop(); //последний элемент - карта; нас не интересует
            }
            var parent = parents.shift();
            parent && this.updateNodeVisibility(parent, elem, parents);
        }
    }
    
    /** Задать видимость узла дерева. Будут сделаны все нужные изменения видимости как выше, 
     * так и ниже по дереву относительно этого узла.
     * @param {nsGmx.LayersTree~Node} node Узел дерева, которому мы хотим задать видимость
     * @param {Boolean} isVisible Видимость узла (true - виден)
     */
    this.setNodeVisibility = function(node, isVisible) {
        if (node.content.properties.visible != isVisible) {
            //устанавливаем видимость поддерева, которое начинается с этого элемента
            setSubtreeVisibility(node, isVisible);
            
            //идём вверх по дереву до корня и меняем видимость родителей
            var parentElem = _this.findElemByGmxProperties(node).parents[0];
            parentElem && parentElem.content && this.updateNodeVisibility(parentElem, node);
        }
    }
}
var nsGmx = nsGmx || {};

/** Вспомогательные ф-ции ГеоМиксера
@namespace _mapHelper
*/
nsGmx.mapHelper = {

}


var mapHelp =
{
	mapHelp: {},
	serviceHelp: {},
	tabs: {},
	externalMaps : {}
}

!(function(_) {

var mapHelper = function()
{
	this.builded = false;
    //this._treeView = false;

	this.defaultStyles =
	{
		'point':{outline:{color:0x0000FF, thickness:1},marker:{size:8}, fill:{color:0xFFFFFF, opacity:20}},
		'linestring':{outline:{color:0x0000FF, thickness:1}},
		'polygon':{outline:{color:0x0000FF, thickness:1}, fill:{color:0xFFFFFF, opacity:20}}
	}

	this.defaultPhotoIconStyles = {
		'point': {
			marker: {
				image: 'img/camera18.png',
				center: true
			}
		}
	}

	this.stylesDialogsHash = {};
	this.drawingDialogsHash = {};

	this.layerEditorsHash = {};

	this.layerStylesHash = {};

	this.attrValues = {};

	this.customErrorsHash = {
		"Unable to locate EXIF content" : "Unable to locate EXIF content"
	}

	// контролирует пользовательские объекты, которые являются редактируемыми контурами растровых слоёв.
	// все такие объекты не будут сериализоваться
	this.drawingBorders = (function()
	{
		var _borders = {};

		//не будем сериализовать все пользовательские объекты, являющиеся контурами слоёв, так как это временные объекты
		nsGmx.DrawingObjectCustomControllers.addDelegate({
			isSerializable: function(obj)
			{
				for (var name in _borders)
					if (_borders[name] === obj)
						return false;

				return true;
			}
		});

		return {
			set: function(name, obj)
			{
                if (name in _borders) {
                    _borders[name].drawingFeature.off('edit', _borders[name].editListener);
                }
                var editListener = function() {
                    _borders[name].isChanged = true;
                }

                obj.on('edit', editListener);

				_borders[name] = {
                    isChanged: !!_borders[name],
                    drawingFeature: obj,
                    editListener: editListener
                }
			},
			get: function(name)
			{
				return _borders[name] && _borders[name].drawingFeature;
			},
			length: function()
			{
				return objLength(_borders);
			},

			//callback(name, obj)
			forEach: function(callback)
			{
				for (var name in _borders)
					callback(name, _borders[name].drawingFeature);
			},

            isChanged: function(name) {
                return !!_borders[name] && _borders[name].isChanged;
            },

			updateBorder: function(name, span)
			{
				if (!_borders[name])
					return;

                var geom = _borders[name].drawingFeature.toGeoJSON().geometry,
                    areaStr = L.gmxUtil.prettifyArea(L.gmxUtil.geoArea(geom, false));

				if (span)
				{
					_(span, [_t(areaStr)]);
					return;
				}

				if (!$('#drawingBorderDescr' + name).length)
					return;

				$('#drawingBorderDescr' + name).empty();

				_($('#drawingBorderDescr' + name)[0], [_t(areaStr)]);
			},

			//Удаляет объект из списка контуров слоя
			//?removeDrawring {bool, default: false} - удалять ли сам пользовательский объект
			removeRoute: function(name, removeDrawing)
			{
				if (!(name in _borders))
					return;

                _borders[name].drawingFeature.off('edit', _borders[name].editListener);

				if (removeDrawing) {
					nsGmx.leafletMap.gmxDrawing.remove(_borders[name].drawingFeature);
                }

				delete _borders[name];

				$('#drawingBorderDescr' + name).empty();
			}
		}
	})();

	this.unsavedChanges = false;

}

mapHelper.prototype = new leftMenu();

/** Менеджер кастомных параметров карты.
 * Содержит набор провайдеров доп. параметров, которые могут сохранять и загружать данные из хранилища параметров
 * Данные загружаются один раз. Возможна асинхронная загрузка данных/добавление провайдеров.
 * Порядок вызова провайдеров не определён.
 *
 * @memberOf _mapHelper
 * @name customParamsManager
 */
mapHelper.prototype.customParamsManager = (function()
{
	var _providers = [];
	var _params = []; //хранит параметры, которые не были загружены провайдерами

	var loadProviderState = function( provider )
	{
		if ( provider.name in _params && typeof provider.loadState !== 'undefined')
		{
			provider.loadState( _params[ provider.name ] );
			delete _params[ provider.name ];
		}
	}

	return {
		saveParams: function()
		{
			if ( !_providers.length ) return;
			var params = {};
			for (var p = 0; p < _providers.length; p++ )
			{
				if (typeof _providers[p].saveState !== 'undefined')
                    params[_providers[p].name] = _providers[p].saveState();
			}

			return params;
		},
		loadParams: function(params)
		{
			_params = params;
			for (var p = 0; p < _providers.length; p++ )
				loadProviderState( _providers[p] );
		},

		//интерфейс провайдера: name, saveState(), loadState(state)
		addProvider: function(provider)
		{
			_providers.push( provider );
			loadProviderState( provider );
		},

        isProvider: function(providerName) {
            return !!nsGmx._.findWhere(_providers, {name: providerName});
        },
        removeProvider: function(providerName) {
            _providers = nsGmx._.filter(_providers, function(provider) {
                return provider.name !== providerName;
            })
        }
	}
})();

mapHelper.prototype.makeStyle = function(style)
{
    style = style || {};
	var givenStyle = {};

	if (typeof style.RenderStyle != 'undefined')
		givenStyle = style.RenderStyle;
	else if (style.outline || style.marker)
		givenStyle = style;
	else
	{
		if (style.PointSize)
			givenStyle.marker = { size: parseInt(style.PointSize) };
		if (style.Icon)
		{
			var src = (style.Icon.indexOf("http://") != -1) ?
				style.Icon :
				(baseAddress + "/" + style.Icon);
			givenStyle.marker = { image: src, center: true };
		}
		if (style.BorderColor || style.BorderWidth)
			givenStyle.outline = {
				color: parseColor(style.BorderColor),
				thickness: parseInt(style.BorderWidth || "1")
			};
		if (style.FillColor)
			givenStyle.fill = {
				color: parseColor(style.FillColor),
				opacity: 100 - parseInt(style.Transparency || "0")
			};

		var label = style.label || style.Label;
		if (label)
			givenStyle.label = {
				field: label.FieldName,
				color: parseColor(label.FontColor),
				size: parseInt(label.FontSize || "12")
			};
	}

	return givenStyle;
}

mapHelper.prototype.getMapStateAsPermalink = function(callback)
{
    // сохраняем состояние карты
    var mapState = _mapHelper.getMapState();

    // туда же сохраним созданные объекты
    nsGmx.userObjectsManager.collect();
    mapState.userObjects = JSON.stringify(nsGmx.userObjectsManager.getData());

    nsGmx.Utils.TinyReference.create(mapState, true).then(callback);
}

mapHelper.prototype.reloadMap = function()
{
    if (!nsGmx.gmxMap) {
        window.location.reload();
    }

    _mapHelper.getMapStateAsPermalink(function(permalinkID)
    {
        createCookie("TempPermalink", permalinkID);
        window.location.replace(window.location.href.split("?")[0] + "?permalink=" + permalinkID + (defaultMapID == globalMapName ? "" : ("&" + globalMapName)));
    })
}

mapHelper.prototype.updateUnloadEvent = function(flag)
{
	if (typeof flag != 'undefined')
		this.unsavedChanges = flag;

	if (this.unsavedChanges)
	{
		window.onbeforeunload = function(e)
		{
			return _gtxt("В дереве слоев остались несохраненные изменения!");
		}
	}
	else
		window.onbeforeunload = null;
}

mapHelper.prototype.setBalloon = function(filter, template)
{
	filter.enableHoverBalloon(function(o)
	{
		return template.replace(/\[([a-zA-Z0-9_а-яА-Я ]+)\]/g, function()
		{
			var key = arguments[1];
			if (key == "SUMMARY")
				return o.getGeometrySummary();
			else
				return o.properties[key];
		});
	});
}

mapHelper.prototype.updateMapStyles = function(newStyles, name)
{
    var layer = nsGmx.gmxMap.layersByID[name],
        styles = newStyles.map(nsGmx.Utils.prepareGmxLayerStyle);

    layer.setStyles(styles);
}

//TODO: remove isEditableStyles
mapHelper.prototype.updateTreeStyles = function(newStyles, div, treeView, isEditableStyles)
{
    isEditableStyles = typeof isEditableStyles === 'undefined' || isEditableStyles;
	div.gmxProperties.content.properties.styles = newStyles;

	var multiStyleParent = $(div).children('[multiStyle]')[0];

	var parentIcon = $(div).children("[styleType]")[0],
		newIcon = _mapHelper.createStylesEditorIcon(newStyles, div.gmxProperties.content.properties.GeometryType.toLowerCase(), {addTitle: isEditableStyles});

	$(parentIcon).empty().append(newIcon).attr('styleType', $(newIcon).attr('styleType'));

	$(multiStyleParent).empty();

	_mapHelper.createMultiStyle(div.gmxProperties.content.properties, treeView, multiStyleParent)
}

mapHelper.prototype.restoreTinyReference = function(id, callbackSuccess, errorCallback)
{
	window.suppressDefaultPermalink = true;
    nsGmx.Utils.TinyReference.get(id).then(function(obj) {
		if (obj.position) {
            var latLngPos = L.Projection.Mercator.unproject(obj.position);
			obj.position.x = latLngPos.lng;
			obj.position.y = latLngPos.lat;
			obj.position.z = 17 - obj.position.z;
			if (obj.drawnObjects) {
				for (var i in obj.drawnObjects) {
                    //эта двойная конвертация в действительности просто перевод координат из Меркатора в LatLng
					obj.drawnObjects[i].geometry = L.gmxUtil.geoJSONtoGeometry(L.gmxUtil.geometryToGeoJSON(obj.drawnObjects[i].geometry, true));
				}
            }
		}
        obj.originalReference = id;
		callbackSuccess(obj);
    }, errorCallback);
}

mapHelper.prototype.getMapState = function() {
    var lmap = nsGmx.leafletMap;

    if (!lmap) {
        return {};
    }

    var drawnObjects = [],
		drawings = lmap.gmxDrawing.saveState(),
		features = drawings.featureCollection.features;
        openPopups = {},
        condition = {expanded:{}, visible:{}},
		LayersTreePermalinkParams = {},
		mercCenter = L.Projection.Mercator.project(lmap.getCenter());

		for (var i = 0; i < features.length; i++) {
			if (features[i].properties.exportRect) {
				features.splice(i, 1);
			}
		}

    lmap.gmxDrawing.getFeatures().forEach(function(feature) {
        if (!nsGmx.DrawingObjectCustomControllers.isSerializable(feature) || feature.options.exportRect) {
            return;
        }

        var geoJSON = feature.toGeoJSON();

        var elem = {
            properties: geoJSON.properties,
            geometry: L.gmxUtil.geoJSONtoGeometry(geoJSON, true)
        };

        if (elem.geometry.type !== "POINT") {
            var style = feature.getOptions().lineStyle;

            if (style) {
                elem.thickness = style.weight || 2;
                elem.color = style.color;
                elem.opacity = (style.opacity || 0.8) * 100;
            }
        }

        if (lmap.hasLayer(feature.getPopup())) {
            elem.isBalloonVisible = true;
        }

        drawnObjects.push(elem);
    });

    for (var l in nsGmx.gmxMap.layersByID) {
        var layer = nsGmx.gmxMap.layersByID[l];

        if (layer.getPopups) {
            var popups = layer.getPopups();
            if (popups.length) {
                openPopups[l] = popups;
            }
        }
    }

    this.findTreeElems(_layersTree.treeModel.getRawTree(), function(elem) {
        var props = elem.content.properties;
        if (elem.type == 'group') {
            var groupId = props.GroupID;

            if (!$("div[GroupID='" + groupId + "']").length && !props.changedByViewer)
                return;

            condition.visible[groupId] = props.visible;
            condition.expanded[groupId] = props.expanded;
        } else {
            if (props.changedByViewer) {
                condition.visible[props.name] = props.visible;
            }
        }
    });

	// layers tree permalink params (without server)
	this.findTreeElems(_layersTree.treeModel.getRawTree(), function(elem) {
		var props = elem.content.properties,
			id = elem.type == 'group' ? props.GroupID : props.LayerID;

		if (props.permalinkParams) {
			LayersTreePermalinkParams[id] = props.permalinkParams;
		}
	});

	var dateIntervals = {};

	for (var l in nsGmx.gmxMap.layersByID) {
		var layer = nsGmx.gmxMap.layersByID[l];
			props = layer.getGmxProperties(),
			isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.setDateInterval);

		if (isTemporalLayer && layer.getDateInterval) {
			dateIntervals[props.LayerID] = layer.getDateInterval();
		}
	}

    return {
        mode: lmap.gmxBaseLayersManager.getCurrentID(),
        mapName: globalMapName,
        position: {
            x: mercCenter.x,
            y: mercCenter.y,
            z: 17 - lmap.getZoom()
        },
        mapStyles: this.getMapStyles(),
		drawings: drawings,
		drawnObjects: drawnObjects,
        isFullScreen: window.layersShown ? "false" : "true",
        condition: condition,
		LayersTreePermalinkParams: LayersTreePermalinkParams,
        language: window.language,
		customParamsCollection: this.customParamsManager.saveParams(),
		dateIntervals: dateIntervals,
        openPopups: openPopups
    }
}

mapHelper.prototype.getMapStyles = function()
{
	var styles = {};

	this.findChilds(_layersTree.treeModel.getRawTree(), function(child)
	{
		if (child.content.properties.type == "Vector" && $("div[LayerID='" + child.content.properties.LayerID + "']").length)
			styles[child.content.properties.name] = child.content.properties.styles;
	}, true);

	return styles;
}

mapHelper.prototype.showPermalink = function()
{
	this.createPermalink(function(id){
        var url = "http://" + window.location.host + window.location.pathname + "?permalink=" + id + (defaultMapID == globalMapName ? "" : ("&" + globalMapName));
        var input = _input(null, [['dir','className','inputStyle inputFullWidth'],['attr','value', url]]);

        showDialog(_gtxt("Ссылка на текущее состояние карты"), _div([input]), 311, 80, false, false);

        input.select();
    });
}

mapHelper.prototype.createExportPermalink = function(params, callback)
{
	var mapState = $.extend(this.getMapState(), params),
		def = nsGmx.Utils.TinyReference.create(mapState, false);
    def.then(callback);
	return def;
}

mapHelper.prototype.createPermalink = function(callback)
{
	var mapState = this.getMapState(),
        def = nsGmx.Utils.TinyReference.create(mapState, false);

    def.then(callback);
    return def;
}

mapHelper.prototype.updateTinyMCE = function(container) {
    gmxCore.loadModule('TinyMCELoader', 'http://' + window.location.host + window.location.pathname.replace('index.html', '') + 'TinyMCELoader.js', function() {
        $('.balloonEditor', container).each(function() {
            var id = $(this).attr('id');
            if (!tinyMCE.get(id)) {
                tinyMCE.execCommand("mceAddControl", true, id);
            }
        })
    });
}

//event: selected(url)
mapHelper.ImageSelectionWidget = Backbone.View.extend({
    tagName: 'span',
    className: 'gmx-icon-choose',
    events: {
        'click': function() {
            var imagesDir = nsGmx.AuthManager.getUserFolder() + 'images'
                _this = this;
            sendCrossDomainJSONRequest(serverBase + 'FileBrowser/CreateFolder.ashx?WrapStyle=func&FullName=' + encodeURIComponent(imagesDir), function(response) {
                if (!parseResponse(response))
                    return;

                _fileBrowser.createBrowser(_gtxt("Изображение"), ['jpg', 'jpeg', 'png', 'gif', 'swf'], function(path) {
                    var relativePath = path.substring(imagesDir.length);
                    if (relativePath[0] == '\\') {
                        relativePath = relativePath.substring(1);
                    }

                    var url = serverBase + "GetImage.ashx?usr=" + encodeURIComponent(nsGmx.AuthManager.getLogin()) + "&img=" + encodeURIComponent(relativePath);

                    _this.trigger('selected', url);
                }, {startDir: imagesDir, restrictDir: imagesDir});
            });
        }
    }
});

mapHelper.ImageInputControl = function(initURL) {
    var prevValue = initURL || '';
    var inputUrl = _input(null, [['dir','className','inputStyle'],['attr','value', prevValue], ['css','width','170px']]);
    _title(inputUrl, _gtxt('URL изображения'));

    var _this = this;

    var update = function() {
        if (inputUrl.value != prevValue) {
            prevValue = inputUrl.value;
            $(_this).change();
        }
    }

    var mainDiv = $('<div/>').append(inputUrl);
    inputUrl.onkeyup = inputUrl.change = update;

    if (nsGmx.AuthManager.canDoAction(nsGmx.ACTION_UPLOAD_FILES)) {
        var imageSelectionWidget = new mapHelper.ImageSelectionWidget();
        imageSelectionWidget.on('selected', function(url) {
            inputUrl.value = url;
            update();
        });

        mainDiv.append(imageSelectionWidget.el);
    }

    this.getControl = function()
    {
        return mainDiv[0];
    }

    this.value = function()
    {
        return inputUrl.value;
    }
}

//params:
//  * addTitle {bool, default: true}
mapHelper.prototype.createStylesEditorIcon = function(parentStyles, type, params)
{
    var _params = $.extend({addTitle: true}, params);
	var icon;

	if ($.isArray(parentStyles) && parentStyles.length > 1)
		icon =  _img(null, [['attr','src','img/misc.png'],['css','margin','0px 2px -3px 4px'],['css','cursor','pointer'],['attr','styleType','multi']]);
	else
	{
		var parentStyle = _mapHelper.makeStyle(parentStyles[0]);

		if (parentStyle.marker && parentStyle.marker.image)
		{
			if (true /*typeof parentStyle.marker.color == 'undefined'*/)
			{
				icon = _img(null, [['dir','className','icon'],['attr','styleType','icon']]);

				var fixFunc = function()
					{
						var width = this.width,
							height = this.height,
                            scale;

                        if (width && height) {
							var scaleX = 14.0 / width;
							var scaleY = 14.0 / height
							scale = Math.min(scaleX, scaleY);
                        } else {
                            scale = 1;
                            width = height = 14;
                        }

						setTimeout(function()
						{
							icon.style.width = Math.round(width * scale) + 'px';
							icon.style.height = Math.round(height * scale) + 'px';
						}, 10);
					}

				icon.onload = fixFunc;
                icon.src = parentStyle.marker.image;
			}
			else
			{
				var dummyStyle = {};

				$.extend(dummyStyle, parentStyle);

				dummyStyle.outline = {color: parentStyle.marker.color, opacity: 100};
				dummyStyle.fill = {color: parentStyle.marker.color, opacity: 100};

				icon = nsGmx.Controls.createGeometryIcon(dummyStyle, type);
			}
		}
		else
		{
			icon = nsGmx.Controls.createGeometryIcon(parentStyle, type);
		}
	}

    if (_params.addTitle)
        _title(icon, _gtxt("Редактировать стили"));

	icon.geometryType = type;

	return icon;
}

mapHelper.prototype.createLoadingLayerEditorProperties = function(div, parent, layerProperties, params)
{
	var elemProperties = div.gmxProperties.content.properties,
		loading = _div([_img(null, [['attr','src','img/progress.gif'],['css','marginRight','10px']]), _t(_gtxt('загрузка...'))], [['css','margin','3px 0px 3px 20px']]),
        type = elemProperties.type,
		_this = this;

    if (type == "Vector")
    {
        nsGmx.createLayerEditor(div, type, parent, layerProperties, params);

        return;
    }
    else
    {
        if (elemProperties.name)
        {
            _(parent, [loading]);

            sendCrossDomainJSONRequest(serverBase + "Layer/GetLayerInfo.ashx?WrapStyle=func&LayerName=" + elemProperties.name, function(response)
            {
                if (!parseResponse(response))
                    return;

                loading.removeNode(true);

                nsGmx.createLayerEditor(div, type, parent, response.Result, params)
            })
        }
    }
}

mapHelper.prototype.createNewLayer = function(type)
{
	if ($('#new' + type + 'Layer').length)
		return;

	var parent = _div(null, [['attr','id','new' + type + 'Layer'], ['css', 'height', '100%']]),
		height = (type == 'Vector') ? 340 : 360;

    if (type !== 'Multi')
    {
		var properties = {Title:'', Description: '', Date: '', TilePath: {Path:''}, ShapePath: {Path:''}};
        var dialogDiv = showDialog(type != 'Vector' ? _gtxt('Создать растровый слой') : _gtxt('Создать векторный слой'), parent, 340, height, false, false);
        nsGmx.createLayerEditor(false, type, parent, properties,
            {
                doneCallback: function()
                {
                    removeDialog(dialogDiv);
                }
            }
        );
    }
    else
    { //мультислой
        var _this = this;
        nsGmx.createMultiLayerEditorNew( _layersTree );
    }
}

// перенос clipLayer из маплетов карты
mapHelper.prototype.clipLayer = function(layer, props)
{
	var sw = L.latLng([props.MinViewY, props.MinViewX]),
		nw = L.latLng([props.MaxViewY, props.MinViewX]),
		ne = L.latLng([props.MaxViewY, props.MaxViewX]),
		se = L.latLng([props.MinViewY, props.MaxViewX]),
		clip = L.polygon([sw, nw, ne, se, sw]);

	    layer.addClipPolygon(clip);
}

// Формирует набор элементов tr используя контролы из shownProperties.
// Параметры:
// - shownProperties: массив со следующими свойствами:
//   * tr - если есть это свойство, то оно помещается в tr, все остальные игнорируются
//   * name - названия свойства, которое будет писаться в левой колонке
//   * elem - если есть, то в правую колонку помещается этот элемент
//   * field - если нет "elem", в правый столбец подставляется layerProperties[field]
//   * trid - id для DOM элементов. Не применяется, если прямо указано tr
//   * trclass - class для DOM элементов. Не применяется, если прямо указано tr
// - layerProperties - просто хеш строк для подстановки в правую колонку
// - style:
//   * leftWidth - ширина левой колонки в пикселях
//   * leftcolumnclass - class для td элементов первого столбца. Не применяется, если прямо указано tr
//   * rightcolumnclass - class для td элементов второго столбца. Не применяется, если прямо указано tr
mapHelper.prototype.createPropertiesTable = function(shownProperties, layerProperties, style)
{
	var _styles = $.extend({leftWidth: 100}, style);
	var trs = [];
	for (var i = 0; i < shownProperties.length; i++)
	{
		var td;
		if (typeof shownProperties[i].tr !== 'undefined')
		{
			trs.push(shownProperties[i].tr);
			continue;
		}

		if (typeof shownProperties[i].elem !== 'undefined')
			td = _td([shownProperties[i].elem]);
		else
			td = _td([_t(layerProperties[shownProperties[i].field] != null ? layerProperties[shownProperties[i].field] : '')],[['css','padding','0px 3px']]);

        var tdTitle = _td([_t(shownProperties[i].name)],[['css','width', _styles.leftWidth + 'px']]);

		var tr = _tr([tdTitle, td]);

        _(tdTitle, [], [['dir', 'className', 'propertiesTable-title ' + (_styles.leftcolumnclass || '')]]);

        if (_styles.rightcolumnclass)
            _(td, [], [['dir', 'className', _styles.rightcolumnclass]]);

        if (shownProperties[i].trid)
            _(tr, [], [['attr', 'id', shownProperties[i].trid]]);

        if (shownProperties[i].trclass)
            _(tr, [], [['dir', 'className', shownProperties[i].trclass]]);

		trs.push(tr);
	}

	return trs;
}

mapHelper.prototype.createLayerEditor = function(div, treeView, selected, openedStyleIndex)
{
	var elemProperties = div.gmxProperties.content.properties,
        layerName = elemProperties.name,
		_this = this;

	if (elemProperties.type == "Vector")
	{
		if (typeof this.layerEditorsHash[layerName] != 'undefined')
		{
			if (this.layerEditorsHash[layerName] != false) {
                this.layerEditorsHash[layerName].selectTab(selected);
            }

			return;
		}

		this.layerEditorsHash[layerName] = false;

		var mapName = elemProperties.mapName,
			createTabs = function(layerProperties)
			{
				var id = 'layertabs' + layerName,
					divProperties = _div(null,[['attr','id','properties' + id], ['css', 'height', '100%']]),
					tabMenu,
                    additionalTabs = [];

				var pos = nsGmx.Utils.getDialogPos(div, true, 390),
                    updateFunc = function()
                    {
                    },
					closeFunc = function()
					{
                        updateFunc();
						return false;
					};

				_this.createLoadingLayerEditorProperties(div, divProperties, layerProperties, {
                    doneCallback: function()
                    {
                        $(divDialog).dialog('close');
                    },
                    additionalTabs: additionalTabs,
                    selected: selected,
                    createdCallback: function(layerEditor) {
                        _this.layerEditorsHash[layerName] = layerEditor;
                        _this.layerEditorsHash[layerName].closeFunc = closeFunc;
                        _this.layerEditorsHash[layerName].updateFunc = updateFunc;
                    }
                });

				var divDialog = showDialog(_gtxt('Слой [value0]', elemProperties.title), divProperties, 350, 470, pos.left, pos.top, null, function()
                {
                    closeFunc();
                    delete _this.layerEditorsHash[layerName];
                });

				// при сохранении карты сбросим все временные стили в json карты
				divProperties.closeFunc = closeFunc;
				divProperties.updateFunc = updateFunc;
			};

		if (!this.attrValues[mapName])
			this.attrValues[mapName] = {};

		sendCrossDomainJSONRequest(serverBase + "Layer/GetLayerInfo.ashx?WrapStyle=func&NeedAttrValues=false&LayerName=" + layerName, function(response)
		{
			if (!parseResponse(response))
				return;

            var columns = response.Result.Columns;
            var attributesHash = {};

            for (var i = 0; i < columns.length; i++) {
                attributesHash[columns[i].Name] = [];
            }

			_this.attrValues[mapName][layerName] = new nsGmx.LazyAttributeValuesProviderFromServer(attributesHash, layerName);

			createTabs(response.Result);
		})
	}
	else if (elemProperties.type == "Raster")
	{
		if (elemProperties.LayerID)
		{
			if (this.layerEditorsHash[layerName])
				return;

			this.layerEditorsHash[layerName] = true;

			var id = 'layertabs' + layerName,
				divProperties = _div(null,[['attr','id','properties' + id], ['css', 'height', '100%']]),
				divStyles = _div(null,[['attr','id','styles' + id], ['css', 'height', '100%'], ['css', 'overflowY', 'auto']]);

			var layer = nsGmx.gmxMap.layersByID[layerName],
				parentStyle = elemProperties.styles && elemProperties.styles[0] || elemProperties;

            var zoomPropertiesControl = new nsGmx.ZoomPropertiesControl(parentStyle.MinZoom, parentStyle.MaxZoom),
                liMinZoom = zoomPropertiesControl.getMinLi(),
                liMaxZoom = zoomPropertiesControl.getMaxLi();

            $(zoomPropertiesControl).change(function()
            {
                layer.setZoomBounds(this.getMinZoom(), this.getMaxZoom());
            });

			_(divStyles, [_ul([liMinZoom, liMaxZoom])]);

			this.createLoadingLayerEditorProperties(div, divProperties, null, {
                doneCallback: function()
                {
                    $(divDialog).dialog('close');
                },
                additionalTabs: [{title: _gtxt("Стили"), name: 'styles', container: divStyles}]

            });

			var pos = nsGmx.Utils.getDialogPos(div, true, 330),
				closeFunc = function()
				{
                    elemProperties.styles = elemProperties.styles || [];
                    elemProperties.styles[0] = elemProperties.styles[0] || {};

					elemProperties.styles[0].MinZoom = zoomPropertiesControl.getMinZoom();
					elemProperties.styles[0].MaxZoom = zoomPropertiesControl.getMaxZoom();

					delete _this.layerEditorsHash[layerName];

					treeView.findTreeElem(div).elem.content.properties = elemProperties;

					_this.drawingBorders.removeRoute(layerName, true);

					if ($('#drawingBorderDialog' + layerName).length)
						removeDialog($('#drawingBorderDialog' + layerName)[0].parentNode);

					return false;
				};

			var divDialog = showDialog(_gtxt('Слой [value0]', elemProperties.title), divProperties, 330, 410, pos.left, pos.top, null, closeFunc);
		}
		else
		{
            nsGmx.createMultiLayerEditorServer(elemProperties, div, treeView);
        }
	} else if (elemProperties.type == "Virtual"){
        var divProperties = _div(null,[['attr','id','properties' + id], ['css', 'height', '100%']]);

        this.createLoadingLayerEditorProperties(div, divProperties, null, {
            doneCallback: function() {
                $(divDialog).dialog('close');
            }
        });

        var closeFunc = function() {
            delete _this.layerEditorsHash[layerName];
        };

        var pos = nsGmx.Utils.getDialogPos(div, true, 330);

        var divDialog = showDialog(_gtxt('Слой [value0]', elemProperties.title), divProperties, 330, 410, pos.left, pos.top, null);
    }
}

mapHelper.prototype.createWFSStylesEditor = function(parentObject, style, geometryType, divCanvas)
{
	var _this = this,
		templateStyle = {};

	$.extend(true, templateStyle, style);

    var elemCanvas = _mapHelper.createStylesEditorIcon([{MinZoom:1, MaxZoom: 21, RenderStyle: style.regularStyle}], geometryType);
    var spanIcon = _span([elemCanvas]);

	spanIcon.onclick = function()
	{
        var listenerId = parentObject.addListener('onSetStyle', function(style)
            {
                var newIcon = _this.createStylesEditorIcon([{MinZoom:1,MaxZoom:21,RenderStyle:style.regularStyle}], geometryType);
                $(spanIcon).empty().append(newIcon).attr('styleType', $(newIcon).attr('styleType'));
            });

		var canvasStyles = _div(null,[['css','marginTop','10px']]),
			canvasCharts = _div(null,[['css','marginTop','10px']]),
			closeFunc = function()
			{
				$(canvasStyles).find(".colorSelector").each(function()
				{
					$('#' + $(this).data("colorpickerId")).remove();
				});

				var layerElemCanvas = $(divCanvas).find("[geometryType='" + geometryType.toUpperCase() + "']")[0];
				layerElemCanvas.graphDataType = $(canvasCharts).find("select")[0].value;
				layerElemCanvas.graphDataProperties = $(canvasCharts).find("input")[0].value;

                parentObject.removeMapStateListener('onSetStyle', listenerId);
			};

		var id = 'wfstabs' + String(Math.random()).substring(2, 9),
			tabMenu = _div([_ul([_li([_a([_t(_gtxt("Стили"))],[['attr','href','#styles' + id]])]),
								 _li([_a([_t(_gtxt("Диаграммы"))],[['attr','href','#graph' + id]])])])]),
			divStyles = _div(null,[['attr','id','styles' + id]]),
			divGraph = _div(null,[['attr','id','graph' + id]]);

		_(tabMenu, [divStyles, divGraph]);

        gmxCore.loadModule('LayerStylesEditor').done(function(module) {
            var resObject = module.createStyleEditor(canvasStyles, templateStyle, geometryType, false);

            $(resObject).change(function()
            {
                nsGmx.Utils.setMapObjectStyle(parentObject, templateStyle);
            })
        });

		canvasStyles.firstChild.style.marginLeft = '0px';
		_(divStyles, [canvasStyles]);

		_mapHelper.createChartsEditor(canvasCharts, $(divCanvas).find("[geometryType='" + geometryType.toUpperCase() + "']")[0]);
		canvasCharts.firstChild.style.marginLeft = '0px';
		_(divGraph, [canvasCharts]);

		var pos = nsGmx.Utils.getDialogPos(spanIcon, false, 160);
		showDialog(_gtxt('Редактирование стилей объекта'), tabMenu, 330, 180, pos.left, pos.top, false, closeFunc);

		$(tabMenu).tabs({active: 0});
	}

	spanIcon.getStyle = function()
	{
		return templateStyle;
	}

    return spanIcon;
}

mapHelper.prototype.createChartsEditor = function(parent, elemCanvas)
{
	var graphTypeSel = nsGmx.Utils._select([_option([_t(_gtxt("График по времени"))], [['attr','value','func']]),
								_option([_t(_gtxt("Круговая"))], [['attr','value','pie']])], [['dir','className','selectStyle'],['css','width','180px']]),
		propertiesMask = _input(null, [['dir','className','inputStyle'],['css','width','180px']]);

	switchSelect(graphTypeSel, elemCanvas.graphDataType);
	propertiesMask.value = elemCanvas.graphDataProperties;

	_(parent, [_table([_tbody([_tr([_td([_t(_gtxt("Тип"))], [['css','width','100px']]), _td([graphTypeSel])]),
								_tr([_td([_t(_gtxt("Маска атрибутов"))]), _td([propertiesMask])])])])]);
}

mapHelper.prototype.createMultiStyle = function(elem, treeView, multiStyleParent, treeviewFlag, layerManagerFlag)
{
	var filters = elem.styles;

	if (filters.length < 2)
	{
		multiStyleParent.style.display = 'none';

		return;
	}

	multiStyleParent.style.display = '';

	var ulFilters = _ul();

	for (var i = 0; i < filters.length; i++)
	{
		var icon = this.createStylesEditorIcon([elem.styles[i]], elem.GeometryType.toLowerCase(), {addTitle: !layerManagerFlag}),
			name = elem.styles[i].Name || elem.styles[i].Filter || 'Без имени ' + (i + 1),
            iconSpan = _span([icon]),
			li = _li([_div([iconSpan, _span([_t(name)],[['css','marginLeft','3px']])])]);

        $(iconSpan).attr('styleType', $(icon).attr('styleType'));

		if (!layerManagerFlag)
		{
			(function(i)
			{
				iconSpan.onclick = function()
				{
                    nsGmx.createStylesDialog(elem, treeView, i);
					//_mapHelper.createLayerEditor(multiStyleParent.parentNode, treeView, 'styles', i);
				}
			})(i);
		}

		_(ulFilters, [li])
	}

	ulFilters.style.display = 'none';
	ulFilters.className = 'hiddenTree';

	_(multiStyleParent, [_ul([_li([_div([_t(_gtxt("Стили слоя"))]), ulFilters])])]);

	if (typeof treeviewFlag == 'undefined')
        $(multiStyleParent.firstChild).treeview();
}

mapHelper.prototype.load = function()
{
	var _this = this;

	if (!this.builded)
	{
		var fileName;

		if (typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.usageFilePrefix !== 'undefined')
			fileName = window.gmxViewerUI.usageFilePrefix;
		else
			fileName = window.gmxJSHost ? window.gmxJSHost + "usageHelp" : "usageHelp";

		fileName += _gtxt("helpPostfix");

		_mapHelper._loadHelpTextFromFile(fileName, function( text )
		{
			var div = _div(null, [['dir','className','help']]);
			div.innerHTML = text;
			_(_this.workCanvas, [div]);
		});

		this.builded = true;
	}
}

mapHelper.prototype._loadHelpTextFromFile = function( fileName, callback, num, data )
{
	var proceess = function( text ) {
		callback(Handlebars.compile(text)({gmxVersion: num, gmxData: data}));
	}

	if (fileName.indexOf("http://") !== 0)
		$.ajax({url: fileName, success: proceess});
	else
		sendCrossDomainJSONRequest(serverBase + "ApiSave.ashx?get=" + encodeURIComponent(fileName), function(response)
		{
			proceess(response.Result);
		});
}

mapHelper.prototype.version = function()
{
    var div = $("<div class='gmx-about'></div>");

    var fileName;

    if (typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.helpFilePrefix !== 'undefined')
        fileName = window.gmxViewerUI.helpFilePrefix;
    else
        fileName = window.gmxJSHost ? window.gmxJSHost + "help" : "help";

    fileName += _gtxt("helpPostfix");

    _mapHelper._loadHelpTextFromFile( fileName, function(text)
    {
        div.html(text);
        showDialog(_gtxt("О проекте"), div[0], 500, 300, false, false);
    }, window.nsGmx.GeomixerFrameworkVersion, '' );
}

mapHelper.prototype.print = function() {
	var centerControl = nsGmx.leafletMap.gmxControlsManager.get('center'),
		map = nsGmx.leafletMap,
    	toggleMode = function(isPreviewMode) {
        	map.gmxControlsManager.get('hide').setActive(!isPreviewMode);
        	window.printMode = isPreviewMode;
        	$('#header, #leftMenu, #leftCollapser, #bottomContent, #tooltip, .ui-datepicker-div').toggleClass('print-preview-hide', isPreviewMode);
        	$('#all').toggleClass('print-preview-all', isPreviewMode);
			$('.ui-dialog').toggle();
			$('.leaflet-gmx-iconSvg-hide').toggle();
			$('.leaflet-control-container').toggle();
    	};

    toggleMode(true);
	centerControl.removeFrom(map);

    var ui = $(Handlebars.compile('<div class="print-ui"><span class="print-ui-inner">' +
        '<button class="print-ui-close">Закрыть</button>' +
        '<button class="print-ui-print">Печать</button>' +
			'<span class="layoutContainer">' +
				'<label><input type="radio" name="layout" value="portrait" checked="true">' + _gtxt('портретная') + '</label>' +
				'<label><input type="radio" name="layout" value="layout">' + _gtxt('альбомная') + '</label>' +
			'</span>' +
		'</span>' +
		'</div>')());

	var BIG = 1150,
		SMALL = BIG / 1.4142
	var layout = {
		width: SMALL + 'px',
		height: BIG + 'px'
	};

	ui.find('input[value="portrait"]').click(function() {
		this.checked = true;
		layout.width = SMALL + 'px';
		layout.height = BIG + 'px';

		$('#flash').css({
			width: layout.width,
			height: layout.height
		});

	    map.invalidateSize();
	});

	ui.find('input[value="layout"]').click(function() {
		this.checked = true;
		layout.width = BIG + 'px';
		layout.height = SMALL + 'px';

		$('#flash').css({
			width: layout.width,
			height: layout.height
		});

	    map.invalidateSize();
	});

	ui.find('.print-ui-print').click(function() {
		window.print();
	})

    ui.find('.print-ui-close').click(function() {
        toggleMode(false);
		centerControl.addTo(map);

        $('#flash').css({
            marginLeft: '0px',
            marginTop: '0px'
        });

        window.resizeAll();
        ui.remove();
    });

    $('body').append(ui);

    $('#flash').css({
		top: '0px',
		left: '0px',
		width: layout.width,
		height: layout.height
	});

    map.invalidateSize();
}

// экспортный режим редактора
mapHelper.prototype.exportMap = function(params) {
	var map = nsGmx.leafletMap,
		hide = map.gmxControlsManager.get('hide'),
		center = map.gmxControlsManager.get('center');

	hide.setActive(false);

	center.removeFrom ? center.removeFrom(map) : center.remove();

    window.exportMode = true;

	if (params.grid) {
		var grid = nsGmx.gridManager.gridControl;

		grid.setFixBounds(L.latLngBounds(params.exportBounds._southWest, params.exportBounds._northEast));

	} else {
		nsGmx.gridManager.setState(false);
	}

    $('#header, #leftMenu, #leftCollapser, #bottomContent, #tooltip, .ui-datepicker-div').toggleClass('print-preview-hide', true);

    $('#all').toggleClass('print-preview-all', true);

	$('.leaflet-control-container').hide();

    $('#leftContent').mCustomScrollbar({live:"off"});

	var exportCssParams = {
		top: '0px',
		left: '0px',
		width: '100%',
		height: '100%'
	};

	$('#flash').css(exportCssParams);
	map.invalidateSize();
}

//вызывает callback для всех слоёв поддерева treeElem. Параметры: callback(layerInfo, visibilityFlag)
mapHelper.prototype.findChilds = function(treeElem, callback, flag)
{
	var childsArr = treeElem.content ? treeElem.content.children : treeElem.children;
	if (childsArr)
	{
		for (var i = 0; i < childsArr.length; i++)
		{
			var child = childsArr[i];

			if (child.type == 'group')
				this.findChilds(child, callback, flag && child.content.properties.visible)
			else
				callback(child, flag && child.content.properties.visible);
		}
	}
}

mapHelper.prototype.findTreeElems = function(treeElem, callback, flag, list)
{
	var childsArr = treeElem.content ? treeElem.content.children : treeElem.children;

	for (var i = 0; i < childsArr.length; i++)
	{
		var child = childsArr[i];

		if (child.type == 'group')
		{
			callback(child, flag, treeElem.content ? treeElem.content.properties.list : treeElem.properties.list, i);

			this.findTreeElems(child, callback, flag && child.content.properties.visible, treeElem.content ? treeElem.content.properties.list : treeElem.properties.list)
		}
		else
			callback(child, flag, treeElem.content ? treeElem.content.properties.list : treeElem.properties.list, i);
	}
}

/**
 *  Модифицирует объекты внутри векторного слоя, отправляя изменения на сервер и информируя об этом API
 *
 * @memberOf _mapHelper
 * @name modifyObjectLayer
 * @function
 * @param {String} layerName Имя слоя
 * @param {Object[]} objs Массив описания объектов. Каждое описание представляет из себя объект:
 *
 *  * id {String} ID объекта слоя, над которым производятся изменения (только для модификации и удаления)
 *  * geometry Описание геометрии (вставка и изменение). GeoJSON
 *  * source: {rc: <name КР-источника>, rcobj: <id объекта внутри КР>}
 *  * properties Свойства объекта (вставка и изменение)
 *  * action {'delete'|'insert'|'update'} Производимое действие. Если не указано, то вычисляется следующим образом:
 *    * Если не указан id, то вставка
 *    * Если указан id, то модифицируем
 *    * Для удаления объекта нужно явно прописать параметр
 * @param {String} [crs='EPSG:3395'] Название системы координат геометрии объектов. Поддерживаются 3395, 4326, 3857
 * @return {jQuery.Deferred} Ресолвится в соответствии с ответом сервера
*/
mapHelper.prototype.modifyObjectLayer = function(layerName, objs, crs)
{
    var def = $.Deferred();

    $.each(objs, function(i, obj)
    {
        obj.action = obj.action || (obj.id ? 'update' : 'insert');
    });
    var params = {
        WrapStyle: 'window',
        LayerName: layerName,
        objects: JSON.stringify(objs)
    };
    if (crs) {
        params.geometry_cs = crs;
    }
    sendCrossDomainPostRequest(serverBase + "VectorLayer/ModifyVectorObjects.ashx",
        params
        ,
        function(addResponse)
        {
			if (!parseResponse(addResponse))
            {
                def.reject();
                return;
            }

            var mapLayer = nsGmx.gmxMap.layersByID[layerName];
            if (mapLayer) {
                L.gmx.layersVersion.chkVersion(mapLayer);
            }
			def.resolve();
        }
    )

    return def.promise();
}

/** Запросить с сервера объекты векторного слоя
 * @memberOf _mapHelper
 * @name searchObjectLayer
 * @function
 * @param {String} layerName ID векторного слоя
 * @param {Object} options Параметры запроса
 * @param {String} [options.query] SQL-подобное выражение для выборки объектов
 * @param {Boolean} [options.includeGeometry=false] Возвращать ли геометрию с сервера или нет
 * @param {Object} [options.border=null] GeoJSON для ограничения выборки по геометрии
 * @param {Number} [options.page=0] номер страницы результатов (0 - результаты с самого первого)
 * @param {Number} [options.pagesize=100000] максимальное кол-во объектов в ответе
 * @return {jQuery.Deferred} Promise, который ресолвится массивом найденных объектов. Каждый объект имеет свойства properties и, возможно, geometry
*/
mapHelper.prototype.searchObjectLayer = function(layerName, options) {
    options = options || {};

    var def = $.Deferred();

    var requestParams = {
        WrapStyle: 'message',
        layer: layerName
    }

    if (options.query) {
        requestParams.query = options.query;
    }

    if (options.includeGeometry) {
        requestParams.geometry = true;
    }

    if (options.border) {
        requestParams.border = JSON.stringify(options.border);
    }

    requestParams.page = options.page || 0;
    requestParams.pagesize = options.pagesize || 100000;

    sendCrossDomainPostRequest(serverBase + "VectorLayer/Search.ashx", requestParams, function(response) {
        if (!parseResponse(response)) {
            def.reject(response);
            return;
        }
        var values = response.Result.values;
        var fields = response.Result.fields;
        var objects = [];
        for (var i = 0; i < values.length; i++) {
            var obj = {properties: {}};

            for (var p = 0; p < values[i].length; p++) {
                if (fields[p] === 'geomixergeojson') {
                    obj.geometry = values[i][p];
                } else {
                    obj.properties[fields[p]] = values[i][p];
                }
            }
            objects.push(obj);
        }

        def.resolve(objects);
    });

    return def.promise();
}

/** Скачать векторный слой с сервера
 * @memberOf _mapHelper
 * @name downloadVectorLayer
 * @function
 * @param {Object} params Параметры запроса
 * @param {String} params.name ID векторного слоя, который нужно скачать
 * @param {String} params.host хост, с которого будем скачивать слой
 * @param {String} [params.format=Shape] В каком формате хотим получить (Shape, Tab, gpx, csv, csv_wkt, excel, kml или несколько через запятую)
 * @param {String} [params.query] SQL запрос для сохранения выборки данных вместо всех данных слоя
 * @param {Array} [params.columns] Атрибуты, которые нужно скачать. Массив объектов с ключами {Value, Alias}
*/
mapHelper.prototype.downloadVectorLayer = function(params) {
    var requestParams = {
        t: params.name
    };

    if (params.format) {
        requestParams.format = params.format;
    }

    if (params.query) {
        requestParams.query = params.query;
    }

    if (params.columns) {
        requestParams.columns = JSON.stringify(params.columns);
    }

    sendCrossDomainPostRequest("http://" + params.host + "/" + "DownloadLayer.ashx", requestParams);


	// if (window.FormData) {
	//
	// 	var form = document.createElement("form");
	// 	form.style.display = 'none';
	// 	form.setAttribute('enctype', 'multipart/form-data');
	// 	form.name = 'uploadFile';
	//
	// 	var hiddenParamsDiv = document.createElement("div");
	// 	hiddenParamsDiv.style.display = 'none';
	//
	// 	for (var paramName in requestParams) {
	// 		var input = document.createElement("input");
	// 		var value = typeof requestParams[paramName] !== 'undefined' ? requestParams[paramName] : '';
	//
	// 		input.setAttribute('type', 'hidden');
	// 		input.setAttribute('name', paramName);
	// 		input.setAttribute('value', value);
	//
	// 		hiddenParamsDiv.appendChild(input)
	// 	}
	//
	//     form.appendChild(hiddenParamsDiv);
	//
	// 	var formData = new FormData(form);
	//
	//
	// 	var xhr = new XMLHttpRequest();
	// 	// :attachment; filename="suda_15062017_Sentinel_poly.zip";
	// 	xhr.open('POST', /*"http://" + /*params.host*/ window.serverBase + /*"/" + */"DownloadLayer.ashx");
	//
	// 	// xhr.setRequestHeader('Content-Disposition', 'attachment');
	// 	xhr.onload = function () {
	// 		if (xhr.status === 200) {
	// 			// var blob = new Blob([xhr.response], {type: "application/zip"});
	// 			var blob = xhr.response;
	// 			console.log(xhr);
	// 			console.log(blob);
	// 			saveData(blob, params.name);
	// 		}
	// 	}
	//
	// 	xhr.withCredentials = true;
	// 	xhr.responseType = "blob";
	// 	xhr.send(formData);
	//
	// 	function saveData(blob, name) {
	// 		var url = window.URL.createObjectURL(blob),
	// 		a = document.createElement("a");
	// 		console.log(url);
	// 		document.body.appendChild(a);
	// 		a.style = "display: none";
	// 		a.href = url;
	// 		a.download = name;
	// 		// a.click();
	// 		window.URL.revokeObjectURL(url);
	// 	};
	// }
}

var _mapHelper = new mapHelper();
window._mapHelper = _mapHelper;
window.mapHelper = mapHelper;

mapHelp.mapHelp.load = function()
{
	var alreadyLoaded = _mapHelper.createWorkCanvas(arguments[0]);

	if (!alreadyLoaded)
		_mapHelper.load()
}

mapHelp.mapHelp.unload = function()
{
}

mapHelp.serviceHelp.load = function()
{
	var alreadyLoaded = _serviceHelper.createWorkCanvas(arguments[0]);

	if (!alreadyLoaded)
		_serviceHelper.load()
}
mapHelp.serviceHelp.unload = function()
{
}

var serviceHelper = function()
{
	this.builded = false;
}

serviceHelper.prototype = new leftMenu();

serviceHelper.prototype.load = function()
{
	var _this = this;
	if (!this.builded)
	{
		var fileName;

		if (typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.servicesFilePrefix !== 'undefined')
			fileName = window.gmxViewerUI.servicesFilePrefix;
		else
			fileName = window.gmxJSHost ? window.gmxJSHost + "servicesHelp" : "servicesHelp";

		fileName += _gtxt("helpPostfix");

		_mapHelper._loadHelpTextFromFile(fileName, function( text )
		{
			var div = _div(null, [['dir','className','help']]);
			div.innerHTML = text;
			_(_this.workCanvas, [div]);
		});

		this.builded = true;
	}
}

var _serviceHelper = new serviceHelper();
window._serviceHelper = _serviceHelper;

mapHelp.tabs.load = function()
{
	var alreadyLoaded = _queryTabs.createWorkCanvas(arguments[0]);

	if (!alreadyLoaded)
		_queryTabs.load()
}
mapHelp.tabs.unload = function()
{
}

mapHelp.externalMaps.load = function()
{
	var alreadyLoaded = _queryExternalMaps.createWorkCanvas(arguments[0]);

	if (!alreadyLoaded)
		_queryExternalMaps.load()
}
mapHelp.externalMaps.unload = function()
{
}

//Динамически подгружаемые части вьюера

//Редактирование мультислоя
nsGmx.createMultiLayerEditorServer = gmxCore.createDeferredFunction('MultiLayerEditor', 'createMultiLayerEditorServer');
nsGmx.createMultiLayerEditorNew = gmxCore.createDeferredFunction('MultiLayerEditor', 'createMultiLayerEditorNew');

//Редактирование карты и группы
nsGmx.addSubGroup = gmxCore.createDeferredFunction('GroupEditor', 'addSubGroup');
nsGmx.createGroupEditor = gmxCore.createDeferredFunction('GroupEditor', 'createGroupEditor');
nsGmx.createMapEditor = gmxCore.createDeferredFunction('GroupEditor', 'createMapEditor');

//Редактирование свойств слоя
nsGmx.createLayerEditor = gmxCore.createDeferredFunction('LayerEditor', 'createLayerEditor');

//Редактирование стилей векторного слоя
nsGmx.createStylesDialog = gmxCore.createDeferredFunction('LayerStylesEditor', 'createStylesDialog');

//Библиотека стилей
nsGmx.showStyleLibraryDialog = gmxCore.createDeferredFunction('StyleLibrary', 'showStyleLibraryDialog');

})(nsGmx.Utils._);

(function(){

//Интерфейс для провайдеров значений параметров
nsGmx.ILazyAttributeValuesProvider = function()
{
	this.isAttributeExists = function( attrName ){};
	this.getValuesForAttribute = function( attrName, callback ){};
};

//Простая обёртка над массивами для обратной совместимости
nsGmx.LazyAttributeValuesProviderFromArray = function( attributes )
{
	var _attrs = attributes;

	this.isAttributeExists = function( attrName )
	{
		return attrName in _attrs; 
	};
	
	this.getValuesForAttribute = function( attrName, callback )
	{
		if ( attrName in _attrs )
			callback(_attrs[attrName]);
		else
			callback();
	};
};
nsGmx.LazyAttributeValuesProviderFromArray.prototype = new nsGmx.ILazyAttributeValuesProvider();

/** При необходимости этот провайдер будет запрашивать значения аттрибутов у сервера
 * @class
 * @memberOf nsGmx
 * @param {Object} attributes Хеш имён атрибутов, значения которых хочется иметь
 * @param {String} layerName ID слоя
*/
nsGmx.LazyAttributeValuesProviderFromServer = function(attributes, layerName)
{
	var _attrs = attributes;
	var _isInited = false;
	var _isProcessing = false;
	
	//в процессе ожидания ответа от сервера мы можем получать запросы на разные аттрибуты
	//важно все их правильно сохранить и выхвать при получении данных
	var _callbacks = {};

    /** Проверить, есть ли такой атрибут
        @param {String} attrName Имя атрибута
        @return {Boolean} Есть ли такой атрибут среди атрибутов
    */
	this.isAttributeExists = function( attrName )
	{
		return attrName in _attrs; 
	};
	
    /** Получить доступные значения атрибута
        @param {String} attrName Имя атрибута
        @param {Function} callback Ф-ция, которая будет вызвана со списком атрибутов, когда он станет доступным
    */
	this.getValuesForAttribute = function( attrName, callback )
	{
		if ( !(attrName in _attrs) ) //вообще нет такого имени
			callback();
		else if ( _attrs[attrName].length ) //есть вектор значений!
			callback( _attrs[attrName] ); 
		else if (_isInited) //вектора значений всё ещё нет и уже ходили на сервер - второй раз пробовать не будем...
			callback(); 
		else
		{
			if ( !(attrName in _callbacks) )
				_callbacks[attrName] = [];
			
			_callbacks[attrName].push(callback);
			
			if (_isProcessing) return;
			//идём на сервер и запрашиваем значения аттрибутов!
			
			_isProcessing = true;
			sendCrossDomainJSONRequest(serverBase + "VectorLayer/GetVectorAttrValues.ashx?WrapStyle=func&LayerName=" + layerName, function(response)
			{
				_isInited = true;
				_isProcessing = false;
				if (!parseResponse(response))
				{
					for (var n in _callbacks)
						for (var k = 0; k < _callbacks[n].length; k++)
							_callbacks[n][k]();
					return;
				}
				
				_attrs = response.Result;
				for (var n in _callbacks)
					for (var k = 0; k < _callbacks[n].length; k++)
						_callbacks[n][k](_attrs[n]);
			});
		}
	};
}
nsGmx.LazyAttributeValuesProviderFromServer.prototype = new nsGmx.ILazyAttributeValuesProvider();

})();
//event: change
nsGmx.ShpEncodingWidget = function()
{
    var _encodings = {
        'windows-1251': 'windows-1251',
        'utf-8': 'utf-8',
        'koi8-r': 'koi8-r',
        'utf-7': 'utf-7',
        'iso-8859-5': 'iso-8859-5',
        'koi8-u': 'koi8-u',
        'cp866': 'cp866'
        
    };
    var _DEFAULT_ENCODING = 'windows-1251';
    var _curEncoding = _DEFAULT_ENCODING;
    var _this = this;
    
    this.drawWidget = function(container, initialEncoding)
    {
        initialEncoding = initialEncoding || _DEFAULT_ENCODING;
        var select = $("<select></select>").addClass('selectStyle VectorLayerEncodingInput');
        select.change(function()
        {
            _curEncoding = $('option:selected', select).val();
            $(_this).change();
        });
        
        var isStandard = false;
        for (var enc in _encodings)
        {
            var opt = $('<option></option>').val(enc).text(enc);
            
            if (_encodings[enc] === initialEncoding)
            {
                opt.attr('selected', 'selected');
                _curEncoding = enc;
                isStandard = true;
            }
                
            select.append(opt);
        }
        
        var anotherCheckbox = $("<input></input>", {'class': 'box', type: 'checkbox', id: 'otherEncoding'});
        var anotherInput = $("<input></input>", {'class': 'VectorLayerEncodingInput'});
        
        if (!isStandard)
        {
            anotherCheckbox[0].checked = 'checked';
            anotherInput.val(initialEncoding);
            select.attr('disabled', 'disabled');
        }
        else
        {
            anotherInput.attr('disabled', 'disabled');
        }
        
        anotherInput.bind('keyup', function()
        {
            _curEncoding = this.value;
            $(_this).change();
        });
        
        anotherCheckbox.click(function()
        {
            if (this.checked)
            {
                select.attr('disabled', 'disabled');
                anotherInput.removeAttr('disabled');
                anotherInput.focus();
                _curEncoding = anotherInput.val();
            }
            else
            {
                select.removeAttr('disabled');
                anotherInput.attr('disabled', 'disabled');
                _curEncoding = $('option:selected', select).val();
            }
            $(_this).change();
        });
        
        
        var tr1 = $("<tr></tr>")
            .append($("<td></td>").text(_gtxt("Кодировка")))
            .append($("<td></td>").append(select));
            
        var tr2 = $("<tr></tr>")
            .append($("<td></td>").append(anotherCheckbox).append($("<label></label>", {'for': 'otherEncoding'}).text(_gtxt("Другая"))))
            .append($("<td></td>").append(anotherInput));
        
        $(container)
            .append($("<table></table>", {'class': 'VectorLayerEncoding'})
                .append(tr1).append(tr2));
    }
    
    this.getServerEncoding = function()
    {
        return _curEncoding;
    }
};
/** Менеджер дополнительных данных карты. Данные собираются и используются набором сборщиков данных, каждый из которых имеет свой уникальный id.
 @class userObjectsManager
 @memberOf nsGmx 
*/
nsGmx.userObjectsManager = {
    _data: {},
    _collectors: {},
    
    /**
     Устанавливает данные, которые потом могут быть использованы поставщиками данных
	 @method
    */
    setData: function(data) {
        this._data = data;
    },
    
    /**
     Возвращает собранные данные
	 @method
    */
    getData: function() {
        return this._data;
    },
    
	/**
	 Собирает данные со всех сборщиков данных. Собранные данные доступны через метод getData
	 @method
	*/
    collect: function() {
        for (var id in this._collectors) {
            if ('collect' in this._collectors[id]) {
                var data = this._collectors[id].collect();
                if (data !== null) {
                    this._data[id] = data;
                }
            }
        }
    },
    
    /**
	 Вызывает метод load() у всех поставщиков данных, для которых есть данные.
     После вызова метода данные для данного загрузчика будут удалены (чтобы предотвратить множественную загрузку)
	 @method
	*/
    load: function(dataCollectorNames) {
        var collectors = {};
        
        if (dataCollectorNames)
        {
            if (typeof dataCollectorNames === 'string')
                dataCollectorNames = [dataCollectorNames];

            for (var dc = 0; dc < dataCollectorNames.length; dc++)
            {
                var name = dataCollectorNames[dc];
                if (name in this._collectors)
                    collectors[name] = this._collectors[name];
            }
        }
        else
            collectors = this._collectors;
        
        for (var id in collectors) {
            if (id in this._data && 'load' in collectors[id])
            {
                collectors[id].load(this._data[id]);
                delete this._data[id];
            }
        }
    },
    
    /**
	 Добавляет новый сборщик данных. Если в момент добавления есть какие-нибудь данные для загрузчика, они будут ему сразу же переданы
	 @method
     @param collectorId {String} - уникальный идентификатор сборщика данных
     @param collector {Object} - сборщик данных. Должен иметь следующие методы:<br/>
         collect()->Object - возвращает собранные данные. Если данных нет, нужно вернуть null
         load(data)->void - передаёт существующие данные загрузчику
	*/
    addDataCollector: function( collectorId, collector ) {
        this._collectors[collectorId] = collector;
        if (collectorId in this._data && 'load' in collector)
        {
            collector.load(this._data[collectorId])
            delete this._data[collectorId];
        }
    }
}
//Отображение закладок карты в левой панели

//TODO: сделать глобально доступным
nsGmx.Controls = nsGmx.Controls || {};
nsGmx.Controls.LanguageSelector = function(container, defLang) {

    var LANGUAGES = [
            {lang: 'rus', title: 'rus'},
            {lang: 'eng', title: 'eng'}
        ],
        lang = null,
        _this = this;

    var template = Handlebars.compile('<div class = "language-container">' +
        '{{#langs}}' +
            '<span data-lang = "{{lang}}" class="language-item">{{title}}</span>' +
        '{{/langs}}' +
    '</div>');

    $(container).empty().append($(template({langs: LANGUAGES})));

    var update = function() {
        var newLang = $(this).data('lang'),
            prevLang = lang;

        if (newLang !== prevLang) {
            lang = newLang;
            $(this).addClass('language-selected')
                .siblings().removeClass('language-selected');
            $(_this).trigger('change', [prevLang, newLang]);
        }
    }

    $(container).find('span').click(update);
    update.bind($(container).find('span')[0])();

    this.getLang = function() {return lang;};
}

var queryTabs = function()
{
	this.builded = false;

	this.tabsCanvas = null;

	this.tabs = [];
}

queryTabs.prototype = new leftMenu();

queryTabs.prototype.load = function()
{
	if (!this.builded)
	{
		var _this = this;
		this.tabsCanvas = _div(null, [['dir','className','tabsCanvas']])

		this.workCanvas.appendChild(this.tabsCanvas);

		for (var i = 0; i < this.tabs.length; i++)
			this.draw(this.tabs[i]);

		this.builded = true;

		$(this.tabsCanvas).sortable({
			axis: 'y',
			tolerance: 'pointer',
			containment: 'parent'
		});
		$(this.tabsCanvas).bind('sortupdate', function(event, ui)
		{
			var orderedTabs = [];
			$(_this.tabsCanvas).children().each(function()
			{
				orderedTabs.push(this.tabInfo);
			})

			_this.tabs = orderedTabs;
		});

        this.leftPanelItem.hide();
	}
}

queryTabs.prototype.add = function(tabInfo, tabIndex)
{
    var isNew = typeof tabIndex === 'undefined';
    tabInfo = tabInfo || {
        name_rus: '',
        description_rus: '',
        name_eng: '',
        description_eng: ''
    };

    if (typeof tabInfo.name_rus === 'undefined') {
        tabInfo.name_rus = tabInfo.name;
    }

    if (typeof tabInfo.description_rus === 'undefined') {
        tabInfo.description_rus = tabInfo.description;
    }

    var uiTemplate = Handlebars.compile(
        '<div class = "addtabs-container">' +
            '<div class = "addtabs-info">{{i "Название"}}</div>' +
            '<input class = "addtabs-title-input inputStyle" value="{{title}}"><br>' +
            '<div class = "addtabs-info">{{i "Описание"}}</div>' +
            '<textarea class = "addtabs-title-description inputStyle">{{description}}</textarea><br>' +
            '<button class = "addtabs-create">{{buttonTitle}}</button>' +
            '<div class = "addtabs-lang-placeholder"></div>' +
        '</div>');


    var titleLoc = {rus: tabInfo.name_rus, eng: tabInfo.name_eng};
    var descrLoc = {rus: tabInfo.description_rus, eng: tabInfo.description_eng};
    var ui = $(uiTemplate({
            title: titleLoc.rus,
            description: descrLoc.rus,
            buttonTitle: isNew ? _gtxt('Создать') : _gtxt('Изменить')
        })),
        titleInput = $('.addtabs-title-input', ui);

    var updateDataLoc = function(lang) {
        titleLoc[lang] = titleInput.val();
        descrLoc[lang] = $('.addtabs-title-description', ui).val();
    }

    var langControl = new nsGmx.Controls.LanguageSelector(ui.find('.addtabs-lang-placeholder'));
    $(langControl).change(function(event, prevLang, newLang) {
        updateDataLoc(prevLang);
        titleInput.val(titleLoc[newLang]);
        $('.addtabs-title-description', ui).val(descrLoc[newLang]);
    })

    titleInput.keyup(function(e) {
        $(this).toggleClass('error', this.value == '');

        if (e.keyCode == 13)
        {
			createTab();
	  		return false;
	  	}

		return true;
    });

    titleInput.focus();

	var createTab = function() {
            updateDataLoc(langControl.getLang());
            var mapState = _mapHelper.getMapState(),
                tab = {
                    name: titleLoc.rus || titleLoc.eng,
                    description: descrLoc.rus || descrLoc.eng,

                    name_rus: titleLoc.rus,
                    description_rus: descrLoc.rus,
                    name_eng: titleLoc.eng,
                    description_eng: descrLoc.eng,

                    state: mapState
                };

            if (isNew) {
            _this.tabs.push(tab);
            } else {
                _this.tabs[tabIndex] = tab;
            }
            _this.draw(tab, tabIndex);

            removeDialog(dialogDiv);
        },
        _this = this;

    $('.addtabs-create', ui).click(createTab);

	var dialogDiv = showDialog(_gtxt("Имя закладки"), ui[0], 280, 230, false, false);
}

queryTabs.prototype.draw = function (tabInfo, tabIndex)
{
    var selectValLoc = function(paramName) {
        var lang = nsGmx.Translations.getLanguage();
        return tabInfo[paramName + '_' + lang] || tabInfo[paramName];
    }

    var tmpl = Handlebars.compile('<div class="canvas">' +
        '<div class="buttonLink tabName" title="{{description}}">{{name}}</div>' +
        '<div class="gmx-icon-edit"></div>' +
        '<div class="gmx-icon-close"></div>' +
    '</div>');


    var canvas = $(tmpl({
            name: selectValLoc('name'),
            description: selectValLoc('description')
        }))[0];
    var _this = this;

	canvas.tabInfo = tabInfo;

    $('.tabName', canvas).click(this.show.bind(this, tabInfo.state));

    $('.gmx-icon-close', canvas).click(function() {
		var index = getOwnChildNumber(canvas);

		_this.tabs.splice(index, 1);

		canvas.removeNode(true);
	})

    $('.gmx-icon-edit', canvas).click(function() {
        var index = getOwnChildNumber(canvas);
        _this.add(_this.tabs[index], index);
    }).toggle(_queryMapLayers.currentMapRights() === "edit");

    if (typeof tabIndex === 'undefined') {
        $(this.tabsCanvas).append(canvas);
    } else {
        $(this.tabsCanvas).find('.canvas').eq(tabIndex).replaceWith(canvas);
    }
}

queryTabs.prototype.show = function(state)
{
	var parsedState = {},
        lmap = nsGmx.leafletMap,
        gmxDrawing = lmap.gmxDrawing;

	$.extend(true, parsedState, state);
    var pos = parsedState.position;

    lmap.setView(L.Projection.Mercator.unproject(L.point(pos.x, pos.y)), 17 - pos.z);

    for (var i = 0; i < state.drawnObjects.length; i++)
    {
        parsedState.drawnObjects[i].geometry = L.gmxUtil.geometryToGeoJSON(state.drawnObjects[i].geometry, true);
    }

    lmap.gmxBaseLayersManager.setCurrentID(lmap.gmxBaseLayersManager.getIDByAlias(parsedState.mode));

    //удаляем все фичи
    gmxDrawing.getFeatures().slice(0).forEach(gmxDrawing.remove.bind(gmxDrawing));

	for (var i = 0; i < parsedState.drawnObjects.length; i++)
	{
        //старый формат - число, новый - строка
		var rawColor = parsedState.drawnObjects[i].color,
            color = (typeof rawColor === 'number' ? '#' + L.gmxUtil.dec2hex(rawColor) : rawColor) || '#0000FF',
			thickness = parsedState.drawnObjects[i].thickness || 2,
			opacity = parsedState.drawnObjects[i].opacity || 80;

        gmxDrawing.addGeoJSON(parsedState.drawnObjects[i].geometry, {
            lineStyle: {
                color: color,
                weight: thickness,
                opacity: opacity/100
            }
        });
	}

	_queryMapLayers.applyState(parsedState.condition, parsedState.mapStyles);

    if (typeof parsedState.customParamsCollection !== 'undefined')
        _mapHelper.customParamsManager.loadParams(parsedState.customParamsCollection);

    if (parsedState.openPopups) {
        for (var l in parsedState.openPopups) {
            var layer = nsGmx.gmxMap.layersByID[l];
            if (layer && layer.addPopup) {
                parsedState.openPopups[l].forEach(layer.addPopup.bind(layer));
            }
        }
    }
}

var _queryTabs = new queryTabs();

nsGmx.userObjectsManager.addDataCollector('tabs', {
    collect: function()
    {
        if (!_queryTabs.tabs.length)
            return null;

        var tabs = [];

        for (var i = 0; i < _queryTabs.tabs.length; i++)
        {
            var tab = {};

            $.extend(tab, _queryTabs.tabs[i]);

            tabs.push(tab);
        }

        return tabs;
    },
    load: function(data)
    {
        if (!data || !data.length)
            return;

        $('#left_mapTabs').remove();

        _queryTabs.builded = false;
        _queryTabs.tabs = data;

        mapHelp.tabs.load('mapTabs');
    }
})

//Загрузка и отображение дополнительных карт в левой панели
!(function(_) {

var queryExternalMaps = function()
{
	this.maps = [];
	this.loadedMaps = {};
}

queryExternalMaps.prototype = new leftMenu();

queryExternalMaps.prototype.load = function()
{
	if (!this.builded)
	{
		var hostButton = _input(null, [['dir','className','inputStyle'],['css','width','200px']]),
			nameButton = _input(null, [['dir','className','inputStyle'],['css','width','200px']]),
			loadButton = makeButton(_gtxt("Загрузить")),
			addMap = makeLinkButton(_gtxt("Добавить карту")),
			paramsTable = _table([_tbody([_tr([_td([_t(_gtxt("Хост"))],[['css','colSpan',2],['css','paddingTop','3px']])]),
											_tr([_td([hostButton]), _td()]),
											_tr([_td([_t(_gtxt("Имя"))],[['css','colSpan',2]])]),
											_tr([_td([nameButton]), _td([loadButton])])])],[['css','margin','3px 0px 0px 10px']]),
			_this = this;

		_(this.workCanvas, [_div([addMap],[['css','margin','5px 0px 5px 10px']]), paramsTable]);

		paramsTable.style.display = 'none';

		hostButton.value = window.serverBase;

		addMap.onclick = function()
		{
			if (paramsTable.style.display == 'none')
				paramsTable.style.display = '';
			else
				paramsTable.style.display = 'none';
		}

		loadButton.onclick = function()
		{
			if (hostButton.value == '')
				inputError(hostButton);

			if (nameButton.value == '')
				inputError(nameButton);

			if (hostButton.value == '' || nameButton.value == '')
				return;

			_this.addMapElem(hostButton.value, nameButton.value);

			nameButton.value = '';
		}

		this.mapsCanvas = _div(null,[['dir','className','drawingObjectsCanvas externalMapsCanvas'],['css','paddingLeft','0px'], ['attr', 'id', 'externalMapsCanvas']]);

		_(this.workCanvas, [this.mapsCanvas]);

		this.builded = true;

		for (var i = 0; i < this.maps.length; ++i)
			this.addMapElem(this.maps[i].hostName, this.maps[i].mapName, true);
	}
}

queryExternalMaps.prototype.addMapElem = function(hostName, mapName, silent)
{
    this.createWorkCanvas('externalMaps');
    this.load();

	var mapElem = _div(),
		div = _div(null, [['css','position','relative'],['css','margin','2px 0px 2px 14px']]),
		remove = $('<div class="gmx-icon-close"></div>'),
        mapInfo,
        _this = this;

    for (var i = 0; i < this.maps.length; i++) {
        var map = this.maps[i];
        if (map.hostName === hostName && map.mapName === mapName) {
            if (map.container) {
                return;
            }
            mapInfo = map;
            break;
        }
    }

    if (!mapInfo) {
        mapInfo = {
            hostName: hostName,
            mapName: mapName
        }
        this.maps.push(mapInfo);
    }

    mapInfo.container = div

	div.hostName = hostName;
	div.mapName = mapName;

	_(div, [mapElem, remove[0]]);
	_(this.mapsCanvas, [div]);

	this.addMap(hostName, mapName, mapElem, silent);

	remove.click(function()
	{
		div.removeNode(true);

		if (!mapElem.extLayersTree)
			return;

		mapElem.extLayersTree.treeModel.forEachLayer(function(layer, isVisible)
		{
			var name = layer.properties.name;

			if (nsGmx.layersByID[name].external)
				_queryMapLayers.removeLayer(name);
		});

        for (var i = 0; i < _this.maps.length; i++) {
            var map = _this.maps[i];
            if (map.hostName === hostName && map.mapName === mapName) {
                _this.maps.splice(i, 1);
                break;
            }
        }
	})
}

queryExternalMaps.prototype.addMap = function(hostName, mapName, parent, silent)
{
	var loading = _div([_img(null, [['attr','src','img/progress.gif'],['css','marginRight','10px'],['css','width','16px'],['css','height','16px']]), _t(_gtxt('загрузка...'))], [['css','margin','3px 0px 3px 20px']]),
		_this = this;

	_(parent, [loading]);

	this.loadMap(hostName, mapName, function(gmxMap)
	{
		if (gmxMap == null)
		{
			loading.parentNode.parentNode.removeNode(true);

			silent || showErrorMessage(_gtxt("Невозможно загрузить карту [value0] с домена [value1]", mapName, hostName), true);

			return;
		}

        var extLayersTree = new layersTree({showVisibilityCheckbox: true, allowActive: false, allowDblClick: true});

		var	tree = extLayersTree.drawTree(gmxMap.rawTree, 2);
		$(tree).treeview();
		extLayersTree.runLoadingFuncs();

		loading.removeNode(true);
		_(parent, [tree]);

        //добавляем перетаскивание в основную карту только если доп. карта с того же домена
        if ( hostName === _layersTree.treeModel.getMapProperties().hostName )
            _queryMapLayers.addDraggable(parent);

		parent.extLayersTree = extLayersTree;
	});
}

queryExternalMaps.prototype.loadMap = function(hostName, mapName, callback)
{
    var _this = this;
	L.gmx.loadMap(mapName, {
        hostName: hostName,
        leafletMap: nsGmx.leafletMap,
        apiKey: window.apiKey,
        srs: nsGmx.leafletMap.options.srs || '',
        isGeneralized: window.mapOptions && 'isGeneralized' in window.mapOptions ? window.mapOptions.isGeneralized : true,
        skipTiles: nsGmx.leafletMap.options.skipTiles || ''
    }).then(function(gmxMap)
	{
        for (var i = 0; i < gmxMap.layers.length; i++) {
            var layer = gmxMap.layers[i];
            var id = layer.getGmxProperties().name;

            layer.external = true;

            if (!(id in nsGmx.gmxMap.layersByID)) {
                nsGmx.gmxMap.addLayer(layer);
            }
        }

        if (gmxMap.properties.Copyright)
        {
            var copyrightLayer = {
                options: {
                    attribution: gmxMap.properties.Copyright
                },
                onAdd: function() {},
                onRemove: function() {}
            }

            copyrightLayer.addTo(nsGmx.leafletMap);
        }

        gmxMap.properties.hostName = hostName;

        callback(gmxMap);
        $(_queryExternalMaps).triggerHandler('map_loaded', gmxMap);

        for (var i = 0; i < _this.maps.length; i++) {
            var map = _this.maps[i];
            if (map.hostName === hostName && map.mapName === mapName) {
                map.tree = layers;
                break;
            }
        }
	},
	function()
	{
		callback(null);
		$(_queryExternalMaps).triggerHandler('map_loaded', null);
	});
}

var _queryExternalMaps = new queryExternalMaps();
window._queryExternalMaps = _queryExternalMaps;

nsGmx.userObjectsManager.addDataCollector('externalMaps', {
    collect: function()
    {
        if (!_queryExternalMaps.workCanvas)
            return;

        var value = [];

        $(_queryExternalMaps.workCanvas.lastChild).children("div").each(function()
        {
            value.push({hostName:this.hostName, mapName:this.mapName})
        })

        if (!value.length)
            return null;

        return value;
    },
    load: function(data)
    {
        if (!data || !data.length)
            return;

        $('#left_externalMaps').remove();

        _queryExternalMaps.builded = false;
        _queryExternalMaps.maps = data;

        mapHelp.externalMaps.load('externalMaps');
    }
});

})(nsGmx.Utils._);

var pointsBinding = 
{
	pointsBinding: {}
}

var queryBinding = function()
{
	this.conf = false;
	
	this.imgPoints = [],
	this.mapPoints = [],
	this.mapPointsFlags = [0,0,0,0],
	this.parentImage = null;
	this.toggle = null;
	
	this.dx = -7;
	this.dy = -26;
	
	this.loadTimer = null;
	
	this.imgDialog = null;
}

queryBinding.prototype = new leftMenu();

queryBinding.prototype.load = function()
{
	this.parentImage = globalFlashMap.rasters.addObject();
	
	for (var i = 0; i < 4; i++)
	{
		this.mapPoints[i] = globalFlashMap.addObject({type:'POINT', coordinates: [0, 0]});
	  	this.mapPoints[i].setStyle({marker: {image: "img/" + (i + 1) + "u.png", dx: this.dx, dy: this.dy}},{marker: {image: "img/" + (i + 1) + "uh.png", dx: this.dx, dy: this.dy}});
		this.mapPoints[i].setVisible(false);
	}
	
	var _this = this;
	
	for (var i = 0; i < 4; i++)
	{
		(function(i)
		{
	    	_this.mapPoints[i].setHandler('onMouseDown', function()
	    	{
	    		var draggedPoint = _this.mapPoints[i];
	    		var dx = draggedPoint.getGeometry().coordinates[0] - globalFlashMap.getMouseX();
	    		var dy = draggedPoint.getGeometry().coordinates[1] - globalFlashMap.getMouseY();

				globalFlashMap.freeze();
				globalFlashMap.setHandler('onMouseMove', function()
				{
					draggedPoint.setPoint(globalFlashMap.getMouseX() + dx, globalFlashMap.getMouseY() + dy);
					
					if (_this.getConformity(true))
						_this.drawConformity();
				});
	    	});
	    	_this.mapPoints[i].setHandler('onMouseUp', function()
	    	{
	    		globalFlashMap.unfreeze();
				globalFlashMap.setHandler('onMouseMove', null);
	    	});
    	})(i)
	}
	
	this.workArea = _div(null,[['dir','className','workArea']]);
	this.imgCanvas = _img(null, [['css','display','none']]);
	
	_(this.workArea, [this.imgCanvas]);
	
	var formFile = _form(null,[['attr','enctype','multipart/form-data'],['dir','method','post'],['dir','action', getAPIHostRoot() + 'imgSave.ashx?WrapStyle=window'],['attr','target','pictureBinding_iframe']]);
	formFile.style.width = '220px';
	_(formFile, [_input(null,[['attr','type','hidden'],['attr','name','id'],['dir','className','inputStyle'], ['attr','value','pictureBinding' + Math.random()]])]);

	var attach = _input(null,[['attr','type','file'],['dir','name','rawdata'],['attr','size',25]]);
	_(formFile, [attach]);
	
	var loadButton = makeButton(_gtxt("Загрузить"));
	loadButton.onclick = function()
	{
		var iframe = createPostIframe("pictureBinding_iframe", function(response)
		{
			if (!parseResponse(response))
				return;
			
			reloadButton.disabled = false;
			
			_this.showPictureDialog();
			
			_this.reloadImg(response.Result)
		});
		
		_(document.body, [iframe]);
		
		formFile.firstChild.setAttribute('value','pictureBinding' + Math.random())
		formFile.submit();
	}
	
	_(this.workCanvas, [_table([_tbody([_tr([_td([formFile]), _td([loadButton])])])],[['css','margin','10px 0px 5px 20px']])]);
		
	var imgTds = [],
		mapTds = [];
	
	this.workArea.imgLeft = 0;
	this.workArea.imgTop = 0;
		
	for (var i = 0; i < 4; i++)
	{
		(function(i)
		{
			var imgPoint = _div(null, [['dir','className','imgBoundingPoint'],['css','position','absolute']]);
			
			imgPoint.style.marginLeft = _this.dx + 'px';
			imgPoint.style.marginTop = _this.dy + 'px';
			
			$(imgPoint).draggable(
			{
				containment: _this.workArea,
				drag: function(ev, ui)
				{
					var pos = _this.getImgPosition();
					
					imgPoint.beginLeft = ui.absolutePosition.left - _this.workArea.imgLeft - pos.left,
					imgPoint.beginTop = ui.absolutePosition.top - _this.workArea.imgTop - pos.top;
					
					if (_this.getConformity(true))
						_this.drawConformity();
				}
			})
			
			imgPoint.style.left = '-500px';
			imgPoint.style.top = '-500px';
			
			imgPoint.beginLeft = -500;
			imgPoint.beginTop = -500;
			
			imgPoint.style.display = 'none';

			_(_this.workArea, [imgPoint]);
				
			_this.imgPoints.push(imgPoint);
			
			var imgHelperPoint = _div(null, [['dir','className','imgHelperPoint']])
			imgHelperPoint.onclick = function()
			{
				imgPoint.style.left = Math.floor(_this.getImgWidth() / 2) + 'px';
				imgPoint.style.top = Math.floor(_this.getImgHeight() / 2) + 'px';
				
				imgPoint.beginLeft = Math.floor(_this.getImgWidth() / 2) - _this.workArea.imgLeft;
				imgPoint.beginTop = Math.floor(_this.getImgHeight() / 2) - _this.workArea.imgTop;
				
				imgPoint.style.display = '';
			}
			
			imgTds.push(_td([imgHelperPoint]));
			
			var mapHelperPoint = _div(null, [['dir','className','imgHelperPoint']])
			mapHelperPoint.onclick = function(e)
			{
				_this.mapPoints[i].setGeometry({type:'POINT', coordinates: [globalFlashMap.getX(),globalFlashMap.getY()]})
				
				_this.mapPoints[i].setVisible(true);
				
				_this.mapPointsFlags[i] = 1;
			}
			
			mapTds.push(_td([mapHelperPoint]));
			
			imgHelperPoint.style.backgroundImage = "url(img/" + (i + 1) + "i.png)";
			mapHelperPoint.style.backgroundImage = "url(img/" + (i + 1) + "i.png)";
			imgPoint.style.backgroundImage = "url(img/" + (i + 1) + "u.png)";
			
			imgPoint.onmouseover = function()
			{
				imgPoint.style.backgroundImage = "url(img/" + (i + 1) + "uh.png)";
			}
			imgPoint.onmouseout = function()
			{
				imgPoint.style.backgroundImage = "url(img/" + (i + 1) + "u.png)";
			}
		})(i)
	}
	
	_(this.workCanvas, [_div([_table([_tbody([_tr([_td([_t(_gtxt('Точки на изображении:'))],[['css','width','150px'],['css','fontSize','12px']])].concat(imgTds))])],[['css','margin','5px 0px 0px 20px']])]),
						  _div([_table([_tbody([_tr([_td([_t(_gtxt('Точки на карте:'))],[['css','width','150px'],['css','fontSize','12px']])].concat(mapTds))])],[['css','margin','5px 0px 0px 20px']])])]);
	
	var drawButton = makeButton(_gtxt('Нарисовать'))
	drawButton.onclick = function()
	{
		if (_this.getConformity())
			_this.drawConformity();
	}
	
	var reloadButton = makeButton(_gtxt("Восстановить"))
	reloadButton.onclick = function()
	{
		$(_this.imgDialog).dialog('open')
	}
	
	if (!this.imgLoaded)
		reloadButton.disabled = true;
	
	this.toggle = _input(null, [['attr','type','checkbox'],['dir','className','box']])
	this.toggle.onclick = function()
	{
		if (_this.parentImage)
			_this.parentImage.setVisible(this.checked);
	}
	
	var tempStyle = typeof this.tempStyle != 'undefined' ? this.tempStyle : {fill: {opacity: 100}};
	
	this.slider = nsGmx.Controls.createSlider(typeof this.tempStyle != 'undefined' ? _this.tempStyle.fill.opacity : 100, 
		function(event, ui)
		{
			if (_this.parentImage)
			{
				tempStyle.fill.opacity = ui.value;
				_this.tempStyle = tempStyle;
				
				_this.parentImage.setStyle(tempStyle);
			}
		});
	
	var table = _table([_tbody([_tr([_td([_t(_gtxt("Видимость"))],[['css','width','100px'],['css','fontSize','12px']]),_td([this.toggle])]),
								_tr([_td([_t(_gtxt("Прозрачность"))],[['css','fontSize','12px']]), _td([this.slider])])])], [['css','margin','15px 0px 10px 0px']])
	
	_(this.workCanvas, [_div([_table([_tbody([_tr([_td([drawButton],[['css','paddingRight','15px']]),_td([reloadButton])])])]), table],[['css','padding','15px 0px 0px 20px']])]);
}

queryBinding.prototype.getImgWidth = function()
{
	return this.workArea.clientWidth;
}
queryBinding.prototype.getImgHeight = function()
{
	return this.workArea.clientHeight;
}
queryBinding.prototype.getImgPosition = function()
{
	return getOffsetRect(this.workArea);
}

queryBinding.prototype.showPictureDialog = function()
{
	if (this.imgDialog)
	{
		$(this.imgDialog).dialog('destroy');
		
		this.imgDialog.removeNode(true);
	}
	
	var canvas = _div([this.workArea]);
	
	showDialog(_gtxt("Привязка изображения"), canvas, 400, 400, 310, 35, null, function(){return true});
	
	this.imgDialog = canvas.parentNode;
}

queryBinding.prototype.reloadImg = function(id)
{
	var img = _img(null, [['attr','src',getAPIHostRoot() + 'imgSave.ashx?id=' + id]]),
		_this = this;
	
	img.onload = function()
	{
		img.style.width = img.width + 'px';
		img.style.height = img.height + 'px';
	}
	
	$(img).draggable(
	{
		cursor: 'crosshair',
		drag: function(ev,ui)
		{
			for (var i = 0; i < 4; i++)
			{
				var imgPoint = _this.imgPoints[i];
				
				var left = imgPoint.beginLeft + ui.position.left,
					top = imgPoint.beginTop + ui.position.top;
				
				imgPoint.style.left = left + 'px';
				imgPoint.style.top = top + 'px';
				
				if (top < 0 ||
					top > _this.getImgHeight() ||
					left < 0 ||
					left > _this.getImgWidth())
					imgPoint.style.display = 'none';
				else
					imgPoint.style.display = '';
			}
			
			_this.workArea.imgLeft = ui.position.left;
			_this.workArea.imgTop = ui.position.top;
		}
	});
	
	$(this.imgCanvas).replaceWith(img);
	
	this.imgCanvas = img;
	
	this.workArea.imgLeft = 0;
	this.workArea.imgTop = 0;
	
	delete this.tempStyle;
	
	for (var i = 0; i < 4; i++)
	{
		var imgPoint = this.imgPoints[i];
			
		imgPoint.style.left = '-500px';
		imgPoint.style.top = '-500px';
		
		imgPoint.beginLeft = -500;
		imgPoint.beginTop = -500;
		
		imgPoint.style.display = 'none';
	}
}

queryBinding.prototype.unload = function()
{
/*	if (this.parentImage)
		this.parentImage.setVisible(false);*/
	if (this.mapPoints && this.mapPoints[0])
		this.mapPoints[0].setVisible(false);
	if (this.mapPoints && this.mapPoints[1])
		this.mapPoints[1].setVisible(false);
	if (this.mapPoints && this.mapPoints[2])
		this.mapPoints[2].setVisible(false);
	
	if (this.imgDialog)
	{
		$(this.imgDialog).dialog("destroy")
			
		this.imgDialog.removeNode(true);
	}
}
queryBinding.prototype.reload = function()
{
/*	if (this.parentImage)
		this.parentImage.setVisible(true);*/
	if (this.mapPoints && this.mapPoints[0])
		this.mapPoints[0].setVisible(true);
	if (this.mapPoints && this.mapPoints[1])
		this.mapPoints[1].setVisible(true);
	if (this.mapPoints && this.mapPoints[2])
		this.mapPoints[2].setVisible(true);
}

queryBinding.prototype.getConformity = function(skipMessage)
{
	this.conf = false;
	
	for (var i = 0; i < 4; i++)
	{
		var imgPoint = this.imgPoints[i],
			conformity = {};
		
		if (imgPoint.beginLeft < 0 ||
			imgPoint.beginLeft > this.imgCanvas.clientWidth ||
			imgPoint.beginTop < 0 ||
			imgPoint.beginTop > this.imgCanvas.clientHeight)
		{
			if (typeof skipMessage != 'undefined' && !skipMessage)
				showErrorMessage(_gtxt("$$phrase$$_2", i + 1), true)
			
			return false;
		}
		
		conformity.x = imgPoint.beginLeft;
		conformity.y = imgPoint.beginTop;
		
		if (!this.mapPointsFlags[i])
		{
			if (typeof skipMessage != 'undefined' && !skipMessage)
				showErrorMessage(_gtxt("$$phrase$$_3", i + 1), true)
			
			return false;
		}
		
		conformity.lat = this.mapPoints[i].getGeometry().coordinates[0];
		conformity.lon = this.mapPoints[i].getGeometry().coordinates[1];
		
		if (!this.conf)
			this.conf = [];
		
		this.conf.push(conformity)
	}
	
	return true;
}

queryBinding.prototype.drawConformity = function()
{
	this.parentImage.setImage(this.imgCanvas.getAttribute('src'), 	this.conf[0].x, this.conf[0].y,
																	this.conf[1].x, this.conf[1].y,
																	this.conf[2].x, this.conf[2].y,
																	this.conf[3].x, this.conf[3].y,
																	this.conf[0].lat, this.conf[0].lon,
																	this.conf[1].lat, this.conf[1].lon,
																	this.conf[2].lat, this.conf[2].lon,
																	this.conf[3].lat, this.conf[3].lon)
	
	this.parentImage.setVisible(true);
	
	this.parentImage.setStyle({fill: {opacity: $(this.slider).slider('option', 'value')}});
	
	this.toggle.checked = true;
}

var _queryBinding = new queryBinding();

pointsBinding.pointsBinding.load = function()
{
	var alreadyLoaded = _queryBinding.createWorkCanvas(arguments[0], _queryBinding.unload);
	
	if (!alreadyLoaded)
		_queryBinding.load();
	else
		_queryBinding.reload();
}
pointsBinding.pointsBinding.unload = function()
{
	_queryBinding.unload();
}


!(function(_) {

    var mapLayers = {
        mapLayers: {}
    }

    window.mapLayers = mapLayers;

    AbstractTree = function() {}

    AbstractTree.prototype.makeSwapChild = function() {
        var div = _div(null, [
            ['attr', 'swap', true],
            ['dir', 'className', 'swap'],
            ['css', 'fontSize', '0px']
        ]);

        return div;
    }

    AbstractTree.prototype.getChildsUl = function(node) {
        var ul = $(node).children("ul");

        if (ul.length > 0)
            return ul[0];
        else
            return false;
    }

    AbstractTree.prototype.toggle = function(box) {
        box.onclick = function() {
            $(this.parentNode)
                .find(">.hitarea")
                .swapClass('collapsable-hitarea', 'expandable-hitarea')
                .swapClass('lastCollapsable-hitarea', 'lastExpandable-hitarea')
                .end()
                .swapClass('collapsable', 'expandable')
                .swapClass('lastCollapsable', 'lastExpandable')

            if ($(this.parentNode).hasClass('expandable') || $(this.parentNode).hasClass('lastExpandable'))
                hide(_abstractTree.getChildsUl(this.parentNode))
            else
                show(_abstractTree.getChildsUl(this.parentNode))
        }
    }
    AbstractTree.prototype.addNode = function(node, newNodeCanvas) {
        var childsUl = _abstractTree.getChildsUl(node);

        if (childsUl)
            childsUl.insertBefore(newNodeCanvas, childsUl.firstChild)
        else {
            // если первый потомок
            var newSubTree = _ul([newNodeCanvas]);
            //_(node, [newSubTree, this.makeSwapChild()]);
            node.insertBefore(newSubTree, node.lastChild)

            newSubTree.loaded = true;

            var div = _div(null, [
                ['dir', 'className', 'hitarea']
            ]);

            if ($(node).hasClass("last")) {
                $(div).addClass('lastCollapsable-hitarea collapsable-hitarea');
                $(node).addClass('lastCollapsable');
            } else {
                $(div).addClass('collapsable-hitarea');
                $(node).addClass('collapsable');
            }

            this.toggle(div);

            node.insertBefore(div, node.firstChild);

            _layersTree.addExpandedEvents(node);

            if ($(newNodeCanvas).hasClass('collapsable')) {
                $(newNodeCanvas).addClass('lastCollapsable')
                $(newNodeCanvas).children('div.hitarea').addClass('lastCollapsable-hitarea')
            }
            if ($(newNodeCanvas).hasClass('expandable')) {
                $(newNodeCanvas).addClass('lastExpandable')
                $(newNodeCanvas).children('div.hitarea').addClass('lastExpandable-hitarea')
            }
            if (!$(newNodeCanvas).hasClass('lastCollapsable') && !$(newNodeCanvas).hasClass('lastExpandable'))
                $(newNodeCanvas).addClass('last');
        }

        $(_abstractTree.getChildsUl(node)).children(":not(li:last)").each(function() {
            $(this).removeClass('last').replaceClass('lastCollapsable', 'collapsable').replaceClass('lastExpandable', 'expandable');
            $(this).children('div.lastCollapsable-hitarea').replaceClass('lastCollapsable-hitarea', 'collapsable-hitarea');
            $(this).children('div.lastExpandable-hitarea').replaceClass('lastExpandable-hitarea', 'expandable-hitarea');
        })
    }
    AbstractTree.prototype.delNode = function(node, parentTree, parent) {
        if (parentTree.childNodes.length == 0) {
            // потомков не осталось, удалим контейнеры
            parentTree.removeNode(true);
            parent.firstChild.removeNode(true);

            // изменим дерево родителя
            $(parent).removeClass("collapsable")
            $(parent).replaceClass("lastCollapsable", "last")
        } else {
            // изменим дерево родителя
            if ($(parentTree).children("li:last").hasClass("collapsable")) {
                $(parentTree).children("li:last").addClass("lastCollapsable");

                $(parentTree).children("li:last").each(function() {
                    $(this.firstChild).addClass("lastCollapsable-hitarea");
                })
            } else
                $(parentTree).children("li:last").addClass("last")
        }
    }

    AbstractTree.prototype.swapNode = function(node, newNodeCanvas) {
        $(node).after(newNodeCanvas)

        $(node.parentNode).children(":not(li:last)").each(function() {
            $(this).removeClass('last').replaceClass('lastCollapsable', 'collapsable').replaceClass('lastExpandable', 'expandable');
            $(this).children('div.lastCollapsable-hitarea').replaceClass('lastCollapsable-hitarea', 'collapsable-hitarea');
            $(this).children('div.lastExpandable-hitarea').replaceClass('lastExpandable-hitarea', 'expandable-hitarea');
        })

        // изменим дерево родителя
        if ($(node.parentNode).children("li:last").hasClass("collapsable")) {
            $(node.parentNode).children("li:last").addClass("lastCollapsable");

            $(node.parentNode).children("li:last").each(function() {
                $(this.firstChild).addClass("lastCollapsable-hitarea");
            })
        } else if ($(node.parentNode).children("li:last").hasClass("expandable")) {
            $(node.parentNode).children("li:last").addClass("lastExpandable");

            $(node.parentNode).children("li:last").each(function() {
                $(this.firstChild).addClass("lastExpandable-hitarea");
            })
        } else
            $(node.parentNode).children("li:last").addClass("last")
    }

    var _abstractTree = new AbstractTree();
    window._abstractTree = _abstractTree;

    //renderParams:
    //  * showVisibilityCheckbox {Bool} - показывать или нет checkbox видимости
    //  * allowActive {Bool} - возможен ли в дереве активный элемент
    //  * allowDblClick {Bool} - переходить ли по двойному клику к видимому экстенту слоя/группы
    //  * showStyle {Bool} - показывать ли иконку стилей
    //  * visibilityFunc {function(layerProps, isVisible)} - ф-ция, которая будет выполнена при изменении видимости слоя.
    //    По умолчанию устанавливает видимость соответствующего слоя в API
    //
    //события:
    //  * layerVisibilityChange - при изменении видимости слоя (параметр - элемент дерева с изменившимся слоем)
    //  * addTreeElem - добавили новый элемент дерева (параметр - новый элемент)
    //  * activeNodeChange - изменили активную ноду дерева (парамер - div активной ноды)
    var layersTree = function(renderParams) {
        this._renderParams = $.extend({
            showVisibilityCheckbox: true,
            allowActive: true,
            allowDblClick: true,
            showStyle: true,
            visibilityFunc: function(props, isVisible) {
                if (props.name in nsGmx.gmxMap.layersByID) {
                    nsGmx.leafletMap[isVisible ? 'addLayer' : 'removeLayer'](nsGmx.gmxMap.layersByID[props.name]);
                }
            }
        }, renderParams);

        // тип узла
        this.type = null;

        // содержимое узла
        this.content = null;

        this.condition = { visible: {}, expanded: {} };

        this.mapStyles = {};

        this.groupLoadingFuncs = [];

        this._treeCanvas = null; //контейнер отрисованного дерева слоёв

        this._layerViewHooks = [];
    }

    layersTree.prototype.addLayerViewHook = function(hook) {
        hook && this._layerViewHooks.push(hook);
    }

    layersTree.prototype._applyLayerViewHooks = function(div, layerProps) {
        this._layerViewHooks.forEach(function(hook) {
            hook(div, layerProps);
        })
    }

    // layerManagerFlag == 0 для дерева слева
    // layerManagerFlag == 1 для списка слоев
    // layerManagerFlag == 2 для списка карт

    layersTree.prototype.drawTree = function(tree, layerManagerFlag) {
        var permalinkParams = this.LayersTreePermalinkParams;

        if (permalinkParams) {
            var tempTree = new nsGmx.LayersTree(tree);

            tempTree.forEachNode(function(elem) {
                var props = elem.content.properties,
                    id = elem.type == 'group' ? props.GroupID : props.LayerID;

                if (id in permalinkParams) {
                    props.permalinkParams = permalinkParams[id];
                }
            });

            tree = tempTree.getRawTree();
        }

        this._treeCanvas = _ul([this.getChildsList(tree, false, layerManagerFlag, true)], [
            ['dir', 'className', 'filetree']
        ]);
        this.treeModel = new nsGmx.LayersTree(tree);
        this._mapTree = tree; //Устарело: используйте this.treeModel для доступа к исходному дереву

        this.treeModel.forEachLayer(function(layerContent, isVisible) {
            layerContent.properties.initVisible = layerContent.properties.visible;
        });

        var _this = this;
        $(this.treeModel).on('nodeVisibilityChange', function(event, elem) {
            var props = elem.content.properties;

            _this.updateVisibilityUI(elem);
            props.changedByViewer = true;

            if (elem.type === 'layer') {
                _this._renderParams.visibilityFunc(props, props.visible);
                $(_this).triggerHandler('layerVisibilityChange', [elem]);
            }
        })

        nsGmx.leafletMap.on('layeradd layerremove', function(event) {
            if (event.layer.getGmxProperties) {
                var name = event.layer.getGmxProperties().name;

                //добавился именно слой из основной карты, а не просто с таким же ID
                if (event.layer === nsGmx.gmxMap.layersByID[name]) {
                    var searchRes = _this.treeModel.findElem('name', name);
                    if (searchRes && (!layerManagerFlag || layerManagerFlag == 0)) {
                        _this.treeModel.setNodeVisibility(searchRes.elem, nsGmx.leafletMap.hasLayer(event.layer));
                    }
                }
            }
        });

        return this._treeCanvas;
    }

    layersTree.prototype.getChildsList = function(elem, parentParams, layerManagerFlag, parentVisibility) {
        // добавляем новый узел
        var li = _li(),
            _this = this;

        _(li, [this.drawNode(elem, parentParams, layerManagerFlag, parentVisibility)]);

        if (elem.content && elem.content.children && elem.content.children.length > 0) {
            var childsUl = _ul();

            // initExpand - временное свойство, сохраняющее начальное состояние развёрнутости группы.
            // В expanded будет храниться только текущее состояние (не сохраняется)
            if (typeof elem.content.properties.initExpand == 'undefined')
                elem.content.properties.initExpand = elem.content.properties.expanded;

            if (!elem.content.properties.expanded) {
                childsUl.style.display = 'none';
                childsUl.className = 'hiddenTree';

                if (!layerManagerFlag) {
                    childsUl.loaded = false;

                    this.addLoadingFunc(childsUl, elem, parentParams, layerManagerFlag);
                } else {
                    childsUl.loaded = true;

                    var childs = [];

                    for (var i = 0; i < elem.content.children.length; i++)
                        childs.push(this.getChildsList(elem.content.children[i], elem.content.properties, layerManagerFlag, true));

                    _(childsUl, childs)
                }
            } else {
                childsUl.loaded = true;

                var childs = [];

                for (var i = 0; i < elem.content.children.length; i++)
                    childs.push(this.getChildsList(elem.content.children[i], elem.content.properties, layerManagerFlag, parentVisibility && elem.content.properties.visible));

                _(childsUl, childs)
            }

            _(li, [childsUl, _abstractTree.makeSwapChild()])
        } else if (elem.children) {
            if (elem.children.length > 0) {
                var childs = [];

                for (var i = 0; i < elem.children.length; i++)
                    childs.push(this.getChildsList(elem.children[i], elem.properties, layerManagerFlag, true));

                var childsUl = _ul(childs);

                childsUl.loaded = true;

                _(li, [childsUl])
            }

            _(li, [_div()])

            li.root = true;
        } else
            _(li, [_abstractTree.makeSwapChild()])

        // видимость слоя в дереве
        if (!nsGmx.AuthManager.isRole(nsGmx.ROLE_ADMIN) &&
            elem.type && elem.type == 'layer' &&
            typeof invisibleLayers != 'undefined' && invisibleLayers[elem.content.properties.name])
            li.style.display = 'none';

        return li;
    }

    layersTree.prototype.addLoadingFunc = function(parentCanvas, elem, parentParams, layerManagerFlag) {
        var func = function() {
                $(parentCanvas.parentNode.firstChild).bind('click', function() {
                    if (!parentCanvas.loaded) {
                        parentCanvas.loaded = true;

                        var childs = [],
                            grId = $(parentCanvas.parentNode).children("div[GroupID]");

                        for (var i = 0; i < elem.content.children.length; i++) {
                            childs.push(_this.getChildsList(elem.content.children[i], elem.content.properties, layerManagerFlag, _this.getLayerVisibility($(grId).find('input[type="checkbox"]')[0] || $(grId).find('input[type="radio"]')[0])));
                        }

                        _(parentCanvas, childs);

                        if (_queryMapLayers.currentMapRights() == "edit") {
                            _queryMapLayers.addDraggable(parentCanvas);

                            if (!layerManagerFlag) {
                                _queryMapLayers.addDroppable(parentCanvas);

                                _queryMapLayers.addSwappable(parentCanvas);
                            }
                        }

                        $(parentCanvas).treeview();

                        _layersTree.addExpandedEvents(parentCanvas);

                        _this.runLoadingFuncs();

                        _queryMapLayers.applyState(_this.condition, _this.mapStyles, $(parentCanvas.parentNode).children("div[GroupID]")[0]);
                    }
                })
            },
            _this = this;

        this.groupLoadingFuncs.push(func);
    }

    layersTree.prototype.runLoadingFuncs = function() {
        for (var i = 0; i < this.groupLoadingFuncs.length; i++)
            this.groupLoadingFuncs[i]();

        this.groupLoadingFuncs = [];
    }

    layersTree.prototype.addExpandedEvents = function(parent) {
        var _this = this;
        $(parent).find("div.hitarea").each(function() {
            if (!this.clickFunc) {
                this.clickFunc = true;

                var divClick = this;

                if (divClick.parentNode.parentNode.parentNode.getAttribute("multiStyle"))
                    return;

                $(divClick).bind('click', function() {
                    var div = $(divClick.parentNode).children("div[MapID],div[GroupID],div[LayerID],div[MultiLayerID]")[0],
                        treeElem = _this.findTreeElem(div);

                    if (!treeElem.parents.length)
                        return;

                    var flag = $(divClick).hasClass("expandable-hitarea");
                    treeElem.elem.content.properties.expanded = !flag;
                })
            }
        });
    }

    layersTree.prototype.drawNode = function(elem, parentParams, layerManagerFlag, parentVisibility) {
        var div;
        var _this = this;

        if (elem.type == "layer") {
            // var elemProperties = !layerManagerFlag ? nsGmx.gmxMap.layersByID[elem.content.properties.name].getGmxProperties(): elem.content.properties;

            var elemProperties;
            if (nsGmx.gmxMap.layersByID[elem.content.properties.name]) {
                elemProperties = !layerManagerFlag ? nsGmx.gmxMap.layersByID[elem.content.properties.name].getGmxProperties() : elem.content.properties;
            } else {
                elemProperties = elem.content.properties;
            }

            var childs = this.drawLayer(elemProperties, parentParams, layerManagerFlag, parentVisibility);

            if (typeof elem.content.properties.LayerID != 'undefined')
                div = _div(childs, [
                    ['attr', 'LayerID', elem.content.properties.LayerID]
                ]);
            else if (typeof elem.content.properties.MultiLayerID != 'undefined')
                div = _div(childs, [
                    ['attr', 'MultiLayerID', elem.content.properties.MultiLayerID]
                ]);
            else
                div = _div(childs, [
                    ['attr', 'LayerID', elem.content.properties.name]
                ]);

            div.gmxProperties = elem;
            div.gmxProperties.content.properties = elemProperties;

            this._applyLayerViewHooks(div, elemProperties);
        } else {
            if (elem.properties && elem.properties.MapID)
                div = _div(this.drawHeaderGroupLayer(elem.properties, parentParams, layerManagerFlag), [
                    ['attr', 'MapID', elem.properties.MapID]
                ])
            else
                div = _div(this.drawGroupLayer(elem.content.properties, parentParams, layerManagerFlag, parentVisibility), [
                    ['attr', 'GroupID', elem.content.properties.GroupID]
                ])

            div.gmxProperties = elem;
        }

        div.oncontextmenu = function(e) {
            return false;
        }

        return div;
    }

    layersTree.prototype.setActive = function(span) {
        $(this._treeCanvas).find(".active").removeClass("active");

        if (span) {
            $(span.parentNode).addClass("active");
            $(this).triggerHandler("activeNodeChange", [span.parentNode.parentNode]);
        } else {
            $(this).triggerHandler("activeNodeChange", [null]);
        }
    }

    layersTree.prototype.getActive = function() {
        var activeDiv = $(this._treeCanvas).find(".active");
        return activeDiv[0] ? activeDiv[0].parentNode : null;
    }

    layersTree.prototype.getMinLayerZoom = function(layer) {
        if (!layer.getStyles) {
            return 1;
        }

        var minLayerZoom = 20,
            styles = layer.getStyles();

        for (var i = 0; i < styles.length; i++) {
            minLayerZoom = Math.min(minLayerZoom, styles[i].MinZoom);
        }

        return minLayerZoom;
    }

    layersTree.prototype.layerZoomToExtent = function(bounds, minZoom) {
        if (!bounds) return;

        var lmap = nsGmx.leafletMap,
            z = lmap.getBoundsZoom(bounds);

        if (minZoom !== 20) {
            z = Math.max(z, minZoom);
        }

        z = Math.min(lmap.getMaxZoom(), Math.max(lmap.getMinZoom(), z));

        //анимация приводит к проблемам из-за бага https://github.com/Leaflet/Leaflet/issues/3249
        //а указать явно zoom в fitBounds нельзя
        //TODO: enable animation!
        lmap.fitBounds(bounds, { animation: false });

        //если вызывать setZoom всегда, карта начнёт глючить (бага Leaflet?)
        if (z !== lmap.getZoom()) {
            lmap.setZoom(z);
        }
    }

    layersTree.prototype.drawLayer = function(elem, parentParams, layerManagerFlag, parentVisibility) {
        var box,
            _this = this;

        if (this._renderParams.showVisibilityCheckbox) {
            box = _checkbox(elem.visible, parentParams.list ? 'radio' : 'checkbox', parentParams.GroupID || parentParams.MapID);

            box.className = 'box layers-visibility-checkbox';

            box.setAttribute('box', 'layer');

            box.onclick = function() {
                _this.treeModel.setNodeVisibility(_this.findTreeElem(this.parentNode).elem, this.checked);
            }
        }

        var span = _span([_t(elem.title)], [
            ['dir', 'className', 'layer'],
            ['attr', 'dragg', true]
        ]);

        var timer = null,
            clickFunc = function() {
                var treeNode = _this.findTreeElem(span.parentNode.parentNode).elem;
                $(treeNode).triggerHandler('click', [treeNode]);

                if (_this._renderParams.allowActive)
                    _this.setActive(span);

                if (_this._renderParams.showVisibilityCheckbox) {
                    _this.treeModel.setNodeVisibility(treeNode, true);
                }
            },
            dbclickFunc = function() {
                var treeNode = _this.findTreeElem(span.parentNode.parentNode).elem;
                var layer = nsGmx.gmxMap.layersByID[elem.name];
                $(treeNode).triggerHandler('dblclick', [treeNode]);
                if (treeNode.content.geometry && layer && layer.getBounds) {
                    var minLayerZoom = _this.getMinLayerZoom(layer);
                    _this.layerZoomToExtent(layer.getBounds(), minLayerZoom);
                }
            };

        span.onclick = function() {
            if (timer)
                clearTimeout(timer);

            timer = setTimeout(clickFunc, 200)
        }

        if (this._renderParams.allowDblClick) {
            span.ondblclick = function() {
                if (timer)
                    clearTimeout(timer);

                timer = null;

                clickFunc();
                dbclickFunc();
            }
        }

        disableSelection(span);

        var spanParent = _div([span], [
                ['attr', 'titleDiv', true],
                ['css', 'display', 'inline'],
                ['css', 'position', 'relative'],
                ['css', 'borderBottom', 'none'],
                ['css', 'paddingRight', '3px']
            ]),
            spanDescr = _span(null, [
                ['dir', 'className', 'layerDescription']
            ]);

        spanDescr.innerHTML = elem.description ? elem.description : '';

        if (layerManagerFlag == 1) {
            return [_img(null, [
                ['attr', 'src', (elem.type == "Vector") ? 'img/vector.png' : (typeof elem.MultiLayerID != 'undefined' ? 'img/multi.png' : 'img/rastr.png')],
                ['css', 'marginLeft', '3px']
            ]), spanParent, spanDescr];
        }

        if (this._renderParams.showVisibilityCheckbox && !elem.visible) {
            $(spanParent).addClass("invisible");
        }

        nsGmx.ContextMenuController.bindMenuToElem(spanParent, 'Layer', function() { return true; }, {
            layerManagerFlag: layerManagerFlag,
            elem: elem,
            tree: this
        });

        var borderDescr = _span();

        var count = 0;
        var metaProps = {};
        if (elem.MetaProperties) {
            for (key in elem.MetaProperties) {
                var tagtype = elem.MetaProperties[key].Type;
                metaProps[key] = nsGmx.Utils.convertFromServer(tagtype, elem.MetaProperties[key].Value);
                count++;
            }
        }

        if (count || elem.Legend) {
            _(borderDescr, [_t('i')], [
                ['dir', 'className', 'layerInfoButton']
            ]);
            borderDescr.onclick = function() {
                nsGmx.Controls.showLayerInfo({ properties: elem }, { properties: metaProps });
            }
        }

        if (elem.type == "Vector") {
            var icon = _mapHelper.createStylesEditorIcon(elem.styles, elem.GeometryType ? elem.GeometryType.toLowerCase() : 'polygon', { addTitle: !layerManagerFlag }),
                multiStyleParent = _div(null, [
                    ['attr', 'multiStyle', true]
                ]),
                timelineIcon,
                iconSpan = _span([icon]);

            if (elem.styles.length === 1 && elem.name in nsGmx.gmxMap.layersByID) {
                var layer = nsGmx.gmxMap.layersByID[elem.name];
                layer.on('stylechange', function() {
                    if (layer.getStyles().length === 1) {
                        var style = L.gmxUtil.toServerStyle(layer.getStyles()[0].RenderStyle);
                        var newIcon = _mapHelper.createStylesEditorIcon(
                            [{ MinZoom: 1, MaxZoom: 21, RenderStyle: style }],
                            elem.GeometryType ? elem.GeometryType.toLowerCase() : 'polygon', { addTitle: !layerManagerFlag }
                        );
                        $(iconSpan).empty().append(newIcon);
                    }
                });
            }

            $(iconSpan).attr('styleType', $(icon).attr('styleType'));

            _mapHelper.createMultiStyle(elem, this, multiStyleParent, true, layerManagerFlag);

            if (!layerManagerFlag) {
                if (!parentVisibility || !elem.visible)
                    $(multiStyleParent).addClass("invisible")

                iconSpan.onclick = function() {
                    if (_queryMapLayers.currentMapRights() == "edit") {
                        nsGmx.createStylesDialog(elem, _this);
                    }
                }

                if (elem.name in nsGmx.gmxMap.layersByID) {
                    var layer = nsGmx.gmxMap.layersByID[elem.name];

                    if (layer.getGmxProperties) {
                        var props = layer.getGmxProperties(),
                            layerName = props.name;

                        if (props.Temporal && (props.IsRasterCatalog || (props.Quicklook && props.Quicklook !== 'null'))) {
                            timelineIcon = document.createElement('img');
                            timelineIcon.src = 'img/timeline-icon-disabled.svg';
                            timelineIcon.className = 'gmx-timeline-icon disabled';
                            timelineIcon.title = window._gtxt("Добавить в таймлайн");

                            timelineIcon.onclick = function() {
                                var disabled = $(this).hasClass('disabled'),
                                    timelinePluginName = 'Timeline Vectors',
                                    timeLineModuleName = 'gmxTimeLine',
                                    timelinePlugin = nsGmx.pluginsManager.getPluginByName(timelinePluginName);

                                // lazy load timeline plugin
                                if (!timelinePlugin.body) {
                                    nsGmx.pluginsManager.setUsePlugin(timelinePluginName, true);

                                    window.gmxCore.loadModule(timeLineModuleName, timelinePlugin.file).then(function(res) {
                                        var paramsClone = $.extend(true, {}, timelinePlugin.params);
                                        var timeLineControl = res.afterViewer && res.afterViewer(paramsClone, nsGmx.leafletMap);
                                        _mapHelper.mapPlugins.addPlugin(timelinePluginName, timelinePlugin.params);
                                        res.addLayer(layer);

                                        if (timeLineControl) {
                                            timeLineControl.on('layerRemove', function(e) {
                                                $(window._layersTree).triggerHandler('layerTimelineRemove', e);
                                            });
                                            timeLineControl.on('layerAdd', function(e) {
                                                $(window._layersTree).triggerHandler('layerTimelineAdd', e);
                                            });
                                        }
                                    }).then(function(err) {
                                        console.log(err);
                                    });
                                } else {
                                    disabled ? timelinePlugin.body.addLayer(layer) : timelinePlugin.body.removeLayer(layer);
                                }

                                if (disabled) {
                                    if (!parentVisibility || !elem.visible) {
                                        $(multiStyleParent).removeClass("invisible");
                                        _this.treeModel.setNodeVisibility(_this.findTreeElem(span.parentNode.parentNode).elem, true);
                                    }
                                }
                            }

                            $(this).on('layerTimelineRemove', function(e, data) {
                                if (data.layerID === layerName) {
                                    timelineIcon.src = 'img/timeline-icon-disabled.svg';
                                    timelineIcon.title = window._gtxt("Удалить из таймлайна");
                                    $(timelineIcon).addClass('disabled');
                                }
                            });

                            $(this).on('layerTimelineAdd', function(e, data) {
                                if (data.layerID === layerName) {
                                    timelineIcon.src = 'img/timeline-icon-enabled.svg';
                                    timelineIcon.title = window._gtxt("Добавить в таймлайн");
                                    $(timelineIcon).removeClass('disabled');
                                }
                            });
                        }
                    }
                }
            }

            var resElems = [spanParent, spanDescr, borderDescr];


            if (this._renderParams.showStyle) {
                resElems.push(multiStyleParent);
                resElems.unshift(iconSpan);
            }
            this._renderParams.showVisibilityCheckbox && resElems.unshift(box);

            if (timelineIcon) {
                resElems.unshift(timelineIcon);
            }
            return resElems;
        } else {
            if (this._renderParams.showVisibilityCheckbox)
                return [box, spanParent, spanDescr, borderDescr];
            else
                return [spanParent, spanDescr, borderDescr];
        }
    }

    layersTree.prototype.drawGroupLayer = function(elem, parentParams, layerManagerFlag, parentVisibility) {
        var box,
            _this = this;

        if (this._renderParams.showVisibilityCheckbox) {
            box = _checkbox(elem.visible, parentParams.list ? 'radio' : 'checkbox', parentParams.GroupID || parentParams.MapID);

            box.className = 'box layers-visibility-checkbox';

            box.setAttribute('box', 'group');

            box.onclick = function() {
                _this.treeModel.setNodeVisibility(_this.findTreeElem(this.parentNode).elem, this.checked);
            }

            if (typeof elem.ShowCheckbox !== 'undefined' && !elem.ShowCheckbox) {
                box.isDummyCheckbox = true;
                box.style.display = 'none';
            }
        }

        var span = _span([_t(elem.title)], [
            ['dir', 'className', 'groupLayer'],
            ['attr', 'dragg', true]
        ]);

        var timer = null,
            clickFunc = function() {
                if (_this._renderParams.allowActive)
                    _this.setActive(span);

                if (_this._renderParams.showVisibilityCheckbox) {
                    var div = span.parentNode.parentNode;

                    if (div.gmxProperties.content.properties.ShowCheckbox) {
                        _this.treeModel.setNodeVisibility(_this.findTreeElem(div).elem, true);
                    }

                    var clickDiv = $(div.parentNode).children("div.hitarea");
                    if (clickDiv.length)
                        $(clickDiv[0]).trigger("click");
                }
            },
            dbclickFunc = function() {
                var childsUl = _abstractTree.getChildsUl(span.parentNode.parentNode.parentNode);

                if (childsUl) {
                    var bounds = new L.LatLngBounds(),
                        minLayerZoom = 20;

                    _mapHelper.findChilds(_this.findTreeElem(span.parentNode.parentNode).elem, function(child) {
                        if (child.type == 'layer' && (child.content.properties.LayerID || child.content.properties.MultiLayerID) && child.content.geometry) {
                            var layer = nsGmx.gmxMap.layersByID[child.content.properties.name];
                            bounds.extend(layer.getBounds());

                            minLayerZoom = Math.min(minLayerZoom, _this.getMinLayerZoom(layer));
                        }
                    });

                    _this.layerZoomToExtent(bounds, minLayerZoom);
                }
            };

        span.onclick = function() {
            if (timer)
                clearTimeout(timer);

            timer = setTimeout(clickFunc, 200)
        }

        if (this._renderParams.allowDblClick) {
            span.ondblclick = function() {
                if (timer)
                    clearTimeout(timer);

                timer = null;

                clickFunc();
                dbclickFunc();
            }
        }

        disableSelection(span);

        var spanParent = _div([span], [
            ['attr', 'titleDiv', true],
            ['css', 'display', 'inline'],
            ['css', 'position', 'relative'],
            ['css', 'borderBottom', 'none'],
            ['css', 'paddingRight', '3px']
        ]);

        if (this._renderParams.showVisibilityCheckbox && (!parentVisibility || !elem.visible)) {
            $(spanParent).addClass("invisible");
        }

        if (!layerManagerFlag) {

            nsGmx.ContextMenuController.bindMenuToElem(spanParent, 'Group', function() {
                    return _queryMapLayers.currentMapRights() == "edit";
                },
                function() {
                    return {
                        div: spanParent.parentNode,
                        tree: _this
                    }
                });
        }

        if (this._renderParams.showVisibilityCheckbox)
            return [box, spanParent];
        else
            return [spanParent];
    }
    layersTree.prototype.drawHeaderGroupLayer = function(elem, parentParams, layerManagerFlag) {
        var span = _span([_t(elem.title)], [
                ['dir', 'className', 'groupLayer']
            ]),
            spanParent = _div([span], [
                ['css', 'display', 'inline'],
                ['css', 'position', 'relative'],
                ['css', 'borderBottom', 'none'],
                ['css', 'paddingRight', '3px']
            ]),
            _this = this;

        if (this._renderParams.allowActive) {
            span.onclick = function() {
                _this.setActive(this);
            }
        }

        if (!layerManagerFlag) {
            nsGmx.ContextMenuController.bindMenuToElem(spanParent, 'Map', function() {
                    return _queryMapLayers.currentMapRights() == "edit";
                },
                function() {
                    return {
                        div: spanParent.parentNode,
                        tree: _this
                    }
                }
            );
        }

        return [spanParent];
    }

    layersTree.prototype.removeGroup = function(div) {
        var template = Handlebars.compile('<div class="removeGroup-container">' +
            '{{#if anyChildren}}' +
            '<label><input type="checkbox" checked class="removeGroup-layers">{{i "Включая вложенные слои"}}</label><br>' +
            '{{/if}}' +
            '<button class="removeGroup-remove">{{i "Удалить"}}</button>' +
            '</div>');
        var groupNode = _layersTree.treeModel.findElemByGmxProperties(div.gmxProperties).elem;

        var ui = $(template({ anyChildren: groupNode.content.children.length > 0 })),
            pos = nsGmx.Utils.getDialogPos(div, true, 90),
            _this = this;

        ui.find('.removeGroup-remove').click(function() {
            var parentTree = div.parentNode.parentNode,
                childsUl = _abstractTree.getChildsUl(div.parentNode);

            if (ui.find('.removeGroup-layers').prop('checked')) {
                _layersTree.treeModel.forEachLayer(function(layerContent) {
                    _queryMapLayers.removeLayer(layerContent.properties.name);
                }, groupNode);
            } else {
                //TODO: не работает, когда группа не раскрыта или раскрыта не полностью
                var divDestination = $(parentTree.parentNode).children("div[MapID],div[GroupID]")[0];

                if (childsUl) {
                    // переносим все слои наверх
                    $(childsUl).find("div[LayerID],div[MultiLayerID]").each(function() {
                        var spanSource = $(this).find("span.layer")[0];

                        _this.moveHandler(spanSource, divDestination);
                    })
                }
            }

            _this.removeTreeElem(div);

            div.parentNode.removeNode(true);

            _abstractTree.delNode(null, parentTree, parentTree.parentNode)

            $(dialogDiv).dialog('destroy');
            dialogDiv.removeNode(true);

            _mapHelper.updateUnloadEvent(true);

            _this.updateZIndexes();
        });

        var title = _gtxt("Удаление группы [value0]", div.gmxProperties.content.properties.title);
        var dialogDiv = showDialog(title, ui[0], 250, 100, pos.left, pos.top);
    }

    //по элементу дерева слоёв ищет соответствующий элемент в DOM представлении
    layersTree.prototype.findUITreeElem = function(elem) {
        var props = elem.content.properties,
            searchStr;

        if (props.LayerID)
            searchStr = "div[LayerID='" + props.LayerID + "']";
        else if (props.MultiLayerID)
            searchStr = "div[MultiLayerID='" + props.MultiLayerID + "']";
        else if (props.GroupID)
            searchStr = "div[GroupID='" + props.GroupID + "']";
        else
            searchStr = "div[LayerID='" + props.name + "']";

        return $(this._treeCanvas).find(searchStr)[0];
    }

    layersTree.prototype.getLayerVisibility = function(box) {
        if (!box.checked)
            return false;

        var el = box.parentNode.parentNode.parentNode;

        while (!el.root) {
            var group = $(el).children("[GroupID]"),
				chB = $(group).find('input[type="checkbox"]')[0] || $(group).find('input[type="radio"]')[0];

            if (group.length > 0) {
                if (!chB.checked)

                    return false;
            }

            el = el.parentNode;
        }

        return true;
    }

    //Устанавливает галочку в checkbox и нужный стиль DOM ноде дерева в зависимости от видимости
    //ничего не трогает вне ноды и в самом дереве
    layersTree.prototype.updateVisibilityUI = function(elem) {
        var div = this.findUITreeElem(elem);
        if (div) {
            var isVisible = elem.content.properties.visible;
            $(div).children("[titleDiv], [multiStyle]").toggleClass("invisible", !isVisible);
            var checkbox = $(div).find('input[type="checkbox"]')[0] || $(div).find('input[type="radio"]')[0];
            checkbox.checked = isVisible;
        }
    }

    layersTree.prototype.dummyNode = function(node) {
        var text = node.innerHTML;

        if (text.length > 40) {
            text = text.substring(0, 37) + '...';
        }

        return div = _div([_t(text)], [
            ['dir', 'className', 'dragableDummy']
        ]);
    }

    //проходится по всем слоям дерева и устанавливает им z-индексы в соответствии с их порядком в дереве
    layersTree.prototype.updateZIndexes = function() {
        var curZIndex = 0;

        this.treeModel.forEachLayer(function(layerContent, isVisible, nodeDepth) {
            var layer = nsGmx.gmxMap.layersByID[layerContent.properties.name];

            var zIndex = curZIndex++;
            layer.setZIndex && layer.setZIndex(zIndex);
        })
    }

    layersTree.prototype.moveHandler = function(spanSource, divDestination) {
        var node = divDestination.parentNode,
            divSource = spanSource.parentNode.parentNode.parentNode,
            parentTree = divSource.parentNode,
            parentElem = this.findTreeElem($(divSource).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0]).parents[0];

        this.removeTreeElem(spanSource.parentNode.parentNode);
        this.addTreeElem(divDestination, 0, spanSource.parentNode.parentNode.gmxProperties);

        // добавим новый узел
        var childsUl = _abstractTree.getChildsUl(node);

        if (childsUl) {
            _abstractTree.addNode(node, divSource);

            this.updateListType(divSource);

            if (!childsUl.loaded)
                divSource.removeNode(true)
        } else {
            _abstractTree.addNode(node, divSource);

            this.updateListType(divSource);
        }

        parentElem && parentElem.content && this.treeModel.updateNodeVisibility(parentElem);

        // удалим старый узел
        _abstractTree.delNode(node, parentTree, parentTree.parentNode);

        _mapHelper.updateUnloadEvent(true);

        this.updateZIndexes();
    }

    layersTree.prototype.swapHandler = function(spanSource, divDestination) {
        var node = divDestination.parentNode,
            divSource = spanSource.parentNode.parentNode.parentNode,
            parentTree = divSource.parentNode,
            parentElem = this.findTreeElem($(divSource).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0]).parents[0];

        if (node == divSource)
            return;

        this.removeTreeElem(spanSource.parentNode.parentNode);

        var divElem = $(divDestination.parentNode).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0],
            divParent = $(divDestination.parentNode.parentNode.parentNode).children("div[MapID],div[GroupID]")[0],
            index = this.findTreeElem(divElem).index;

        this.addTreeElem(divParent, index + 1, spanSource.parentNode.parentNode.gmxProperties);

        _abstractTree.swapNode(node, divSource);

        this.updateListType(divSource);

        parentElem && parentElem.content && this.treeModel.updateNodeVisibility(parentElem);

        // удалим старый узел
        _abstractTree.delNode(node, parentTree, parentTree.parentNode);

        _mapHelper.updateUnloadEvent(true);

        this.updateZIndexes();
    }

    layersTree.prototype.copyHandler = function(gmxProperties, divDestination, swapFlag, addToMap) {
        var _this = this;
        var isFromList = typeof gmxProperties.content.geometry === 'undefined';
        var layerProperties = (gmxProperties.type !== 'layer' || !isFromList) ? gmxProperties : false,
            copyFunc = function() {
                if (addToMap) {
                    if (!_this.addLayersToMap(layerProperties))
                        return;
                } else {
                    if (_this.treeModel.findElemByGmxProperties(gmxProperties)) {
                        if (layerProperties.type === 'layer')
                            showErrorMessage(_gtxt("Слой '[value0]' уже есть в карте", layerProperties.content.properties.title), true)
                        else
                            showErrorMessage(_gtxt("Группа '[value0]' уже есть в карте", layerProperties.content.properties.title), true)

                        return;
                    }
                }

                var node = divDestination.parentNode,
                    parentProperties = swapFlag ? $(divDestination.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0].gmxProperties : divDestination.gmxProperties,
                    li;

                if (swapFlag) {
                    var parentDiv = $(divDestination.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0];

                    li = _this.getChildsList(layerProperties, parentProperties, false, parentDiv.getAttribute('MapID') ? true : _this.getLayerVisibility($(parentDiv).find('input[type="checkbox"]')[0] ? $(parentDiv).find('input[type="checkbox"]')[0] : parentDiv.firstChild));
                } else
                    li = _this.getChildsList(layerProperties, parentProperties, false, _this.getLayerVisibility($(divDestination).find('input[type="checkbox"]')[0] ? $(divDestination).find('input[type="checkbox"]')[0] : divDestination.firstChild));

                if (layerProperties.type == 'group') {
                    // добавляем группу
                    if (_abstractTree.getChildsUl(li)) {
                        var div = _div(null, [
                            ['dir', 'className', 'hitarea']
                        ]);

                        if (layerProperties.content.properties.expanded) {
                            $(div).addClass('collapsable-hitarea');
                            $(li).addClass('collapsable');
                        } else {
                            $(div).addClass('expandable-hitarea');
                            $(li).addClass('expandable');
                        }

                        _abstractTree.toggle(div);

                        li.insertBefore(div, li.firstChild);

                        $(li).treeview();

                        // если копируем из карты
                        if (isFromList)
                            _layersTree.runLoadingFuncs();
                    }

                    _queryMapLayers.addDraggable(li)

                    _queryMapLayers.addDroppable(li);
                } else {
                    _queryMapLayers.addDraggable(li);

                    if (layerProperties.type == 'layer' && layerProperties.content.properties.styles.length > 1)
                        $(li).treeview();
                }

                _queryMapLayers.addSwappable(li);

                if (swapFlag) {
                    var divElem = $(divDestination.parentNode).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0],
                        divParent = $(divDestination.parentNode.parentNode.parentNode).children("div[MapID],div[GroupID]")[0],
                        index = _this.findTreeElem(divElem).index;

                    _this.addTreeElem(divParent, index + 1, layerProperties);

                    _abstractTree.swapNode(node, li);

                    _this.updateListType(li, true);
                } else {
                    _this.addTreeElem(divDestination, 0, layerProperties);

                    var childsUl = _abstractTree.getChildsUl(node);

                    _abstractTree.addNode(node, li);
                    _this.updateListType(li, true);

                    if (childsUl && !childsUl.loaded) {
                        li.removeNode(true)
                    }
                }

                _mapHelper.updateUnloadEvent(true);

                _this.updateZIndexes();
            },
            _this = this;

        if (!layerProperties) {
            if (gmxProperties.content.properties.LayerID) {
                sendCrossDomainJSONRequest(serverBase + "Layer/GetLayerJson.ashx?WrapStyle=func&LayerName=" + gmxProperties.content.properties.name + "&srs=" + (nsGmx.leafletMap.options.srs || "3395"), function(response) {
                    if (!parseResponse(response))
                        return;

                    layerProperties = { type: 'layer', content: response.Result };

                    if (layerProperties.content.properties.type == 'Vector')
                        layerProperties.content.properties.styles = [{ MinZoom: 1, MaxZoom: 21, RenderStyle: layerProperties.content.properties.IsPhotoLayer ? _mapHelper.defaultPhotoIconStyles[layerProperties.content.properties.GeometryType] : _mapHelper.defaultStyles[layerProperties.content.properties.GeometryType] }]
                    else if (layerProperties.content.properties.type != 'Vector' && !layerProperties.content.properties.MultiLayerID)
                        layerProperties.content.properties.styles = [{ MinZoom: layerProperties.content.properties.MinZoom, MaxZoom: 21 }];

                    layerProperties.content.properties.mapName = _this.treeModel.getMapProperties().name;
                    layerProperties.content.properties.hostName = _this.treeModel.getMapProperties().hostName;
                    layerProperties.content.properties.visible = true;

                    copyFunc();
                })
            } else {
                sendCrossDomainJSONRequest(serverBase + "MultiLayer/GetMultiLayerJson.ashx?WrapStyle=func&MultiLayerID=" + gmxProperties.content.properties.MultiLayerID, function(response) {
                    if (!parseResponse(response))
                        return;

                    layerProperties = { type: 'layer', content: response.Result };

                    layerProperties.content.properties.styles = [{ MinZoom: layerProperties.content.properties.MinZoom, MaxZoom: 20 }];

                    layerProperties.content.properties.mapName = _this.treeModel.getMapProperties().name;
                    layerProperties.content.properties.hostName = _this.treeModel.getMapProperties().hostName;
                    layerProperties.content.properties.visible = true;

                    copyFunc();
                })
            }
        } else
            copyFunc();
    }

    //не работает для мультислоёв
    layersTree.prototype.addLayerToTree = function(layerName) {
        var gmxProperties = {
            type: 'layer',
            content: {
                properties: {
                    LayerID: layerName,
                    name: layerName
                }
            }
        };

        var targetDiv = $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0];

        this.copyHandler(gmxProperties, targetDiv, false, true);
    }

    //геометрия слоёв должна быть в координатах меркатора
    layersTree.prototype.addLayersToMap = function(elem) {
        var DEFAULT_VECTOR_LAYER_ZINDEXOFFSET = 2000000;

        var layerOrder = nsGmx.gmxMap.rawTree.properties.LayerOrder,
            currentZoom = nsGmx.leafletMap.getZoom();

        if (typeof elem.content.properties.GroupID != 'undefined') {
            for (var i = 0; i < elem.content.children.length; i++) {
                var res = this.addLayersToMap(elem.content.children[i]);

                if (!res)
                    return false;
            }
        } else {
            var layer = elem.content,
                name = layer.properties.name;

            if (!nsGmx.gmxMap.layersByID[name]) {
                var visibility = typeof layer.properties.visible != 'undefined' ? layer.properties.visible : false,
                    rcMinZoom = layer.properties.RCMinZoomForRasters,
                    layerOnMap = L.gmx.createLayer(layer, {
                        layerID: name,
                        hostName: window.serverBase,
                        zIndexOffset: null,
                        srs: nsGmx.leafletMap.options.srs || '',
                        skipTiles: nsGmx.leafletMap.options.skipTiles || '',
                        isGeneralized: window.mapOptions && 'isGeneralized' in window.mapOptions ? window.mapOptions.isGeneralized : true
                    });

                updateZIndex(layerOnMap);
                nsGmx.gmxMap.addLayer(layerOnMap);

                visibility && nsGmx.leafletMap.addLayer(layerOnMap);

                layerOnMap.getGmxProperties().changedByViewer = true;

                nsGmx.leafletMap.on('zoomend', function(e) {
                    currentZoom = nsGmx.leafletMap.getZoom();

                    for (var l = 0; l < nsGmx.gmxMap.layers.length; l++) {
                        var layer = nsGmx.gmxMap.layers[l];

                        updateZIndex(layer);
                    }
                });
            } else {
                showErrorMessage(_gtxt("Слой '[value0]' уже есть в карте", nsGmx.gmxMap.layersByID[name].getGmxProperties().title), true);
                return false;
            }
        }

        function updateZIndex(layer) {
            var props = layer.getGmxProperties();

            switch (layerOrder) {
                case 'VectorOnTop':
                    if (props.type === 'Vector') {
                        if (props.IsRasterCatalog) {
                            var rcMinZoom = props.RCMinZoomForRasters;
                            layer.setZIndexOffset(currentZoom < rcMinZoom ? DEFAULT_VECTOR_LAYER_ZINDEXOFFSET : 0);
                        } else {
                            layer.setZIndexOffset(DEFAULT_VECTOR_LAYER_ZINDEXOFFSET);
                        }
                    }
                    break;
            }
        }

        return true;
    }

    layersTree.prototype.getParentParams = function(li) {
        //при визуализации дерева в него добавляются новые элементы. Используем хак, чтобы понять, было отрисовано дерево или нет
        var parentParams = li.parentNode.parentNode.childNodes[1].tagName == "DIV" ? li.parentNode.parentNode.childNodes[1].gmxProperties : li.parentNode.parentNode.childNodes[0].gmxProperties,
            listFlag;

        if (parentParams.content)
            listFlag = parentParams.content.properties;
        else
            listFlag = parentParams.properties;

        return listFlag;
    }

    layersTree.prototype.updateListType = function(li, skipVisible) {
        //при визуализации дерева в него добавляются новые элементы. Используем хак, чтобы понять, было отрисовано дерево или нет
        var parentParams = li.parentNode.parentNode.childNodes[1].tagName == "DIV" ? li.parentNode.parentNode.childNodes[1].gmxProperties : li.parentNode.parentNode.childNodes[0].gmxProperties,
            listFlag;

        if (parentParams.content)
            listFlag = parentParams.content.properties.list;
        else
            listFlag = parentParams.properties.list;

        var div = $(li).children("div[MapID],div[GroupID],div[LayerID],div[MultiLayerID]")[0],
            box = $(div).find('input[type="checkbox"]')[0] || $(div).find('input[type="radio"]')[0],
            newBox = _checkbox(
                box.checked,
                listFlag ? 'radio' : 'checkbox',
                parentParams.content ? parentParams.content.properties.GroupID : parentParams.properties.MapID
            ),
            _this = this;

        newBox.className = 'box layers-visibility-checkbox';

        if (box.getAttribute('box') == 'group')
            newBox.setAttribute('box', 'group');

        $(box).replaceWith(newBox);

        newBox.onclick = function() {
            _this.treeModel.setNodeVisibility(_this.findTreeElem(this.parentNode).elem, this.checked);
        }

        if (box.isDummyCheckbox) {
            newBox.isDummyCheckbox = true;
            newBox.style.display = 'none';
        }

        if (!skipVisible) {
            var parentDiv = $(newBox.parentNode.parentNode.parentNode.parentNode).children("div[GroupID]")[0];
            parentDiv && this.treeModel.updateNodeVisibility(this.findTreeElem(parentDiv).elem, this.findTreeElem(newBox.parentNode).elem);
        }

        return newBox;
    }

    layersTree.prototype.removeTreeElem = function(div) {
        var elem = this.findTreeElem(div);

        if (typeof elem.parents[0].children != 'undefined')
            elem.parents[0].children.splice(elem.index, 1);
        else
            elem.parents[0].content.children.splice(elem.index, 1);
    }

    layersTree.prototype.addTreeElem = function(div, index, elemProperties) {
        var elem = this.findTreeElem(div);

        if (typeof elem.elem.children != 'undefined')
            elem.elem.children.splice(index, 0, elemProperties);
        else
            elem.elem.content.children.splice(index, 0, elemProperties);

        $(this.treeModel.getRawTree()).triggerHandler('addTreeElem', [elemProperties]);
    }

    layersTree.prototype.findTreeElem = function(div) {
        if (div.getAttribute("MapID"))
            return { elem: this.treeModel.getRawTree(), parents: [], index: false };
        else if (div.getAttribute("GroupID"))
            return this.treeModel.findElem("GroupID", div.getAttribute("GroupID"));
        else if (div.getAttribute("LayerID"))
            return this.treeModel.findElem("name", div.getAttribute("LayerID"));
        else if (div.getAttribute("MultiLayerID"))
            return this.treeModel.findElem("name", div.getAttribute("MultiLayerID"));
    }

    //Дерево основной карты
    var _layersTree = new layersTree({ showVisibilityCheckbox: true, allowActive: true, allowDblClick: true });

    window.layersTree = layersTree;
    window._layersTree = _layersTree;

    //Виджет в левой панели для отображения основного дерева
    var queryMapLayers = function() {
        this.buildedTree = null;
        this.builded = false;

        this.buttonsCanvas = _div();

        this.loadDeferred = $.Deferred();
    }

    queryMapLayers.prototype = new leftMenu();

    queryMapLayers.prototype.addLayers = function(data, condition, mapStyles, LayersTreePermalinkParams) {
        if (condition)
            _layersTree.condition = condition;

        if (mapStyles)
            _layersTree.mapStyles = mapStyles;

        if (LayersTreePermalinkParams)
            _layersTree.LayersTreePermalinkParams = LayersTreePermalinkParams;

        this.buildedTree = _layersTree.drawTree(data);
    }

    queryMapLayers.prototype.applyState = function(condition, mapLayersParam, div) {
        if (!objLength(condition.visible) && !objLength(condition.expanded) && !objLength(mapLayersParam))
            return;

        var parentElem = typeof div == 'undefined' ? _layersTree.treeModel.getRawTree() : _layersTree.findTreeElem(div).elem,
            visFlag = typeof div == 'undefined' ? true : _layersTree.getLayerVisibility($(div).find('input[type="checkbox"]')[0]),
            _this = this;

        _mapHelper.findTreeElems(parentElem, function(elem, visibleFlag) {
            var props = elem.content.properties;
            if (elem.type == 'group') {
                var groupId = props.GroupID;

                if (typeof condition.visible[groupId] != 'undefined' && props.visible != condition.visible[groupId]) {
                    props.visible = condition.visible[groupId];

                    var group = $(_this.buildedTree).find("div[GroupID='" + groupId + "']");

                    if (group.length)
                        $(group).find('input[type="checkbox"]')[0].checked = condition.visible[groupId];
                }

                if (typeof condition.expanded[groupId] != 'undefined' && props.expanded != condition.expanded[groupId]) {
                    props.expanded = condition.expanded[groupId];

                    var group = $(_this.buildedTree).find("div[GroupID='" + groupId + "']");

                    if (group.length) {
                        var clickDiv = $(group[0].parentNode).children("div.hitarea");

                        if (clickDiv.length)
                            $(clickDiv[0]).trigger("click");
                    }
                }
            } else {
                var name = props.name;
                if (typeof condition.visible[name] != 'undefined') {
                    _layersTree.treeModel.setNodeVisibility(elem, condition.visible[name]);
                } else {
                    _layersTree.treeModel.setNodeVisibility(elem, props.initVisible);
                }

                if (props.type == "Vector" && typeof mapLayersParam != 'undefined' && typeof mapLayersParam[name] != 'undefined' &&
                    !_this.equalStyles(props.styles, mapLayersParam[name])) {
                    // что-то менялось в стилях
                    var newStyles = mapLayersParam[name],
                        div = $(_this.buildedTree).find("div[LayerID='" + props.LayerID + "']")[0];

                    props.styles = newStyles;

                    _mapHelper.updateMapStyles(newStyles, name);
                    props.changedByViewer = true;

                    div && _mapHelper.updateTreeStyles(newStyles, div, _layersTree, true);
                }
            }
        }, visFlag)
    }

    queryMapLayers.prototype.equalStyles = function(style1, style2) {
        if (style1.length != style2.length)
            return false;

        for (var i = 0; i < style1.length; i++)
            if (!equals(style1[i], style2[i]))
                return false;

        return true;
    }

    queryMapLayers.prototype.getContainerBefore = function() {
        if (!this.builded) return;

        return $('.layers-before', this.workCanvas).show();
    }

    queryMapLayers.prototype.getContainerAfter = function() {
        if (!this.builded) return;

        return $('.layers-after', this.workCanvas).show();
    }

    queryMapLayers.prototype.load = function(data) {
        if (this.buildedTree && !this.builded) {
            var _this = this;

            this.treeCanvas = _div(null, [
                ['dir', 'className', 'layers-tree']
            ]);

            //Для обратной совместимости - есть много мапплетов карт, которые пытаются интегрироваться после первого table
            //TODO: изнечтожить все такие мапплеты
            _(this.workCanvas, [_table()]);

            _(this.workCanvas, [
                _div([
                    //_table([_tbody([_tr([_td([_span([_t(_gtxt("Шкала прозрачности"))],[['css','marginLeft','7px'],['css','color','#153069'],['css','fontSize','12px']])]), _td([this.rasterLayersSlider(_queryMapLayers.treeCanvas)])])])])
                ], [
                    ['dir', 'className', 'layers-before'],
                    ['css', 'display', 'none']
                ])
            ]);

            _(this.workCanvas, [this.treeCanvas]);

            _(this.treeCanvas, [this.buildedTree]);

            _(this.workCanvas, [
                _div([
                    //_table([_tbody([_tr([_td([_span([_t(_gtxt("Шкала прозрачности"))],[['css','marginLeft','7px'],['css','color','#153069'],['css','fontSize','12px']])]), _td([this.rasterLayersSlider(_queryMapLayers.treeCanvas)])])])])
                ], [
                    ['dir', 'className', 'layers-after'],
                    ['css', 'display', 'none']
                ])
            ]);

            $(this.buildedTree).treeview();

            _layersTree.runLoadingFuncs();

            _layersTree.addExpandedEvents(this.buildedTree);

            //при клике на любом пустом месте дерева слоёв снимаем выделение
            $(this.treeCanvas).click(function(event) {
                var t = $(event.target);
                //все элементы, на которых можно кликнуть без снятия выделения
                if (t.hasClass('hitarea') || t.hasClass('groupLayer') || t.attr('styletype') || t.parents('div[layerid],div[MultiLayerID]').length) {
                    return;
                }
                _layersTree.setActive(null);
            });

            $(this.treeCanvas).droppable({
                accept: "span[dragg]",
                drop: function(ev, ui) {
                    queryMapLayers._droppableHandler.bind($(_this.buildedTree).find('[mapid]')[0], ev, ui)();
                }
            })

            this.applyState(_layersTree.condition, _layersTree.mapStyles);

            this.builded = true;

            $(this).triggerHandler('load');
            this.loadDeferred.resolve();
        }
    }

    queryMapLayers.prototype.applyOpacityToRasterLayers = function(opacity, parent) {

        var active = $(parent).find(".active");

        // слой
        if (active[0] && (active[0].parentNode.getAttribute("LayerID") || active[0].parentNode.getAttribute("MultiLayerID"))) {
            var props = active[0].parentNode.gmxProperties.content.properties,
                layer = nsGmx.gmxMap.layersByID[props.name];

            layer.setRasterOpacity && layer.setRasterOpacity(opacity / 100);

            return;
        }

        if (active.length) {
            // группа или карта
            var treeElem = _layersTree.findTreeElem(active[0].parentNode);

            _mapHelper.findChilds(treeElem.elem, function(child) {
                var props = child.content.properties;
                var layer = nsGmx.gmxMap.layersByID[props.name];
                layer.setRasterOpacity && layer.setRasterOpacity(opacity / 100);
            }, true);
        } else {
            // все растровые слои
            var layers = nsGmx.gmxMap.layers;
            for (var i = 0; i < layers.length; i++) {
                layers[i].setRasterOpacity && layers[i].setRasterOpacity(opacity / 100);
            }
        }
    }

    queryMapLayers.prototype.rasterLayersSlider = function(parent) {
        var slider = nsGmx.Controls.createSlider(100,
                function(event, ui) {
                    _queryMapLayers.applyOpacityToRasterLayers(ui.value, parent);
                }),
            elem = _div([slider], [
                ['css', 'width', '120px']
            ]);

        slider.style.margin = '10px';
        slider.style.backgroundColor = '#F4F4F4';

        _title(slider, _gtxt("Прозрачность выбранного слоя/группы/карты"));

        return _div([elem], [
            ['css', 'padding', '5px 0px 0px 15px']
        ]);
    }

    queryMapLayers.prototype.currentMapRights = function() {
        var mapProperties = _layersTree.treeModel && _layersTree.treeModel.getMapProperties();
        return mapProperties ? mapProperties.Access : "none";
    }

    queryMapLayers.prototype.layerRights = function(name) {
        var layer = nsGmx.gmxMap.layersByID[name];
        return layer ? layer.getGmxProperties().Access : null;
    }

    queryMapLayers.prototype.addUserActions = function() {
        if (this.currentMapRights() == "edit") {
            this.addDraggable(this.treeCanvas);

            this.addDroppable(this.treeCanvas);

            this.addSwappable(this.treeCanvas);
        }
    }

    queryMapLayers.prototype.removeUserActions = function() {
        //	removeChilds(this.buttonsCanvas);

        this.removeDraggable(this.treeCanvas);

        this.removeDroppable(this.treeCanvas);

        this.removeSwappable(this.treeCanvas);
    }

    queryMapLayers.prototype.addDraggable = function(parent) {
        $(parent).find("span[dragg]").draggable({
            helper: function(ev) {
                return _layersTree.dummyNode(ev.target)
            },
            cursorAt: { left: 5, top: 10 },
            appendTo: document.body
        });
    }
    queryMapLayers.prototype.removeDraggable = function(parent) {
        $(parent).find("span[dragg]").draggable('destroy');
    }

    queryMapLayers._droppableHandler = function(ev, ui) {
        $('body').css("cursor", '');

        // удалим элемент, отображающий копирование
        ui.helper[0].removeNode(true)

        // уберем заведомо ложные варианты - сам в себя, копирование условий
        if (this == ui.draggable[0].parentNode.parentNode) return;

        var circle = false,
            layerManager = false;

        $(this).parents().each(function() {
            if ($(this).prev().length > 0 && $(this).prev()[0] == ui.draggable[0].parentNode.parentNode)
                circle = true;
        })

        if (circle) return;

        var isFromExternalMaps = false;
        $(ui.draggable[0].parentNode.parentNode).parents().each(function() {
            if (this == $('#layersList')[0] || this == $('#mapsList')[0] || this == $('#externalMapsCanvas')[0])
                layerManager = true;

            if (this == $('#externalMapsCanvas')[0])
                isFromExternalMaps = true;
        })

        if (!layerManager)
            _layersTree.moveHandler(ui.draggable[0], this)
        else
            _layersTree.copyHandler(ui.draggable[0].parentNode.parentNode.gmxProperties, this, false, !isFromExternalMaps)
    }

    queryMapLayers.prototype.addDroppable = function(parent) {
        $(parent).find("div[GroupID],div[MapID]").droppable({
            accept: "span[dragg]",
            hoverClass: 'droppableHover',
            greedy: true,
            drop: queryMapLayers._droppableHandler
        })

        $(parent).find("div[LayerID],div[MultiLayerID]").droppable({
            accept: "span[dragg]",
            greedy: true,
            drop: function(ev, ui) {
                var swapElem = $(this).next();
                swapElem.removeClass('swap-droppableHover');
                queryMapLayers._swapHandler.call(swapElem[0], ev, ui);
            },
            over: function(ev, ui) {
                $(this).next().addClass('swap-droppableHover');
            },
            out: function(ev, ui) {
                $(this).next().removeClass('swap-droppableHover');
            }
        })
    }
    queryMapLayers.prototype.removeDroppable = function(parent) {
        $(parent).find("div[GroupID],div[MapID]").droppable('destroy');
    }

    //статическая ф-ция
    queryMapLayers._swapHandler = function(ev, ui) {
        $('body').css("cursor", '');

        // удалим элемент, отображающий копирование
        ui.helper[0].removeNode(true);

        //проверим, не идёт ли копирование группы внутрь самой себя
        var circle = false;

        $(this).parents().each(function() {
            if ($(this).prev().length > 0 && $(this).prev()[0] == ui.draggable[0].parentNode.parentNode)
                circle = true;
        })

        if (circle) return;

        var layerManager = false;

        var isFromExternalMaps = false;
        $(ui.draggable[0].parentNode.parentNode).parents().each(function() {
            if (this == $('#layersList')[0] || this == $('#mapsList')[0] || this == $('#externalMapsCanvas')[0])
                layerManager = true;

            if (this == $('#externalMapsCanvas')[0])
                isFromExternalMaps = true;
        })

        var gmxProperties = ui.draggable[0].parentNode.parentNode.gmxProperties;

        if (!layerManager)
            _layersTree.swapHandler(ui.draggable[0], this)
        else
            _layersTree.copyHandler(gmxProperties, this, true, !isFromExternalMaps)
    }

    queryMapLayers.prototype.addSwappable = function(parent) {
        $(parent).find("div[swap]").droppable({ accept: "span[dragg]", hoverClass: 'swap-droppableHover', greedy: true, drop: queryMapLayers._swapHandler })
    }
    queryMapLayers.prototype.removeSwappable = function(parent) {
        $(parent).find("div[swap]").droppable('destroy');
    }

    queryMapLayers.prototype.asyncCreateLayer = function(promise, title) {
        var _this = this;

        var taskDiv = _div(),
            active = $(_this.buildedTree).find(".active")[0],
            parentDiv;

        if (active && (active.parentNode.getAttribute('MapID') || active.parentNode.getAttribute('GroupID')))
            parentDiv = active.parentNode.parentNode;
        else
            parentDiv = _this.buildedTree.firstChild;

        _abstractTree.addNode(parentDiv, _li([taskDiv, _div(null, [
            ['css', 'height', '5px'],
            ['css', 'fontSize', '0px']
        ])]));

        promise.fail(function(taskInfo) {
            var parentTree = taskDiv.parentNode.parentNode;
            taskDiv.parentNode.removeNode(true);
            _abstractTree.delNode(null, parentTree, parentTree.parentNode);
        }).done(function(taskInfo) {
            if (!$.isArray(taskInfo.Result)) {
                taskInfo.Result = [taskInfo.Result];
            }

            var parentDiv = $(taskDiv.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0],
                parentProperties = parentDiv.gmxProperties;

            var parentTree = taskDiv.parentNode.parentNode;
            taskDiv.parentNode.removeNode(true);
            _abstractTree.delNode(null, parentTree, parentTree.parentNode);

            for (var l = 0; l < taskInfo.Result.length; l++) {
                var newLayer = taskInfo.Result[l];
                var newProps = newLayer.properties;

                var mapProperties = _layersTree.treeModel.getMapProperties();
                newProps.mapName = mapProperties.name;
                newProps.hostName = mapProperties.hostName;
                newProps.visible = true;

                if (!newProps.styles) {
                    if (newProps.type == 'Vector')
                        newProps.styles = [{ MinZoom: 1, MaxZoom: 21, RenderStyle: newProps.IsPhotoLayer ? _mapHelper.defaultPhotoIconStyles[newProps.GeometryType] : _mapHelper.defaultStyles[newProps.GeometryType] }]
                    else if (newProps.type != 'Vector' && !newProps.MultiLayerID)
                        newProps.styles = [{ MinZoom: newProps.MinZoom, MaxZoom: 21 }];
                }

                var convertedCoords = newLayer.geometry ? L.gmxUtil.convertGeometry(newLayer.geometry, true) : null;

                _layersTree.addLayersToMap({ content: { properties: newProps, geometry: newLayer.geometry } });

                var li = _layersTree.getChildsList({
                        type: 'layer',
                        content: { properties: newProps, geometry: convertedCoords }
                    },
                    parentProperties,
                    false,
                    parentDiv.getAttribute('MapID') ? true : _layersTree.getLayerVisibility($(parentDiv).find('input[type="checkbox"]')[0])
                );

                _abstractTree.addNode(parentDiv.parentNode, li);

                var divElem = $(li).children("div[LayerID]")[0],
                    divParent = $(li.parentNode.parentNode).children("div[MapID],div[GroupID]")[0];

                _layersTree.addTreeElem(divParent, 0, { type: 'layer', content: { properties: newProps, geometry: convertedCoords } });

                _queryMapLayers.addSwappable(li);

                _queryMapLayers.addDraggable(li);

                _layersTree.updateListType(li);
            }

            _mapHelper.updateUnloadEvent(true);
            _layersTree.updateZIndexes();
        }).progress(function(taskInfo) {
            $(taskDiv).empty();
            _(taskDiv, [_span([_t(title + ':')], [
                ['css', 'color', '#153069'],
                ['css', 'margin', '0px 3px']
            ]), _t(taskInfo.Status)])
        })
    }

    queryMapLayers.prototype.asyncUpdateLayer = function(promise, properties, recreateLayer) {
        var layerDiv = $(_queryMapLayers.buildedTree).find("[LayerID='" + properties.LayerID + "']")[0],
            _this = this;

        promise
            .done(function(taskInfo) {
                if (recreateLayer) {
                    var newLayerProperties = taskInfo.Result.properties;

                    var mapProperties = _layersTree.treeModel.getMapProperties();
                    newLayerProperties.mapName = mapProperties.name;
                    newLayerProperties.hostName = mapProperties.hostName;
                    newLayerProperties.visible = layerDiv.gmxProperties.content.properties.visible;

                    newLayerProperties.styles = layerDiv.gmxProperties.content.properties.styles;

                    //var convertedCoords = from_merc_geometry(taskInfo.Result.geometry);
                    var origGeometry = taskInfo.Result.geometry,
                        convertedGeometry = origGeometry ? L.gmxUtil.geometryToGeoJSON(origGeometry, true) : null;

                    _this.removeLayer(newLayerProperties.name);

                    _layersTree.addLayersToMap({ content: { properties: newLayerProperties, geometry: origGeometry } });

                    var parentProperties = $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0].gmxProperties,
                        li = _layersTree.getChildsList({ type: 'layer', content: { properties: newLayerProperties, geometry: convertedGeometry } }, parentProperties, false, _layersTree.getLayerVisibility($(layerDiv).find('input[type="checkbox"]')[0]));

                    $(li).find('[multiStyle]').treeview();

                    $(layerDiv.parentNode).replaceWith(li);

                    _layersTree.findTreeElem($(li).children("div[LayerID]")[0]).elem = { type: 'layer', content: { properties: newLayerProperties, geometry: convertedGeometry } }

                    _queryMapLayers.addSwappable(li);

                    _queryMapLayers.addDraggable(li);

                    _layersTree.updateListType(li);
                    _layersTree.updateZIndexes();

                    var checkedLayer = nsGmx.gmxMap.layersByID[newLayerProperties.name];
                    if (checkedLayer) {
                        L.gmx.layersVersion.chkVersion(checkedLayer);
                    };
                } else {
                    $('#' + taskInfo.TaskID).remove();

                    layerDiv.style.display = '';
                }
            }).fail(function(taskInfo) {
                $('#' + taskInfo.TaskID).remove();
                layerDiv.style.display = '';
            }).progress(function(taskInfo) {
                var taskDiv;

                if (!$('#' + taskInfo.TaskID).length) {
                    taskDiv = _div(null, [
                        ['attr', 'id', taskInfo.TaskID]
                    ]);

                    layerDiv.style.display = 'none';

                    $(layerDiv).before(taskDiv);
                } else {
                    taskDiv = $('#' + taskInfo.TaskID)[0];

                    $(taskDiv).empty();
                }

                _(taskDiv, [_span([_t(properties.Title + ':')], [
                    ['css', 'color', '#153069'],
                    ['css', 'margin', '0px 3px']
                ]), _t(taskInfo.Status)]);
            })
    }

    queryMapLayers.prototype.asyncCopyLayer = function(promise, title) {
        console.log('layer copied');

        var _this = this;

        var taskDiv = _div(),
            active = $(_this.buildedTree).find(".active")[0],
            parentDiv;

        if (active && (active.parentNode.getAttribute('MapID') || active.parentNode.getAttribute('GroupID')))
            parentDiv = active.parentNode.parentNode;
        else
            parentDiv = _this.buildedTree.firstChild;

        _abstractTree.addNode(parentDiv, _li([taskDiv, _div(null, [
            ['css', 'height', '5px'],
            ['css', 'fontSize', '0px']
        ])]));

        promise.fail(function(taskInfo) {
            console.log('failed');
            var parentTree = taskDiv.parentNode.parentNode;
            taskDiv.parentNode.removeNode(true);
            _abstractTree.delNode(null, parentTree, parentTree.parentNode);
        }).done(function(taskInfo) {
            console.log('ok');
            if (!$.isArray(taskInfo.Result)) {
                taskInfo.Result = [taskInfo.Result];
            }

            var parentDiv = $(taskDiv.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0],
                parentProperties = parentDiv.gmxProperties;

            var parentTree = taskDiv.parentNode.parentNode;
            taskDiv.parentNode.removeNode(true);
            _abstractTree.delNode(null, parentTree, parentTree.parentNode);

            for (var l = 0; l < taskInfo.Result.length; l++) {
                var newLayer = taskInfo.Result[l];
                var newProps = newLayer.properties;

                var mapProperties = _layersTree.treeModel.getMapProperties();
                newProps.mapName = mapProperties.name;
                newProps.hostName = mapProperties.hostName;
                newProps.visible = true;

                if (!newProps.styles) {
                    if (newProps.type == 'Vector')
                        newProps.styles = [{ MinZoom: 1, MaxZoom: 21, RenderStyle: newProps.IsPhotoLayer ? _mapHelper.defaultPhotoIconStyles[newProps.GeometryType] : _mapHelper.defaultStyles[newProps.GeometryType] }]
                    else if (newProps.type != 'Vector' && !newProps.MultiLayerID)
                        newProps.styles = [{ MinZoom: newProps.MinZoom, MaxZoom: 21 }];
                }

                var convertedCoords = newLayer.geometry ? L.gmxUtil.convertGeometry(newLayer.geometry, true) : null;

                _layersTree.addLayersToMap({ content: { properties: newProps, geometry: newLayer.geometry } });

                var li = _layersTree.getChildsList({
                        type: 'layer',
                        content: { properties: newProps, geometry: convertedCoords }
                    },
                    parentProperties,
                    false,
                    parentDiv.getAttribute('MapID') ? true : _layersTree.getLayerVisibility($(parentDiv).find('input[type="checkbox"]')[0])
                );

                _abstractTree.addNode(parentDiv.parentNode, li);

                var divElem = $(li).children("div[LayerID]")[0],
                    divParent = $(li.parentNode.parentNode).children("div[MapID],div[GroupID]")[0];

                _layersTree.addTreeElem(divParent, 0, { type: 'layer', content: { properties: newProps, geometry: convertedCoords } });

                _queryMapLayers.addSwappable(li);

                _queryMapLayers.addDraggable(li);

                _layersTree.updateListType(li);
            }

            _mapHelper.updateUnloadEvent(true);
            _layersTree.updateZIndexes();
        }).progress(function(taskInfo) {
            console.log('progress');
            $(taskDiv).empty();
            _(taskDiv, [_span([_t(title + ':')], [
                ['css', 'color', '#153069'],
                ['css', 'margin', '0px 3px']
            ]), _t(taskInfo.Status)])
        }).always(function(taskInfo) {
            console.log(taskInfo);
        })
    }

    queryMapLayers.prototype.removeLayer = function(name) {
        var layer = nsGmx.gmxMap.layersByID[name];
        if (layer) {
            nsGmx.leafletMap.removeLayer(layer);
            nsGmx.gmxMap.removeLayer(layer);
        }
    }

    queryMapLayers.prototype.getLayers = function() {
        this.createLayersManager();
    }

    queryMapLayers.prototype.createLayersManager = function() {
        var canvas = _div();
        var layerManagerControl = new nsGmx.LayerManagerControl(canvas, 'layers');

        var existLayers = [];
        for (var i = 0; i < nsGmx.gmxMap.layers.length; i++)
            existLayers.push(nsGmx.gmxMap.layers[i].getGmxProperties().name);

        layerManagerControl.disableLayers(existLayers);

        var dialogDiv = showDialog(_gtxt("Список слоев"), canvas, 571, 485, 535, 130, function(size) {
            layerManagerControl.resize(size.height - 55);
        });
    }

    queryMapLayers.prototype.getMaps = function() {
        if (!$('#mapsList').length)
            new nsGmx.MapsManagerControl();
    }

    queryMapLayers.prototype.createMapDialog = function(title, buttonName, func, addLink) {
        var uiTemplate = Handlebars.compile(
            '<div class = "createMap-container">' +
            '<input class = "inputStyle inputFullWidth createMap-input">' +
            '<button class = "createMap-button">{{buttonName}}</button>' +
            '</div>');

        var ui = $(uiTemplate({ buttonName: buttonName })),
            input = $('.createMap-input', ui)[0];

        var tryCreateMap = function() {
            input.focus();
            if (input.value != '') {
                removeDialog(dialogDiv);
                func(input.value);
            } else {
                inputError(input);
            }
        }

        $(input, ui).on('keydown', function(e) {
            if (e.keyCode === 13) {
                tryCreateMap();
                return false;
            }
        })

        $('.createMap-button', ui).click(tryCreateMap)

        addLink && ui.append(addLink);

        var dialogDiv = showDialog(title, ui[0], 280, 115 + (addLink ? 20 : 0), false, false);
    }

    queryMapLayers.prototype.createMap = function(name) {
        sendCrossDomainJSONRequest(serverBase + 'Map/Insert.ashx?WrapStyle=func&Title=' + encodeURIComponent(name), function(response) {
            if (!parseResponse(response))
                return;

            window.location.replace(window.location.href.split(/\?|#/)[0] + "?" + response.Result);
        })
    };

    (function() {

        var saveMapInternal = function(scriptName, mapTitle, callback) {
            var mapID = String($(_queryMapLayers.buildedTree).find("[MapID]")[0].gmxProperties.properties.MapID),
                saveTree = {};

            window._mapEditorsHash && _mapEditorsHash[mapID] && _mapEditorsHash[mapID].update();

            //обновим стили слоёв из всех незакрытых диалогов редактирования стилей
            var mStyleEditor = gmxCore.getModule('LayerStylesEditor');
            mStyleEditor && mStyleEditor.updateAllStyles();

            nsGmx.userObjectsManager.collect();
            $(_queryMapLayers.buildedTree).find("[MapID]")[0].gmxProperties.properties.UserData = JSON.stringify(nsGmx.userObjectsManager.getData());

            $.extend(true, saveTree, _layersTree.treeModel.getRawTree());

            var attributesToSave = ['visible', 'styles', 'AllowSearch', 'TiledQuicklook', 'TiledQuicklookMinZoom', 'name', 'MapStructureID'];
            saveTree.properties.BaseLayers = JSON.stringify(nsGmx.leafletMap.gmxBaseLayersManager.getActiveIDs());

            //раскрываем все группы так, как записано в свойствах групп
            _mapHelper.findTreeElems(saveTree, function(child, flag) {
                var props = child.content.properties;
                if (child.type === "group") {
                    props.expanded = typeof props.initExpand !== 'undefined' ? props.initExpand : false;
                    delete props.initVisible;
                    delete props.initExpand;
                } else {
                    var propsToSave = {};
                    for (var i = 0; i < attributesToSave.length; i++) {
                        var attrName = attributesToSave[i];
                        if (attrName in props) {
                            propsToSave[attrName] = props[attrName];
                        }
                    }

                    var styles = props.styles || [];

                    for (var s = 0; s < styles.length; s++) {
                        delete styles[s].HoverStyle;
                    }

                    child.content.properties = propsToSave;
                    delete child.content.geometry;
                }
            }, true);

            var params = {
                WrapStyle: 'window',
                MapID: mapID,

                MapJson: JSON.stringify(saveTree)
            }

            if (mapTitle)
                params.Title = mapTitle;

            sendCrossDomainPostRequest(serverBase + scriptName, params,
                function(response) {
                    if (!parseResponse(response))
                        return;

                    callback && callback(response.Result);

                    _mapHelper.updateUnloadEvent(false);

                    nsGmx.widgets.notifications.stopAction('saveMap', 'success', _gtxt("Сохранено"));
                }
            )
        }

        queryMapLayers.prototype.saveMap = function() {
            nsGmx.widgets.notifications.startAction('saveMap');
            saveMapInternal("Map/SaveMap.ashx", null);
        }

        queryMapLayers.prototype.saveMapAs = function(name) {
            nsGmx.widgets.notifications.startAction('saveMap');
            saveMapInternal("Map/SaveAs.ashx", name);
        }

    })();

    var _queryMapLayers = new queryMapLayers();
    window._queryMapLayers = _queryMapLayers;

    mapLayers.mapLayers.load = function() {
        var alreadyLoaded = _queryMapLayers.createWorkCanvas('layers', {
            path: null,
            showCloseButton: false,
            showMinimizeButton: false
        });

        if (!alreadyLoaded)
            _queryMapLayers.load()
    }
    mapLayers.mapLayers.unload = function() {}

})(nsGmx.Utils._);

!(function() {
//Контроллёр контектных меню и соответствующие пункты всех меню...

nsGmx = nsGmx || {};

/** 
* Контроллёр контекстных меню.
* @class
* @name ContextMenuController
* @memberOf nsGmx
* 
* @description Позволяет добавлять элементы контектсного меню разного типа и привязывать меню к отдельным DOM элементам. 
* Возможно динамическое создание меню при клике на объекте. Элементам меню передаётся контекст, 
* указанный при привязке меню к элементу (он так же может создаваться в момент клика на элементе)
* Каждый элемент меню - отдельный объект, они независимо добавляются в контроллер. 
* При создании меню определённого типа из этого набора выбираются нужные элементы.
*/
nsGmx.ContextMenuController = (function()
{
	var _menuItems = {};
	var SUGGEST_TIMEOUT = 700;
	
	// Показывает контектное меню для конкретного элемента. 
	// В Opera меню показывается при наведении на элемент в течении некоторого времени, во всех остальных браузерах - по правому клику.
	// Меню исчезает при потере фокуса
	// Параметры:
	// * elem {DOMElement} - элемент, на который навешивается меню
	// * menuFunc {Function, menuFunc()->DomElement} - функция, создающая меню
	// * checkFunc {Function, checkFunc()->Bool} - если возвращает false, то ничего не показывается...
	var _context = function(elem, menuFunc, checkFunc)
	{
        var menu = null;
        elem.oncontextmenu = function(e)
        {
            if (typeof checkFunc != 'undefined' && !checkFunc())
                return false;
                
            if (menu && menu.parentNode) 
                menu.parentNode.removeChild(menu);
                
            menu = menuFunc();
            if (!menu) return false;
            
            var contextMenu = _div([menu],[['dir','className','contextMenu'], ['attr','id','contextMenuCanvas']])
            
            var evt = e || window.event;
            
            hidden(contextMenu);
            document.body.appendChild(contextMenu)
            
            // определение координат курсора для ie
            if (evt.pageX == null && evt.clientX != null )
            {
                var html = document.documentElement
                var body = document.body
                
                evt.pageX = evt.clientX + (html && html.scrollLeft || body && body.scrollLeft || 0) - (html.clientLeft || 0)
                evt.pageY = evt.clientY + (html && html.scrollTop || body && body.scrollTop || 0) - (html.clientTop || 0)
            }
            
            if (evt.pageX + contextMenu.clientWidth < getWindowWidth())
                contextMenu.style.left = evt.pageX - 5 + 'px';
            else
                contextMenu.style.left = evt.pageX - contextMenu.clientWidth + 5 + 'px';
            
            if (evt.pageY + contextMenu.clientHeight < getWindowHeight())
                contextMenu.style.top = evt.pageY - 5 + 'px';
            else
                contextMenu.style.top = evt.pageY - contextMenu.clientHeight + 5 + 'px';
            
            visible(contextMenu)
            
            var menuArea = contextMenu.getBoundingClientRect();
            
            contextMenu.onmouseout = function(e)
            {
                var evt = e || window.event;
                
                // определение координат курсора для ie
                if (evt.pageX == null && evt.clientX != null )
                {
                    var html = document.documentElement
                    var body = document.body
                    
                    evt.pageX = evt.clientX + (html && html.scrollLeft || body && body.scrollLeft || 0) - (html.clientLeft || 0)
                    evt.pageY = evt.clientY + (html && html.scrollTop || body && body.scrollTop || 0) - (html.clientTop || 0)
                }
                
                if (evt.pageX <= menuArea.left || evt.pageX >= menuArea.right ||
                    evt.clientY <= menuArea.top || evt.clientY >= menuArea.bottom)
                {
                    menu = null;
                    contextMenu.removeNode(true);
                }
            }
            
            return false;
        }
	}	
	
	var _contextClose = function()
	{
        $('#contextMenuCanvas').remove();
	}	
	
	var _generateMenuDiv = function(type, context)
	{
        var uiTemplate = Handlebars.compile('<div>' +
            '{{#menuItems}}' +
                '{{#if separator}}<div class = "contextMenuSeparator"></div>{{/if}}' + 
                '<div class = "contextMenuItem" data-itemIndex="{{index}}">{{title}}</div>' +
            '{{/menuItems}}' +
        '</div>');
        
		var items = _menuItems[type],
            visibleItems = [];
		
		for (var e = 0; e < items.length; e++) {
			var menuElem = items[e];
            if (menuElem.isVisible && !menuElem.isVisible(context)) {
                continue;
            }
            
            visibleItems.push({
                index: e,
                title: typeof menuElem.title === 'function' ? menuElem.title() : menuElem.title,
                separator: menuElem.isSeparatorBefore && menuElem.isSeparatorBefore(context)
            });
        }
        
        if (visibleItems.length) {
            var ui = $(uiTemplate({menuItems: visibleItems}));
            ui.find('.contextMenuItem').click(function() {
                var itemIndex = Number($(this).data('itemindex'));
                context.contentMenuArea = getOffsetRect(this);
                context.contentMenuType = type;
                _contextClose();
                _menuItems[type][itemIndex].clickCallback(context);
            });
            
            return ui[0];
        }
        
        return null;
	}
	
	//public interface
	return {
	
		/**
		 * Добавляет новый пункт меню
         * @memberOf nsGmx.ContextMenuController
		 * @function
		 * @param {nsGmx.ContextMenuController.IContextMenuElem} menuItem Элемент контекстного меню
		 * @param {String | String[]} menuType Тип меню (например: "Layer", "Map", "Group"). Если массив, то данный элемент применяется в нескольких типах меню
		 */
		addContextMenuElem: function(menuItem, menuType)
		{
			if (typeof menuType === 'string')
				menuType = [menuType];
				
			for (var i = 0; i < menuType.length; i++)
			{
				_menuItems[menuType[i]] = _menuItems[menuType[i]] || [];
				_menuItems[menuType[i]].push(menuItem);
			}
		},
		
		/**
		 * Добавляет к DOM элементу контекстное меню
		 * @function
         * @memberOf nsGmx.ContextMenuController
		 * @param {DOMElement} elem Целевой DOM-элемент
		 * @param {String} type Тип меню
		 * @param {function():Boolean} checkFunc Проверка, показывать ли сейчас меню. Если ф-ция возвращает false, меню не показывается
		 * @param {Object|function(context):Object} context Контекст, который будет передан в элемент меню при клике на DOM-элементе. 
		 *        Если контект - ф-ция, она будет вызвана непосредственно при клике. В контекст при клике будут добавлены элементы contentMenuArea и contentMenuType.
		 */
		bindMenuToElem: function(elem, type, checkFunc, context)
		{
			_context(elem, function()
			{
				if (typeof context === 'function')
					context = context(); //
					
				return _generateMenuDiv(type, context);
			}, checkFunc, SUGGEST_TIMEOUT)
		}
	}
})();


/** Интерфейс для задания контекстного меню пользователей
* @class
* @name nsGmx.ContextMenuController.IContextMenuElem
*/

/** Нужно ли отображать данный пункт меню для данного элемента и типа дерева. Необязательная (по умолчанию отображается)
@function
@name isVisible
@memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
@param {Object} context - контекст, специфический для конкретного типа меню
*/

/** Нужно ли рисовать перед данным пунктом разделитель (гориз. черту). Необязательная (по умолчанию не рисуется)
@function
@name isSeparatorBefore
@memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
@param {Object} context - контекст, специфический для конкретного типа меню
*/

/** Вызывается при клике по соответствующему пункту меню
* @function
* @name clickCallback
* @memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
* @param {object} context - контекст, который был передан при привязке меню к DOM-элементу. В контекст будут добавлены поля:
* 
*  * contentMenuArea {Object} - координаты верхнего левого угла пункта меню, на которое было нажатие. {left: int, top: int}. Если нужно привязаться к месту текущего клика
*  * contentMenuType {String}- тип вызванного контекстного меню. Актуально, если элемент меню используется в нескольких типах меню.
*/

/** Строка или ф-ция, которую нужно отображать в контекстном меню. Если ф-ция, то она будет вызываться при каждом формировании меню и должна возвращать строку.
@name title
@memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
*/


//Все заголовки элементов меню заданы как ф-ции, так как на момент выполенения этого кода неизвестен выбранный язык системы

///////////////////////////////////////////////////////////////////////////////
/////////////////////////// Контекстное меню слоёв ////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/*
В контексте типа "Layer" присутствуют следующие атрибуты:
 * layerManagerFlag {int} Тип дерева
 * elem Элемент (слой), для которого стротся меню
 * tree {layersTree} Текущее дерево, внутри которого находится слой
*/

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Свойства"); },
	isVisible: function(context)
	{
		return !context.layerManagerFlag && nsGmx.AuthManager.isLogin();
	},
	clickCallback: function(context)
	{
		var div;
		if (context.elem.MultiLayerID)
			div = $(_queryMapLayers.buildedTree).find("div[MultiLayerID='" + context.elem.MultiLayerID + "']")[0];
		else
			div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + context.elem.name + "']")[0];
		_mapHelper.createLayerEditor(div, context.tree, 'main', div.gmxProperties.content.properties.styles.length > 1 ? -1 : 0);
	}
}, 'Layer');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Стили"); },
	isVisible: function(context)
	{
		return !context.layerManagerFlag && context.elem.type === "Vector" && _queryMapLayers.currentMapRights() === "edit";
	},
	clickCallback: function(context)
	{
        nsGmx.createStylesDialog(context.elem, context.tree);
	}
}, 'Layer');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Таблица атрибутов"); },
	isVisible: function(context)
	{
		return !context.layerManagerFlag && (_queryMapLayers.currentMapRights() === "edit" || _queryMapLayers.layerRights(context.elem.name) == 'edit' || _queryMapLayers.layerRights(context.elem.name) === 'editrows') && context.elem.type === "Vector";
	},
	clickCallback: function(context)
	{
		nsGmx.createAttributesTable(context.elem.name);
	}
}, 'Layer');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Права доступа"); },
	isVisible: function(context)
	{
		return !context.layerManagerFlag && 
				nsGmx.AuthManager.canDoAction( nsGmx.ACTION_SEE_MAP_RIGHTS ) && 
				_queryMapLayers.layerRights(context.elem.name) === 'edit';
	},
	clickCallback: function(context) {
		if (context.elem.MultiLayerID) {
            var securityDialog = new nsGmx.multiLayerSecurity();
			securityDialog.getRights(context.elem.MultiLayerID, context.elem.title);
        } else {
            var securityDialog = new nsGmx.layerSecurity(context.elem.type);
			securityDialog.getRights(context.elem.name, context.elem.title);
        }
	}
}, 'Layer');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Скачать"); },
	isVisible: function(context)
	{
		return !context.layerManagerFlag && 
				( _queryMapLayers.currentMapRights() === "edit" || (_queryMapLayers.currentMapRights() == "view" && nsGmx.AuthManager.isLogin() ) ) && 
				context.elem.type == "Vector" &&
				context.tree.treeModel.getMapProperties().CanDownloadVectors;
	},
	clickCallback: function(context)
	{
		_mapHelper.downloadVectorLayer({
            name: context.elem.name,
            host: context.elem.hostName
        });
	}
}, 'Layer');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Удалить"); },
	isVisible: function(context)
	{
		return !context.layerManagerFlag && _queryMapLayers.currentMapRights() === "edit";
	},
	clickCallback: function(context)
	{
		_queryMapLayers.removeLayer(context.elem.name)
		
		var div;
			
		if (context.elem.MultiLayerID)
			div = $(_queryMapLayers.buildedTree).find("div[MultiLayerID='" + context.elem.MultiLayerID + "']")[0];
		else
			div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + context.elem.name + "']")[0];
		
		var treeElem = _layersTree.findTreeElem(div).elem,
			node = div.parentNode,
			parentTree = node.parentNode;
		
		_layersTree.removeTreeElem(div);

		node.removeNode(true);
		
		_abstractTree.delNode(null, parentTree, parentTree.parentNode);
		
		_mapHelper.updateUnloadEvent(true);
	}
}, 'Layer');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Добавить снимки"); },
	isVisible: function(context)
	{
        var layerRights = _queryMapLayers.layerRights(context.elem.name);
		return !context.layerManagerFlag &&
               (layerRights === 'edit' || layerRights === 'editrows') && 
               context.elem.type == "Vector" &&
               context.elem.IsRasterCatalog;
	},
	clickCallback: function(context)
	{
        new nsGmx.RCAddLayerControl(nsGmx.gmxMap, context.elem.name);
	}
}, 'Layer');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Копировать стиль"); },
	isVisible: function(context)
	{
		return context.elem.type == "Vector" && 
		       (context.layerManagerFlag || _queryMapLayers.currentMapRights() === "edit");
	},
	isSeparatorBefore: function(context)
	{
		return !context.layerManagerFlag;
	},
	clickCallback: function(context)
	{            
		var rawTree = context.tree.treeModel,
            elem;
        if (context.elem.MultiLayerID)
			elem = rawTree.findElem("MultiLayerID", context.elem.MultiLayerID).elem;
		else
			elem = rawTree.findElem("LayerID", context.elem.name).elem;

        nsGmx.ClipboardController.addItem('LayerStyle', {type: context.elem.GeometryType, style: elem.content.properties.styles});
	}
}, 'Layer');

var applyStyleContentMenuItem = {
	title: function() { return _gtxt("Применить стиль"); },
	isVisible: function(context)
	{
        if (context.layerManagerFlag || 
            _queryMapLayers.currentMapRights() !== "edit" || 
            nsGmx.ClipboardController.getCount('LayerStyle') === 0 ) 
        {
            return false;
        }
        
        if (context.contentMenuType === 'Layer') {
            return context.elem.type == "Vector" && 
                nsGmx.ClipboardController.get('LayerStyle', -1).type === context.elem.GeometryType;
        } else { //группы
            return true;
        }
	},
	clickCallback: function(context)
	{
		var 
            newStyles = nsGmx.ClipboardController.get('LayerStyle', -1).style,
            stylesType = nsGmx.ClipboardController.get('LayerStyle', -1).type;
            
		if (context.contentMenuType === 'Layer') {
            var div;
            if (context.elem.MultiLayerID)
                div = $(_queryMapLayers.buildedTree).find("div[MultiLayerID='" + context.elem.MultiLayerID + "']")[0];
            else
                div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + context.elem.name + "']")[0];
            
            div.gmxProperties.content.properties.styles = newStyles;
            
            _mapHelper.updateMapStyles(newStyles, context.elem.name);
            
            _mapHelper.updateTreeStyles(newStyles, div, context.tree, true);
        } else { //группа
            var tree = context.tree.treeModel,
                node = tree.findElemByGmxProperties(context.div.gmxProperties).elem;
                
            tree.forEachLayer(function(layerContent) {
                if (layerContent.properties.type !== "Vector" || layerContent.properties.GeometryType !== stylesType){
                    return;
                };
                
                layerContent.properties.styles = newStyles;
                _mapHelper.updateMapStyles(newStyles, layerContent.properties.name);
                
                var div = context.tree.findUITreeElem({content: layerContent});
                if (div) {
                    // div.gmxProperties.content.properties.styles = newStyles;
                    _mapHelper.updateTreeStyles(newStyles, div, context.tree, true);
                }
            }, node);
        }
	}
};

nsGmx.ContextMenuController.addContextMenuElem(applyStyleContentMenuItem, 'Layer');

///////////////////////////////////////////////////////////////////////////////
/////////////////////////// Контекстное меню групп ////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/*
В контексте типа "Group" присутствуют следующие атрибуты:
 * div {DOMElement} Элемент дерева, для которого стротся меню
 * tree {layersTree} Текущее дерево карты
*/

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Свойства"); },
	clickCallback: function(context)
	{
		nsGmx.createGroupEditor(context.div);
	}
}, 'Group');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Добавить подгруппу"); },
	clickCallback: function(context)
	{
		nsGmx.addSubGroup(context.div, context.tree);
	}
}, 'Group');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Удалить"); },
	clickCallback: function(context)
	{
		context.tree.removeGroup(context.div);
		_mapHelper.updateUnloadEvent(true);
	}
}, 'Group');

nsGmx.ContextMenuController.addContextMenuElem(applyStyleContentMenuItem, 'Group');
///////////////////////////////////////////////////////////////////////////////
/////////////////////////// Контекстное меню карты ////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/*
В контексте типа "Map" присутствуют следующие атрибуты:
 * div {DOMElement} Элемент дерева, для которого стротся меню
 * tree {layersTree} Текущее дерево карты
*/
nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Свойства"); },
	clickCallback: function(context)
	{
		nsGmx.createMapEditor(context.div);
	}
}, 'Map');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Добавить подгруппу"); },
	clickCallback: function(context)
	{
		nsGmx.addSubGroup(context.div, context.tree);
	}
}, 'Map');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Права доступа"); },
	clickCallback: function(context)
	{
        var securityDialog = new nsGmx.mapSecurity();
		securityDialog.getRights(context.tree.treeModel.getMapProperties().MapID, context.tree.treeModel.getMapProperties().title);
	},
	isVisible: function(context)
	{
		return nsGmx.AuthManager.canDoAction(nsGmx.ACTION_SEE_MAP_RIGHTS) &&
            (_queryMapLayers.currentMapRights() === "edit" || nsGmx.AuthManager.isRole(nsGmx.ROLE_ADMIN));
	}
}, 'Map');

//групповое редактирование слоев
nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Права доступа к слоям"); },
	isVisible: function(context)
	{
		var treeModel = context.tree.treeModel,
			layersFlag = false,
			layersRights = false;
		treeModel.forEachNode(function (node) {
			if (node.type !== 'group') {
				layersFlag = true;
				if (_queryMapLayers.layerRights(node.content.properties.LayerID) === 'edit') {
					layersRights = true;
				}
			}
		});

		return nsGmx.AuthManager.canDoAction( nsGmx.ACTION_SEE_MAP_RIGHTS ) &&
			layersFlag &&
			layersRights;
	},
	clickCallback: function(context) {
        var securityDialog = new nsGmx.layersGroupSecurity(),
			props = _layersTree.treeModel.getMapProperties();
		securityDialog.getRights(props.MapID, props.title);

	}
}, 'Map');

})();

//рисует диалог со списком карт.
//позволяет загрузить карту, просмотреть слои карты, перетащить слой в текущую карту
!(function(_){

nsGmx.MapsManagerControl = function()
{
    var _this = this;
    this._activeIndex = 0;
    this._mapsTable = new nsGmx.ScrollTable();
    this._canvas = _div(null, [['attr','id','mapsList']]);
    this._mapPreview = null;
    
    $(this._canvas).append('<div class="gmx-icon-progress"></div>');
    
    this._dialogDiv = showDialog(_gtxt("Список карт"), this._canvas, 571, 360, 535, 130, this._resize.bind(this));
    
    sendCrossDomainJSONRequest(serverBase + "Map/GetMaps.ashx?WrapStyle=func", function(response)
    {
        $(_this._canvas).empty();
        
        if (!parseResponse(response))
            return;

        _this._drawMapsDialog(response.Result);
    })
    this._previewMapName = null;
}

nsGmx.MapsManagerControl.prototype._resize = function() {
    var canvas = this._canvas,
        mapsTable = this._mapsTable,
        mapPreview = this._mapPreview;
        
    var dialogWidth = canvas.parentNode.parentNode.offsetWidth;
    mapsTable.tableParent.style.width = dialogWidth - 15 - 21 + 'px';
    mapsTable.tableBody.parentNode.parentNode.style.width = dialogWidth + 5 - 21 + 'px';
    mapsTable.tableBody.parentNode.style.width = dialogWidth - 15 - 21 + 'px';

    mapsTable.tablePages.parentNode.parentNode.parentNode.parentNode.style.width = dialogWidth - 12 - 21 + 'px';

    mapsTable.tableParent.style.height = '200px';
    mapsTable.tableBody.parentNode.parentNode.style.height = '170px';
    
    if (mapPreview) {
        mapPreview.style.height = canvas.parentNode.offsetHeight - canvas.firstChild.offsetHeight - 250 + 'px';
        mapPreview.style.width = dialogWidth + 5 - 21 + 'px';
    }
}

nsGmx.MapsManagerControl.prototype._drawMapsDialog = function(mapsList)
{
    var searchUITemplate = Handlebars.compile(
        '<div class="mapslist-search">' +
            '<table class="mapslist-search-table"><tr>' +
                '<td>' +
                    '{{i "Название"}}<input class="inputStyle mapslist-search-name">' +
                '</td><td>' +
                    '{{i "Владелец"}}<input class="inputStyle mapslist-search-owner">' +
                '</td>' +
            '</tr></table>' +
        '</div>');
        
    var searchCanvas = $(searchUITemplate())[0];
	var canvas = this._canvas,
		name = 'maps',
        mapsTable = this._mapsTable,
		_this = this;
	
	var mapNameInput = $('.mapslist-search-name', searchCanvas)[0],
        mapOwnerInput = $('.mapslist-search-owner', searchCanvas)[0];
	_(canvas, [searchCanvas]);
	
	var tableParent = _div(),
		sortFuncs = {};
			
	var sign = function(n1, n2) { return n1 < n2 ? -1 : (n1 > n2 ? 1 : 0) };
	var sortFuncFactory = function(f1, f2) {
		return [
			function(_a,_b){ return sign(f1(_a), f1(_b)) || sign(f2(_a), f2(_b)); },
			function(_b,_a){ return sign(f1(_a), f1(_b)) || sign(f2(_a), f2(_b)); }
		]
	}
	
    var idFunc = function(_a){ return _a.Name; };
    var titleFunc = function(_a){ return String(_a.Title).toLowerCase(); };
    var ownerFunc = function(_a){ return String(_a.Owner).toLowerCase(); };
    var dateFunc  = function(_a){ return _a.LastModificationDateTime; };
    
	sortFuncs[_gtxt('Имя')]                 = sortFuncFactory(titleFunc, idFunc);
	sortFuncs[_gtxt('Владелец')]            = sortFuncFactory(ownerFunc, idFunc);
	sortFuncs[_gtxt('Последнее изменение')] = sortFuncFactory(dateFunc, idFunc);
	
	mapsTable.createTable(tableParent, name, 410, ["", _gtxt("Имя"), _gtxt("Владелец"), _gtxt("Последнее изменение"), ""], ['5%', '55%', '15%', '15%', '5%'], function(map, i)
    {
        return _this._drawMaps.call(this, map, i, _this);
    }, sortFuncs);
    
    mapsTable.getDataProvider().setSortFunctions(sortFuncs);
	
	var inputPredicate = function(value, fieldValue)
    {
        return !!value && String(value).toLowerCase().indexOf(fieldValue) > -1;
    };

    $([mapNameInput, mapOwnerInput]).bind('keydown', function(event) {
        var numItems = mapsTable.getVisibleItems().length;
        
        if (event.keyCode === 13) {
            var firstItem = mapsTable.getVisibleItems()[_this._activeIndex];
            firstItem && window.location.replace(window.location.href.split(/\?|#/)[0] + "?" + firstItem.Name);
        }
        
        if (event.keyCode === 38) {
            _this._activeIndex = Math.max(0, Math.min(_this._activeIndex - 1, numItems - 1));
            $(mapsTable.getDataProvider()).change();
            event.preventDefault();
        }
        
        if (event.keyCode === 40) {
            _this._activeIndex = Math.max(0, Math.min(_this._activeIndex + 1, numItems - 1));
            $(mapsTable.getDataProvider()).change();
            event.preventDefault();
        }
    })
    
	mapsTable.getDataProvider().attachFilterEvents(mapNameInput, 'Title', function(fieldName, fieldValue, vals)
	{
		if (fieldValue == "") {
			return vals;
        }
        
        fieldValue = fieldValue.toLowerCase();
		
        return vals.filter(function(value) {
            return inputPredicate(value[fieldName], fieldValue) || value['Name'].toLowerCase() === fieldValue;
        });
	})
	
	mapsTable.getDataProvider().attachFilterEvents(mapOwnerInput, 'Owner', function(fieldName, fieldValue, vals)
	{
		if (fieldValue == "") {
			return vals;
        }
        
        fieldValue = fieldValue.toLowerCase();
        
        return vals.filter(function(value) {
            return inputPredicate(value[fieldName], fieldValue);
        });
	})

	_(canvas, [tableParent]);
	
	mapsTable.tableHeader.firstChild.childNodes[1].style.textAlign = 'left';

	this._resize();
	
	mapsTable.getDataProvider().setOriginalItems(mapsList);
	
	mapNameInput.focus();
}

nsGmx.MapsManagerControl.prototype._drawMaps = function(map, mapIndex, mapsManager)
{
	var name = makeLinkButton(map.Title),
        img_url = map.Name === mapsManager._previewMapName ? 'img/collapse-arrow-se.png' : 'img/collapse-arrow-right.gif',
		load = makeImageButton(img_url, img_url),
		remove = makeImageButton("img/recycle.png", "img/recycle_a.png");

	_title(name, _gtxt("Загрузить"));
	_title(load, _gtxt("Показать"));
	_title(remove, _gtxt("Удалить"));
	
    name.className = name.className + ' maps-manager-mapname';
	
	name.onclick = function()
	{
		window.location.replace(window.location.href.split(/\?|#/)[0] + "?" + map.Name);
	}
    
    nsGmx.ContextMenuController.bindMenuToElem(name, 'MapListItem', function(){return true;},
    {
        name: map.Name
	});
	
	load.onclick = function()
	{
		$(mapsManager._mapPreview).empty();
		
		var loading = _div([_img(null, [['attr','src','img/progress.gif'],['css','marginRight','10px']]), _t(_gtxt('загрузка...'))], [['css','margin','3px 0px 3px 20px']]);
		
        if (!mapsManager._mapPreview) {
            mapsManager._mapPreview = _div(null, [['css','marginTop','5px'],['css','borderTop','1px solid #216B9C'],['css','overflowY','auto']]);
            $(mapsManager._canvas).append(mapsManager._mapPreview);
            $(mapsManager._dialogDiv).dialog('option', 'height', 550);
            $(mapsManager._dialogDiv).dialog('option', 'minHeight', 550);
            mapsManager._resize();
            
        }
		_(mapsManager._mapPreview, [loading]);
        

		// раз уж мы список получили с сервера, то и карты из этого списка точно нужно загружать с него же...
		mapsManager._loadMapJSON(window.serverBase, map.Name, mapsManager._mapPreview); 

        $(mapsManager._mapsTable.getDataProvider()).change();
	}
	
	remove.onclick = function()
	{
		if (map.Name == defaultMapID)
		{
			showErrorMessage(_gtxt("$$phrase$$_14"), true)
			
			return;
		}
		
		if (map.Name == globalMapName)
		{
			showErrorMessage(_gtxt("$$phrase$$_15"), true)
			
			return;
		}
		
		if (confirm(_gtxt("Вы действительно хотите удалить эту карту?")))
		{
			var loading = loading = _div([_img(null, [['attr','src','img/progress.gif']]), _t(_gtxt('удаление...'))], [['css','marginLeft','5px']]);
		
			$(remove.parentNode.parentNode).replaceWith(_tr([_td([loading], [['attr','colSpan', 5]])]))
			
			sendCrossDomainJSONRequest(serverBase + "Map/Delete.ashx?WrapStyle=func&MapID=" + map.MapID, function(response){mapsManager._deleteMapHandler(response, map.MapID)});
		}
	}
	
	var date = new Date(map.LastModificationDateTime*1000);
	var modificationDateString = $.datepicker.formatDate('dd.mm.yy', date); // + " " + date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds();
	
	var tr = _tr([
		_td([load], [['css','textAlign','center']]), 
		_td([name]), 
		_td([_t(map.Owner)], [['css','textAlign','center'],['dir','className','invisible maps-manager-owner'], ['dir','title',map.Owner]]), 
		_td([_t(modificationDateString)], [['css','textAlign','center'],['dir','className','invisible']]), 
		_td([remove], [['css','textAlign','center']])
	]);
	
	for (var i = 0; i < tr.childNodes.length; i++)
		tr.childNodes[i].style.width = this._fields[i].width;
	
	attachEffects(tr, 'hover');
    
    if (mapsManager._activeIndex === mapIndex) {
        $(tr).addClass('maps-manager-active');
    }
	
	return tr;
}

nsGmx.MapsManagerControl.prototype._deleteMapHandler = function(response, id)
{
	if (!parseResponse(response))
		return;
	
    var mapsTable = this._mapsTable;
    
	if (response.Result == 'deleted')
	{
        mapsTable.start = 0;
		mapsTable.reportStart = mapsTable.start * mapsTable.limit;
        mapsTable.getDataProvider().filterOriginalItems(function(elem)
		{
			return elem.MapID != id;
		});
	}
	else
		showErrorMessage(_gtxt("Ошибка!"), true, _gtxt("Слоя нет в базе"))
}

nsGmx.MapsManagerControl.prototype._loadMapJSON = function(host, name, parent)
{
	//loadMapJSON(host, name, function(layers)
    this._previewMapName = name;
    
    var hostName = L.gmxUtil.normalizeHostname(host),
        apiKey = window.mapsSite ? window.apiKey : null; //передаём apiKey только если не локальная версия ГеоМиксера
    
    L.gmx.gmxMapManager.getMap(hostName, apiKey, name, window.gmxSkipTiles).then(function(mapInfo) {
        var previewLayersTree = new layersTree({showVisibilityCheckbox: false, allowActive: false, allowDblClick: false}),
            ul = previewLayersTree.drawTree(mapInfo, 2);

        $(ul).treeview();

        //раскрываем группы по клику
        $(ul).click(function(event) {
            if ($(event.target).hasClass('groupLayer')) {
                var clickDiv = $(event.target.parentNode.parentNode.parentNode).children("div.hitarea");
                clickDiv.length && $(clickDiv[0]).trigger('click');
            }
        })
		
		$(parent).empty();
        
        var hint = $('<div class="mapslist-hint">' + _gtxt('maplist.hint') + '</div>');

		_(parent, [hint[0], ul]);
		
		_queryMapLayers.addDraggable(parent);
	})
}

nsGmx.ContextMenuController.addContextMenuElem({
    title: function() { return "Открыть в новом окне"; },
    clickCallback: function(context)
    {
        window.open(window.location.href.split(/\?|#/)[0] + "?" + context.name, '_blank');
    }
}, 'MapListItem');

})(nsGmx.Utils._);
//Управление показом списка слоёв и поиска по этому списку
var nsGmx = nsGmx || {};

(function(_){

var LayersListProvider = function(filtersProvider)
{
    var _this = this;
    $(filtersProvider).change(function()
    {
        $(_this).change();
    });

    var getQueryText = function()
    {
        var filterStrings = [];

        if (filtersProvider.getTitle() !== '')
            filterStrings.push("([Title] containsIC '" + filtersProvider.getTitle() + "' or [Name] = GetLayerName('" + filtersProvider.getTitle() + "'))");

        if (filtersProvider.getOwner() !== '')
            filterStrings.push("[OwnerNickname] containsIC '" + filtersProvider.getOwner() + "'");

        var types = filtersProvider.getTypes();
        var typeFilters = $.map(types, function(type) {
            if (type === 'catalog')
            {
                return "([LayerType]=LayerTypeCode('vector') AND [IsRasterCatalog]=true)"
            }
            else if (type)
            {
                return "[LayerType]=LayerTypeCode('" + type + "')";
            }
        })

        if (typeFilters.length > 0)
            filterStrings.push('(' + typeFilters.join(' OR ') + ')');

        var dateBegin = filtersProvider.getDateBegin();
        var dateEnd = filtersProvider.getDateEnd();

        dateBegin && filterStrings.push("[DateCreate] >= '" + $.datepicker.formatDate('yy.mm.dd', dateBegin) + "'");
        dateEnd   && filterStrings.push("[DateCreate] < '"  + $.datepicker.formatDate('yy.mm.dd', dateEnd) + "'");

        var layerTags = filtersProvider.getTags();

        if (layerTags)
        {
            layerTags.each(function(id, tag, value)
            {
                if (tag)
                {
                    if (value !== '')
                        filterStrings.push("[" + tag + "] containsIC '" + value + "'");
                    else
                        filterStrings.push("PropertyExist('" + tag + "')");
                }
            });
        }

        return '&query=' + encodeURIComponent(filterStrings.join(' AND '));
    }

    this.getCount = function(callback)
    {
        var query = getQueryText();
        sendCrossDomainJSONRequest(serverBase + 'Layer/Search2.ashx?count=true' + query, function(response)
        {
            if (!parseResponse(response))
            {
                callback();
                return;
            }
            callback(response.Result.count);
        })
    }

    this.getItems = function(page, pageSize, sortParam, sortDec, callback)
    {
        this.getCountAndItems(page, pageSize, sortParam, sortDec, function(count, items)
        {
            callback(items);
        })
    }

    this.getCountAndItems = function(page, pageSize, sortParam, sortDec, callback)
    {
        var sortParams = {};
        sortParams[_gtxt("Имя")] = "title";
        sortParams[_gtxt("Дата создания")] = "datecreate";
        sortParams[_gtxt("Владелец")] = "ownernickname";

        var query = getQueryText();

        sendCrossDomainJSONRequest(serverBase + 'Layer/Search2.ashx?page=' + page + '&pageSize=' + pageSize + "&orderby=" + sortParams[sortParam] + " " + (sortDec ? "desc" : "") + query, function(response)
        {
            if (!parseResponse(response))
            {
                callback();
                return;
            }

            callback(response.Result.count, response.Result.layers);
        })
    }
}

var drawLayers = function(layer, params)
{
	var _params = $.extend({onclick: function(){ removeLayerFromList(); }, enableDragging: true, disabled: false}, params);
	var newLayerProperties = {properties:layer};

    var mapProperties = _layersTree.treeModel.getMapProperties();
	newLayerProperties.properties.mapName = mapProperties.name;
	newLayerProperties.properties.hostName = mapProperties.hostName;
	newLayerProperties.properties.visible = false;

    // newLayerProperties.properties.type = newLayerProperties.properties.type === 1 ? 'Vector' : 'Raster';

	if (newLayerProperties.properties.type == 'Vector')
		newLayerProperties.properties.styles = [{MinZoom:1, MaxZoom:20, RenderStyle:_mapHelper.defaultStyles[newLayerProperties.properties.GeometryType]}]
	else if (newLayerProperties.properties.type != 'Vector' && !newLayerProperties.properties.MultiLayerID)
		newLayerProperties.properties.styles = [{MinZoom:newLayerProperties.properties.MinZoom, MaxZoom:20}];

	var res = _layersTree.drawNode({type: 'layer', content:newLayerProperties}, false, 1),
		icon = res.firstChild.cloneNode(true),
		remove = makeImageButton("img/recycle.png", "img/recycle_a.png"),
		tr,
		tdRemove = (layer.Access == 'edit') ? _td([remove], [['css','textAlign','center']]) : _td(),
		removeLayerFromList = function()
		{
			var active = $(_queryMapLayers.buildedTree).find(".active");

            var gmxProperties = $(res).find("span[dragg]")[0].parentNode.parentNode.gmxProperties;
			if (active.length && (active[0].parentNode.getAttribute('MapID') || active[0].parentNode.getAttribute('GroupID'))){
                _layersTree.copyHandler(gmxProperties, active[0].parentNode, false, true)
            } else {
                _layersTree.copyHandler(gmxProperties, $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0], false, true);
            }
            $(res).addClass('gmx-disabled');
		},
		_this = this;

	_title(remove, _gtxt("Удалить"));

	res.firstChild.removeNode(true);

	remove.onclick = function()
	{
		if (confirm(_gtxt("Вы действительно хотите удалить этот слой?")))
		{
			var loading = loading = _div([_img(null, [['attr','src','img/progress.gif']]), _t('удаление...')], [['css','marginLeft','5px']]);

			$(remove.parentNode.parentNode).replaceWith(_tr([_td([loading], [['attr','colSpan', 5]])]))

            var deleteLayerHandler = function(response, id, flag)
            {
                if (!parseResponse(response))
                    return;

                if (response.Result == 'deleted')
                    $(_this.getDataProvider()).change();
                else
                    showErrorMessage(_gtxt("Ошибка!"), true, _gtxt("Слоя нет в базе"));
            }

			if (newLayerProperties.properties.MultiLayerID)
				sendCrossDomainJSONRequest(serverBase + "MultiLayer/Delete.ashx?WrapStyle=func&MultiLayerID=" + newLayerProperties.properties.MultiLayerID, deleteLayerHandler);
			else
				sendCrossDomainJSONRequest(serverBase + "Layer/Delete.ashx?WrapStyle=func&LayerID=" + newLayerProperties.properties.LayerID, deleteLayerHandler);
		}
	}

	var span = $(res).find("span.layer")[0];

    if (_params.disabled)
            $(span).addClass('invisible');

	if (!_params.disabled && _params.onclick)
	{
		span.onclick = function()
		{
			_params.onclick({ elem: layer, scrollTable: _this });
		}
	}
    else
    {
        span.onclick = null;
        $(span).css('cursor', 'auto');
    }

    span.ondblclick = null;

	if (_params.enableDragging && !params.disabled)
	{
		$(res).find("span[dragg]").draggable(
		{
			helper: function(ev)
			{
				return _layersTree.dummyNode(ev.target)
			},
			cursorAt: { left: 5 , top: 10},
			cursor: 'move',
			delay: 200,
			appendTo: document.body
		});
	}

	var nameDivInternal = _div([res], [['css','position','absolute'], ['css','width','100%'],['css','padding',"1px 0px"], ['css','overflowX','hidden'],['css','whiteSpace','nowrap']]);
	var nameDiv = _div([nameDivInternal], [['css', 'position', 'relative'], ['css', 'height', '100%']]);

	tr = _tr([_td(), _td([icon], [['css','textAlign','center']]), _td([nameDiv]), _td([_t(layer.date)], [['css','textAlign','center'],['dir','className','invisible']]),  _td([_t(layer.Owner)], [['css','textAlign','center'],['dir','className','invisible']]), tdRemove]);

	for (var i = 0; i < tr.childNodes.length; i++)
		tr.childNodes[i].style.width = this._fields[i].width;

	attachEffects(tr, 'hover')

	return tr;
}

/** Внутри контейнера помещает табличку со списком слоёв и контролами для фильтрации
* @param {HTMLNode} parentDiv Куда помещать контрол
* @param {String} name Уникальное имя этого инстанса
* @param {object} params Параметры отображения списка:
*
*  * fixType {String | Vector} Какой тип слоёв показывать. 'vector', 'raster', 'multilayer', 'catalog' или ''. Если '', то добавится контрол с выбором типа слоя. Вектор
*  * enableDragging {Boolean}
*  * height {Integer} высота всего виджета. Если не указана, то будет применяться дефолтная высота (~460px)
*  * onclick {function({ elem: , scrollTable: })}
*/
var LayerManagerControl = function( parentDiv, name, params )
{
	var _params = $.extend({fixType: [], height: ''}, params);

    if (typeof _params.fixType === 'string')
        _params.fixType = [_params.fixType];

	var canvas = _div(null, [['attr','id','layersList']]),
		searchCanvas = _div(null, [['dir','className','layersSearchCanvas']]),
		_this = this;

	var layerName = _input(null, [['dir','className','inputStyle'],['css','width','185px']]),
		layerOwner = _input(null, [['dir','className','inputStyle'],['css','width','185px']]);

	var typeSel = nsGmx.Utils._select([_option([_t(_gtxt("Любой"))], [['attr','value','']]),
					   _option([_t(_gtxt("Векторный"))], [['attr','value','vector']]),
					   _option([_t(_gtxt("Растровый"))], [['attr','value','raster']]),
					   _option([_t(_gtxt("Мультислой"))], [['attr','value','multilayer']]),
					   _option([_t(_gtxt("Каталог растров"))], [['attr','value','catalog']])], [['dir','className','selectStyle'], ['css','width','100px']]);

    var calendar = new nsGmx.CalendarWidget({
        minimized: false,
        showSwitcher: false,
        dateInterval: new nsGmx.DateInterval({dateBegin: null, dateEnd: null})
    });
    // calendar.init('layerManager', {
        // minimized: false,
        // showSwitcher: false,
        // dateBegin: null,
        // dateEnd: null
    // });

    var _disabledLayers = {};

	_(searchCanvas, [_div([_table([_tbody([_tr([_td([_span([_t(_gtxt("Название"))],[['css','fontSize','12px']])]), _td([layerName])]),
										   _tr([_td([_span([_t(_gtxt("Владелец"))],[['css','fontSize','12px']])]),_td([layerOwner])]),
                                           _tr([_td([_span([_t(_gtxt("Период"))],[['css','fontSize','12px']])]),_td([calendar.canvas[0]])]),
										   _tr([_td([_span([_t(_gtxt("Тип"))],[['css','fontSize','12px']])]), _td([typeSel])])])])], [['css','marginBottom','10px']])]);

    $.each(_params.fixType, function(i, type) {
        if (type !== '')
            $("tr:last", searchCanvas).hide();
    });

	var tableParent = _div();

    var sortColumns = {};
    sortColumns[_gtxt('Имя')] = true;
    sortColumns[_gtxt('Владелец')] = true;
    sortColumns[_gtxt('Дата создания')] = true;

    // Временно сервер не поддерживает сортировку по типу
    // if (_params.fixType.length > 1 || _params.fixType[0] === '')
        // sortColumns[_gtxt('Тип')] = true;

    var tagsParent = _div(null, [['css', 'height', '100px'], ['css', 'overflow', 'auto']]);

    _(canvas, [_table([_tbody([_tr([
        _td([searchCanvas], [['css', 'width', '50%']]),
        _td([tagsParent])
    ])])], [['css', 'width', '100%']])]);

    var LayersFilterParams = (function()
    {
        var prevLayerName, prevLayerOwner;

        layerName.oninput = layerName.onkeyup = function()
        {
            if (this.value !== prevLayerName) {
                prevLayerName = this.value;
                $(pi).change();
            }
        }

        layerOwner.oninput = layerOwner.onkeyup = function()
        {
            if (this.value !== prevLayerOwner) {
                prevLayerOwner = this.value;
                $(pi).change();
            }
        }

        typeSel.onchange = function()
        {
            $(pi).change();
        }

        calendar.getDateInterval().on('change', function()
        {
            $(pi).change();
        });

        var _layerTags = null;

        var pi = {
            setTags: function(layerTags)
            {
                _layerTags = layerTags;
                $(_layerTags).change(function()
                {
                    $(pi).change();
                })
            },
            getTitle:     function() { return layerName.value; },
            getOwner:     function() { return layerOwner.value; },
            getDateBegin: function() { return calendar.getDateInterval().get('dateBegin'); },
            getDateEnd:   function() { return calendar.getDateInterval().get('dateEnd'); },
            getTags:      function() { return _layerTags; },
            getTypes:     function() { return _params.fixType.length > 0 ? _params.fixType : [$("option:selected", typeSel).val()]; }
        }

        return pi;
    })();

    nsGmx.TagMetaInfo.loadFromServer(function(tagsInfo)
    {
        var layerTags = new nsGmx.LayerTagsWithInfo(tagsInfo);
        new nsGmx.LayerTagSearchControl(layerTags, tagsParent, {inputWidth: 115});
        LayersFilterParams.setTags(layerTags);
    });

    var layersListProvider = new LayersListProvider(LayersFilterParams);
    var layersTable = new nsGmx.ScrollTable({height: _params.height ? _params.height - 130 : ''});
    layersTable.setDataProvider(layersListProvider);

	layersTable.createTable(tableParent, name, 0,
		["", _gtxt("Тип"), _gtxt("Имя"), _gtxt("Дата создания"), _gtxt("Владелец"), ""],
		['1%','5%','45%','24%','20%','5%'],
		function(layer)
		{
            var curParams = $.extend( {}, _params, {disabled: layer.name in _disabledLayers } );
			return drawLayers.apply(this, [layer, curParams]);
		},
		sortColumns
	);

	_(canvas, [tableParent]);

	$(parentDiv).empty().append(canvas);

	layerName.focus();

    this.getScrollTable = function()
    {
        return layersTable;
    }

    /** Деактивировать слои
      @param layerNames {String|String[]} - массив имён слоёв (или просто имя), которые нужно сделать неактивными
    */
    this.disableLayers = function(layerNames)
    {
        if (!$.isArray(layerNames))
            layerNames = [layerNames];

        for (var k = 0; k < layerNames.length; k++)
            _disabledLayers[layerNames[k]] = true;

        layersTable.repaint();
    }

    /** Aктивировать слои
      @param layerNames {String|String[]} - массив имён слоёв (или просто имя), которые нужно сделать активными
    */
    this.enableLayers = function(layerNames)
    {
        if (!$.isArray(layerNames))
            layerNames = [layerNames];

        for (var k = 0; k < layerNames.length; k++)
            delete _disabledLayers[layerNames[k]];

        layersTable.repaint();
    }

    this.resize = function(h) {
        layersTable.updateHeight(h - 130);
    }
}

nsGmx.LayerManagerControl = LayerManagerControl;
nsGmx.drawLayers = drawLayers;

gmxCore.addModule('LayersManagerControl', {
    LayerManagerControl: LayerManagerControl,
    drawLayers: drawLayers
});

})(nsGmx.Utils._);


_translationsHash.addtext("rus", {
							"loadShape.inputTitle": "Добавить shp-файл (в zip)",
                            "loadShape.loadDone": "Геометрия успешно загружена",
                            "loadShape.loadFail": "Ошибка загрузки геометрии"
						 });
						 
_translationsHash.addtext("eng", {
							"loadShape.inputTitle": "Add shp-file (zipped)",
                            "loadShape.loadDone": "Successfully loaded",
                            "loadShape.loadFail": "Error loading file"
						 });

var drawingObjects = 
{
	loadShp: {}
}

var queryLoadShp = function()
{
	this.builded = false;
	
	this.uploader = null;
}

queryLoadShp.prototype = new leftMenu();

//Старый вариант для IE9
//просто удаляет все контролы и создаёт все их заново...
queryLoadShp.prototype._regenerateControl = function()
{
    var _this = this;
    $(this.workCanvas).empty();

    var fileInput = _input(null, [['attr', 'type', 'file'], ['attr', 'name', 'file'], ['attr', 'id', 'upload_shapefile']]);
    fileInput.onchange = function()
    {
        if (this.value != "")
            _this.upload();
    }

    //задаём одновременно и enctype и encoding для корректной работы в IE
    this.postForm = _form([fileInput], [['attr', 'method', 'POST'], ['attr', 'encoding', 'multipart/form-data'], ['attr', 'enctype', 'multipart/form-data'], ['attr', 'id', 'upload_shapefile_form']]);

    this.progress = _img(null,[['attr','src','img/progress.gif'],['css','display','none']])

    this.inputControl = _div([_span([_t(_gtxt("loadShape.inputTitle") + ":")]), this.postForm]);

    this.workCanvas.appendChild(_div([this.inputControl, this.progress], [['css','padding','10px 0px 5px 20px']]));
}

queryLoadShp.prototype.load = function()
{
    if (!this.builded)
    {
        this._regenerateControl();
        this.builded = true;
    }
}

queryLoadShp.prototype._showObjectsOnMap = function(objs){
    if (objs.length == 0)
    {
        showErrorMessage(_gtxt("Загруженный shp-файл пуст"), true);
        return;
    }
    var lmap = nsGmx.leafletMap,
        gmxDrawing = lmap.gmxDrawing,
        latLngBounds = L.latLngBounds([]);
    for (var i = 0; i < objs.length; i++) {
        var it = objs[i],
            geoJSON = L.gmxUtil.geometryToGeoJSON(it.geometry),
            b = gmxDrawing.addGeoJSON(geoJSON, {fill: false, properties: it.properties})[0].getBounds();

        latLngBounds.extend(b);
    }
    if (latLngBounds.isValid()) {
        lmap.fitBounds(latLngBounds);
    }
}

//files - массив File или WebForms
queryLoadShp.prototype.loadAndShowFiles = function(files) {
    nsGmx.widgets.notifications.startAction('uploadShp');
    
    var def = $.when.apply($, [].slice.call(files).map(function(file) {
        return nsGmx.Utils.parseShpFile(file);
    }));
    
    def.then(function() {
        this._showObjectsOnMap(_.flatten([].slice.call(arguments)));
        nsGmx.widgets.notifications.stopAction('uploadShp', 'success', _gtxt('loadShape.loadDone'));
    }.bind(this), function() {
        nsGmx.widgets.notifications.stopAction('uploadShp', 'failure', _gtxt('loadShape.loadFail'));
    });
    
    return def;
}


//Загружает файлы из поля "file"
queryLoadShp.prototype.upload = function()
{
	hide(this.inputControl);
	show(this.progress);

    this.loadAndShowFiles([this.postForm]).always(function() {
        this.inputControl.removeChild(this.postForm);
        this._regenerateControl();
    }.bind(this));
}

var _queryLoadShp = new queryLoadShp();


drawingObjects.loadShp.load = function() {
    if ('File' in window) {
        $('<input type="file" multiple>').change(function(e) {
            _queryLoadShp.loadAndShowFiles(e.target.files);
        }).click();
    } else { //IE9
        var alreadyLoaded = _queryLoadShp.createWorkCanvas(arguments[0] || "shp");

        if (!alreadyLoaded)
            _queryLoadShp.load()
    }
}

drawingObjects.loadShp.unload = function()
{
}
/**
* @namespace DrawingObjects
* @description SDK для редактирования объектов на карте
*/
!(function($, _){

nsGmx.Translations.addText('rus', {
    drawingObjects: {
        editStyleTitle: 'Редактировать стиль',
        removeObject: 'Удалить',
        pointTitle: 'точка',
        lineTitle: 'линия',
        polygonTitle: 'многоугольник',
        rectangleTitle: 'прямоугольник',
        removeAll: 'Очистить',
        downloadShp: 'shp',
        downloadGeoJSON: 'geojson',
        downloadGpx: 'gpx',
        downloadCsv: 'csv',
        downloadNameTitle: 'Введите имя файла для скачивания',
        download: 'Скачать файл',
        downloadRaster: 'Скачать фрагмент растра',
        noRectangleError: 'Выберите область рамкой на карте',
        noRasterError: 'К прямоугольнику не подходит ни одного растрового слоя',

        edit: {
            border: 'Граница',
            color: 'Цвет',
            transparency: 'Прозрачность',
            lineWidth: 'Толщина линии',
            description: 'Описание',
            title: 'Редактирование стиля объекта'
        }
    }
})

nsGmx.Translations.addText('eng', {
    drawingObjects: {
        editStyleTitle: 'Edit style',
        removeObject: 'Delete',
        pointTitle: 'point',
        lineTitle: 'line',
        polygonTitle: 'polygon',
        rectangleTitle: 'rectangle',
        removeAll: 'Delete',
        downloadShp: 'shp',
        downloadGeoJSON: 'geojson',
        downloadGpx: 'gpx',
        downloadCsv: 'csv',
        downloadNameTitle: 'Enter file name to download',
        download: 'Download file',
        downloadRaster: 'Download fragment of raster',
        noRectangleError: 'Select region using frame',
        noRasterError: 'No one raster layer fit the rectangle',

        edit: {
            border: 'Outline',
            color: 'Color',
            transparency: 'Transparency',
            lineWidth: 'Line thickness',
            description: 'Description',
            title: 'Object style editing'
        }
    }
});

var setDrawingFeatureStyle = function(drawingFeature, templateStyle) {
    var color = '#' + L.gmxUtil.dec2hex(templateStyle.outline.color),
        opacity = templateStyle.outline.opacity/100;
    drawingFeature.setOptions({
        lineStyle: {
            color: color,
            opacity: opacity,
            weight: templateStyle.outline.thickness
        },
        pointStyle: {
            color: color,
            opacity: opacity
        }
    });
}

var CreateDrawingStylesEditorIcon = function(style, type)
{
	var icon = nsGmx.Controls.createGeometryIcon(style, type);

	_title(icon, _gtxt('drawingObjects.editStyleTitle'));

	return icon;
}

var CreateDrawingStylesEditor = function(parentObject, style, elemCanvas)
{
	var templateStyle = {};
    var jQueryDialog = null;

	$.extend(true, templateStyle, style);

	elemCanvas.onclick = function()
	{
        if (jQueryDialog) {
            return;
        }
		var canvas = _div(null,[['css','marginTop','10px']]),
			outlineParent = _tr(),
			outlineTitleTds = [],
			outlineTds = [];

		outlineTitleTds.push(_td([_t(_gtxt('drawingObjects.edit.border'))],[['css','width','70px']]));

		var outlineColor = nsGmx.Controls.createColorPicker(templateStyle.outline.color,
			function (colpkr){
				$(colpkr).fadeIn(500);
				return false;
			},
			function (colpkr){
				$(colpkr).fadeOut(500);
				return false;
			},
			function (hsb, hex, rgb) {
				outlineColor.style.backgroundColor = '#' + hex;

				templateStyle.outline.color = outlineColor.hex = parseInt('0x' + hex);

				$(elemCanvas).find(".borderIcon")[0].style.borderColor = '#' + hex;

				setDrawingFeatureStyle(parentObject, templateStyle);
			});

		outlineColor.hex = templateStyle.outline.color;

		_title(outlineColor, _gtxt('drawingObjects.edit.color'));

		outlineTds.push(_td([outlineColor],[['css','width','40px']]));

		var divSlider = nsGmx.Controls.createSlider(templateStyle.outline.opacity,
				function(event, ui)
				{
					templateStyle.outline.opacity = ui.value;

                    setDrawingFeatureStyle(parentObject, templateStyle);
				})

		_title(divSlider, _gtxt('drawingObjects.edit.transparency'));

		outlineTds.push(_td([divSlider],[['css','width','100px'],['css','padding','4px 5px 3px 5px']]));

		var outlineThick = nsGmx.Controls.createInput((templateStyle.outline && typeof templateStyle.outline.thickness != 'undefined') ? templateStyle.outline.thickness : 2,
				function()
				{
					templateStyle.outline.thickness = Number(this.value);

                    setDrawingFeatureStyle(parentObject, templateStyle);

					return true;
				}),
			closeFunc = function()
			{
				var newIcon = CreateDrawingStylesEditorIcon(templateStyle, parentObject.toGeoJSON().geometry.type.toLowerCase());
				CreateDrawingStylesEditor(parentObject, templateStyle, newIcon);

				$(elemCanvas).replaceWith(newIcon);

				$(canvas).find(".colorSelector").each(function()
				{
					$('#' + $(this).data("colorpickerId")).remove();
				});
			};

		_title(outlineThick, _gtxt('drawingObjects.edit.lineWidth'));

		outlineTds.push(_td([outlineThick],[['css','width','30px']]));

		_(outlineParent, outlineTitleTds.concat(_td([_div([_table([_tbody([_tr(outlineTds)])])],[['attr','fade',true]])])));

		var text = _input(null, [['attr','value', parentObject.options.title || ""],['dir','className','inputStyle'],['css','width','180px']]);
		$(text).on('keyup', function(evt)
		{
            if (evt.keyCode === 13)
            {
                $(jQueryDialog).dialog('destroy');
                return;
            }

            parentObject.setOptions({title: this.value});

			$(parentObject).triggerHandler('onEdit', [parentObject]);

			return true;
		})

		_(canvas, [_table([_tbody([_tr([_td([_t(_gtxt('drawingObjects.edit.description'))], [['css','width','70px']]), _td([text])])])]), _br(), _table([_tbody([outlineParent])])])

		var pos = nsGmx.Utils.getDialogPos(elemCanvas, false, 80);
		jQueryDialog = showDialog(_gtxt('drawingObjects.edit.title'), canvas, 280, 130, pos.left, pos.top, false, closeFunc);
        
        $(jQueryDialog).addClass('drawing-object-leaflet-id-' + parentObject._leaflet_id);
	}

	elemCanvas.getStyle = function()
	{
		return templateStyle;
	}
}

/** Конструктор
 @class Коллекция нарисованных объектов
 @memberOf DrawingObjects
 @param oInitMap Карта, из которой будут добавляться объекты в коллекцию
*/
var DrawingObjectCollection = function(oInitMap) {
	var _objects = []; //{item:, editID: , removeID: }
	var _this = this;
    var _map = oInitMap;

	var onEdit = function(drawingObject) {
		/** Вызывается при изменении объекта в коллекции
		@name DrawingObjects.DrawingObjectCollection.onEdit
		@event
		@param {drawingObject} drawingObject изменённый объект*/
		$(_this).triggerHandler('onEdit', [drawingObject]);
	}

	var onRemove = function(drawingObject) {
		_this.Remove(drawingObject);
	}

	/** Возвращает элемент по номеру
	@param {int} index № объекта в коллекции*/
	this.Item = function(index){
		return _objects[index].item;
	}

	/** Возвращает количество элементов в коллекции*/
	this.Count = function(){
		return _objects.length;
	}

	/** Добавляет объект в коллекцию
	@param {drawingObject} drawingObject Добавляемый объект*/
	this.Add = function(drawingObject){

        var editID = drawingObject.on('edit', function() {
            onEdit(drawingObject);
        });

        var removeID = drawingObject.on('remove', function() {
            onRemove(drawingObject);
        });

		_objects.push({
            item: drawingObject,
            editID: editID,
            removeID: removeID
        });

		/** Вызывается при добавлении объекта в коллекцию
		@name DrawingObjects.DrawingObjectCollection.onAdd
		@event
		@param {drawingObject} drawingObject добавленный объект*/
		$(this).triggerHandler('onAdd', [drawingObject]);
	};

	/** Удаляет объект из коллекции
	@param {int} index индекс удаляемого объекта*/
	this.RemoveAt = function(index){
		var obj = _objects.splice(index, 1)[0];

		/** Вызывается при удалении объекта из коллекции
		@name DrawingObjects.DrawingObjectCollection.onRemove
		@event
		@param {int} index индекс удаляённого объекта*/
		$(this).triggerHandler('onRemove', [index]);
	};

	/** Удаляет объект из коллекции
	@param {drawingObject} drawingObject удаляемый объект*/
	this.Remove = function(drawingObject){
		for (var i=0; i<_objects.length; i++){
			if (_objects[i].item === drawingObject) this.RemoveAt(i);
		}
	}

    /** Получить индекс объекта в коллекции. null, если объект не найден
	@param {drawingObject} drawingObject объект, индекс которого мы хотим найти*/
	this.getIndex = function(drawingObject){
		for (var i=0; i<_objects.length; i++){
			if (_objects[i].item === drawingObject) return i;
		}

        return null;
	}
}

/** Конструктор
 @class Строка с описанием объекта и ссылкой на него
 @description К строке биндится контекстное меню типа "DrawingObject"
 @memberOf DrawingObjects
 @param {L.Map} oInitMap Карта Leaflet
 @param oInitContainer Объект, в котором находится контрол (div)
 @param drawingObject Объект для добавления на карту
 @param options дополнительные параметры
 @param {bool} [options.allowDelete=true] рисовать ли крестик удаления объекта
 @param {bool} [options.editStyle=true] нужна ли возможность редактировать стили
 @param {function(DrawingObject)} [options.click] ф-ция, которая будет вызвана при клике на объекте.
        По умолчанию - центрирование карты на объекте.
*/
var DrawingObjectInfoRow = function(oInitMap, oInitContainer, drawingObject, options) {
    var defaultClickFunction = function(obj) {
        var geom = obj.toGeoJSON().geometry;
        var coords = geom.coordinates;
		if (geom.type == "Point") {
            _map.setView([coords[1], coords[0]], Math.max(14, _map.getZoom()));
        } else {
            _map.fitBounds(drawingObject.getBounds());
        }
    }

    var _options = $.extend({
        allowDelete: true,
        editStyle: true,
        click: defaultClickFunction
    }, options);

	var _drawingObject = drawingObject;
	var _this = this;
	var _map = oInitMap;

	var _canvas = _div(null, [['dir','className','drawingObjectsItemCanvas']]);
	var _title = _span(null, [['dir','className','drawingObjectsItemTitle']]);
	var _text = _span(null, [['dir','className', 'drawingObjectsItemTitle']]);
	var _summary = _span(null, [['dir','className','summary']]);

    if (_options.click) {
        _canvas.onclick = function(e) {
            if (e.target !== remove && (!_options.editStyle || e.target !== icon)) {
                _options.click(_drawingObject);
            }
        };
    }

    var lineOptions = _drawingObject.options.lineStyle || L.GmxDrawing.utils.defaultStyles.lineStyle;

	var icon = null;

    var geom = _drawingObject.toGeoJSON().geometry;
    if (_options.editStyle)
    {
        if (geom.type == "Point")
        {
            icon = _img(null, [['attr','src', (window.gmxJSHost || '') + 'img/flag_min.png'], ['dir', 'className', 'colorIcon']])
        }
        else
        {
            var regularDrawingStyle = {
                outline: {
                    color: parseInt('0x' + lineOptions.color.split('#')[1]),
                    thickness: lineOptions.weight,
                    opacity: lineOptions.opacity * 100
                }
            };

            icon = CreateDrawingStylesEditorIcon(regularDrawingStyle, geom.type.toLowerCase());
            CreateDrawingStylesEditor(_drawingObject, regularDrawingStyle, icon);
        }
    }
    else
        icon = _span(null, [['dir', 'className', geom.type + (L.gmxUtil.isRectangle(geom.coordinates) ? ' RECTANGLE' : '')]]);

	var remove = _span();

    if (_options.allowDelete)
    {
        remove.setAttribute('title', _gtxt('drawingObjects.removeObject'));
        remove.className = 'gmx-icon-close';
        remove.onclick = function(){
            $(_this).triggerHandler('onRemove', [_drawingObject]);
        }
    }

	_(_canvas, [_span([icon, _title, _text, _summary], [['dir','className','drawingObjectsItem']]), remove]);

	_(oInitContainer, [_canvas])

    this._mouseOverHandler = function() {
        $(_canvas).addClass('drawingObjectsActiveItemCanvas');
    };

    this._mouseOutHandler = function() {
        $(_canvas).removeClass('drawingObjectsActiveItemCanvas');
    }

    _drawingObject.on('mouseover', this._mouseOverHandler);
    _drawingObject.on('mouseout', this._mouseOutHandler);

	/** Обновляет информацию о геометрии */
	this.UpdateRow = function(){
        var summary = _drawingObject.getSummary(),
            text = _drawingObject.options.title,
            type = _drawingObject.getType();

		$(_title).empty();
		$(_text).empty();
		$(_summary).empty();

		if (type === 'Point')
		{
			_(_title, [_t(_gtxt('drawingObjects.pointTitle'))]);
			_(_summary, [_t("(" + summary + ")")]);
		}
		else if (type === 'Polyline' || type === 'MultiPolyline')
		{
			_(_title, [_t(_gtxt('drawingObjects.lineTitle'))]);
			_(_summary, [_t("(" + summary + ")")]);
		}
		else if (type === 'Polygon' || type === 'MultiPolygon' || type === 'Rectangle')
		{
			_(_title, [_t(type === 'Rectangle' ? _gtxt('drawingObjects.rectangleTitle') : _gtxt('drawingObjects.polygonTitle'))]);
			_(_summary, [_t("(" + summary + ")")]);
		}

		_(_text, [_t(text ? text.replace(/<[^<>]*>/g, " ") : "")])

		if (text)
			_title.style.display = 'none';
		else
			_title.style.display = '';
	}

	/** Удаляет строчку */
	this.RemoveRow = function(){

		if (_canvas.parentNode)
            _canvas.parentNode.removeChild(_canvas);

        if (_drawingObject === null) return;

        _drawingObject.off('edit', this.UpdateRow);
        _drawingObject.off('remove', this.RemoveRow);
        _drawingObject.off('mouseover', this._mouseOverHandler);
        _drawingObject.off('mouseout', this._mouseOutHandler);

        _drawingObject = null;
	}

    /** Удаляет строчку */
    this.getContainer = function() {return _canvas;};

    if (nsGmx && nsGmx.ContextMenuController) {
        nsGmx.ContextMenuController.bindMenuToElem(_title, 'DrawingObject', function(){return true; }, {obj: _drawingObject} );
    }

    this.getDrawingObject = function(){
        return _drawingObject;
    }

    _drawingObject.on('edit', this.UpdateRow);
    _drawingObject.on('remove', this.RemoveRow);

	this.UpdateRow();
}

/** Конструктор
 @class Контрол для отображения коллекции пользовательских объектов
 @memberOf DrawingObjects
 @param oInitMap Карта
 @param {documentElement} oInitContainer Объект, в котором находится контрол (div)
 @param {DrawingObjects.DrawingObjectCollection} oInitDrawingObjectCollection Коллекция пользовательских объектов
 @param {Object} options Дополнительные параметры.Включает все доп. параметры DrawingObjectInfoRow
 @param {bool} [options.showButtons=true] показывать ли кнопки под списком
 @param {selectedIndex} [options.selectedIndex=null] индекс выбранного элемента
*/
var DrawingObjectList = function(oInitMap, oInitContainer, oInitDrawingObjectCollection, options){
    var _options = $.extend({showButtons: true, selectedIndex: null}, options);
	var _this = this;
	var _rows = [];
	var _containers = [];
	var _map = oInitMap;
	var _collection = oInitDrawingObjectCollection;
	var _container = oInitContainer;
	var _divList = _div(null, [['dir', 'className', 'DrawingObjectList']]);
	var _divButtons = _div();

	/** Добавляет объект в "список объектов на карте"
	@param {drawingObject} drawingObject добавляемый объект */
	var add = function(drawingObject){
		var divRow = _div();
		_(_divList, [divRow]);
		var row = new DrawingObjectInfoRow(_map, divRow, drawingObject, options);
		_containers.push(divRow);
		_rows.push(row);
		$(row).bind('onRemove', function(){ drawingObject.remove(); } );
		if (_collection.Count() == 1 && _options.showButtons) show(_divButtons);

        /** В списке мышь переместилась над объект
		@name DrawingObjects.DrawingObjectList.mouseover
		@event
		@param {drawingObject} drawingObject объект, над которым находится мышь*/

        /** В списке мышь переместилась с объекта
		@name DrawingObjects.DrawingObjectList.mouseout
		@event
		@param {drawingObject} drawingObject объект, с которого переместилась мышь*/

        $(divRow).bind({
            mouseover: function() {
                $(_this).triggerHandler('mouseover', [drawingObject]);
            },
            mouseout: function() {
                $(_this).triggerHandler('mouseout', [drawingObject]);
            }
        });
	}

	var onRemove = function(event, index){
		if (_collection.Count() == 0) hide(_divButtons);
		var removedDiv = _containers.splice(index, 1)[0];
		_rows.splice(index, 1);
		removedDiv.parentNode && removedDiv.parentNode.removeChild(removedDiv);

        if (index === _selectedIndex) {
            _selectedIndex = null;
        } else if (index < _selectedIndex) {
            _selectedIndex--;
        }
	}

	$(_collection).bind('onRemove', onRemove);
	$(_collection).bind('onAdd', function(event, drawingObject){
		add(drawingObject);
	});

	for (var i=0; i<_collection.Count(); i++){ add(_collection.Item(i));}

    /** Очищает список пользовательских объектов*/
	this.Clear = function(){
		while (_collection.Count()>0){
			_collection.Item(0).remove();
		}

        _selectedIndex = null;
	}

	/** Возвращает div, в котором находится кнопка "Очистить" и который не виден при пустой коллекции */
	this.GetDivButtons = function(){
		return _divButtons;
	}

    var delAll = makeLinkButton(_gtxt('drawingObjects.removeAll'));
	delAll.onclick = this.Clear;

	_(_divButtons, [_div([delAll])]);
	_( oInitContainer, [_divList, _divButtons]);

	if (_collection.Count() == 0 || !_options.showButtons) hide(_divButtons);

    var _selectedIndex = null;

    /** Устанавливает выбранный элемент списка пользовательских объектов.
        null - нет активного. Неправильные индексы игнорируются. К контейнеру выбранного элемента добавляется класс drawingObjectsSelectedItemCanvas
    */
    this.setSelection = function(selectedIndex) {
        var isValidIndex = !!_rows[selectedIndex] || selectedIndex === null;
        if (selectedIndex === _selectedIndex || !isValidIndex) {
            return _selectedIndex;
        }

        if (_rows[_selectedIndex]) {
            $(_rows[_selectedIndex].getContainer()).removeClass('drawingObjectsSelectedItemCanvas');
        }

        if (_rows[selectedIndex]) {
            $(_rows[selectedIndex].getContainer()).addClass('drawingObjectsSelectedItemCanvas');
        }

        _selectedIndex = selectedIndex;

        return _selectedIndex;
    };

    /** Возвращает индекс выбранного элемента списка пользовательских объектов, null - если нет выбранного*/
    this.getSelection = function() {
        return _selectedIndex;
    }

    this.setSelection(_options.selectedIndex);
}

/** Конструктор
 @memberOf DrawingObjects
 @class Встраивает список объектов на карте в геомиксер*/
var DrawingObjectGeomixer = function() {
	var _this = this;
	var oMap = null;
    var gmxMap = null;
	var oMenu = new leftMenu();
	var oListDiv = _div(null, [['dir', 'className', 'DrawingObjectsLeftMenu']]);
	var bVisible = false;
    var oCollection = null;

	/** Вызывается при скрывании меню*/
	this.Unload = function(){ bVisible = false; };

	/** Загружает меню*/
	this.Load = function(){
		if (oMenu != null){
			var alreadyLoaded = oMenu.createWorkCanvas("DrawingObjects", this.Unload);
			if(!alreadyLoaded) _(oMenu.workCanvas, [oListDiv]);
		}
		bVisible = true;
	}

	var fnAddToCollection = function(ev) {
        var feature = ev.object;
		if (!nsGmx.DrawingObjectCustomControllers || !nsGmx.DrawingObjectCustomControllers.isHidden(feature)) {
            oCollection.Add(feature);
            var tt = 1;
        }
	}

	var checkDownloadVisibility = function(){
		var isAnyRectangle = false,
            isNonPolygon = false;

		for (var i=0; i< oCollection.Count(); i++){
            var feature = oCollection.Item(i);
            var geom = feature.toGeoJSON().geometry;
            isAnyRectangle = isAnyRectangle || L.gmxUtil.isRectangle(geom.coordinates);
            isNonPolygon = isNonPolygon || geom.type !== 'Polygon';
		}

        $(downloadContainer).toggle(oCollection.Count() > 0);
        $(downloadRaster).toggle(gmxMap.properties.CanDownloadRasters && isAnyRectangle);
        $(downloadGpx).toggle(isNonPolygon);
	}

    var downloadFormat = null;

	var downloadShp = makeLinkButton(_gtxt('drawingObjects.downloadShp'));
	downloadShp.onclick = function(){
        downloadFormat = 'Shape';
        downloadNameContainer.toggle();
	}
    downloadShp.style.margin = '0px 3px';

	var downloadGeoJSON = makeLinkButton(_gtxt('drawingObjects.downloadGeoJSON'));
	downloadGeoJSON.onclick = function(){
        downloadFormat = 'GeoJSON';
        downloadNameContainer.toggle();
	}
    downloadGeoJSON.style.margin = '0px 3px';

    var downloadGpx = makeLinkButton(_gtxt('drawingObjects.downloadGpx'));
	downloadGpx.onclick = function(){
        downloadFormat = 'gpx';
        downloadNameContainer.toggle();
	}
    downloadGpx.style.margin = '0px 3px';

    var downloadCsv = makeLinkButton(_gtxt('drawingObjects.downloadCsv'));
	downloadCsv.onclick = function(){
        downloadFormat = 'csv_wkt';
        downloadNameContainer.toggle();
	}
    downloadCsv.style.margin = '0px 3px';

    var downloadNameInput = $('<input/>', {title: _gtxt('drawingObjects.downloadNameTitle')}).val('markers').addClass('inputStyle');

    downloadNameInput.keyup(function(e) {
        if (e.keyCode == 13) {
            downloadNameButton.click();
        }
    })

    var downloadNameButton = $('<input/>', {type: 'button'}).val(_gtxt('drawingObjects.download')).addClass('btn').click(function() {
        downloadMarkers(downloadNameInput.val(), downloadFormat);
        downloadNameContainer.hide();
        downloadFormat = null;
    });
    var downloadNameContainer = $('<div/>').append(downloadNameInput, downloadNameButton).hide();

    var downloadRasterOptions = $(
        '<div class="drawingObjectsDownloadRaster">' +
            '<label><input type="radio" name="rasterFormat" checked value="univers">jpeg + georefernce</label>' +
            '<label><input type="radio" name="rasterFormat" value="garmin">kmz (Garmin Custom Maps)</label>' +
            '<button id="downloadRaster" class="btn">' + _gtxt('drawingObjects.download') + '</button>' +
        '</div>'
    ).hide();

    $('#downloadRaster', downloadRasterOptions).click(function() {
        var checkInfo = checkRasterLayer();
        if (checkInfo) {
            var bounds = checkInfo.bounds,
                layer = checkInfo.layer,
                format = $('input:checked', downloadRasterOptions).val(),
                temporalParam = "",
                props = layer.getGmxProperties();

            if (props.Temporal) {
                var dateInterval = layer.getDateInterval();
                if (dateInterval) {
                    var dateBeginStr = nsGmx.Utils.convertFromServer('date', dateInterval.beginDate/1000),
                        dateEndStr = nsGmx.Utils.convertFromServer('date', dateInterval.endDate/1000);

                    temporalParam = "&StartDate=" + encodeURIComponent(dateBeginStr) + "&EndDate=" + encodeURIComponent(dateEndStr);
                }
            }

            var truncate9 = function(x) { return ("" + x).substring(0, 9); };

            window.location.href =
                "http://" + props.hostName + "/DownloadLayer.ashx" +
                "?t=" + props.name +
                "&MinX=" + truncate9(bounds.getWest()) +
                "&MinY=" + truncate9(bounds.getSouth()) +
                "&MaxX=" + truncate9(bounds.getEast()) +
                "&MaxY=" + truncate9(bounds.getNorth()) +
                "&Format=" + format +
                temporalParam;
        }
    })

	var downloadRaster = makeLinkButton(_gtxt('drawingObjects.downloadRaster'));
	downloadRaster.onclick = function(){
        if (downloadRasterOptions.find(':visible').length || checkRasterLayer()) {
            downloadRasterOptions.toggle();
        }
	}

    var downloadContainer = _div();

	/** Встраивает список объектов на карте в геомиксер*/
	this.Init = function(leafletMap, initGmxMap){
		oMap = leafletMap;
        gmxMap = initGmxMap;
		oCollection = new DrawingObjectCollection(leafletMap);
        $(oCollection).bind('onAdd', function (){
            if(!bVisible) _this.Load();
        });

        $(oCollection).bind('onRemove', function (){
            oCollection.Count() || oMenu.leftPanelItem.close();
        });

        var lmap = nsGmx.leafletMap,
            gmxDrawing = lmap.gmxDrawing,
            features = gmxDrawing.getFeatures();

        features.map(function(ret){
			fnAddToCollection(ret);
		});

        lmap.gmxDrawing.on('add', fnAddToCollection);

        $(oCollection).bind('onRemove onAdd', checkDownloadVisibility);

        var oDrawingObjectList = new DrawingObjectList(oMap, oListDiv, oCollection);
        _(downloadContainer, [
            _div([_span([_t(_gtxt('drawingObjects.download'))], [['css', 'fontSize', '12px']]), downloadShp, downloadGeoJSON, downloadGpx, downloadCsv]),
            downloadNameContainer[0],
            _div([downloadRaster]),
            downloadRasterOptions[0]
        ]);
		_(oDrawingObjectList.GetDivButtons(), [downloadContainer]);

		checkDownloadVisibility();
	}

	/** Скачивает shp файл*/
	var downloadMarkers = function(fileName, format) {
        var geoms = [];

		for (var i = 0; i < oCollection.Count(); i++) {
            geoms.push(oCollection.Item(i).toGeoJSON());
        }

        nsGmx.Utils.downloadGeometry(geoms, {
            fileName: fileName,
            format: format
        });
	}

	/** Скачивает растровые слои*/
	var checkRasterLayer = function(){
		var obj = false,
			_this = this;

		for (var i = 0; i < oCollection.Count(); i++){
			var elem = oCollection.Item(i);

			if (elem.getType() == 'Rectangle') {
				obj = elem;
            }
		}

		if (!obj)
		{
			showErrorMessage(_gtxt('drawingObjects.noRectangleError'), true);
			return;
		}

		var bounds = obj.getBounds(),
            center = bounds.getCenter(),
			layer = false;

		var testPolygon = function(polygon, latlng){
			var testRing = function(ring, x, y)
			{
				var isInside = false;
				for (var j = 0; j < ring.length - 1; j++)
				{
					var x1 = ring[j][0],
						y1 = ring[j][1],
						x2 = ring[j + 1][0],
						y2 = ring[j + 1][1];

					if (((y1 >= y) != (y2 >= y)) && ((x1 + (x2 - x1)*(y - y1)/(y2 - y1)) > x))
						isInside = !isInside;
				}

				return isInside;
			}

			for (var j = 0; j < polygon.length; j++)
				if (testRing(polygon[j], latlng.lng, latlng.lat) != (j == 0))
					return false;

			return true;
		}

        for (var iLayerN = 0; iLayerN < gmxMap.layers.length; iLayerN++) {
            var l = gmxMap.layers[iLayerN],
                props = l.getGmxProperties(),
                layerBounds = l.getBounds && l.getBounds(),
                isProperType = props.type == "Raster" || props.IsRasterCatalog;

            if (isProperType && oMap.hasLayer(l) && layerBounds && layerBounds.isValid() && layerBounds.contains(center)) {
                var geom = l.getGeometry(),
                    coords = geom.coordinates,
                    bIsPolygonBad = false;

                if (geom.type === "Polygon" && !testPolygon(coords, center)) {
                    bIsPolygonBad = true;
                } else if (geom.type == "MultiPolygon") {
                    bIsPolygonBad = true;
                    for (var k = 0; k < coords.length; k++)
                        if (testPolygon(coords[k], center)){
                            bIsPolygonBad = false;
                            break;
                        }
                }

                if (!bIsPolygonBad && l && (!layer || (props.MaxZoom > layer.getGmxProperties().MaxZoom))) {
                    layer = l;
                }
            }
        };

        if (!layer) {
            showErrorMessage(_gtxt('drawingObjects.noRasterError'), true);
            return;
        }

        return {bounds: bounds, layer: layer};
	}
}

var publicInterface = {
	DrawingObjectCollection: DrawingObjectCollection,
	DrawingObjectInfoRow: DrawingObjectInfoRow,
	DrawingObjectList: DrawingObjectList,
	DrawingObjectGeomixer: DrawingObjectGeomixer
}

gmxCore.addModule("DrawingObjects", publicInterface);

})(jQuery, nsGmx.Utils._);

!(function(_){

/** 
* @class Веб браузер для выбора и загрузки файлов на сервер
*/
var fileBrowser = function()
{
    var _this = this;
	this.parentCanvas = null;
	
	this._homeDir = '';
    
    this._status = {
        _state: false,
        start: function() {
            this._state = true;
            var me = this;
            setTimeout(function() {
                if (me._state) {
                    $(_this.statusContainer).show();
                }
            }, 100);
        },
        stop: function() {
            $(_this.statusContainer).hide();
            this._state = false;
        }
    }
    
    this._path = (function()
    {
        var path;
        var alternativePath;
        return {
            set: function(newPath, newAlternativePath)
            {
                path = newPath + (newPath.charAt(newPath.length-1) === _this.slash ? '' : _this.slash);
                if (newAlternativePath) {
                    alternativePath = newAlternativePath + (newAlternativePath.charAt(newAlternativePath.length-1) === _this.slash ? '' : _this.slash);
                } else {
                    alternativePath = undefined;
                }
                $(this).change();
            },
            get: function()
            {
                return path;
            },
            getAlternative: function()
            {
                return alternativePath;
            },
            isRoot: function()
            {
                return path && path.indexOf(_this.slash) === path.length-1;
            },
            isInited: function()
            {
                return typeof path !== 'undefined';
            },
            isInHome: function()
            {
                return path && path.indexOf(_this._homeDir) === 0;
            },
            getRoot: function()
            {
                var index = String(path).indexOf(_this.slash);
                return newPath = String(path).substr(0, index+1);
            },
            getParentFolder: function()
            {
                var index = String(path).lastIndexOf(_this.slash, path.length-2);
                return String(path).substr(0, index+1);
            }
        }
    })();
	
	this.currentFiles = [];
	
	this.slash = "\\";
	
	this.fileCanvas = null;
	this.fileHeader = null;
	this.fileUpload = null;
	
	this.sortFuncs = 
	{
		name:[
			function(_a,_b){var a = String(_a.Name).toLowerCase(), b = String(_b.Name).toLowerCase(); if (a > b) return 1; else if (a < b) return -1; else return 0},
			function(_a,_b){var a = String(_a.Name).toLowerCase(), b = String(_b.Name).toLowerCase(); if (a < b) return 1; else if (a > b) return -1; else return 0}
		],
		ext:[
			function(_a,_b)
			{
				var a = String(_a.Name).toLowerCase(),
					b = String(_b.Name).toLowerCase(),
					index1 = a.lastIndexOf('.'),
					ext1 = a.substr(index1 + 1, a.length),
					index2 = b.lastIndexOf('.'),
					ext2 = b.substr(index2 + 1, b.length);
				
				if (ext1 > ext2) return 1; else if (ext1 < ext2) return -1; else return 0;
			},
			function(_a,_b)
			{
				var a = String(_a.Name).toLowerCase(),
					b = String(_b.Name).toLowerCase(),
					index1 = a.lastIndexOf('.'),
					ext1 = a.substr(index1 + 1, a.length),
					index2 = b.lastIndexOf('.'),
					ext2 = b.substr(index2 + 1, b.length);
				
				if (ext1 < ext2) return 1; else if (ext1 > ext2) return -1; else return 0;
			}
		],
		size:[
			function(a,b){return a.Size - b.Size},
			function(a,b){return b.Size - a.Size}
		],
		date:[
			function(a,b){return a.Date - b.Date},
			function(a,b){return b.Date - a.Date}
		]
	};
	
	this.currentSortType = 'name';
	this.currentSortIndex = 
	{
		name: 0,
		ext: 0,
		size: 0,
		date: 0
	};
		
	this.shownPathScroll = false;

	this.returnMask = ['noname'];
	
	this._discs = null;
     
    this._params = null;
	
	this.ext7z = ['7Z', 'ZIP', 'GZIP', 'BZIP2', 'TAR', 'ARJ', 'CAB', 'CHM', 'CPIO', 'DEB', 'DMG', 'HFS', 'ISO', 'LZH', 'LZMA', 'MSI', 'NSIS', 'RAR', 'RPM', 'UDF', 'WIM', 'XAR', 'Z'];
}

fileBrowser.MAX_UPLOAD_SIZE = 500*1024*1024;

/**
 Показать браузер пользователю. Если браузер уже показывается, он будет закрыт и открыт новый
 @param {String} title Заголовок окна браузера
 @param {String[]} mask Массив допустимых для выбора разрешений файлов. Если массив пустой, то выбираются директории, а не отдельные файлы
 @param {function(path)} closeFunc Функция, которая будет вызвана при выборе файла/директории (если браузер просто закрыли, не вызовется)
 @param {Object} params Параметры браузера
 @param {String} params.restrictDir Ограничивающая директория (поддерево). Нельзя посмотреть файлы вне этой директории (даже для админов)
 @param {String} params.startDir Начальная директория. Если нет, то будет открыто в том же месте, где и закрыт в прошлый раз.
*/
fileBrowser.prototype.createBrowser = function(title, mask, closeFunc, params)
{
    this._params = $.extend({restrictDir: null, startDir: null}, params);
    
    if (this._params.startDir !== null)
        this._path.set(this._params.startDir);
    
	if ($('#fileBrowserDialog').length)
	{
		$('#fileBrowserDialog').parent().dialog("destroy");
		$('#fileBrowserDialog').parent().remove();
	}
	
	var canvas = _div(null, [['attr','id','fileBrowserDialog']]);
    
	var oDialog = showDialog(title, canvas, 800, 400, false, false, this.resize);
	
	this.returnMask = mask;
	this.parentCanvas = canvas;
	this.closeFunc = closeFunc;
    this._homeDir = nsGmx.AuthManager.getUserFolder();
	
	if (this._discs === null )// && nsGmx.AuthManager.canDoAction(nsGmx.ACTION_SEE_FILE_STRUCTURE )
		this.loadInfo();
	else
		this.loadInfoHandler()
		
	return oDialog;
}

fileBrowser.prototype.resize = function()
{
	if (!$("#fileBrowserDialog").find(".fileCanvas").length)
		return;
    
    var container = $('#fileBrowserDialog')[0];
	
	var titleHeight = container.parentNode.parentNode.firstChild.offsetHeight;
    
	
	container.childNodes[1].lastChild.style.height = container.parentNode.parentNode.offsetHeight - titleHeight - 6 - container.lastChild.offsetHeight - container.firstChild.offsetHeight - container.childNodes[1].firstChild.offsetHeight - 20 + 'px';
}

fileBrowser.prototype.close = function(path)
{
	this.closeFunc(path);
	
	var canvas = $('#fileBrowserDialog')[0];
	
	$(canvas.parentNode).dialog("destroy");
	
	canvas.parentNode.removeNode(true);
}

fileBrowser.prototype.loadInfo = function()
{
	var _this = this;
	sendCrossDomainJSONRequest(serverBase + "FileBrowser/GetDrives.ashx?WrapStyle=func", function(response)
	{
		if (!parseResponse(response))
			return;
		
        _this._discs = response.Result;
		_this.loadInfoHandler()
	})
}

fileBrowser.prototype._showWarningDialog = function() {
    var canvas = _div([_t(_gtxt("FileBrowser.ExceedLimitMessage"))], [['dir', 'className', 'CustomErrorText']]);
    showDialog(_gtxt("Ошибка!"), canvas, 220, 100);
}

fileBrowser.prototype._uploadFilesAjax = function(formData) {
    var _this = this;
    this.progressBar.progressbar('option', 'value', 0);
    this.progressBar.show();
    
    formData.append('WrapStyle', 'None');
    
    var xhr = new XMLHttpRequest();
    
    xhr.upload.addEventListener("progress", function(e) {
        _this.progressBar.progressbar('option', 'value', e.loaded / e.total * 100);
    }, false);
    
    xhr.open('POST', serverBase + 'FileBrowser/Upload.ashx');
    xhr.withCredentials = true;
    xhr.onload = function () {
        _this.progressBar.hide();
        if (xhr.status === 200) {
            response = JSON.parse(xhr.responseText);
            
            if (!parseResponse(response))
                return;
                
            if (typeof response.Result == 'string') {
                var indexSlash = String(response.Result).lastIndexOf(_this.slash),
                    fileName = String(response.Result).substring(indexSlash + 1, response.Result.length);
                
                _this.shownPath = fileName;
            }
            
            _this.getFiles();
        }
    };
    
    xhr.send(formData);    
}

fileBrowser.prototype.loadInfoHandler = function()
{
    var _this = this;
	if (!this._path.isInited())
	{
        var mapFolder = _layersTree.treeModel.getMapProperties().LayersDir;
        if (mapFolder) {
            this._path.set(_layersTree.treeModel.getMapProperties().LayersDir, nsGmx.AuthManager.getUserFolder());
        } else {
            this._path.set(nsGmx.AuthManager.getUserFolder());
        }
	}
	
	this.currentSortFunc = this.sortFuncs['name'][0];
	
	this.fileUpload = _div(null, [['dir','className','fileUpload']]);
	this.fileHeader = _div(null, [['css','height','24px']]);
	this.fileCanvas = _div(null, [['dir','className','fileCanvas']]);
    
    $(this.parentCanvas).bind('dragover', function()
    {
        return false;
    });
    
    $(this.parentCanvas).bind('drop', function(e)
    {
        if (!window.FormData) return false;
        
        var files = e.originalEvent.dataTransfer.files;
        var formData = new FormData();
        
        var totalSize = 0;
        for (var f = 0; f < files.length; f++) {
            totalSize += files[f].size;
        }
        
        if (totalSize > fileBrowser.MAX_UPLOAD_SIZE) {
            _this._showWarningDialog();
            return false;
        }
        
        for (var f = 0; f < files.length; f++) {
            formData.append('rawdata', files[f]);
        }
        
        formData.append('ParentDir', _this._path.get());
        
        _this._uploadFilesAjax(formData);
        
        return false;
    })
	
	_(this.parentCanvas, [this.fileHeader, this.fileCanvas, this.fileUpload]);
	
	this.createHeader();
	this.createUpload();
	
	this._updateUploadVisibility();
	
	this.getFiles();
}

fileBrowser.prototype._updateUploadVisibility = function()
{
    $([this.fileUpload, this.tdAddFolder]).toggle(nsGmx.AuthManager.isRole(nsGmx.ROLE_ADMIN) || this._path.isInHome())
}

fileBrowser.prototype.createHeader = function()
{
	var reloadButton = makeImageButton("img/reload.png"),
		homeButton = makeImageButton("img/home.png"),
		discButtonTds = [],
		_this = this;
	
	reloadButton.style.margin = '0px 5px 0px 10px';
	homeButton.style.margin = '0px 10px 0px 5px';
	
	reloadButton.style.width = '14px';
	reloadButton.style.height = '15px';
	homeButton.style.width = '15px';
	homeButton.style.height = '15px';
	
	_title(reloadButton, _gtxt("Обновить"));
	_title(homeButton, _gtxt("Домашняя директория"));
	
	reloadButton.onclick = function()
	{
		_this.getFiles();
	}
	
	homeButton.onclick = function()
	{
        _this._path.set(_layersTree.treeModel.getMapProperties().LayersDir, _this._homeDir);
		_this.getFiles(_layersTree.treeModel.getMapProperties().LayersDir);
	}
	
	//if ( nsGmx.AuthManager.canDoAction(nsGmx.ACTION_SEE_FILE_STRUCTURE ) )
	//{
		for (var i = 0; i < this._discs.length; i++)
		{
			var discButtons = makeButton(this._discs[i]);
			
			(function(i)
			{
				discButtons.onclick = function()
				{
					_this.getFiles(_this._discs[i])
				}
			})(i)
			
			discButtonTds.push(_td([discButtons]))
		}
	//}
	
	discButtonTds.push(_td([reloadButton], [['attr','vAlign','top']]));
	discButtonTds.push(_td([homeButton], [['attr','vAlign','top']]));
	
	var newFolderName = _input(null, [['dir','className','inputStyle'], ['css','width','150px']]),
		showFolderButton = makeImageButton("img/newfolder.png"),
		newFolderButton = makeButton(_gtxt("Создать")),
		createFolder = function()
		{
            _this._status.start();
			sendCrossDomainJSONRequest(serverBase + 'FileBrowser/CreateFolder.ashx?WrapStyle=func&FullName=' + encodeURIComponent(_this._path.get() + newFolderName.value), function(response)
			{
                _this._status.stop();
				if (!parseResponse(response))
					return;
				
				_this.shownPath = newFolderName.value;
				
				newFolderName.value = '';
				
				_this.getFiles();
			})
		};
		
	showFolderButton.style.width = '16px';
	showFolderButton.style.height = '13px';
	
	newFolderName.style.margin = '0px 3px';
	
	_title(showFolderButton, _gtxt("Новая папка"))
	
	showFolderButton.style.marginRight = '10px';
	
	showFolderButton.onclick = function()
	{
        $(newFolderName).toggle().focus();
        $(newFolderButton).toggle();
	}
	
	newFolderName.style.display = 'none';
	newFolderButton.style.display = 'none';
		
	$(newFolderName).on('keydown', function(e)
	{
		if (e.keyCode === 13)
	  	{
	  		if (newFolderName.value != '')
				createFolder();
			else
				inputError(newFolderName);
	  		
	  		return false;
	  	}
	});
	
	newFolderButton.onclick = function()
	{
		if (newFolderName.value != '')
			createFolder();
		else
			inputError(newFolderName);
	}
	
	this.tdAddFolder = _td([_table([_tbody([_tr([
            _td([showFolderButton], [['attr','vAlign','top']]),
            _td([newFolderName]),
            _td([newFolderButton])]
        )])])], [['attr','vAlign','top'], ['css','height','20px']]);
        
	discButtonTds.push(this.tdAddFolder);
	
	_(this.fileHeader, [_table([_tbody([_tr(discButtonTds)])])]);
}

fileBrowser.prototype.createUpload = function()
{
	var div = _div(null, [['css','height','30px']]),
		_this = this;
	
	var formFile = _form(null,[['attr','enctype','multipart/form-data'],['dir','method','post'],['dir','action', serverBase + 'FileBrowser/Upload.ashx?WrapStyle=message'],['attr','target','fileBrowserUpload_iframe']]);

	var attach = _input(null,[['attr','type','file'],['dir','name','rawdata'],['css','width','200px'], ['attr','multiple','multiple']]);
	_(formFile, [attach]);
    
    attach.onchange = function()
	{
        if (attach.files && attach.files[0] && attach.files[0].size > fileBrowser.MAX_UPLOAD_SIZE) {
            _this._showWarningDialog();
            return;
        }
        
        //если можем послать через AJAX, посылаем - будет работать прогресс-бар
        if (window.FormData) {
            var formData = new FormData(formFile);
            formData.append('ParentDir', _this._path.get());
            _this._uploadFilesAjax(formData);
            return;
        }
        
        sendCrossDomainPostRequest(serverBase + 'FileBrowser/Upload.ashx', 
            {
                WrapStyle: 'message',
                ParentDir: _this._path.get()
            },
            function(response) {
                if (!parseResponse(response))
                    return;
                
                var indexSlash = String(response.Result).lastIndexOf(_this.slash),
                    fileName = String(response.Result).substring(indexSlash + 1, response.Result.length);
                
                _this.shownPath = fileName;
                
                _this.getFiles();
            }, 
            formFile
        );
	}
    
    var dropInfoDiv = window.FormData ? _div([_t(_gtxt('FileBrowser.DropInfo'))], [['dir', 'className', 'fileBrowser-dragFileMessage']]) : _div();
	
	_(div, [
        dropInfoDiv,
        _table([_tbody([_tr([
            _td([formFile], [['css', 'paddingTop', '18px']])
        ])])])
    ]);
    
    this.progressBar = $('<div/>').addClass('fileBrowser-progressBar').progressbar({value: 100}).hide();
    
    _(this.fileUpload, [this.progressBar[0], div]);
}

fileBrowser.prototype.getFiles = function(path)
{
	var path = (typeof path != 'undefined') ? path : this._path.get();
    var alternativePath = this._path.getAlternative();
	var _this = this;
    
    if (this._isRestrictedPath(path)) 
        return;
        
    var doProcessResponce = function(response) {
        _this._status.stop();
        
		if (!parseResponse(response))
			return;
		
		_this.getFilesHandler(response.Result, path);
    }

    this._status.start();
	sendCrossDomainJSONRequest(serverBase + "FileBrowser/GetDirectoryContent.ashx?WrapStyle=func&root=" + encodeURIComponent(path), function(response)
	{
        if (response.Status !== 'ok' && alternativePath) {
            path = alternativePath;
            _this._path.set(alternativePath);
            sendCrossDomainJSONRequest(serverBase + "FileBrowser/GetDirectoryContent.ashx?WrapStyle=func&root=" + encodeURIComponent(alternativePath), doProcessResponce);
        } else {
            doProcessResponce(response);
        }
	})
}

fileBrowser.prototype.getFilesHandler = function(files, path)
{
	this._path.set(path);
	this.currentFiles = files;

	this._updateUploadVisibility();

	this.reloadFiles();
}

fileBrowser.prototype.pathWidget = function()
{
    var shortPath = this._path.get();
    var _this = this;
    
    var parent = $('<span/>', {'class': 'fileBrowser-pathWidget'});
    var pathElements = [];
    
    var highlightPath = function(index)
    {
        for (var e = 0; e < pathElements.length; e++)
            if (e <= index)
                pathElements[e].addClass('fileBrowser-activePathElem');
            else
                pathElements[e].removeClass('fileBrowser-activePathElem');
    }
    
    var appendElem = function(text, path){
        var elemIndex = pathElements.length;
        var newElem = $('<span/>', {'class': 'fileBrowser-pathElem'}).text(text + _this.slash)
        .click(function()
        {
            _this.getFiles(path[path.legnth - 1] === _this.slash ? path : path  + _this.slash);
        })
        .hover(function(){highlightPath(elemIndex)}, function(){highlightPath(-1)});
        
        pathElements.push(newElem);
        parent.append(newElem);//.append( $('<span/>').text(_this.slash) );
    }
    
    var curFolder = '';
    while (shortPath.length)
    {
        var index = shortPath.indexOf(this.slash);
        if (index == 0) break;
            
        if (index < 0)
        {
            appendElem(shortPath, curFolder + shortPath);
            break;
        }
        var curText = shortPath.substr(0, index);
        curFolder += curText + this.slash;
        shortPath = shortPath.substr(index+1);
        
        appendElem(curText, curFolder.substr(0, curFolder.length-1));
    }
    
    return parent[0];
}

fileBrowser.prototype.quickSearch = function()
{
	var input = _input(null, [['dir','className','inputStyle'],['css','width','200px']]),
		_this = this;
	
	input.onkeyup = function()
	{
		if (this.value != "")
		{
			var scroll = _this.findContent(this.value);
			
			if (scroll >= 0)
				_this.fileCanvas.lastChild.scrollTop = scroll;
		}
	}
	
	return input;
}

fileBrowser.prototype.findContent = function(value)
{
	var tbody = this.fileCanvas.lastChild.firstChild.lastChild;
	
	for (var i = 0; i < tbody.childNodes.length; ++i)
	{
		var text = tbody.childNodes[i].textContent.toLowerCase();
		
		if (text != "[..]" && text.indexOf(value.toLowerCase()) == 0)
			return tbody.childNodes[i].offsetTop;
	}
	
	return -1;
}

fileBrowser.prototype.reloadFiles = function()
{
    $(this.fileCanvas).empty();
    
    this.statusContainer = _div(null, [['dir', 'className', 'fileBrowser-progress'], ['css', 'display', 'none']]);
	
	_(this.fileCanvas, [_div([this.pathWidget(), _br(), _t(_gtxt("Фильтр")), this.quickSearch(), this.statusContainer], [['dir','className','currentDir'],['css','color','#153069'],['css','fontSize','12px']])]);
	
	_(this.fileCanvas, [this.draw(this.currentFiles)]);
	
	this.resize();
	
	if (this.shownPathScroll)
	{
		this.fileCanvas.lastChild.scrollTop = this.shownPathScroll.offsetTop;
		
		this.shownPathScroll = false;
	}
}

fileBrowser.prototype._getParentFolder = function(path)
{
    var index = String(path).lastIndexOf(this.slash),
        newPath = String(path).substr(0, index);
    
    if (new RegExp(/^[a-z]:$/i).test(newPath))
        newPath += this.slash;
        
    return newPath;
}

fileBrowser.prototype._isRestrictedPath = function(path)
{
    return this._params.restrictDir !== null && path.indexOf(this._params.restrictDir) != 0;
}

fileBrowser.prototype.draw = function(files)
{
	var nameSort = makeLinkButton(_gtxt("Имя")),
		extSort = makeLinkButton(_gtxt("Тип")),
		sizeSort = makeLinkButton(_gtxt("Размер")),
		dateSort = makeLinkButton(_gtxt("Дата")),
		_this = this;
	
	nameSort.sortType = 'name';
	extSort.sortType = 'ext';
	sizeSort.sortType = 'size';
	dateSort.sortType = 'date';
	
	nameSort.onclick = extSort.onclick = sizeSort.onclick = dateSort.onclick = function()
	{
		_this.currentSortType = this.sortType;
		_this.currentSortIndex[_this.currentSortType] = 1 - _this.currentSortIndex[_this.currentSortType];
		
		_this.reloadFiles();
	}
	
	var tdRoot = _td(null, [['css','width','20px']]);
	
	if ( nsGmx.AuthManager.canDoAction(nsGmx.ACTION_SEE_FILE_STRUCTURE ) )
	{
		var rootButton = makeButton(this.slash);
		
		_(tdRoot, [rootButton]);
		
		rootButton.onclick = function()
		{
			_this.getFiles(_this._path.getRoot());
		}
	}
	
	var tableHeaderTr = _tr([tdRoot, _td([nameSort],[['css','textAlign','left']]), _td([extSort], [['css','width','10%'],['css','textAlign','center']]), _td([sizeSort], [['css','width','15%'],['css','textAlign','center']]), _td([dateSort], [['css','width','25%'],['css','textAlign','center']])]),
		prevDirTr = _tr([_td(), _td([_t("[..]")]), _td(), _td(), _td()]),
		tableFilesTrs = [];
	
    var parentFolder = _this._path.getParentFolder();
	if (parentFolder && !this._isRestrictedPath(parentFolder))
	{
        tableFilesTrs.push(prevDirTr)
	
		attachEffects(prevDirTr, 'hover')

		prevDirTr.onclick = function()
		{
			_this.getFiles(parentFolder);
		}
	}
	
	tableFilesTrs = tableFilesTrs.concat(this.drawFolders(files));
	tableFilesTrs = tableFilesTrs.concat(this.drawFiles(files));
	
	return _div([_table([_thead([tableHeaderTr]), _tbody(tableFilesTrs)], [['css','width','100%']])], [['css','overflowY','scroll']]);
}

fileBrowser.prototype.getCurrentSortFunc = function()
{
	return this.sortFuncs[this.currentSortType][this.currentSortIndex[this.currentSortType]];
}

fileBrowser.prototype.formatDate = function(sec)
{
	var sysDate = new Date(sec * 1000),
		date = [];

	date[0] = sysDate.getDate(),
	date[1] = sysDate.getMonth() + 1,
	date[2] = sysDate.getFullYear(),
	date[3] = sysDate.getHours(),
	date[4] = sysDate.getMinutes(),
	date[5] = sysDate.getSeconds();

	for (var i = 0; i < 6; i++)
		if (date[i] < 10)
			date[i] = '0' + date[i];

	return date[0] + '.' + date[1] + '.' + date[2] + ' ' + date[3] + ':' + date[4] + ':' + date[5];
}

fileBrowser.prototype.drawFolders = function(arr)
{
	var folders = [],
		trs = [],
		_this = this;;
	
	for (var i = 0; i < arr.length; i++)
		if (arr[i].Directory)
			folders.push(arr[i]);
	
	if (this.currentSortType == 'name' || this.currentSortType == 'date')
		folders = folders.sort(this.getCurrentSortFunc());
	
	for (var i = 0; i < folders.length; i++)
	{
		var tdReturn = _td();
		
		if (!this.returnMask.length)
		{
			var returnButton = makeImageButton("img/choose.png", "img/choose_a.png");
			returnButton.style.cursor = 'pointer';
			returnButton.style.marginLeft = '5px';
			
			_title(returnButton, _gtxt("Выбрать"));
			
			(function(i){
				returnButton.onclick = function(e)
				{
					_this.close(_this._path.get() + folders[i].Name + _this.slash);
				}
			})(i);
			
			_(tdReturn, [returnButton])
		}
		
		var tr = _tr([
            tdReturn, 
            _td([_div(null, [['dir','className','fileCanvas-folder-icon']]), this.createFolderActions(folders[i].Name)]), 
            _td(), 
            _td([_t(_gtxt("Папка"))],[['css','textAlign','center'],['dir','className','invisible']]), 
            _td([_t(this.formatDate(folders[i].Date))],[['css','textAlign','center'],['dir','className','invisible']])
        ]);
		
		(function(i){
			tr.onclick = function()
			{
				_this.getFiles(_this._path.get() + folders[i].Name);
			}
		})(i);
		
		attachEffects(tr, 'hover');
		
		if (this.shownPath && folders[i].Name == this.shownPath)
		{
			$(tr).children("td").css('backgroundColor', '#CEEECE');
			
			this.shownPath = null;
			
			this.shownPathScroll = tr;
		}
		
		trs.push(tr)
	}
	
	return trs;
}

fileBrowser.prototype.drawFiles = function(arr)
{
	var files = [],
		trs = [],
		_this = this;
	
	for (var i = 0; i < arr.length; i++)
		if (!arr[i].Directory)
			files.push(arr[i]);
	
	files = files.sort(this.getCurrentSortFunc());
	
	for (var i = 0; i < files.length; i++)
	{
		var index = String(files[i].Name).lastIndexOf('.'),
			name = String(files[i].Name).substr(0, index),
			ext = String(files[i].Name).substr(index + 1, files[i].Name.length),
			tdReturn = _td()
			tdSize = _td([_t(this.makeSize(files[i].Size))], [['attr','size',files[i].Size],['css','textAlign','right'],['dir','className','invisible']]);
		
		if (this.returnMask.length && valueInArray(this.returnMask, ext.toLowerCase()))
		{
			var returnButton = makeImageButton("img/choose.png", "img/choose_a.png");
			returnButton.style.cursor = 'pointer';
			returnButton.style.marginLeft = '5px';
			
			_title(returnButton, _gtxt("Выбрать"));
			
			(function(i){
				returnButton.onclick = function(e)
				{
					_this.close(_this._path.get() + files[i].Name);
				}
			})(i);
			
			_(tdReturn, [returnButton])
		}
		
		var	tr = _tr([tdReturn, _td([this.createFileActions(name, ext)]), _td([_t(ext)],[['css','textAlign','right'],['css','fontSize','12px']]), tdSize, _td([_t(this.formatDate(files[i].Date))],[['css','textAlign','center'],['dir','className','invisible']])]);
		
		attachEffects(tr, 'hover');
		
		if (this.shownPath && files[i].Name == this.shownPath)
		{
			$(tr).children("td").css('backgroundColor', '#CEEECE');
			
			this.shownPath = null;
			
			this.shownPathScroll = tr;
		}

		trs.push(tr)
	}
	
	return trs;
}

fileBrowser.prototype.createFolderActions = function(name)
{
	var span = _span([_t(name)],[['css','fontSize','12px']]),
		spanParent = _div([span],[['css','display', 'inline-block'],['css','position','relative']]),
		_this = this;
	
	nsGmx.ContextMenuController.bindMenuToElem(spanParent, 'FileBrowserFolder', 
		function()
		{
			return _this._path.isInHome() || nsGmx.AuthManager.canDoAction( nsGmx.ACTION_SEE_FILE_STRUCTURE );
		}, 
		{
			fullPath: this._path.get() + name + this.slash,
			fileBrowser: this,
			enableZip: true
		}
	);

	return spanParent;
}

fileBrowser.prototype.createFileActions = function(name, ext)
{
	var span = _span([_t(name)],[['css','fontSize','12px']]),
		spanParent = _div([span],[['css','display','inline-block'],['css','position','relative']]),
		_this = this;

	nsGmx.ContextMenuController.bindMenuToElem(spanParent, 'FileBrowserFile', 
		function()
		{
			return _this._path.isInHome() || nsGmx.AuthManager.canDoAction( nsGmx.ACTION_SEE_FILE_STRUCTURE );
		}, 
		{
			fullPath: this._path.get() + name + '.' + ext,
			fileBrowser: this,
			enableUnzip: valueInArray(_this.ext7z, ext.toUpperCase())
		}
	);
	
	return spanParent;
}

//TODO: translate
fileBrowser.prototype.makeSize = function(size)
{
	if (size > 1024 * 1024 * 1024)
		return (size / (1024 * 1024 * 1024)).toFixed(2) + ' Гб';
	else if (size > 1024 * 1024)
		return (size / (1024 * 1024)).toFixed(2) + ' Мб';
	else if (size > 1024)
		return (size / 1024).toFixed(2) + ' Кб';
	
	return size + ' б';
}

window.fileBrowser = fileBrowser;
window._fileBrowser = new fileBrowser();

///////////////////////////////////////////////////////////////////////////////
////////////////////////// Контекстное меню браузера //////////////////////////
///////////////////////////////////////////////////////////////////////////////

//фабрика, которая может возвращать элементы меню для архивирования (isZip=true) и разархивирования (isZip=false)
var zipUnzipActionFactory = function(isZip)
{
	return {
		title:  function() { return isZip ? _gtxt("Упаковать") : _gtxt("Извлечь"); },
		clickCallback: function(context)
		{
            context.fileBrowser._status.start();
			sendCrossDomainJSONRequest(serverBase + (context.enableUnzip ? 'FileBrowser/Unzip.ashx' : 'FileBrowser/Zip.ashx') + '?WrapStyle=func&FullName=' + encodeURIComponent(context.fullPath), function(response)
			{
                context.fileBrowser._status.stop();
                
				if (!parseResponse(response))
					return;
				
				var indexSlash = String(response.Result).lastIndexOf('\\'),
					fileName = String(response.Result).substring(indexSlash + 1, response.Result.length);
				
				context.fileBrowser.shownPath = fileName;
				
				context.fileBrowser.getFiles();
			})
		},
		isVisible: function(context)
		{
			return isZip ? !context.enableUnzip : context.enableUnzip; //XOR
		}
	}
}

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Скачать"); },
	clickCallback: function(context)
	{
		var form = _form([_input(null,[['attr','name','FullName'], ['attr','value', context.fullPath]])], [['css','display','none'],['attr','method','POST'],['attr','action',serverBase + "FileBrowser/Download.ashx"]]);
		
		_(document.body, [form]);
		
		form.submit();
		
		form.removeNode(true);
	}
}, ['FileBrowserFolder', 'FileBrowserFile']);

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Удалить"); },
	clickCallback: function(context)
	{
        context.fileBrowser._status.start();
		sendCrossDomainJSONRequest(serverBase + 'FileBrowser/Delete.ashx?WrapStyle=func&FullName=' + encodeURIComponent(context.fullPath), function(response)
		{
            context.fileBrowser._status.stop();
			if (!parseResponse(response))
				return;
			
			context.fileBrowser.getFiles();
		})
	}
}, ['FileBrowserFolder', 'FileBrowserFile']);

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Очистить"); },
	clickCallback: function(context)
	{
        context.fileBrowser._status.start();
		sendCrossDomainJSONRequest(serverBase + 'FileBrowser/CleanFolder.ashx?WrapStyle=func&FullName=' + encodeURIComponent(context.fullPath), function(response)
		{
            context.fileBrowser._status.stop();
			if (!parseResponse(response))
				return;
			
			context.fileBrowser.getFiles();
		})	
	}
}, 'FileBrowserFolder');

//упаковываем и файлы и папки
nsGmx.ContextMenuController.addContextMenuElem(zipUnzipActionFactory(true), ['FileBrowserFolder', 'FileBrowserFile']);

//распаковываем только файлы
nsGmx.ContextMenuController.addContextMenuElem(zipUnzipActionFactory(false), 'FileBrowserFile');

})(nsGmx.Utils._);

_translationsHash.addtext("rus", {
                            "tableBrowser.title" : "Список таблиц",
                            "tableBrowser.filterText" : "Фильтр по названию"
                         });
                         
_translationsHash.addtext("eng", {
                            "tableBrowser.title" : "Tables list",
                            "tableBrowser.filterText" : "Filter by name"
                         });                         

var tableBrowser = function()
{
	this.sortFuncs = 
	{
		name:[
			function(_a,_b){var a = String(_a).toLowerCase(), b = String(_b).toLowerCase(); if (a > b) return 1; else if (a < b) return -1; else return 0},
			function(_a,_b){var a = String(_a).toLowerCase(), b = String(_b).toLowerCase(); if (a < b) return 1; else if (a > b) return -1; else return 0}
		]
	};
	
	this.tables = [];
}

tableBrowser.prototype.createBrowser = function(closeFunc)
{
    var canvas = $('#tableBrowserDialog');
    
	if (canvas)
	{
		canvas.parent().dialog("destroy");
		
		canvas.parent().remove();
	}
		
	this.closeFunc = closeFunc;
	
	if (!this.tables.length)
		this.loadInfo();
	else
		this.loadInfoHandler(this.tables)
}

tableBrowser.prototype.close = function(name)
{
	this.closeFunc(name);
	
	var canvas = $('#tableBrowserDialog');
	
	$(canvas).parent().dialog("destroy");
	
	$(canvas).parent().remove();
}

tableBrowser.prototype.loadInfo = function()
{
	sendCrossDomainJSONRequest(serverBase + "VectorLayer/GetGeometryTables.ashx?WrapStyle=func", function(response)
	{
		if (!parseResponse(response))
			return;
		
		_tableBrowser.loadInfoHandler(response.Result)
	})
}

tableBrowser.prototype.loadInfoHandler = function(tables)
{
	this.tables = tables;
    
    var _this = this;
    var renderTableRow = function(table)
    {
        var	tdName = _td([_t(table)],[['css','fontSize','12px']]),
			returnButton = makeImageButton("img/choose.png", "img/choose_a.png"),
			tr = _tr([_td([returnButton]), tdName], [['dir', 'className', 'tableTableRow']]);
		
		returnButton.style.cursor = 'pointer';
		returnButton.style.marginLeft = '5px';
	
		_title(returnButton, _gtxt("Выбрать"));
			
        returnButton.onclick = function()
        {
            _this.close(table);
        }
		
		attachEffects(tr, 'hover');
        
        for (var i = 0; i < tr.childNodes.length; i++)
            tr.childNodes[i].style.width = this._fields[i].width;
        
        return tr;
    }
    
    var sortFuncs = {};
    sortFuncs[_gtxt('Имя')] = this.sortFuncs['name'];
    
    var tableProvider = new nsGmx.ScrollTable.StaticDataProvider();
    tableProvider.setOriginalItems(this.tables);
    tableProvider.setSortFunctions(sortFuncs);
    
    var tableTable = new nsGmx.ScrollTable({limit:5000, pagesCount: 5, height: 220, showFooter: false});
    tableTable.setDataProvider(tableProvider);
    
    var tableParent = _div(null, [['dir', 'id', 'tableBrowserDialog']]);
    tableTable.createTable({
        parent: tableParent, 
        name: 'tableTable', 
        width: 0, 
        fields: ['', _gtxt('Имя')], 
        fieldsWidths: ['10%', '90%'], 
        sortableFields: sortFuncs,
        drawFunc: renderTableRow, 
        isWidthScroll: false
    });
    
    var filterInput = _input(null, [['css','width','150px'],['dir','className','selectStyle']]);
    $(tableParent).prepend(filterInput).prepend($('<span/>', {'class': 'tableFilter'}).text(_gtxt("tableBrowser.filterText") + ": "));
    tableProvider.attachFilterEvents(filterInput, 'Table', function(fieldName, fieldValue, vals)
    {
        return vals.filter(function(val) {
            return String(val).toLowerCase().indexOf(fieldValue.toLowerCase()) > -1;
        });
    });
    
    showDialog( _gtxt("tableBrowser.title"), tableParent, {width: 300, height: 300} );
}

var _tableBrowser = new tableBrowser();
!(function(_) {
    
var wmsProjections = ['EPSG:3395', 'EPSG:4326', 'EPSG:41001'];	// типы проекций
    
var getTextContent = function(node) {
    if (typeof node.textContent != 'undefined')
        return node.textContent;
    
    var data = '';
    for (var i = 0; i < node.childNodes.length; i++)
        data += node.childNodes[i].data;
    
    return data;
}

var getScale = function(z)
{
    return Math.pow(2, -z)*156543.033928041;
}

/** Формирует URL картинки, который можно использовать для получения WMS слоя для данного положения карты
 * @property {String} url - WMS ссылка.
 * @property {object} props - атрибуты.
 * @property {String} props.srs - тип проекции.
 * @property {String} props.version - версия.
 * @property {String} props.name - Идентификатор слоя.
 * @property {object} props.bbox - ограничение по bounds(в географических координатах).
 * @property {object} requestProperties - атрибуты формата результирующего image.
 * @property {String} requestProperties.format - тип (по умолчанию 'image/jpeg').
 * @property {String} requestProperties.transparent - прозрачность подложки ('TRUE'/'FALSE' по умолчанию 'FALSE').
 * @returns {object} - {url: String, bounds: {Extent}}. bounds в географических координатах.
*/
var getWMSMapURL = function(url, props, requestProperties)
{
    var CRSParam = {'1.1.1': 'SRS', '1.3.0': 'CRS'};
    
    requestProperties = requestProperties || {};

    var lmap = nsGmx.leafletMap,
        extend = lmap.getBounds();
    
    var miny = Math.max(extend.getSouth(), -90);
    var maxy = Math.min(extend.getNorth(), 90);
    var minx = Math.max(extend.getWest(), -180);
    var maxx = Math.min(extend.getEast(), 180);
    
    if (props.bbox)
    {
        minx = Math.max(props.bbox.minx, minx);
        miny = Math.max(props.bbox.miny, miny);
        maxx = Math.min(props.bbox.maxx, maxx);
        maxy = Math.min(props.bbox.maxy, maxy);

        if (minx >= maxx || miny >= maxy)
            return;
    }
    
    var mercMin = L.Projection.Mercator.project({lat: miny, lng: minx}),
        mercMax = L.Projection.Mercator.project({lat: maxy, lng: maxx});
    
    var scale = getScale(lmap.getZoom());
    var w = Math.round((mercMax.x - mercMin.x)/scale);
    var h = Math.round((mercMax.y - mercMin.y)/scale);

    var isMerc = !(props.srs == wmsProjections[1]);

    var st = url;
    var format = requestProperties.format || 'image/jpeg';
    var transparentParam = requestProperties.transparent ? 'TRUE' : 'FALSE';
    var version = props.version || '1.1.1';
    var isV130 = version === '1.3.0';
    
    //st = st.replace(/Service=WMS[\&]*/i, '');
    //st = st.replace(/\&$/, '');
    
    st += (st.indexOf('?') == -1 ? '?':'&') + 'request=GetMap&Service=WMS';
    st += "&layers=" + encodeURIComponent(props.name) +
        "&VERSION=" + encodeURIComponent(version) +
        "&" + CRSParam[version] + "=" + encodeURIComponent(props.srs) +
        "&styles=" +
        "&width=" + w +
        "&height=" + h +
        "&bbox=" + (isMerc ? mercMin.x : isV130 ? miny : minx) +
             "," + (isMerc ? mercMin.y : isV130 ? minx : miny) +
             "," + (isMerc ? mercMax.x : isV130 ? maxy : maxx) +
             "," + (isMerc ? mercMax.y : isV130 ? maxx : maxy);

    if (url.indexOf('format=') == -1) st += "&format=" + encodeURIComponent(format);
    if (url.indexOf('transparent=') == -1) st += "&transparent=" + encodeURIComponent(transparentParam);
   
    return {url: st, bounds: {minX: minx, maxX: maxx, minY: miny, maxY: maxy}};
}

/**
 * Возвращает описание WMS-слоёв от XML, которую вернул сервер на запрос GetCapabilities
 * @returns {Array} - массив объектов с описанием слоёв
*/
var parseWMSCapabilities = function(response)
{
    var supportedVersions = {'1.1.1': true, '1.3.0': true};
    var SRSTagName = {'1.1.1': 'SRS', '1.3.0': 'CRS'};
    var BBOXTagName = {'1.1.1': 'LatLonBoundingBox', '1.3.0': 'EX_GeographicBoundingBox'};
    var serviceLayers = [],
        strResp = response.replace(/[\t\n\r]/g, ' '),
        strResp = strResp.replace(/\s+/g, ' '),
        xml = parseXML(response),
        mainTag = xml.getElementsByTagName('WMS_Capabilities')[0] || xml.getElementsByTagName('WMT_MS_Capabilities')[0],
        version = mainTag.getAttribute('version'),
        layersXML = xml.getElementsByTagName('Layer');
    
    if (!(version in supportedVersions)) {
        return [];
    }
    
    for (var i = 0; i < layersXML.length; i++)
    {
        var layer = {version: version},
            name = layersXML[i].getElementsByTagName('Name'),
            title = layersXML[i].getElementsByTagName('Title'),
            bbox = layersXML[i].getElementsByTagName(BBOXTagName[version]),
            srs = layersXML[i].getElementsByTagName(SRSTagName[version]);
        
        if (srs.length)
        {
            layer.srs = null;
            var supportedSrs = {};
            for (var si = 0; si < srs.length; si++)
            {
                var srsName = strip(getTextContent(srs[si]));
                supportedSrs[srsName] = true;
            }
            
            //порядок имеет значение!
            for (var p = 0; p < wmsProjections.length; p++) {
                if (wmsProjections[p] in supportedSrs) {
                    layer.srs = wmsProjections[p];
                    break;
                }
            }
            if (!layer.srs) continue;
        }
        else {
            layer.srs = wmsProjections[0];
        }

        if (name.length)
            layer.name = getTextContent(name[0]);
        
        if (bbox.length)
        {
            if (version == '1.1.1') {
                layer.bbox = 
                {
                    minx: Number(bbox[0].getAttribute('minx')),
                    miny: Number(bbox[0].getAttribute('miny')),
                    maxx: Number(bbox[0].getAttribute('maxx')),
                    maxy: Number(bbox[0].getAttribute('maxy'))
                };
            } else {
                layer.bbox = 
                {
                    minx: Number(getTextContent(bbox[0].getElementsByTagName('westBoundLongitude')[0])),
                    miny: Number(getTextContent(bbox[0].getElementsByTagName('southBoundLatitude')[0])),
                    maxx: Number(getTextContent(bbox[0].getElementsByTagName('eastBoundLongitude')[0])),
                    maxy: Number(getTextContent(bbox[0].getElementsByTagName('northBoundLatitude')[0]))
                };
            }
        }
        
        if (title.length)
            layer.title = getTextContent(title[0]);
        
        if (layer.name)
            serviceLayers.push(layer);
    }
    
    return serviceLayers;
}

var loadServerData = window.loadServerData =
{
	WFS:{},
	WMS:{}
}

/* Порядок координат в WFS зависит от формата SRS (http://geoserver.org/display/GEOSDOC/2.+WFS+-+Web+Feature+Service)
    * EPSG:xxxx: longitude/latitude (supported in WFS 1.1 requests too)
    * http://www.opengis.net/gml/srs/epsg.xml#xxxx: longitude/latitude (supported in WFS 1.1 requests too)
    * urn:x-ogc:def:crs:EPSG:xxxx: latitude/longitude
*/

var wfsParser = function()
{
	this.gmlns = 'http://www.opengis.net/gml';
	this.kmlns = 'http://earth.google.com/kml/2.0';
	
	this.axisOrder = null;
}

wfsParser.prototype.elementsNS = function(node,uri,name)
{
	var elements=[];
	
	if (node.getElementsByTagNameNS)
		elements = node.getElementsByTagNameNS(uri,name);
	else
	{
		var allNodes = node.getElementsByTagName("*"),
			potentialNode,
			fullName;
		
		for (var i = 0, len = allNodes.length; i < len ; ++i)
		{
			potentialNode = allNodes[i];
			fullName = (potentialNode.prefix) ? (potentialNode.prefix + ":" + name) : name;
			if ((name == "*") || (fullName == potentialNode.nodeName))
			{
				if( (uri == "*") || (uri == potentialNode.namespaceURI))
					elements.push(potentialNode);
			}
		}
	}
	
	return elements;
}

wfsParser.prototype.getChildValue = function(node, def)
{
	var value = def || "";
	if (node)
	{
		for(var child = node.firstChild; child; child = child.nextSibling)
		{
			switch (child.nodeType)
			{
				case 3:
				case 4: value += child.nodeValue;
			}
		}
	}
	
	return value;
}

wfsParser.prototype.parse = function(response, srs)
{
	var geometries = [],
		strResp = response.replace(/[\t\n\r]/g, ' '),
		strResp = strResp.replace(/\s+/g, ' '),
		xml = parseXML(strResp),
		parsedNS = strResp.indexOf('<kml') > -1 ? this.kmlns : this.gmlns;
	
	this.axisOrder = srs && srs.indexOf("urn:") == 0 ? 'latlong' : 'longlat';
	
	var order = ["Polygon","LineString","Point"];
	
	for (var i = 0, len = order.length; i < len; ++i)
	{
		var type = order[i],
			nodeList = this.elementsNS(xml.documentElement,parsedNS,type);
		
		for (var j = 0; j < nodeList.length; ++j)
		{
			geometry = this['parse' + type].apply(this,[nodeList[j]]);
			
			if (geometry)
				geometries.push(geometry);
		}
	}
	
	return geometries;
}

wfsParser.prototype.parsePoint = function(node)
{
	var coordString,
		coords=[],
		nodeList = this.elementsNS(node,this.gmlns,"pos");
	
	if (nodeList.length > 0)
	{
		coordString = strip(nodeList[0].firstChild.nodeValue);
		coords = coordString.split(" ");
	}
	if (coords.length == 0)
	{
		nodeList = this.elementsNS(node,this.gmlns,"coordinates");
		
		if (nodeList.length > 0)
		{
			coordString = strip(nodeList[0].firstChild.nodeValue);
			coords = coordString.split(",");
		}
	}
	if (coords.length == 0)
	{
		nodeList = this.elementsNS(node,this.gmlns,"coord");
		
		if (nodeList.length > 0)
		{
			var xList = this.elementsNS(nodeList[0],this.gmlns,"X"),
				yList = this.elementsNS(nodeList[0],this.gmlns,"Y");
			
			if (xList.length > 0 && yList.length > 0)
				coords = [xList[0].firstChild.nodeValue, yList[0].firstChild.nodeValue];
		}
	}
	
	return {feature:{}, geometry:{type: 'Point', coordinates: this.swapCoordinates([Number(coords[0]), Number(coords[1])])}}
}

wfsParser.prototype.parseLineString = function(node)
{
	var nodeList,
		coordString,
		coords = [],
		points = [],
		nodeList = this.elementsNS(node,this.gmlns,"posList");
	
	if (nodeList.length > 0)
	{
		coordString = strip(this.getChildValue(nodeList[0]));
		coords = coordString.split(" ");
		
		for (var i = 0; i < coords.length / 2; ++i)
		{
			j = i * 2;
			x = coords[j];
			y = coords[j + 1];
			
			points.push(this.swapCoordinates([Number(coords[j]), Number(coords[j + 1])]));
		}
	}
	if (coords.length == 0)
	{
		nodeList = this.elementsNS(node,this.gmlns,"coordinates");
		
		if (nodeList.length > 0)
		{
			coordString = strip(this.getChildValue(nodeList[0]));
			coordString = coordString.replace(/\s*,\s*/g,",");
			
			var pointList = coordString.split(" ");
			
			for (var i = 0; i < pointList.length; ++i)
			{
				coords = pointList[i].split(",");
				
				points.push(this.swapCoordinates([Number(coords[0]), Number(coords[1])]));
			}
		}
	}
	
	if (points.length != 0)
	{
		return {feature:{}, geometry:{type: 'LineString', coordinates: points}}
	}
	else
		return false
		
}

wfsParser.prototype.parsePolygon = function(node)
{
	var nodeList = this.elementsNS(node,this.gmlns,"LinearRing"),
		components = [];
	
	if (nodeList.length > 0)
	{
		var ring;
		
		for (var i = 0; i < nodeList.length; ++i)
		{
			ring = this.parseLineString.apply(this,[nodeList[i],true]);
			
			if (ring)
				components.push(ring.geometry.coordinates);
		}
	}
	
	return {feature:{}, geometry:{type: 'Polygon', coordinates: components}}
}

wfsParser.prototype.swapCoordinates = function(arr)
{
	if (this.axisOrder == 'latlong')
		return [arr[1], arr[0]]
	else
		return [arr[0], arr[1]];
}

var _wfsParser = new wfsParser();

var jsonParser = function()
{
	this.axisOrder = null;
}

jsonParser.prototype.parse = function(response, srs)
{
	var resp = JSON.parse(response),
		geometries = [];
	
	this.axisOrder = srs && srs.indexOf("urn:") == 0 ? 'latlong' : 'longlat';
	
	for (var i = 0; i < resp.features.length; i++)
	{
		if (resp.features[i].geometry.type.toLowerCase().indexOf('point') > -1)
			this.parsePoint(resp.features[i], geometries);
		else if (resp.features[i].geometry.type.toLowerCase().indexOf('linestring') > -1)
			this.parseLineString(resp.features[i], geometries);
		else if (resp.features[i].geometry.type.toLowerCase().indexOf('polygon') > -1)
			this.parsePolygon(resp.features[i], geometries);
	}
	
	return geometries;
}

jsonParser.prototype.parsePoint = function(feature, geometryArr)
{
	if (feature.geometry.type.toLowerCase().indexOf('multi') < 0)
		geometryArr.push({feature: feature, geometry:{type: 'POINT', coordinates: this.swapCoordinates(feature.geometry.coordinates)}});
	else
	{
		for (var i = 0; i < feature.geometry.coordinates.length; i++)
			geometryArr.push({feature: feature, geometry:{type: 'POINT', coordinates: this.swapCoordinates(feature.geometry.coordinates[i])}})
	}
}
jsonParser.prototype.parseLineString = function(feature, geometryArr)
{
	if (feature.geometry.type.toLowerCase().indexOf('multi') < 0)
	{
		var newCoords = [];
		
		for (var j = 0; j < feature.geometry.coordinates.length; j++)
			newCoords.push(this.swapCoordinates(feature.geometry.coordinates[j]))
		
		geometryArr.push({feature: feature, geometry:{type: 'LINESTRING', coordinates: newCoords}});
	}
	else
	{
		for (var i = 0; i < feature.geometry.coordinates.length; i++)
		{
			var newCoords = [];
		
			for (var j = 0; j < feature.geometry.coordinates[i].length; j++)
				newCoords.push(this.swapCoordinates(feature.geometry.coordinates[i][j]))
			
			geometryArr.push({feature: feature, geometry:{type: 'LINESTRING', coordinates: newCoords}});
		}
	}
}
jsonParser.prototype.parsePolygon = function(feature, geometryArr)
{
	if (feature.geometry.type.toLowerCase().indexOf('multi') < 0)
	{
		var newCoords = [];
		
		for (var k = 0; k < feature.geometry.coordinates.length; j++)
		{
			var newCoords2 = [];
			
			for (var j = 0; j < feature.geometry.coordinates[k].length; k++)
				newCoords2.push(this.swapCoordinates(feature.geometry.coordinates[k][j]))
			
			newCoords.push(newCoords2)
		}
		
		geometryArr.push({feature: feature, geometry:{type: 'POLYGON', coordinates: newCoords}});
	}
	else
	{
		for (var i = 0; i < feature.geometry.coordinates.length; i++)
		{
			var newCoords = [];
			
			for (var k = 0; k < feature.geometry.coordinates[i].length; k++)
			{
				var newCoords2 = [];
				
				for (var j = 0; j < feature.geometry.coordinates[i][k].length; j++)
					newCoords2.push(this.swapCoordinates(feature.geometry.coordinates[i][k][j]))
				
				newCoords.push(newCoords2)
			}
			
			geometryArr.push({feature: feature, geometry:{type: 'POLYGON', coordinates: newCoords}});
		}
	}
}
jsonParser.prototype.swapCoordinates = function(arr)
{
	if (this.axisOrder == 'latlong')
		return [arr[1], arr[0]]
	else
		return [arr[0], arr[1]];
}

var _jsonParser = new jsonParser();

var queryServerData = function()
{
	this.inputField = null;
	this.parentCanvas = null;
	
	this.wfsFormats = {};
	
	this.oldBalloon = false;
	this.oldBalloonIndex = -1;
	
	this.proj = ['EPSG:4326','EPSG:3395','EPSG:41001'];
	
	this.customParams = undefined;
}

queryServerData.prototype = new leftMenu();

/**
    Загружает виджет для добавления/просмотра WMS/WFS слоёв
 @param protocol
 @param parseFunc 
 @param drawFunc
 @param customParamsManager {object}- контролер дополнительных параметров. Имеет методы: <br/> 
        - init(targetDiv)->void Добавляет контрол к элементу targetDiv<br/>
        - collect()->Object Возвращает выбранные пользователем объекты<br/>
 @param version {string} Версия протокола, которая будет использоваться
*/
queryServerData.prototype.load = function(protocol, parseFunc, drawFunc, customParamsManager, version)
{
	window.convertCoords = function(coordsStr)
	{
		var res = [],
			coordsPairs = strip(coordsStr).replace(/\s+/,' ').split(' ');
		
		if (coordsStr.indexOf(',') == -1)
		{
			for (var j = 0; j < Math.floor(coordsPairs.length / 2); j++)
				res.push([Number(coordsPairs[2 * j + 1]), Number(coordsPairs[2 * j])])
		}
		else
		{
			for (var j = 0; j < coordsPairs.length; j++)
			{
				var parsedCoords = coordsPairs[j].split(',');
				
				res.push([Number(parsedCoords[1]), Number(parsedCoords[0])])
			}
		}
		
		return res;
	}
	
	window.parseGML = function(response, format, srs)
	{
		if (format == 'gml')
			return _wfsParser.parse(response, srs);
		else if (format == 'json')
			return _jsonParser.parse(response, srs);
		else
			return [];
	}
	
	var inputField = _input(null, [['dir','className','inputStyle'],['css','width','200px']]);
	
	this.parentCanvas = _div(null, [['dir','className','serverDataCanvas']]);
	
	var goButton = makeButton(_gtxt("Загрузить")),
		_this = this;
		
	var doGetCapabilities = function()
	{
		if (inputField.value != '')
		{
			if ( customParamsManager )
				_this.customParams = customParamsManager.collect();
				
			_this.getCapabilities(protocol, strip(inputField.value), parseFunc, drawFunc);
				
			inputField.value = '';
		}
		else
			inputError(inputField);
	}
	
	goButton.onclick = doGetCapabilities;
	
	$(inputField).on('keydown', function(e)
	{
		if (e.keyCode === 13)
	  	{
			doGetCapabilities();
	  		return false;
	  	}
	});
	
	var canvas = _div([_div([_span([_t(_gtxt("URL сервера"))])], [['css','marginBottom','3px']]),_table([_tbody([_tr([_td([inputField]),_td([goButton])])])], [['css','marginBottom','5px']])],[['css','margin','3px 0px 0px 10px']])
	
	if (customParamsManager)
	{
		var customParamsDiv = _div();
		$(canvas).append(customParamsDiv);
		_this.customParams = customParamsManager.init(customParamsDiv);
	}	

	_(this.workCanvas, [canvas, this.parentCanvas])
}

queryServerData.prototype.getCapabilities = function(protocol, url, parseFunc, drawFunc, version)
{
	var loading = _div([_img(null, [['attr','src','img/progress.gif'],['css','marginRight','10px']]), _t(_gtxt('загрузка...'))], [['css','margin','3px 0px 3px 20px']]),
		_this = this;
	
	if (this.parentCanvas.childNodes.length == 0)
		_(this.parentCanvas, [loading]);
	else
		this.parentCanvas.insertBefore(loading, this.parentCanvas.firstChild);
	
    var capabilitiesUrl = 
            url.replace(/REQUEST=GetCapabilities[\&]*/i, '')
               .replace(new RegExp('SERVICE=' + protocol + '[\&]', 'i'), '')
               .replace(/\&$/, '');
    
    capabilitiesUrl += capabilitiesUrl.indexOf('?') !== -1 ? '&' : '?';
    capabilitiesUrl += 'REQUEST=GetCapabilities&SERVICE=' + protocol;
    
    if (version) {
        capabilitiesUrl += '&VERSION=' + version;
    }
    
	sendCrossDomainJSONRequest(serverBase + "ApiSave.ashx?get=" + encodeURIComponent(capabilitiesUrl), function(response) {
		if (!parseResponse(response)) return;

		var servicelayers = parseFunc.call(_this, response.Result);

		drawFunc.call(_this, servicelayers, url, loading, undefined, _this.customParams);
	})
}

queryServerData.prototype.parseWFSCapabilities = function(response)
{
	var serviceLayers = [],
		strResp = response.replace(/[\t\n\r]/g, ' '),
		strResp = strResp.replace(/\s+/g, ' '),
		featuresXML = parseXML(response).getElementsByTagName('FeatureType');
	
	for (var i = 0; i < featuresXML.length; i++)
	{
		var layer = {},
			name = featuresXML[i].getElementsByTagName('Name'),
			title = featuresXML[i].getElementsByTagName('Title'),
			srs = featuresXML[i].getElementsByTagName('DefaultSRS');
		
		if (name.length)
			layer.name = getTextContent(name[0]);
		
		if (title.length)
			layer.title = getTextContent(title[0]);
		
		if (srs.length)
			layer.srs = getTextContent(srs[0]);
		
		if (layer.name)
			serviceLayers.push(layer);
	}
	
	return serviceLayers;
}

queryServerData.prototype.loadGML = function(url, parentTreeCanvas, box, header, format, loadLayerParams, srs)
{
	var _this = this;
	
	sendCrossDomainJSONRequest(serverBase + "ApiSave.ashx?get=" + encodeURIComponent(url), function(response)
	{
		if (!parseResponse(response)) return;
		var geometries = parseGML(response.Result, format, srs);
		_this.drawGML(geometries, url, parentTreeCanvas, box, header, loadLayerParams);
	})
}

queryServerData.prototype.saveGML = function(geometries)
{
	if (typeof geometries == 'undefined' || geometries == null)
	{
		geometries = [];
		
		globalFlashMap.drawing.forEachObject(function(ret)
		{
			geometries.push(ret.geometry);
		})
	}
	
	window.promptFunction(_gtxt('Введите имя gml-файла для скачивания:'), 'objects.gml', function(fileName)
	{
		globalFlashMap.saveObjects(geometries, nsGmx.Utils.translit(fileName));
	});
	
	return false;
}

queryServerData.prototype.drawGML = function(geometries, url, parentTreeCanvas, box, header, loadLayerParams)
{
	var parent = {
					'Point': L.gmx.createLayer({properties: {}}).addTo(nsGmx.leafletMap),
					'LineString': L.gmx.createLayer({properties: {}}).addTo(nsGmx.leafletMap),
					'Polygon': L.gmx.createLayer({properties: {}}).addTo(nsGmx.leafletMap)
				},
		styles = {
					'Point': typeof loadLayerParams != 'undefined' && loadLayerParams['point'] ? loadLayerParams['point'].RenderStyle : { marker: { size: 2 }, outline: { color: 0x0000ff, thickness: 1 } },
					'LineString': typeof loadLayerParams != 'undefined' && loadLayerParams['linestring'] ? loadLayerParams['linestring'].RenderStyle : { outline: { color: 0x0000ff, thickness: 2 } },
					'Polygon': typeof loadLayerParams != 'undefined' && loadLayerParams['polygon'] ? loadLayerParams['polygon'].RenderStyle : { outline: { color: 0x0000ff, thickness: 2, opacity: 100 }, fill: {color: 0xffffff, opacity: 20} }
				};
	// parent['POINT'].setStyle(styles['POINT']);
	// parent['LINESTRING'].setStyle(styles['LINESTRING']);
	// parent['POLYGON'].setStyle(styles['POLYGON']);
	
	var geomsPresent = {},
		bounds = L.gmxUtil.bounds(),
        items = {'Point': [], 'LineString': [], 'Polygon': []};
	
	for (var i = 0; i < geometries.length; i++)
	{
		//var elem = parent[geometries[i].geometry.type].addObject(geometries[i].geometry);
        items[geometries[i].geometry.type].push([L.gmxUtil.geoJSONtoGeometry(geometries[i].geometry, true)]);
        //parent[geometries[i].geometry.type].addItems();
		
		/*if (objLength(geometries[i].feature) > 0)
		{
			(function(i)
			{
				elem.setHandler("onClick", function(obj)
				{
					var elemCanvas = $(divCanvas).find("[geometryType='" + geometries[i].geometry.type + "']")[0];
					
					if (!elemCanvas.graphDataProperties ||
						!geometries[i].feature.properties)
						return;
					
					var balloonCanvas = _div();
						
					if (!_diagram.createBalloon(obj, balloonCanvas))
						return;
					
					if (_diagram.createDateTimeDiagramByAttrs(balloonCanvas, 500, 300, geometries[i].feature.properties, elemCanvas.graphDataProperties))
						_diagram.oldBalloon.resize();
				})
			})(i);
		}*/

		geomsPresent[geometries[i].geometry.type] = true;

		bounds.extendArray(geometries[i].geometry.coordinates[0]);
	}

    parent['Point'].addData(items['Point']);
    parent['LineString'].addData(items['LineString']);
    parent['Polygon'].addData(items['Polygon']);

	var divCanvas = _div(),
		divChilds = _div(),
		spanHeader = _span([_t(url.length < 45 ? url : url.substr(0, 45) + '...')]),
		_this = this;
	
	var clickFunc = function(flag)
	{
        var lmap = nsGmx.leafletMap,
            method = flag ? 'addLayer' : 'removeLayer';
        lmap[method](parent['Point']);
        lmap[method](parent['LineString']);
        lmap[method](parent['Polygon']);

		if (flag)
			show(divChilds);
		else
			hide(divChilds);
	}
	
	parentTreeCanvas.loaded = function() // переопределим функцию загрузки слоя на центрирование
	{
		if (!box.checked)
		{
			clickFunc.call(_this, true);
			
			box.checked = true;
		}
		
		//globalFlashMap.zoomToExtent(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
        nsGmx.leafletMap.fitBounds([[bounds.min.y, bounds.min.x], [bounds.max.y, bounds.max.x]]);
	}
	
	parentTreeCanvas.clear = function()
	{
        var lmap = nsGmx.leafletMap;
		lmap.removeLayer(parent['Point']);
		lmap.removeLayer(parent['LineString']);
		lmap.removeLayer(parent['Polygon']);
		
		divCanvas.removeNode(true);
	}
	
	box.onclick = function()
	{
		clickFunc.call(_this, this.checked);
	}
	
	$(parentTreeCanvas).empty();
	
	if (parentTreeCanvas.childNodes.length == 0)
		_(parentTreeCanvas, [divCanvas]);
	else
		parentTreeCanvas.insertBefore(divCanvas, parentTreeCanvas.firstChild);
	
	_(divCanvas, [divChilds]);
	
	// for (var type in geomsPresent)
	// {
		// var elemCanvas = _div(null, [['css','padding','2px'],['attr','geometryType', type]]),
			// //icon = _mapHelper.createStylesEditorIcon([{MinZoom:1,MaxZoom:20,RenderStyle:styles[type]}], type.toLowerCase()),
			// spanElem = _span(null, [['dir','className','layerfeature']]);
		
		// if (type == 'Point')
			// _(spanElem, [_t(_gtxt('точки'))]);
		// else if (type == 'LineString')
			// _(spanElem, [_t(_gtxt('линии'))]);
		// else if (type == 'Polygon')
			// _(spanElem, [_t(_gtxt('полигоны'))]);

        // var icon;
		// (function(type){
			// icon = _mapHelper.createWFSStylesEditor(parent[type], styles[type], type.toLowerCase(), divCanvas)
		// })(type);
		
		// if (typeof loadLayerParams != 'undefined' && loadLayerParams[type.toLowerCase()])
		// {
			// var info = loadLayerParams[type.toLowerCase()];
			
			// elemCanvas.graphDataType = info.graphDataType;
			// elemCanvas.graphDataProperties = info.graphDataProperties;
		// }
		// else
		// {
			// elemCanvas.graphDataType = "func";
			// elemCanvas.graphDataProperties = "";
		// }
		
		// _(elemCanvas, [icon, spanElem])
		// _(divChilds, [elemCanvas]);
		
	// }
	
	//globalFlashMap.zoomToExtent(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
    nsGmx.leafletMap.fitBounds([[bounds.min.y, bounds.min.x], [bounds.max.y, bounds.max.x]]);
	
	box.checked = true;
}

//loadParams - параметры для отдельных слоёв
//serverParams - параметры сервера, которые были указаны пользователем.
queryServerData.prototype.drawWMS = function(serviceLayers, url, replaceElem, loadParams, serverParams)
{
	var ulCanvas = _ul(null, [['css','paddingBottom','5px'], ['attr','url',url]]),
		ulChilds = _ul(),
		remove = makeImageButton('img/closemin.png','img/close_orange.png'),
		_this = this,
        lmap = nsGmx.leafletMap;
	
	$(replaceElem).replaceWith(ulCanvas)
    
    $(ulCanvas).data('serverParams', serverParams);
	
	remove.onclick = function()
	{
		for (var i = 0; i < ulChilds.childNodes.length; i++)
        {
			ulChilds.childNodes[i].firstChild.lastChild.clear && ulChilds.childNodes[i].firstChild.lastChild.clear();
            lmap.removeLayer(ulChilds.childNodes[i].firstChild.lastChild.gmxObject);
		}
        
		this.parentNode.parentNode.parentNode.removeNode(true);
	}
	
	remove.className = 'remove';
	remove.style.right = '0px';
	
	_(ulCanvas, [_li([_div([_span([_t(url.length < 45 ? url : url.substr(0, 45) + '...')],[['dir','className','urlHeader']]), remove],[['css','position','relative']]), ulChilds])])
	
	var clickFunc = function(layer, parent, flag)
	{
		if (!flag) {
			lmap.removeLayer(parent);
        } else {
			updateFunc(layer, parent);
			lmap.addLayer(parent);
		}
	}

	var updateFunc = function(layer, parent)
	{
        var requestParams = {}
		if (serverParams && serverParams.format)
        {
            requestParams.format = "image/" + serverParams.format;
            requestParams.transparent = serverParams.format === 'png';
        }
        
        var res = getWMSMapURL(url, layer, requestParams);
        
        if (res)
        {
            var b = res.bounds;
            parent.clearLayers();
            parent.addLayer(L.imageOverlay(serverBase + "ImgSave.ashx?now=true&get=" + encodeURIComponent(res.url), L.latLngBounds([[b.minY, b.minX], [b.maxY, b.maxX]])));
        }
	}
	
	serviceLayers.forEach(function(layer)
	{
		var elemCanvas = _div(null, [['css','padding','2px']]),
			box = _checkbox(false, 'checkbox'),
			spanElem = _span([_t(layer.title)], [['css','cursor','pointer'],['dir','className','layerfeature']]),
			parent = L.layerGroup().addTo(nsGmx.leafletMap);

        spanElem.gmxObject = parent;

		box.className = 'floatLeft';

        spanElem.onclick = function()
        {
            if (!box.checked)
                box.checked = true;
            
            clickFunc(layer, parent, true);
        }
        box.onclick = function()
        {
            clickFunc(layer, parent, this.checked);
        }
        box.update = function()
        {
            updateFunc(layer, parent);
        }
		
		box.setAttribute('layerName', layer.name);
		
		_(elemCanvas, [box, spanElem]);
		_(ulChilds, [_li([elemCanvas])]);
		
		if (typeof loadParams != 'undefined' && loadParams[layer.name])
			$(spanElem).trigger("click");
	});

	$(ulCanvas).treeview();

	nsGmx.leafletMap.on('moveend', function()
	{
        var boxes = ulChilds.getElementsByTagName('input');

        for (var i = 0; i < boxes.length; i++)
        {
            if (boxes[i].checked)
                boxes[i].update();
        }
	})
}

//Добавляет контрол выбора формата запроса к WMS и возвращает его в параметре format (пример: "png", "jpg")
queryServerData.prototype.customWMSParamsManager = (function()
{
	var _targetDiv = null;
	return {
		init: function(targetDiv) 
		{
			var select = nsGmx.Utils._select([_option([_t('png')]), _option([_t('jpeg')])], [['dir','className','selectStyle'], ['css', 'width', '60px']]);
			_targetDiv = targetDiv;
			_(_targetDiv, [_t(_gtxt('Формат изображения') + ': '), select]);
			_targetDiv.style.marginBottom = '5px';
		},
		collect: function() {
			return { format: $("option:selected", _targetDiv).text() };
		}
	}
})();

queryServerData.prototype.drawWFS = function(serviceLayers, url, replaceElem, loadParams)
{
	var ulCanvas = _ul(null, [['css','paddingBottom','5px'], ['attr','url',url]]),
		ulChilds = _ul(),
		divFormat = _div(),
		remove = makeImageButton('img/closemin.png','img/close_orange.png'),
		_this = this;
	
	$(replaceElem).replaceWith(ulCanvas)
	
	remove.onclick = function()
	{
		for (var i = 0; i < ulChilds.childNodes.length; i++)
			ulChilds.childNodes[i].firstChild.lastChild.clear && ulChilds.childNodes[i].firstChild.lastChild.clear();

		this.parentNode.parentNode.parentNode.removeNode(true);
	}

	remove.className = 'remove';
	remove.style.right = '0px';

	_(ulCanvas, [_li([_div([_span([_t(url.length < 45 ? url : url.substr(0, 45) + '...')],[['dir','className','urlHeader']]), divFormat, remove],[['css','position','relative']]), ulChilds])]);

	var formatSelect = nsGmx.Utils._select([_option([_t("JSON")], [['attr','value','json']]),
								_option([_t("GML / KML")], [['attr','value','gml']])], [['dir','className','selectStyle'],['css','width','100px']]);

	_(divFormat, [formatSelect]);

	var clickFunc = function(layer, flag, elemCanvas, box, header, loadLayerParams)
	{
		if (flag) {
			var newFormat = formatSelect.value;
			
			// загружаем данные только один раз
			if (!elemCanvas.loaded || elemCanvas.format != newFormat)
			{
				elemCanvas.clear && elemCanvas.clear();
				
                var separator = url.indexOf('?') !== -1 ? '&' : '?';
                
				var objUrl = url + separator + "request=GetFeature&version=1.0.0&typeName=" + layer.name;
				
				if (formatSelect.value == 'json')
					objUrl += '&outputFormat=json'
				
				_this.loadGML(objUrl, elemCanvas, box, header, newFormat, loadLayerParams, layer.srs);
				
				elemCanvas.loaded = true;
				elemCanvas.format = newFormat;
				
				var loading = _div([_img(null, [['attr','src','img/progress.gif'],['css','marginRight','10px']]), _t(_gtxt('загрузка...'))], [['css','margin','3px 0px']]);
		
				_(elemCanvas, [loading]);
			}
			else
			{
				if (typeof elemCanvas.loaded == 'function')
					elemCanvas.loaded();
			}
		}
	}
	
	for (var i = 0; i < serviceLayers.length; i++)
	{
		var elemCanvas = _div(null, [['css','padding','2px']]),
			box = _checkbox(false, 'checkbox'),
			spanElem = _span([_t(serviceLayers[i].title != '' ? serviceLayers[i].title : serviceLayers[i].name)],[['css','cursor','pointer'],['dir','className','layerfeature']]),
			elemChilds = _div(null, [['css','marginLeft','20px']]);

		box.className = 'floatLeft';

		box.setAttribute('layerName', serviceLayers[i].name);
		
		(function(layer, parentTreeCanvas, box, header){
			spanElem.onclick = function()
			{
				if (!box.checked)
					box.checked = true;
				
				clickFunc.call(_this, layer, true, parentTreeCanvas, box, header);
			}
			box.onclick = function()
			{
				clickFunc.call(_this, layer, this.checked, parentTreeCanvas, box, header);
			}
		})(serviceLayers[i], elemChilds, box, spanElem);
		
		_(elemCanvas, [box, _div([spanElem],[['css','display','inline']]), elemChilds])
		_(ulChilds, [_li([elemCanvas])])
			
		if (typeof loadParams != 'undefined' && loadParams[serviceLayers[i].name])
		{
			if (!box.checked)
				box.checked = true;
			
			formatSelect.value = loadParams[serviceLayers[i].name].format;
			clickFunc.call(_this, serviceLayers[i], true, elemChilds, box, spanElem, loadParams[serviceLayers[i].name].info);
		}
	}
	
	$(ulCanvas).treeview();
}


var _queryServerDataWFS = new queryServerData(),
	_queryServerDataWMS = new queryServerData();

loadServerData.WFS.load = function()
{
	var alreadyLoaded = _queryServerDataWFS.createWorkCanvas(arguments[0]);
	
	if (!alreadyLoaded)
		_queryServerDataWFS.load('WFS', _queryServerDataWFS.parseWFSCapabilities, _queryServerDataWFS.drawWFS, null, '1.0.0');
}
loadServerData.WFS.unload = function()
{
//	removeChilds($$('leftContent'))
}

loadServerData.WMS.load = function()
{
	var alreadyLoaded = _queryServerDataWMS.createWorkCanvas(arguments[0]);
	
	if (!alreadyLoaded)
		_queryServerDataWMS.load('WMS', parseWMSCapabilities, _queryServerDataWMS.drawWMS, _queryServerDataWMS.customWMSParamsManager);
}
loadServerData.WMS.unload = function()
{
//	removeChilds($$('leftContent'))
}

nsGmx.userObjectsManager.addDataCollector('wms', {
    collect: function()
    {
        if (!_queryServerDataWMS.workCanvas)
            return null;
        
        var value = {};
        
        $(_queryServerDataWMS.workCanvas.lastChild).children("ul[url]").each(function()
        {
            var url = this.getAttribute('url');
            var serverParams = $(this).data('serverParams');
            
            value[url] = {params: serverParams, layersVisibility: {}};
            
            $(this).find("input[type='checkbox']").each(function()
            {
                if (this.checked)
                {
                    value[url].layersVisibility[this.getAttribute('layerName')] = true;
                }
            })
        })
        
        if (!objLength(value))
            return null;
        
        return value;
    },
    
    load: function(data)
    {
        if (!data)
            return;

        $('#left_wms').remove();
        
        _queryServerDataWMS.builded = false;
        
        loadServerData.WMS.load('wms');
        
        for (var url in data)
        {
            (function(loadParams)
            {
                //поддержка старого формата данных
                if (!('layersVisibility' in loadParams))
                {
                    loadParams = {layersVisibility: loadParams};
                }
                
                _queryServerDataWMS.getCapabilities('WMS', url, parseWMSCapabilities, function(serviceLayers, url, replaceElem)
                {
                    _queryServerDataWMS.drawWMS(serviceLayers, url, replaceElem, loadParams.layersVisibility, loadParams.params);
                })
            })(data[url])
        }
    }
})

nsGmx.userObjectsManager.addDataCollector('wfs', {
    collect: function()
    {
        if (!_queryServerDataWFS.workCanvas)
            return null;
        
        var value = {};
        
        $(_queryServerDataWFS.workCanvas.lastChild).children("ul[url]").each(function()
        {
            var url = this.getAttribute('url');
            
            value[url] = {};
            
            $(this).find("input[type='checkbox']").each(function()
            {
                if (this.checked)
                {
                    var wfsLayerInfo = {};
                    
                    $(this.parentNode.lastChild).find(".colorIcon").each(function()
                    {
                        wfsLayerInfo[this.geometryType] = {RenderStyle: this.getStyle(), graphDataType: this.parentNode.graphDataType, graphDataProperties: this.parentNode.graphDataProperties}
                    })
                    
                    value[url][this.getAttribute('layerName')] = {format: this.parentNode.lastChild.format, info: wfsLayerInfo};
                }
            })
        })
        
        if (!objLength(value))   
            return null;
        
        return value;
    },
    
    load: function(data)
    {
        if (!data)
            return;

        $('#left_wfs').remove();
        
        _queryServerDataWFS.builded = false;
        
        loadServerData.WFS.load('wfs');
        
        for (var url in data)
        {
            (function(loadParams)
            {
                _queryServerDataWFS.getCapabilities('WFS', url, _queryServerDataWFS.parseWFSCapabilities, function(serviceLayers, url, replaceElem)
                {
                    _queryServerDataWFS.drawWFS(serviceLayers, url, replaceElem, loadParams);
                }, '1.0.0')
            })(data[url])
        }
    }
});

})(nsGmx.Utils._);
/*
 * Raphael 1.2.8 - JavaScript Vector Library
 *
 * Copyright (c) 2008 - 2009 Dmitry Baranovskiy (http://raphaeljs.com)
 * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.
 */

window.Raphael=(function(){var a=/[, ]+/,aH=/^(circle|rect|path|ellipse|text|image)$/,G=document,an=window,k={was:"Raphael" in an,is:an.Raphael},ai=function(){if(ai.is(arguments[0],"array")){var e=arguments[0],E=t[aO](ai,e.splice(0,3+ai.is(e[0],ag))),aS=E.set();for(var S=0,aT=e[l];S<aT;S++){var R=e[S]||{};aH.test(R.type)&&aS[d](E[R.type]().attr(R));}return aS;}return t[aO](ai,arguments);},aE="appendChild",aO="apply",aL="concat",am="",ah=" ",A="click dblclick mousedown mousemove mouseout mouseover mouseup".split(ah),L="hasOwnProperty",ae=/^\[object\s+|\]$/gi,ar="join",l="length",aQ="prototype",aR=String[aQ].toLowerCase,W=Math,f=W.max,aB=W.min,ag="number",at="toString",ap=Object[aQ][at],aJ={},aF=W.pow,d="push",aM=/^(?=[\da-f]$)/,c=/^url\(['"]?([^\)]+)['"]?\)$/i,u=/^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgb\(\s*([\d\.]+\s*,\s*[\d\.]+\s*,\s*[\d\.]+)\s*\)|rgb\(\s*([\d\.]+%\s*,\s*[\d\.]+%\s*,\s*[\d\.]+%)\s*\)|hs[bl]\(\s*([\d\.]+\s*,\s*[\d\.]+\s*,\s*[\d\.]+)\s*\)|hs[bl]\(\s*([\d\.]+%\s*,\s*[\d\.]+%\s*,\s*[\d\.]+%)\s*\))\s*$/i,J=W.round,s="setAttribute",w="split",P=parseFloat,B=parseInt,aG=String[aQ].toUpperCase,h={"clip-rect":"0 0 10e9 10e9",cursor:"default",cx:0,cy:0,fill:"#fff","fill-opacity":1,font:'10px "Arial"',"font-family":'"Arial"',"font-size":"10","font-style":"normal","font-weight":400,gradient:0,height:0,href:"http://raphaeljs.com/",opacity:1,path:"M0,0",r:0,rotation:0,rx:0,ry:0,scale:"1 1",src:"",stroke:"#000","stroke-dasharray":"","stroke-linecap":"butt","stroke-linejoin":"butt","stroke-miterlimit":0,"stroke-opacity":1,"stroke-width":1,target:"_blank","text-anchor":"middle",title:"Raphael",translation:"0 0",width:0,x:0,y:0},U={"clip-rect":"csv",cx:ag,cy:ag,fill:"colour","fill-opacity":ag,"font-size":ag,height:ag,opacity:ag,path:"path",r:ag,rotation:"csv",rx:ag,ry:ag,scale:"csv",stroke:"colour","stroke-opacity":ag,"stroke-width":ag,translation:"csv",width:ag,x:ag,y:ag},aI="replace";ai.version="1.2.8";ai.type=(an.SVGAngle||G.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1")?"SVG":"VML");ai.svg=!(ai.vml=ai.type=="VML");ai._id=0;ai._oid=0;ai.fn={};ai.is=function(i,e){e=aR.call(e);return((e=="object"||e=="undefined")&&typeof i==e)||(i==null&&e=="null")||aR.call(ap.call(i)[aI](ae,am))==e;};ai.setWindow=function(e){an=e;G=an.document;};var aw=function(E){if(ai.vml){var e=/^\s+|\s+$/g;aw=ad(function(S){var aS;S=(S+am)[aI](e,am);try{var aT=new ActiveXObject("htmlfile");aT.write("<body>");aT.close();aS=aT.body;}catch(aV){aS=createPopup().document.body;}var i=aS.createTextRange();try{aS.style.color=S;var aU=i.queryCommandValue("ForeColor");aU=((aU&255)<<16)|(aU&65280)|((aU&16711680)>>>16);return"#"+("000000"+aU[at](16)).slice(-6);}catch(aV){return"none";}});}else{var R=G.createElement("i");R.title="Rapha\xebl Colour Picker";R.style.display="none";G.body[aE](R);aw=ad(function(i){R.style.color=i;return G.defaultView.getComputedStyle(R,am).getPropertyValue("color");});}return aw(E);};ai.hsb2rgb=ad(function(aW,aU,a0){if(ai.is(aW,"object")&&"h" in aW&&"s" in aW&&"b" in aW){a0=aW.b;aU=aW.s;aW=aW.h;}var S,aS,a1;if(a0==0){return{r:0,g:0,b:0,hex:"#000"};}if(aW>1||aU>1||a0>1){aW/=255;aU/=255;a0/=255;}var aT=~~(aW*6),aX=(aW*6)-aT,R=a0*(1-aU),E=a0*(1-(aU*aX)),a2=a0*(1-(aU*(1-aX)));S=[a0,E,R,R,a2,a0,a0][aT];aS=[a2,a0,a0,E,R,R,a2][aT];a1=[R,R,a2,a0,a0,E,R][aT];S*=255;aS*=255;a1*=255;var aY={r:S,g:aS,b:a1},e=(~~S)[at](16),aV=(~~aS)[at](16),aZ=(~~a1)[at](16);e=e[aI](aM,"0");aV=aV[aI](aM,"0");aZ=aZ[aI](aM,"0");aY.hex="#"+e+aV+aZ;return aY;},ai);ai.rgb2hsb=ad(function(e,i,aU){if(ai.is(e,"object")&&"r" in e&&"g" in e&&"b" in e){aU=e.b;i=e.g;e=e.r;}if(ai.is(e,"string")){var aW=ai.getRGB(e);e=aW.r;i=aW.g;aU=aW.b;}if(e>1||i>1||aU>1){e/=255;i/=255;aU/=255;}var aT=f(e,i,aU),E=aB(e,i,aU),S,R,aS=aT;if(E==aT){return{h:0,s:0,b:aT};}else{var aV=(aT-E);R=aV/aT;if(e==aT){S=(i-aU)/aV;}else{if(i==aT){S=2+((aU-e)/aV);}else{S=4+((e-i)/aV);}}S/=6;S<0&&S++;S>1&&S--;}return{h:S,s:R,b:aS};},ai);var ax=/,?([achlmqrstvxz]),?/gi;ai._path2string=function(){return this.join(",")[aI](ax,"$1");};function ad(R,i,e){function E(){var S=Array[aQ].slice.call(arguments,0),aT=S[ar]("\u25ba"),aS=E.cache=E.cache||{},aU=E.count=E.count||[];if(aS[L](aT)){return e?e(aS[aT]):aS[aT];}aU[l]>=1000&&delete aS[aU.shift()];aU[d](aT);aS[aT]=R[aO](i,S);return e?e(aS[aT]):aS[aT];}return E;}ai.getRGB=ad(function(e){if(!e||!!((e=e+am).indexOf("-")+1)){return{r:-1,g:-1,b:-1,hex:"none",error:1};}if(e=="none"){return{r:-1,g:-1,b:-1,hex:"none"};}!(({hs:1,rg:1})[L](e.substring(0,2))||e.charAt()=="#")&&(e=aw(e));var aS,E,R,aV,aW,aT=e.match(u);if(aT){if(aT[2]){aV=B(aT[2].substring(5),16);R=B(aT[2].substring(3,5),16);E=B(aT[2].substring(1,3),16);}if(aT[3]){aV=B((aW=aT[3].charAt(3))+aW,16);R=B((aW=aT[3].charAt(2))+aW,16);E=B((aW=aT[3].charAt(1))+aW,16);}if(aT[4]){aT=aT[4][w](/\s*,\s*/);E=P(aT[0]);R=P(aT[1]);aV=P(aT[2]);}if(aT[5]){aT=aT[5][w](/\s*,\s*/);E=P(aT[0])*2.55;R=P(aT[1])*2.55;aV=P(aT[2])*2.55;}if(aT[6]){aT=aT[6][w](/\s*,\s*/);E=P(aT[0]);R=P(aT[1]);aV=P(aT[2]);return ai.hsb2rgb(E,R,aV);}if(aT[7]){aT=aT[7][w](/\s*,\s*/);E=P(aT[0])*2.55;R=P(aT[1])*2.55;aV=P(aT[2])*2.55;return ai.hsb2rgb(E,R,aV);}aT={r:E,g:R,b:aV};var i=(~~E)[at](16),S=(~~R)[at](16),aU=(~~aV)[at](16);i=i[aI](aM,"0");S=S[aI](aM,"0");aU=aU[aI](aM,"0");aT.hex="#"+i+S+aU;return aT;}return{r:-1,g:-1,b:-1,hex:"none",error:1};},ai);ai.getColor=function(i){var E=this.getColor.start=this.getColor.start||{h:0,s:1,b:i||0.75},e=this.hsb2rgb(E.h,E.s,E.b);E.h+=0.075;if(E.h>1){E.h=0;E.s-=0.2;E.s<=0&&(this.getColor.start={h:0,s:1,b:E.b});}return e.hex;};ai.getColor.reset=function(){delete this.start;};ai.parsePathString=ad(function(e){if(!e){return null;}var E={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},i=[];if(ai.is(e,"array")&&ai.is(e[0],"array")){i=ao(e);}if(!i[l]){(e+am)[aI](/([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig,function(S,R,aU){var aT=[],aS=aR.call(R);aU[aI](/(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig,function(aW,aV){aV&&aT[d](+aV);});while(aT[l]>=E[aS]){i[d]([R][aL](aT.splice(0,E[aS])));if(!E[aS]){break;}}});}i[at]=ai._path2string;return i;});var N=ad(function(aY){if(!aY){return{x:0,y:0,width:0,height:0};}aY=C(aY);var aV=0,aU=0,S=[],E=[],R;for(var aS=0,aX=aY[l];aS<aX;aS++){R=aY[aS];if(R[0]=="M"){aV=R[1];aU=R[2];S[d](aV);E[d](aU);}else{var aT=au(aV,aU,R[1],R[2],R[3],R[4],R[5],R[6]);S=S[aL](aT.min.x,aT.max.x);E=E[aL](aT.min.y,aT.max.y);aV=R[5];aU=R[6];}}var e=aB[aO](0,S),aW=aB[aO](0,E);return{x:e,y:aW,width:f[aO](0,S)-e,height:f[aO](0,E)-aW};}),ao=function(aT){var R=[];if(!ai.is(aT,"array")||!ai.is(aT&&aT[0],"array")){aT=ai.parsePathString(aT);}for(var E=0,S=aT[l];E<S;E++){R[E]=[];for(var e=0,aS=aT[E][l];e<aS;e++){R[E][e]=aT[E][e];}}R[at]=ai._path2string;return R;},Y=ad(function(S){if(!ai.is(S,"array")||!ai.is(S&&S[0],"array")){S=ai.parsePathString(S);}var aX=[],aZ=0,aY=0,a2=0,a1=0,R=0;if(S[0][0]=="M"){aZ=S[0][1];aY=S[0][2];a2=aZ;a1=aY;R++;aX[d](["M",aZ,aY]);}for(var aU=R,a3=S[l];aU<a3;aU++){var e=aX[aU]=[],a0=S[aU];if(a0[0]!=aR.call(a0[0])){e[0]=aR.call(a0[0]);switch(e[0]){case"a":e[1]=a0[1];e[2]=a0[2];e[3]=a0[3];e[4]=a0[4];e[5]=a0[5];e[6]=+(a0[6]-aZ).toFixed(3);e[7]=+(a0[7]-aY).toFixed(3);break;case"v":e[1]=+(a0[1]-aY).toFixed(3);break;case"m":a2=a0[1];a1=a0[2];default:for(var aT=1,aV=a0[l];aT<aV;aT++){e[aT]=+(a0[aT]-((aT%2)?aZ:aY)).toFixed(3);}}}else{e=aX[aU]=[];if(a0[0]=="m"){a2=a0[1]+aZ;a1=a0[2]+aY;}for(var aS=0,E=a0[l];aS<E;aS++){aX[aU][aS]=a0[aS];}}var aW=aX[aU][l];switch(aX[aU][0]){case"z":aZ=a2;aY=a1;break;case"h":aZ+=+aX[aU][aW-1];break;case"v":aY+=+aX[aU][aW-1];break;default:aZ+=+aX[aU][aW-2];aY+=+aX[aU][aW-1];}}aX[at]=ai._path2string;return aX;},0,ao),p=ad(function(S){if(!ai.is(S,"array")||!ai.is(S&&S[0],"array")){S=ai.parsePathString(S);}var aW=[],aY=0,aX=0,a1=0,a0=0,R=0;if(S[0][0]=="M"){aY=+S[0][1];aX=+S[0][2];a1=aY;a0=aX;R++;aW[0]=["M",aY,aX];}for(var aU=R,a2=S[l];aU<a2;aU++){var e=aW[aU]=[],aZ=S[aU];if(aZ[0]!=aG.call(aZ[0])){e[0]=aG.call(aZ[0]);switch(e[0]){case"A":e[1]=aZ[1];e[2]=aZ[2];e[3]=aZ[3];e[4]=aZ[4];e[5]=aZ[5];e[6]=+(aZ[6]+aY);e[7]=+(aZ[7]+aX);break;case"V":e[1]=+aZ[1]+aX;break;case"H":e[1]=+aZ[1]+aY;break;case"M":a1=+aZ[1]+aY;a0=+aZ[2]+aX;default:for(var aT=1,aV=aZ[l];aT<aV;aT++){e[aT]=+aZ[aT]+((aT%2)?aY:aX);}}}else{for(var aS=0,E=aZ[l];aS<E;aS++){aW[aU][aS]=aZ[aS];}}switch(e[0]){case"Z":aY=a1;aX=a0;break;case"H":aY=e[1];break;case"V":aX=e[1];break;default:aY=aW[aU][aW[aU][l]-2];aX=aW[aU][aW[aU][l]-1];}}aW[at]=ai._path2string;return aW;},null,ao),aP=function(i,R,e,E){return[i,R,e,E,e,E];},aD=function(i,R,aT,S,e,E){var aS=1/3,aU=2/3;return[aS*i+aU*aT,aS*R+aU*S,aS*e+aU*aT,aS*E+aU*S,e,E];},F=function(a2,bw,bb,a9,a3,aX,aS,a1,bv,a4){var S=W.PI,a8=S*120/180,e=S/180*(+a3||0),bf=[],bc,bs=ad(function(bx,bA,i){var bz=bx*W.cos(i)-bA*W.sin(i),by=bx*W.sin(i)+bA*W.cos(i);return{x:bz,y:by};});if(!a4){bc=bs(a2,bw,-e);a2=bc.x;bw=bc.y;bc=bs(a1,bv,-e);a1=bc.x;bv=bc.y;var E=W.cos(S/180*a3),aZ=W.sin(S/180*a3),bh=(a2-a1)/2,bg=(bw-bv)/2;bb=f(bb,W.abs(bh));a9=f(a9,W.abs(bg));var R=bb*bb,bk=a9*a9,bm=(aX==aS?-1:1)*W.sqrt(W.abs((R*bk-R*bg*bg-bk*bh*bh)/(R*bg*bg+bk*bh*bh))),a6=bm*bb*bg/a9+(a2+a1)/2,a5=bm*-a9*bh/bb+(bw+bv)/2,aW=W.asin(((bw-a5)/a9).toFixed(7)),aV=W.asin(((bv-a5)/a9).toFixed(7));aW=a2<a6?S-aW:aW;aV=a1<a6?S-aV:aV;aW<0&&(aW=S*2+aW);aV<0&&(aV=S*2+aV);if(aS&&aW>aV){aW=aW-S*2;}if(!aS&&aV>aW){aV=aV-S*2;}}else{aW=a4[0];aV=a4[1];a6=a4[2];a5=a4[3];}var a0=aV-aW;if(W.abs(a0)>a8){var a7=aV,ba=a1,aY=bv;aV=aW+a8*(aS&&aV>aW?1:-1);a1=a6+bb*W.cos(aV);bv=a5+a9*W.sin(aV);bf=F(a1,bv,bb,a9,a3,0,aS,ba,aY,[aV,a7,a6,a5]);}a0=aV-aW;var aU=W.cos(aW),bu=W.sin(aW),aT=W.cos(aV),bt=W.sin(aV),bi=W.tan(a0/4),bl=4/3*bb*bi,bj=4/3*a9*bi,br=[a2,bw],bq=[a2+bl*bu,bw-bj*aU],bp=[a1+bl*bt,bv-bj*aT],bn=[a1,bv];bq[0]=2*br[0]-bq[0];bq[1]=2*br[1]-bq[1];if(a4){return[bq,bp,bn][aL](bf);}else{bf=[bq,bp,bn][aL](bf)[ar]()[w](",");var bd=[];for(var bo=0,be=bf[l];bo<be;bo++){bd[bo]=bo%2?bs(bf[bo-1],bf[bo],e).y:bs(bf[bo],bf[bo+1],e).x;}return bd;}},H=ad(function(i,e,R,E,aV,aU,aT,aS,aW){var S=1-aW;return{x:aF(S,3)*i+aF(S,2)*3*aW*R+S*3*aW*aW*aV+aF(aW,3)*aT,y:aF(S,3)*e+aF(S,2)*3*aW*E+S*3*aW*aW*aU+aF(aW,3)*aS};}),av=ad(function(i,e,a6,a4,aS,S,aU,aT,a0){var aY=1-a0,aX=aF(aY,3)*i+aF(aY,2)*3*a0*a6+aY*3*a0*a0*aS+aF(a0,3)*aU,aV=aF(aY,3)*e+aF(aY,2)*3*a0*a4+aY*3*a0*a0*S+aF(a0,3)*aT,a2=i+2*a0*(a6-i)+a0*a0*(aS-2*a6+i),a1=e+2*a0*(a4-e)+a0*a0*(S-2*a4+e),a5=a6+2*a0*(aS-a6)+a0*a0*(aU-2*aS+a6),a3=a4+2*a0*(S-a4)+a0*a0*(aT-2*S+a4),aZ=(1-a0)*i+a0*a6,aW=(1-a0)*e+a0*a4,R=(1-a0)*aS+a0*aU,E=(1-a0)*S+a0*aT;return{x:aX,y:aV,m:{x:a2,y:a1},n:{x:a5,y:a3},start:{x:aZ,y:aW},end:{x:R,y:E}};}),au=ad(function(E,e,S,R,a2,a1,aY,aV){var a0=(a2-2*S+E)-(aY-2*a2+S),aX=2*(S-E)-2*(a2-S),aU=E-S,aT=(-aX+W.sqrt(aX*aX-4*a0*aU))/2/a0,aS=(-aX-W.sqrt(aX*aX-4*a0*aU))/2/a0,aW=[e,aV],aZ=[E,aY],i;W.abs(aT)>1000000000000&&(aT=0.5);W.abs(aS)>1000000000000&&(aS=0.5);if(aT>0&&aT<1){i=H(E,e,S,R,a2,a1,aY,aV,aT);aZ[d](i.x);aW[d](i.y);}if(aS>0&&aS<1){i=H(E,e,S,R,a2,a1,aY,aV,aS);aZ[d](i.x);aW[d](i.y);}a0=(a1-2*R+e)-(aV-2*a1+R);aX=2*(R-e)-2*(a1-R);aU=e-R;aT=(-aX+W.sqrt(aX*aX-4*a0*aU))/2/a0;aS=(-aX-W.sqrt(aX*aX-4*a0*aU))/2/a0;W.abs(aT)>1000000000000&&(aT=0.5);W.abs(aS)>1000000000000&&(aS=0.5);if(aT>0&&aT<1){i=H(E,e,S,R,a2,a1,aY,aV,aT);aZ[d](i.x);aW[d](i.y);}if(aS>0&&aS<1){i=H(E,e,S,R,a2,a1,aY,aV,aS);aZ[d](i.x);aW[d](i.y);}return{min:{x:aB[aO](0,aZ),y:aB[aO](0,aW)},max:{x:f[aO](0,aZ),y:f[aO](0,aW)}};}),C=ad(function(a2,aX){var S=p(a2),aY=aX&&p(aX),aZ={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},e={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},aT=function(a3,a4){var i,a5;if(!a3){return["C",a4.x,a4.y,a4.x,a4.y,a4.x,a4.y];}!(a3[0] in {T:1,Q:1})&&(a4.qx=a4.qy=null);switch(a3[0]){case"M":a4.X=a3[1];a4.Y=a3[2];break;case"A":a3=["C"][aL](F[aO](0,[a4.x,a4.y][aL](a3.slice(1))));break;case"S":i=a4.x+(a4.x-(a4.bx||a4.x));a5=a4.y+(a4.y-(a4.by||a4.y));a3=["C",i,a5][aL](a3.slice(1));break;case"T":a4.qx=a4.x+(a4.x-(a4.qx||a4.x));a4.qy=a4.y+(a4.y-(a4.qy||a4.y));a3=["C"][aL](aD(a4.x,a4.y,a4.qx,a4.qy,a3[1],a3[2]));break;case"Q":a4.qx=a3[1];a4.qy=a3[2];a3=["C"][aL](aD(a4.x,a4.y,a3[1],a3[2],a3[3],a3[4]));break;case"L":a3=["C"][aL](aP(a4.x,a4.y,a3[1],a3[2]));break;case"H":a3=["C"][aL](aP(a4.x,a4.y,a3[1],a4.y));break;case"V":a3=["C"][aL](aP(a4.x,a4.y,a4.x,a3[1]));break;case"Z":a3=["C"][aL](aP(a4.x,a4.y,a4.X,a4.Y));break;}return a3;},E=function(a3,a4){if(a3[a4][l]>7){a3[a4].shift();var a5=a3[a4];while(a5[l]){a3.splice(a4++,0,["C"][aL](a5.splice(0,6)));}a3.splice(a4,1);a0=f(S[l],aY&&aY[l]||0);}},R=function(a7,a6,a4,a3,a5){if(a7&&a6&&a7[a5][0]=="M"&&a6[a5][0]!="M"){a6.splice(a5,0,["M",a3.x,a3.y]);a4.bx=0;a4.by=0;a4.x=a7[a5][1];a4.y=a7[a5][2];a0=f(S[l],aY&&aY[l]||0);}};for(var aV=0,a0=f(S[l],aY&&aY[l]||0);aV<a0;aV++){S[aV]=aT(S[aV],aZ);E(S,aV);aY&&(aY[aV]=aT(aY[aV],e));aY&&E(aY,aV);R(S,aY,aZ,e,aV);R(aY,S,e,aZ,aV);var aU=S[aV],a1=aY&&aY[aV],aS=aU[l],aW=aY&&a1[l];aZ.x=aU[aS-2];aZ.y=aU[aS-1];aZ.bx=P(aU[aS-4])||aZ.x;aZ.by=P(aU[aS-3])||aZ.y;e.bx=aY&&(P(a1[aW-4])||e.x);e.by=aY&&(P(a1[aW-3])||e.y);e.x=aY&&a1[aW-2];e.y=aY&&a1[aW-1];}return aY?[S,aY]:S;},null,ao),n=ad(function(aW){var aV=[];for(var aS=0,aX=aW[l];aS<aX;aS++){var e={},aU=aW[aS].match(/^([^:]*):?([\d\.]*)/);e.color=ai.getRGB(aU[1]);if(e.color.error){return null;}e.color=e.color.hex;aU[2]&&(e.offset=aU[2]+"%");aV[d](e);}for(var aS=1,aX=aV[l]-1;aS<aX;aS++){if(!aV[aS].offset){var E=P(aV[aS-1].offset||0),R=0;for(var S=aS+1;S<aX;S++){if(aV[S].offset){R=aV[S].offset;break;}}if(!R){R=100;S=aX;}R=P(R);var aT=(R-E)/(S-aS+1);for(;aS<S;aS++){E+=aT;aV[aS].offset=E+"%";}}}return aV;}),aj=function(){var E,i,S,R,e;if(ai.is(arguments[0],"string")||ai.is(arguments[0],"object")){if(ai.is(arguments[0],"string")){E=G.getElementById(arguments[0]);}else{E=arguments[0];}if(E.tagName){if(arguments[1]==null){return{container:E,width:E.style.pixelWidth||E.offsetWidth,height:E.style.pixelHeight||E.offsetHeight};}else{return{container:E,width:arguments[1],height:arguments[2]};}}}else{if(ai.is(arguments[0],ag)&&arguments[l]>3){return{container:1,x:arguments[0],y:arguments[1],width:arguments[2],height:arguments[3]};}}},az=function(e,E){var i=this;for(var R in E){if(E[L](R)&&!(R in e)){switch(typeof E[R]){case"function":(function(S){e[R]=e===i?S:function(){return S[aO](i,arguments);};})(E[R]);break;case"object":e[R]=e[R]||{};az.call(this,e[R],E[R]);break;default:e[R]=E[R];break;}}}},af=function(e,i){e==i.top&&(i.top=e.prev);e==i.bottom&&(i.bottom=e.next);e.next&&(e.next.prev=e.prev);e.prev&&(e.prev.next=e.next);},T=function(e,i){if(i.top===e){return;}af(e,i);e.next=null;e.prev=i.top;i.top.next=e;i.top=e;},j=function(e,i){if(i.bottom===e){return;}af(e,i);e.next=i.bottom;e.prev=null;i.bottom.prev=e;i.bottom=e;},x=function(i,e,E){af(i,E);e==E.top&&(E.top=i);e.next&&(e.next.prev=i);i.next=e.next;i.prev=e;e.next=i;},ak=function(i,e,E){af(i,E);e==E.bottom&&(E.bottom=i);e.prev&&(e.prev.next=i);i.prev=e.prev;e.prev=i;i.next=e;},al=/^r(?:\(([^,]+?)\s*,\s*([^\)]+?)\))?/;if(ai.svg){aJ.svgns="http://www.w3.org/2000/svg";aJ.xlink="http://www.w3.org/1999/xlink";var J=function(e){return +e+(~~e===e)*0.5;},O=function(aS){for(var E=0,R=aS[l];E<R;E++){if(aR.call(aS[E][0])!="a"){for(var e=1,S=aS[E][l];e<S;e++){aS[E][e]=J(aS[E][e]);}}else{aS[E][6]=J(aS[E][6]);aS[E][7]=J(aS[E][7]);}}return aS;},aC=function(E,e){if(e){for(var i in e){if(e[L](i)){E[s](i,e[i]);}}}else{return G.createElementNS(aJ.svgns,E);}};ai[at]=function(){return"Your browser supports SVG.\nYou are running Rapha\xebl "+this.version;};var o=function(e,R){var i=aC("path");R.canvas&&R.canvas[aE](i);var E=new aq(i,R);E.type="path";V(E,{fill:"none",stroke:"#000",path:e});return E;};var b=function(R,a0,e){var aX="linear",aU=0.5,aS=0.5,a2=R.style;a0=(a0+am)[aI](al,function(a4,i,a5){aX="radial";if(i&&a5){aU=P(i);aS=P(a5);var a3=((aS>0.5)*2-1);aF(aU-0.5,2)+aF(aS-0.5,2)>0.25&&(aS=W.sqrt(0.25-aF(aU-0.5,2))*a3+0.5)&&aS!=0.5&&(aS=aS.toFixed(5)-0.00001*a3);}return am;});a0=a0[w](/\s*\-\s*/);if(aX=="linear"){var aT=a0.shift();aT=-P(aT);if(isNaN(aT)){return null;}var S=[0,0,W.cos(aT*W.PI/180),W.sin(aT*W.PI/180)],aZ=1/(f(W.abs(S[2]),W.abs(S[3]))||1);S[2]*=aZ;S[3]*=aZ;if(S[2]<0){S[0]=-S[2];S[2]=0;}if(S[3]<0){S[1]=-S[3];S[3]=0;}}var aW=n(a0);if(!aW){return null;}var E=aC(aX+"Gradient");E.id="r"+(ai._id++)[at](36);aC(E,aX=="radial"?{fx:aU,fy:aS}:{x1:S[0],y1:S[1],x2:S[2],y2:S[3]});e.defs[aE](E);for(var aV=0,a1=aW[l];aV<a1;aV++){var aY=aC("stop");aC(aY,{offset:aW[aV].offset?aW[aV].offset:!aV?"0%":"100%","stop-color":aW[aV].color||"#fff"});E[aE](aY);}aC(R,{fill:"url(#"+E.id+")",opacity:1,"fill-opacity":1});a2.fill=am;a2.opacity=1;a2.fillOpacity=1;return 1;};var I=function(i){var e=i.getBBox();aC(i.pattern,{patternTransform:ai.format("translate({0},{1})",e.x,e.y)});};var V=function(aZ,a8){var a2={"":[0],none:[0],"-":[3,1],".":[1,1],"-.":[3,1,1,1],"-..":[3,1,1,1,1,1],". ":[1,3],"- ":[4,3],"--":[8,3],"- .":[4,3,1,3],"--.":[8,3,1,3],"--..":[8,3,1,3,1,3]},a4=aZ.node,a0=aZ.attrs,aW=aZ.rotate(),aS=function(bf,be){be=a2[aR.call(be)];if(be){var bc=bf.attrs["stroke-width"]||"1",ba={round:bc,square:bc,butt:0}[bf.attrs["stroke-linecap"]||a8["stroke-linecap"]]||0,bd=[];var bb=be[l];while(bb--){bd[bb]=be[bb]*bc+((bb%2)?1:-1)*ba;}aC(a4,{"stroke-dasharray":bd[ar](",")});}};a8[L]("rotation")&&(aW=a8.rotation);var aV=(aW+am)[w](a);if(!(aV.length-1)){aV=null;}else{aV[1]=+aV[1];aV[2]=+aV[2];}P(aW)&&aZ.rotate(0,true);for(var a3 in a8){if(a8[L](a3)){if(!h[L](a3)){continue;}var a1=a8[a3];a0[a3]=a1;switch(a3){case"rotation":aZ.rotate(a1,true);break;case"href":case"title":case"target":var a6=a4.parentNode;if(aR.call(a6.tagName)!="a"){var R=aC("a");a6.insertBefore(R,a4);R[aE](a4);a6=R;}a6.setAttributeNS(aZ.paper.xlink,a3,a1);break;case"cursor":a4.style.cursor=a1;break;case"clip-rect":var i=(a1+am)[w](a);if(i[l]==4){aZ.clip&&aZ.clip.parentNode.parentNode.removeChild(aZ.clip.parentNode);var E=aC("clipPath"),a5=aC("rect");E.id="r"+(ai._id++)[at](36);aC(a5,{x:i[0],y:i[1],width:i[2],height:i[3]});E[aE](a5);aZ.paper.defs[aE](E);aC(a4,{"clip-path":"url(#"+E.id+")"});aZ.clip=a5;}if(!a1){var a7=G.getElementById(a4.getAttribute("clip-path")[aI](/(^url\(#|\)$)/g,am));a7&&a7.parentNode.removeChild(a7);aC(a4,{"clip-path":am});delete aZ.clip;}break;case"path":if(a1&&aZ.type=="path"){a0.path=O(p(a1));aC(a4,{d:a0.path});}break;case"width":a4[s](a3,a1);if(a0.fx){a3="x";a1=a0.x;}else{break;}case"x":if(a0.fx){a1=-a0.x-(a0.width||0);}case"rx":if(a3=="rx"&&aZ.type=="rect"){break;}case"cx":aV&&(a3=="x"||a3=="cx")&&(aV[1]+=a1-a0[a3]);a4[s](a3,J(a1));aZ.pattern&&I(aZ);break;case"height":a4[s](a3,a1);if(a0.fy){a3="y";a1=a0.y;}else{break;}case"y":if(a0.fy){a1=-a0.y-(a0.height||0);}case"ry":if(a3=="ry"&&aZ.type=="rect"){break;}case"cy":aV&&(a3=="y"||a3=="cy")&&(aV[2]+=a1-a0[a3]);a4[s](a3,J(a1));aZ.pattern&&I(aZ);break;case"r":if(aZ.type=="rect"){aC(a4,{rx:a1,ry:a1});}else{a4[s](a3,a1);}break;case"src":if(aZ.type=="image"){a4.setAttributeNS(aZ.paper.xlink,"href",a1);}break;case"stroke-width":a4.style.strokeWidth=a1;a4[s](a3,a1);if(a0["stroke-dasharray"]){aS(aZ,a0["stroke-dasharray"]);}break;case"stroke-dasharray":aS(aZ,a1);break;case"translation":var aT=(a1+am)[w](a);aT[0]=+aT[0]||0;aT[1]=+aT[1]||0;if(aV){aV[1]+=aT[0];aV[2]+=aT[1];}q.call(aZ,aT[0],aT[1]);break;case"scale":var aT=(a1+am)[w](a);aZ.scale(+aT[0]||1,+aT[1]||+aT[0]||1,+aT[2]||null,+aT[3]||null);break;case"fill":var S=(a1+am).match(c);if(S){var E=aC("pattern"),aY=aC("image");E.id="r"+(ai._id++)[at](36);aC(E,{x:0,y:0,patternUnits:"userSpaceOnUse",height:1,width:1});aC(aY,{x:0,y:0});aY.setAttributeNS(aZ.paper.xlink,"href",S[1]);E[aE](aY);var a9=G.createElement("img");a9.style.cssText="position:absolute;left:-9999em;top-9999em";a9.onload=function(){aC(E,{width:this.offsetWidth,height:this.offsetHeight});aC(aY,{width:this.offsetWidth,height:this.offsetHeight});G.body.removeChild(this);aJ.safari();};G.body[aE](a9);a9.src=S[1];aZ.paper.defs[aE](E);a4.style.fill="url(#"+E.id+")";aC(a4,{fill:"url(#"+E.id+")"});aZ.pattern=E;aZ.pattern&&I(aZ);break;}if(!ai.getRGB(a1).error){delete a8.gradient;delete a0.gradient;!ai.is(a0.opacity,"undefined")&&ai.is(a8.opacity,"undefined")&&aC(a4,{opacity:a0.opacity});!ai.is(a0["fill-opacity"],"undefined")&&ai.is(a8["fill-opacity"],"undefined")&&aC(a4,{"fill-opacity":a0["fill-opacity"]});}else{if((({circle:1,ellipse:1})[L](aZ.type)||(a1+am).charAt()!="r")&&b(a4,a1,aZ.paper)){a0.gradient=a1;a0.fill="none";break;}}case"stroke":a4[s](a3,ai.getRGB(a1).hex);break;case"gradient":(({circle:1,ellipse:1})[L](aZ.type)||(a1+am).charAt()!="r")&&b(a4,a1,aZ.paper);break;case"opacity":case"fill-opacity":if(a0.gradient){var e=G.getElementById(a4.getAttribute("fill")[aI](/^url\(#|\)$/g,am));if(e){var aU=e.getElementsByTagName("stop");aU[aU[l]-1][s]("stop-opacity",a1);}break;}default:a3=="font-size"&&(a1=B(a1,10)+"px");var aX=a3[aI](/(\-.)/g,function(ba){return aG.call(ba.substring(1));});a4.style[aX]=a1;a4[s](a3,a1);break;}}}z(aZ,a8);if(aV){aZ.rotate(aV.join(ah));}else{P(aW)&&aZ.rotate(aW,true);}};var g=1.2;var z=function(e,S){if(e.type!="text"||!(S[L]("text")||S[L]("font")||S[L]("font-size")||S[L]("x")||S[L]("y"))){return;}var aW=e.attrs,E=e.node,aY=E.firstChild?B(G.defaultView.getComputedStyle(E.firstChild,am).getPropertyValue("font-size"),10):10;if(S[L]("text")){aW.text=S.text;while(E.firstChild){E.removeChild(E.firstChild);}var R=(S.text+am)[w]("\n");for(var aS=0,aX=R[l];aS<aX;aS++){if(R[aS]){var aU=aC("tspan");aS&&aC(aU,{dy:aY*g,x:aW.x});aU[aE](G.createTextNode(R[aS]));E[aE](aU);}}}else{var R=E.getElementsByTagName("tspan");for(var aS=0,aX=R[l];aS<aX;aS++){aS&&aC(R[aS],{dy:aY*g,x:aW.x});}}aC(E,{y:aW.y});var aT=e.getBBox(),aV=aW.y-(aT.y+aT.height/2);aV&&isFinite(aV)&&aC(E,{y:aW.y+aV});};var aq=function(i,e){var R=0,E=0;this[0]=i;this.id=ai._oid++;this.node=i;i.raphael=this;this.paper=e;this.attrs=this.attrs||{};this.transformations=[];this._={tx:0,ty:0,rt:{deg:0,cx:0,cy:0},sx:1,sy:1};!e.bottom&&(e.bottom=this);this.prev=e.top;e.top&&(e.top.next=this);e.top=this;this.next=null;};aq[aQ].rotate=function(i,e,R){if(this.removed){return this;}if(i==null){if(this._.rt.cx){return[this._.rt.deg,this._.rt.cx,this._.rt.cy][ar](ah);}return this._.rt.deg;}var E=this.getBBox();i=(i+am)[w](a);if(i[l]-1){e=P(i[1]);R=P(i[2]);}i=P(i[0]);if(e!=null){this._.rt.deg=i;}else{this._.rt.deg+=i;}(R==null)&&(e=null);this._.rt.cx=e;this._.rt.cy=R;e=e==null?E.x+E.width/2:e;R=R==null?E.y+E.height/2:R;if(this._.rt.deg){this.transformations[0]=ai.format("rotate({0} {1} {2})",this._.rt.deg,e,R);this.clip&&aC(this.clip,{transform:ai.format("rotate({0} {1} {2})",-this._.rt.deg,e,R)});}else{this.transformations[0]=am;this.clip&&aC(this.clip,{transform:am});}aC(this.node,{transform:this.transformations[ar](ah)});return this;};aq[aQ].hide=function(){!this.removed&&(this.node.style.display="none");return this;};aq[aQ].show=function(){!this.removed&&(this.node.style.display="");return this;};aq[aQ].remove=function(){if(this.removed){return;}af(this,this.paper);this.node.parentNode.removeChild(this.node);for(var e in this){delete this[e];}this.removed=true;};aq[aQ].getBBox=function(){if(this.removed){return this;}if(this.type=="path"){return N(this.attrs.path);}if(this.node.style.display=="none"){this.show();var R=true;}var aU={};try{aU=this.node.getBBox();}catch(aS){}finally{aU=aU||{};}if(this.type=="text"){aU={x:aU.x,y:Infinity,width:0,height:0};for(var E=0,S=this.node.getNumberOfChars();E<S;E++){var aT=this.node.getExtentOfChar(E);(aT.y<aU.y)&&(aU.y=aT.y);(aT.y+aT.height-aU.y>aU.height)&&(aU.height=aT.y+aT.height-aU.y);(aT.x+aT.width-aU.x>aU.width)&&(aU.width=aT.x+aT.width-aU.x);}}R&&this.hide();return aU;};aq[aQ].attr=function(){if(this.removed){return this;}if(arguments[l]==0){var S={};for(var R in this.attrs){if(this.attrs[L](R)){S[R]=this.attrs[R];}}this._.rt.deg&&(S.rotation=this.rotate());(this._.sx!=1||this._.sy!=1)&&(S.scale=this.scale());delete S.translation;S.gradient&&S.fill=="none"&&(S.fill=S.gradient)&&delete S.gradient;return S;}if(arguments[l]==1&&ai.is(arguments[0],"string")){if(arguments[0]=="translation"){return q.call(this);}if(arguments[0]=="rotation"){return this.rotate();}if(arguments[0]=="scale"){return this.scale();}if(arguments[0]=="fill"&&this.attrs.fill=="none"&&this.attrs.gradient){return this.attrs.gradient;}return this.attrs[arguments[0]];}if(arguments[l]==1&&ai.is(arguments[0],"array")){var e={};for(var E in arguments[0]){if(arguments[0][L](E)){e[arguments[0][E]]=this.attrs[arguments[0][E]];}}return e;}if(arguments[l]==2){var aS={};aS[arguments[0]]=arguments[1];V(this,aS);}else{if(arguments[l]==1&&ai.is(arguments[0],"object")){V(this,arguments[0]);}}return this;};aq[aQ].toFront=function(){if(this.removed){return this;}this.node.parentNode[aE](this.node);var e=this.paper;e.top!=this&&T(this,e);return this;};aq[aQ].toBack=function(){if(this.removed){return this;}if(this.node.parentNode.firstChild!=this.node){this.node.parentNode.insertBefore(this.node,this.node.parentNode.firstChild);j(this,this.paper);var e=this.paper;}return this;};aq[aQ].insertAfter=function(i){if(this.removed){return this;}var e=this.paper,E=i.node;if(E.nextSibling){E.parentNode.insertBefore(this.node,E.nextSibling);}else{E.parentNode[aE](this.node);}x(this,i,this.paper);return this;};aq[aQ].insertBefore=function(e){if(this.removed){return this;}var i=e.node;i.parentNode.insertBefore(this.node,i);ak(this,e,this.paper);return this;};var K=function(i,e,aS,S){e=J(e);aS=J(aS);var R=aC("circle");i.canvas&&i.canvas[aE](R);var E=new aq(R,i);E.attrs={cx:e,cy:aS,r:S,fill:"none",stroke:"#000"};E.type="circle";aC(R,E.attrs);return E;};var ay=function(E,e,aU,i,aS,aT){e=J(e);aU=J(aU);var S=aC("rect");E.canvas&&E.canvas[aE](S);var R=new aq(S,E);R.attrs={x:e,y:aU,width:i,height:aS,r:aT||0,rx:aT||0,ry:aT||0,fill:"none",stroke:"#000"};R.type="rect";aC(S,R.attrs);return R;};var ac=function(i,e,aT,aS,S){e=J(e);aT=J(aT);var R=aC("ellipse");i.canvas&&i.canvas[aE](R);var E=new aq(R,i);E.attrs={cx:e,cy:aT,rx:aS,ry:S,fill:"none",stroke:"#000"};E.type="ellipse";aC(R,E.attrs);return E;};var m=function(E,aT,e,aU,i,aS){var S=aC("image");aC(S,{x:e,y:aU,width:i,height:aS,preserveAspectRatio:"none"});S.setAttributeNS(E.xlink,"href",aT);E.canvas&&E.canvas[aE](S);var R=new aq(S,E);R.attrs={x:e,y:aU,width:i,height:aS,src:aT};R.type="image";return R;};var Q=function(i,e,aS,S){var R=aC("text");aC(R,{x:e,y:aS,"text-anchor":"middle"});i.canvas&&i.canvas[aE](R);var E=new aq(R,i);E.attrs={x:e,y:aS,"text-anchor":"middle",text:S,font:h.font,stroke:"none",fill:"#000"};E.type="text";V(E,E.attrs);return E;};var aN=function(i,e){this.width=i||this.width;this.height=e||this.height;this.canvas[s]("width",this.width);this.canvas[s]("height",this.height);return this;};var t=function(){var R=aj[aO](null,arguments),E=R&&R.container,i=R.x,aU=R.y,S=R.width,e=R.height;if(!E){throw new Error("SVG container not found.");}aJ.canvas=aC("svg");var aT=aJ.canvas;aJ.width=S||512;aJ.height=e||342;aC(aT,{xmlns:"http://www.w3.org/2000/svg",version:1.1,width:aJ.width,height:aJ.height});if(E==1){aT.style.cssText="position:absolute;left:"+i+"px;top:"+aU+"px";G.body[aE](aT);}else{if(E.firstChild){E.insertBefore(aT,E.firstChild);}else{E[aE](aT);}}E={canvas:aT};for(var aS in aJ){if(aJ[L](aS)){E[aS]=aJ[aS];}}E.bottom=E.top=null;az.call(E,E,ai.fn);E.clear();E.raphael=ai;return E;};aJ.clear=function(){var e=this.canvas;while(e.firstChild){e.removeChild(e.firstChild);}this.bottom=this.top=null;(this.desc=aC("desc"))[aE](G.createTextNode("Created with Rapha\xebl"));e[aE](this.desc);e[aE](this.defs=aC("defs"));};aJ.remove=function(){this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas);for(var e in this){delete this[e];}};}if(ai.vml){var aA=function(a1){var aY=/[ahqtv]/ig,aT=p;(a1+am).match(aY)&&(aT=C);aY=/[clmz]/g;if(aT==p&&!(a1+am).match(aY)){var E={M:"m",L:"l",C:"c",Z:"x",m:"t",l:"r",c:"v",z:"x"},S=/([clmz]),?([^clmz]*)/gi,aS=/-?[^,\s-]+/g;var aX=(a1+am)[aI](S,function(a2,a4,i){var a3=[];i[aI](aS,function(a5){a3[d](J(a5));});return E[a4]+a3;});return aX;}var aZ=aT(a1),R,aX=[],e;for(var aV=0,a0=aZ[l];aV<a0;aV++){R=aZ[aV];e=aR.call(aZ[aV][0]);e=="z"&&(e="x");for(var aU=1,aW=R[l];aU<aW;aU++){e+=J(R[aU])+(aU!=aW-1?",":am);}aX[d](e);}return aX[ar](ah);};ai[at]=function(){return"Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl "+this.version;};var o=function(e,aS){var R=ab("group");R.style.cssText="position:absolute;left:0;top:0;width:"+aS.width+"px;height:"+aS.height+"px";R.coordsize=aS.coordsize;R.coordorigin=aS.coordorigin;var E=ab("shape"),i=E.style;i.width=aS.width+"px";i.height=aS.height+"px";E.coordsize=this.coordsize;E.coordorigin=this.coordorigin;R[aE](E);var S=new aq(E,R,aS);S.isAbsolute=true;S.type="path";S.path=[];S.Path=am;e&&V(S,{fill:"none",stroke:"#000",path:e});aS.canvas[aE](R);return S;};var V=function(aW,a1){aW.attrs=aW.attrs||{};var aZ=aW.node,a2=aW.attrs,aT=aZ.style,R,a6=aW;for(var aU in a1){if(a1[L](aU)){a2[aU]=a1[aU];}}a1.href&&(aZ.href=a1.href);a1.title&&(aZ.title=a1.title);a1.target&&(aZ.target=a1.target);a1.cursor&&(aT.cursor=a1.cursor);if(a1.path&&aW.type=="path"){a2.path=a1.path;aZ.path=aA(a2.path);}if(a1.rotation!=null){aW.rotate(a1.rotation,true);}if(a1.translation){R=(a1.translation+am)[w](a);q.call(aW,R[0],R[1]);if(aW._.rt.cx!=null){aW._.rt.cx+=+R[0];aW._.rt.cy+=+R[1];aW.setBox(aW.attrs,R[0],R[1]);}}if(a1.scale){R=(a1.scale+am)[w](a);aW.scale(+R[0]||1,+R[1]||+R[0]||1,+R[2]||null,+R[3]||null);}if("clip-rect" in a1){var e=(a1["clip-rect"]+am)[w](a);if(e[l]==4){e[2]=+e[2]+(+e[0]);e[3]=+e[3]+(+e[1]);var aV=aZ.clipRect||G.createElement("div"),a5=aV.style,aS=aZ.parentNode;a5.clip=ai.format("rect({1}px {2}px {3}px {0}px)",e);if(!aZ.clipRect){a5.position="absolute";a5.top=0;a5.left=0;a5.width=aW.paper.width+"px";a5.height=aW.paper.height+"px";aS.parentNode.insertBefore(aV,aS);aV[aE](aS);aZ.clipRect=aV;}}if(!a1["clip-rect"]){aZ.clipRect&&(aZ.clipRect.style.clip=am);}}if(aW.type=="image"&&a1.src){aZ.src=a1.src;}if(aW.type=="image"&&a1.opacity){aZ.filterOpacity=" progid:DXImageTransform.Microsoft.Alpha(opacity="+(a1.opacity*100)+")";aT.filter=(aZ.filterMatrix||am)+(aZ.filterOpacity||am);}a1.font&&(aT.font=a1.font);a1["font-family"]&&(aT.fontFamily='"'+a1["font-family"][w](",")[0][aI](/^['"]+|['"]+$/g,am)+'"');a1["font-size"]&&(aT.fontSize=a1["font-size"]);a1["font-weight"]&&(aT.fontWeight=a1["font-weight"]);a1["font-style"]&&(aT.fontStyle=a1["font-style"]);if(a1.opacity!=null||a1["stroke-width"]!=null||a1.fill!=null||a1.stroke!=null||a1["stroke-width"]!=null||a1["stroke-opacity"]!=null||a1["fill-opacity"]!=null||a1["stroke-dasharray"]!=null||a1["stroke-miterlimit"]!=null||a1["stroke-linejoin"]!=null||a1["stroke-linecap"]!=null){aZ=aW.shape||aZ;var a0=(aZ.getElementsByTagName("fill")&&aZ.getElementsByTagName("fill")[0]),a3=false;!a0&&(a3=a0=ab("fill"));if("fill-opacity" in a1||"opacity" in a1){var i=((+a2["fill-opacity"]+1||2)-1)*((+a2.opacity+1||2)-1);i<0&&(i=0);i>1&&(i=1);a0.opacity=i;}a1.fill&&(a0.on=true);if(a0.on==null||a1.fill=="none"){a0.on=false;}if(a0.on&&a1.fill){var E=a1.fill.match(c);if(E){a0.src=E[1];a0.type="tile";}else{a0.color=ai.getRGB(a1.fill).hex;a0.src=am;a0.type="solid";if(ai.getRGB(a1.fill).error&&(a6.type in {circle:1,ellipse:1}||(a1.fill+am).charAt()!="r")&&b(a6,a1.fill)){a2.fill="none";a2.gradient=a1.fill;}}}a3&&aZ[aE](a0);var S=(aZ.getElementsByTagName("stroke")&&aZ.getElementsByTagName("stroke")[0]),a4=false;!S&&(a4=S=ab("stroke"));if((a1.stroke&&a1.stroke!="none")||a1["stroke-width"]||a1["stroke-opacity"]!=null||a1["stroke-dasharray"]||a1["stroke-miterlimit"]||a1["stroke-linejoin"]||a1["stroke-linecap"]){S.on=true;}(a1.stroke=="none"||S.on==null||a1.stroke==0||a1["stroke-width"]==0)&&(S.on=false);S.on&&a1.stroke&&(S.color=ai.getRGB(a1.stroke).hex);var i=((+a2["stroke-opacity"]+1||2)-1)*((+a2.opacity+1||2)-1),aX=(P(a1["stroke-width"])||1)*0.75;i<0&&(i=0);i>1&&(i=1);a1["stroke-width"]==null&&(aX=a2["stroke-width"]);a1["stroke-width"]&&(S.weight=aX);aX&&aX<1&&(i*=aX)&&(S.weight=1);S.opacity=i;a1["stroke-linejoin"]&&(S.joinstyle=a1["stroke-linejoin"]||"miter");S.miterlimit=a1["stroke-miterlimit"]||8;a1["stroke-linecap"]&&(S.endcap=a1["stroke-linecap"]=="butt"?"flat":a1["stroke-linecap"]=="square"?"square":"round");if(a1["stroke-dasharray"]){var aY={"-":"shortdash",".":"shortdot","-.":"shortdashdot","-..":"shortdashdotdot",". ":"dot","- ":"dash","--":"longdash","- .":"dashdot","--.":"longdashdot","--..":"longdashdotdot"};S.dashstyle=aY[L](a1["stroke-dasharray"])?aY[a1["stroke-dasharray"]]:am;}a4&&aZ[aE](S);}if(a6.type=="text"){var aT=a6.paper.span.style;a2.font&&(aT.font=a2.font);a2["font-family"]&&(aT.fontFamily=a2["font-family"]);a2["font-size"]&&(aT.fontSize=a2["font-size"]);a2["font-weight"]&&(aT.fontWeight=a2["font-weight"]);a2["font-style"]&&(aT.fontStyle=a2["font-style"]);a6.node.string&&(a6.paper.span.innerHTML=(a6.node.string+am)[aI](/</g,"&#60;")[aI](/&/g,"&#38;")[aI](/\n/g,"<br>"));a6.W=a2.w=a6.paper.span.offsetWidth;a6.H=a2.h=a6.paper.span.offsetHeight;a6.X=a2.x;a6.Y=a2.y+J(a6.H/2);switch(a2["text-anchor"]){case"start":a6.node.style["v-text-align"]="left";a6.bbx=J(a6.W/2);break;case"end":a6.node.style["v-text-align"]="right";a6.bbx=-J(a6.W/2);break;default:a6.node.style["v-text-align"]="center";break;}}};var b=function(e,aU){e.attrs=e.attrs||{};var aV=e.attrs,aX=e.node.getElementsByTagName("fill"),aS="linear",aT=".5 .5";e.attrs.gradient=aU;aU=(aU+am)[aI](al,function(aZ,a0,i){aS="radial";if(a0&&i){a0=P(a0);i=P(i);aF(a0-0.5,2)+aF(i-0.5,2)>0.25&&(i=W.sqrt(0.25-aF(a0-0.5,2))*((i>0.5)*2-1)+0.5);aT=a0+ah+i;}return am;});aU=aU[w](/\s*\-\s*/);if(aS=="linear"){var E=aU.shift();E=-P(E);if(isNaN(E)){return null;}}var S=n(aU);if(!S){return null;}e=e.shape||e.node;aX=aX[0]||ab("fill");if(S[l]){aX.on=true;aX.method="none";aX.type=(aS=="radial")?"gradientradial":"gradient";aX.color=S[0].color;aX.color2=S[S[l]-1].color;var aY=[];for(var R=0,aW=S[l];R<aW;R++){S[R].offset&&aY[d](S[R].offset+ah+S[R].color);}aX.colors&&(aX.colors.value=aY[l]?aY[ar](","):"0% "+aX.color);if(aS=="radial"){aX.focus="100%";aX.focussize=aT;aX.focusposition=aT;}else{aX.angle=(270-E)%360;}}return 1;};var aq=function(S,aT,e){var aS=0,E=0,i=0,R=1;this[0]=S;this.id=ai._oid++;this.node=S;S.raphael=this;this.X=0;this.Y=0;this.attrs={};this.Group=aT;this.paper=e;this._={tx:0,ty:0,rt:{deg:0},sx:1,sy:1};!e.bottom&&(e.bottom=this);this.prev=e.top;e.top&&(e.top.next=this);e.top=this;this.next=null;};aq[aQ].rotate=function(i,e,E){if(this.removed){return this;}if(i==null){if(this._.rt.cx){return[this._.rt.deg,this._.rt.cx,this._.rt.cy][ar](ah);}return this._.rt.deg;}i=(i+am)[w](a);if(i[l]-1){e=P(i[1]);E=P(i[2]);}i=P(i[0]);if(e!=null){this._.rt.deg=i;}else{this._.rt.deg+=i;}E==null&&(e=null);this._.rt.cx=e;this._.rt.cy=E;this.setBox(this.attrs,e,E);this.Group.style.rotation=this._.rt.deg;return this;};aq[aQ].setBox=function(a4,E,e){if(this.removed){return this;}var aY=this.Group.style,S=(this.shape&&this.shape.style)||this.node.style;a4=a4||{};for(var a2 in a4){if(a4[L](a2)){this.attrs[a2]=a4[a2];}}E=E||this._.rt.cx;e=e||this._.rt.cy;var a0=this.attrs,aU,aT,aV,a3;switch(this.type){case"circle":aU=a0.cx-a0.r;aT=a0.cy-a0.r;aV=a3=a0.r*2;break;case"ellipse":aU=a0.cx-a0.rx;aT=a0.cy-a0.ry;aV=a0.rx*2;a3=a0.ry*2;break;case"rect":case"image":aU=+a0.x;aT=+a0.y;aV=a0.width||0;a3=a0.height||0;break;case"text":this.textpath.v=["m",J(a0.x),", ",J(a0.y-2),"l",J(a0.x)+1,", ",J(a0.y-2)][ar](am);aU=a0.x-J(this.W/2);aT=a0.y-this.H/2;aV=this.W;a3=this.H;break;case"path":if(!this.attrs.path){aU=0;aT=0;aV=this.paper.width;a3=this.paper.height;}else{var a1=N(this.attrs.path);aU=a1.x;aT=a1.y;aV=a1.width;a3=a1.height;}break;default:aU=0;aT=0;aV=this.paper.width;a3=this.paper.height;break;}E=(E==null)?aU+aV/2:E;e=(e==null)?aT+a3/2:e;var R=E-this.paper.width/2,aX=e-this.paper.height/2;if(this.type=="path"||this.type=="text"){(aY.left!=R+"px")&&(aY.left=R+"px");(aY.top!=aX+"px")&&(aY.top=aX+"px");this.X=this.type=="text"?aU:-R;this.Y=this.type=="text"?aT:-aX;this.W=aV;this.H=a3;(S.left!=-R+"px")&&(S.left=-R+"px");(S.top!=-aX+"px")&&(S.top=-aX+"px");}else{(aY.left!=R+"px")&&(aY.left=R+"px");(aY.top!=aX+"px")&&(aY.top=aX+"px");this.X=aU;this.Y=aT;this.W=aV;this.H=a3;(aY.width!=this.paper.width+"px")&&(aY.width=this.paper.width+"px");(aY.height!=this.paper.height+"px")&&(aY.height=this.paper.height+"px");(S.left!=aU-R+"px")&&(S.left=aU-R+"px");(S.top!=aT-aX+"px")&&(S.top=aT-aX+"px");(S.width!=aV+"px")&&(S.width=aV+"px");(S.height!=a3+"px")&&(S.height=a3+"px");var aS=(+a4.r||0)/aB(aV,a3);if(this.type=="rect"&&this.arcsize.toFixed(4)!=aS.toFixed(4)&&(aS||this.arcsize)){var aZ=ab("roundrect"),a5={},a2=0,aW=this.events&&this.events[l];aZ.arcsize=aS;aZ.raphael=this;this.Group[aE](aZ);this.Group.removeChild(this.node);this[0]=this.node=aZ;this.arcsize=aS;for(var a2 in a0){a5[a2]=a0[a2];}delete a5.scale;this.attr(a5);if(this.events){for(;a2<aW;a2++){this.events[a2].unbind=Z(this.node,this.events[a2].name,this.events[a2].f,this);}}}}};aq[aQ].hide=function(){!this.removed&&(this.Group.style.display="none");return this;};aq[aQ].show=function(){!this.removed&&(this.Group.style.display="block");return this;};aq[aQ].getBBox=function(){if(this.removed){return this;}if(this.type=="path"){return N(this.attrs.path);}return{x:this.X+(this.bbx||0),y:this.Y,width:this.W,height:this.H};};aq[aQ].remove=function(){if(this.removed){return;}af(this,this.paper);this.node.parentNode.removeChild(this.node);this.Group.parentNode.removeChild(this.Group);this.shape&&this.shape.parentNode.removeChild(this.shape);for(var e in this){delete this[e];}this.removed=true;};aq[aQ].attr=function(){if(this.removed){return this;}if(arguments[l]==0){var R={};for(var E in this.attrs){if(this.attrs[L](E)){R[E]=this.attrs[E];}}this._.rt.deg&&(R.rotation=this.rotate());(this._.sx!=1||this._.sy!=1)&&(R.scale=this.scale());delete R.translation;R.gradient&&R.fill=="none"&&(R.fill=R.gradient)&&delete R.gradient;return R;}if(arguments[l]==1&&ai.is(arguments[0],"string")){if(arguments[0]=="translation"){return q.call(this);}if(arguments[0]=="rotation"){return this.rotate();}if(arguments[0]=="scale"){return this.scale();}if(arguments[0]=="fill"&&this.attrs.fill=="none"&&this.attrs.gradient){return this.attrs.gradient;}return this.attrs[arguments[0]];}if(this.attrs&&arguments[l]==1&&ai.is(arguments[0],"array")){var e={};for(var E=0,S=arguments[0][l];E<S;E++){e[arguments[0][E]]=this.attrs[arguments[0][E]];}return e;}var aS;if(arguments[l]==2){aS={};aS[arguments[0]]=arguments[1];}arguments[l]==1&&ai.is(arguments[0],"object")&&(aS=arguments[0]);if(aS){if(aS.text&&this.type=="text"){this.node.string=aS.text;}V(this,aS);if(aS.gradient&&(({circle:1,ellipse:1})[L](this.type)||(aS.gradient+am).charAt()!="r")){b(this,aS.gradient);}(this.type!="path"||this._.rt.deg)&&this.setBox(this.attrs);}return this;};aq[aQ].toFront=function(){!this.removed&&this.Group.parentNode[aE](this.Group);this.paper.top!=this&&T(this,this.paper);return this;};aq[aQ].toBack=function(){if(this.removed){return this;}if(this.Group.parentNode.firstChild!=this.Group){this.Group.parentNode.insertBefore(this.Group,this.Group.parentNode.firstChild);j(this,this.paper);}return this;};aq[aQ].insertAfter=function(e){if(this.removed){return this;}if(e.Group.nextSibling){e.Group.parentNode.insertBefore(this.Group,e.Group.nextSibling);}else{e.Group.parentNode[aE](this.Group);}x(this,e,this.paper);return this;};aq[aQ].insertBefore=function(e){if(this.removed){return this;}e.Group.parentNode.insertBefore(this.Group,e.Group);ak(this,e,this.paper);return this;};var K=function(i,e,aU,aS){var S=ab("group"),aT=ab("oval"),E=aT.style;S.style.cssText="position:absolute;left:0;top:0;width:"+i.width+"px;height:"+i.height+"px";S.coordsize=i.coordsize;S.coordorigin=i.coordorigin;S[aE](aT);var R=new aq(aT,S,i);R.type="circle";V(R,{stroke:"#000",fill:"none"});R.attrs.cx=e;R.attrs.cy=aU;R.attrs.r=aS;R.setBox({x:e-aS,y:aU-aS,width:aS*2,height:aS*2});i.canvas[aE](S);return R;};var ay=function(i,aU,aT,aV,R,e){var S=ab("group"),E=ab("roundrect"),aW=(+e||0)/(aB(aV,R));S.style.cssText="position:absolute;left:0;top:0;width:"+i.width+"px;height:"+i.height+"px";S.coordsize=i.coordsize;S.coordorigin=i.coordorigin;S[aE](E);E.arcsize=aW;var aS=new aq(E,S,i);aS.type="rect";V(aS,{stroke:"#000"});aS.arcsize=aW;aS.setBox({x:aU,y:aT,width:aV,height:R,r:e});i.canvas[aE](S);return aS;};var ac=function(e,aV,aU,E,i){var S=ab("group"),R=ab("oval"),aT=R.style;S.style.cssText="position:absolute;left:0;top:0;width:"+e.width+"px;height:"+e.height+"px";S.coordsize=e.coordsize;S.coordorigin=e.coordorigin;S[aE](R);var aS=new aq(R,S,e);aS.type="ellipse";V(aS,{stroke:"#000"});aS.attrs.cx=aV;aS.attrs.cy=aU;aS.attrs.rx=E;aS.attrs.ry=i;aS.setBox({x:aV-E,y:aU-i,width:E*2,height:i*2});e.canvas[aE](S);return aS;};var m=function(i,e,aV,aU,aW,R){var S=ab("group"),E=ab("image"),aT=E.style;S.style.cssText="position:absolute;left:0;top:0;width:"+i.width+"px;height:"+i.height+"px";S.coordsize=i.coordsize;S.coordorigin=i.coordorigin;E.src=e;S[aE](E);var aS=new aq(E,S,i);aS.type="image";aS.attrs.src=e;aS.attrs.x=aV;aS.attrs.y=aU;aS.attrs.w=aW;aS.attrs.h=R;aS.setBox({x:aV,y:aU,width:aW,height:R});i.canvas[aE](S);return aS;};var Q=function(i,aV,aU,aW){var S=ab("group"),R=ab("shape"),aT=R.style,aX=ab("path"),e=aX.style,E=ab("textpath");S.style.cssText="position:absolute;left:0;top:0;width:"+i.width+"px;height:"+i.height+"px";S.coordsize=i.coordsize;S.coordorigin=i.coordorigin;aX.v=ai.format("m{0},{1}l{2},{1}",J(aV),J(aU),J(aV)+1);aX.textpathok=true;aT.width=i.width;aT.height=i.height;E.string=aW+am;E.on=true;R[aE](E);R[aE](aX);S[aE](R);var aS=new aq(E,S,i);aS.shape=R;aS.textpath=aX;aS.type="text";aS.attrs.text=aW;aS.attrs.x=aV;aS.attrs.y=aU;aS.attrs.w=1;aS.attrs.h=1;V(aS,{font:h.font,stroke:"none",fill:"#000"});aS.setBox();i.canvas[aE](S);return aS;};var aN=function(E,e){var i=this.canvas.style;E==+E&&(E+="px");e==+e&&(e+="px");i.width=E;i.height=e;i.clip="rect(0 "+E+" "+e+" 0)";return this;};G.createStyleSheet().addRule(".rvml","behavior:url(#default#VML)");try{!G.namespaces.rvml&&G.namespaces.add("rvml","urn:schemas-microsoft-com:vml");var ab=function(e){return G.createElement("<rvml:"+e+' class="rvml">');};}catch(aa){var ab=function(e){return G.createElement("<"+e+' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');};}var t=function(){var R=aj[aO](null,arguments),i=R.container,aW=R.height,aX,E=R.width,aV=R.x,aU=R.y;if(!i){throw new Error("VML container not found.");}var aS={},aT=aS.canvas=G.createElement("div"),S=aT.style;E=E||512;aW=aW||342;E==+E&&(E+="px");aW==+aW&&(aW+="px");aS.width=1000;aS.height=1000;aS.coordsize="1000 1000";aS.coordorigin="0 0";aS.span=G.createElement("span");aS.span.style.cssText="position:absolute;left:-9999px;top:-9999px;padding:0;margin:0;line-height:1;display:inline;";aT[aE](aS.span);S.cssText=ai.format("width:{0};height:{1};position:absolute;clip:rect(0 {0} {1} 0);overflow:hidden",E,aW);if(i==1){G.body[aE](aT);S.left=aV+"px";S.top=aU+"px";i={style:{width:E,height:aW}};}else{i.style.width=E;i.style.height=aW;if(i.firstChild){i.insertBefore(aT,i.firstChild);}else{i[aE](aT);}}for(var e in aJ){if(aJ[L](e)){aS[e]=aJ[e];}}az.call(aS,aS,ai.fn);aS.top=aS.bottom=null;aS.raphael=ai;return aS;};aJ.clear=function(){this.canvas.innerHTML=am;this.bottom=this.top=null;};aJ.remove=function(){this.canvas.parentNode.removeChild(this.canvas);for(var e in this){delete this[e];}};}if((/^Apple|^Google/).test(navigator.vendor)&&!(navigator.userAgent.indexOf("Version/4.0")+1)){aJ.safari=function(){var e=this.rect(-99,-99,this.width+99,this.height+99);setTimeout(function(){e.remove();});};}else{aJ.safari=function(){};}var Z=(function(){if(G.addEventListener){return function(S,E,i,e){var R=function(aS){return i.call(e,aS);};S.addEventListener(E,R,false);return function(){S.removeEventListener(E,R,false);return true;};};}else{if(G.attachEvent){return function(aS,R,E,i){var S=function(aT){return E.call(i,aT||an.event);};aS.attachEvent("on"+R,S);var e=function(){aS.detachEvent("on"+R,S);return true;};return e;};}}})();for(var X=A[l];X--;){(function(e){aq[aQ][e]=function(i){if(ai.is(i,"function")){this.events=this.events||[];this.events.push({name:e,f:i,unbind:Z(this.shape||this.node,e,i,this)});}return this;};aq[aQ]["un"+e]=function(R){var E=this.events,i=E[l];while(i--){if(E[i].name==e&&E[i].f==R){E[i].unbind();E.splice(i,1);!E.length&&delete this.events;return this;}}return this;};})(A[X]);}aq[aQ].hover=function(i,e){return this.mouseover(i).mouseout(e);};aq[aQ].unhover=function(i,e){return this.unmouseover(i).unmouseout(e);};aJ.circle=function(e,E,i){return K(this,e||0,E||0,i||0);};aJ.rect=function(e,S,i,E,R){return ay(this,e||0,S||0,i||0,E||0,R||0);};aJ.ellipse=function(e,R,E,i){return ac(this,e||0,R||0,E||0,i||0);};aJ.path=function(e){e&&!ai.is(e,"string")&&!ai.is(e[0],"array")&&(e+=am);return o(ai.format[aO](ai,arguments),this);};aJ.image=function(R,e,S,i,E){return m(this,R||"about:blank",e||0,S||0,i||0,E||0);};aJ.text=function(e,E,i){return Q(this,e||0,E||0,i||am);};aJ.set=function(e){arguments[l]>1&&(e=Array[aQ].splice.call(arguments,0,arguments[l]));return new M(e);};aJ.setSize=aN;function r(){return this.x+ah+this.y;}aq[aQ].scale=function(a2,a1,R,E){if(a2==null&&a1==null){return{x:this._.sx,y:this._.sy,toString:r};}a1=a1||a2;!+a1&&(a1=a2);var a6,a4,a5,a3,bi=this.attrs;if(a2!=0){var aZ=this.getBBox(),aW=aZ.x+aZ.width/2,aS=aZ.y+aZ.height/2,bh=a2/this._.sx,bg=a1/this._.sy;R=(+R||R==0)?R:aW;E=(+E||E==0)?E:aS;var aY=~~(a2/W.abs(a2)),aV=~~(a1/W.abs(a1)),a9=this.node.style,bk=R+(aW-R)*bh,bj=E+(aS-E)*bg;switch(this.type){case"rect":case"image":var aX=bi.width*aY*bh,a8=bi.height*aV*bg,a0=bi.r*aB(bh,bg),aU=bk-aX/2,S=bj-a8/2;this.attr({height:a8,r:a0,width:aX,x:aU,y:S});break;case"circle":case"ellipse":this.attr({rx:bi.rx*aY*bh,ry:bi.ry*aV*bg,r:bi.r*aB(aY*bh,aV*bg),cx:bk,cy:bj});break;case"path":var bc=Y(bi.path),bd=true;for(var bf=0,a7=bc[l];bf<a7;bf++){var ba=bc[bf],be,aT=aG.call(ba[0]);if(aT=="M"&&bd){continue;}else{bd=false;}if(aT=="A"){ba[bc[bf][l]-2]*=bh;ba[bc[bf][l]-1]*=bg;ba[1]*=aY*bh;ba[2]*=aV*bg;ba[5]=+(aY+aV?!!+ba[5]:!+ba[5]);}else{if(aT=="H"){for(be=1,jj=ba[l];be<jj;be++){ba[be]*=bh;}}else{if(aT=="V"){for(be=1,jj=ba[l];be<jj;be++){ba[be]*=bg;}}else{for(be=1,jj=ba[l];be<jj;be++){ba[be]*=(be%2)?bh:bg;}}}}}var e=N(bc),a6=bk-e.x-e.width/2,a4=bj-e.y-e.height/2;bc[0][1]+=a6;bc[0][2]+=a4;this.attr({path:bc});break;}if(this.type in {text:1,image:1}&&(aY!=1||aV!=1)){if(this.transformations){this.transformations[2]="scale("[aL](aY,",",aV,")");this.node[s]("transform",this.transformations[ar](ah));a6=(aY==-1)?-bi.x-(aX||0):bi.x;a4=(aV==-1)?-bi.y-(a8||0):bi.y;this.attr({x:a6,y:a4});bi.fx=aY-1;bi.fy=aV-1;}else{this.node.filterMatrix=" progid:DXImageTransform.Microsoft.Matrix(M11="[aL](aY,", M12=0, M21=0, M22=",aV,", Dx=0, Dy=0, sizingmethod='auto expand', filtertype='bilinear')");a9.filter=(this.node.filterMatrix||am)+(this.node.filterOpacity||am);}}else{if(this.transformations){this.transformations[2]=am;this.node[s]("transform",this.transformations[ar](ah));bi.fx=0;bi.fy=0;}else{this.node.filterMatrix=am;a9.filter=(this.node.filterMatrix||am)+(this.node.filterOpacity||am);}}bi.scale=[a2,a1,R,E][ar](ah);this._.sx=a2;this._.sy=a1;}return this;};aq[aQ].clone=function(){return this.paper[this.type]().attr(this.attr());};ai.easing_formulas={linear:function(e){return e;},"<":function(e){return aF(e,3);},">":function(e){return aF(e-1,3)+1;},"<>":function(e){e=e*2;if(e<1){return aF(e,3)/2;}e-=2;return(aF(e,3)+2)/2;},backIn:function(i){var e=1.70158;return i*i*((e+1)*i-e);},backOut:function(i){i=i-1;var e=1.70158;return i*i*((e+1)*i+e)+1;},elastic:function(E){if(E==0||E==1){return E;}var i=0.3,e=i/4;return aF(2,-10*E)*W.sin((E-e)*(2*W.PI)/i)+1;},bounce:function(R){var i=7.5625,E=2.75,e;if(R<(1/E)){e=i*R*R;}else{if(R<(2/E)){R-=(1.5/E);e=i*R*R+0.75;}else{if(R<(2.5/E)){R-=(2.25/E);e=i*R*R+0.9375;}else{R-=(2.625/E);e=i*R*R+0.984375;}}}return e;}};var D={length:0},aK=function(){var aV=+new Date;for(var a6 in D){if(a6!="length"&&D[L](a6)){var bb=D[a6];if(bb.stop){delete D[a6];D[l]--;continue;}var aT=aV-bb.start,a4=bb.ms,a3=bb.easing,a7=bb.from,a0=bb.diff,R=bb.to,aZ=bb.t,a2=bb.prev||0,aU=bb.el,S=bb.callback,a1={},E;if(aT<a4){var aS=ai.easing_formulas[a3]?ai.easing_formulas[a3](aT/a4):aT/a4;for(var a5 in a7){if(a7[L](a5)){switch(U[a5]){case"number":E=+a7[a5]+aS*a4*a0[a5];break;case"colour":E="rgb("+[y(J(a7[a5].r+aS*a4*a0[a5].r)),y(J(a7[a5].g+aS*a4*a0[a5].g)),y(J(a7[a5].b+aS*a4*a0[a5].b))][ar](",")+")";break;case"path":E=[];for(var a9=0,aY=a7[a5][l];a9<aY;a9++){E[a9]=[a7[a5][a9][0]];for(var a8=1,ba=a7[a5][a9][l];a8<ba;a8++){E[a9][a8]=+a7[a5][a9][a8]+aS*a4*a0[a5][a9][a8];}E[a9]=E[a9][ar](ah);}E=E[ar](ah);break;case"csv":switch(a5){case"translation":var aX=a0[a5][0]*(aT-a2),aW=a0[a5][1]*(aT-a2);aZ.x+=aX;aZ.y+=aW;E=aX+ah+aW;break;case"rotation":E=+a7[a5][0]+aS*a4*a0[a5][0];a7[a5][1]&&(E+=","+a7[a5][1]+","+a7[a5][2]);break;case"scale":E=[+a7[a5][0]+aS*a4*a0[a5][0],+a7[a5][1]+aS*a4*a0[a5][1],(2 in R[a5]?R[a5][2]:am),(3 in R[a5]?R[a5][3]:am)][ar](ah);break;case"clip-rect":E=[];var a9=4;while(a9--){E[a9]=+a7[a5][a9]+aS*a4*a0[a5][a9];}break;}break;}a1[a5]=E;}}aU.attr(a1);aU._run&&aU._run.call(aU);}else{(aZ.x||aZ.y)&&aU.translate(-aZ.x,-aZ.y);R.scale&&(R.scale=R.scale+am);aU.attr(R);delete D[a6];D[l]--;aU.in_animation=null;ai.is(S,"function")&&S.call(aU);}bb.prev=aT;}}ai.svg&&aJ.safari();D[l]&&setTimeout(aK);},y=function(e){return e>255?255:(e<0?0:e);},q=function(e,E){if(e==null){return{x:this._.tx,y:this._.ty,toString:r};}this._.tx+=+e;this._.ty+=+E;switch(this.type){case"circle":case"ellipse":this.attr({cx:+e+this.attrs.cx,cy:+E+this.attrs.cy});break;case"rect":case"image":case"text":this.attr({x:+e+this.attrs.x,y:+E+this.attrs.y});break;case"path":var i=Y(this.attrs.path);i[0][1]+=+e;i[0][2]+=+E;this.attr({path:i});break;}return this;};aq[aQ].animateWith=function(i,E,e,S,R){D[i.id]&&(E.start=D[i.id].start);return this.animate(E,e,S,R);};aq[aQ].onAnimation=function(e){this._run=e||null;return this;};aq[aQ].animate=function(R,e,aX,a3){if(ai.is(aX,"function")||!aX){a3=aX||null;}var aY={},aZ={},a0={};for(var aW in R){if(R[L](aW)){if(U[L](aW)){aY[aW]=this.attr(aW);(aY[aW]==null)&&(aY[aW]=h[aW]);aZ[aW]=R[aW];switch(U[aW]){case"number":a0[aW]=(aZ[aW]-aY[aW])/e;break;case"colour":aY[aW]=ai.getRGB(aY[aW]);var aU=ai.getRGB(aZ[aW]);a0[aW]={r:(aU.r-aY[aW].r)/e,g:(aU.g-aY[aW].g)/e,b:(aU.b-aY[aW].b)/e};break;case"path":var E=C(aY[aW],aZ[aW]);aY[aW]=E[0];aZ[aW]=E[1];a0[aW]=[];for(var aT=0,a2=aY[aW][l];aT<a2;aT++){a0[aW][aT]=[0];for(var S=1,aV=aY[aW][aT][l];S<aV;S++){a0[aW][aT][S]=(aZ[aW][aT][S]-aY[aW][aT][S])/e;}}break;case"csv":var a1=(R[aW]+am)[w](a),aS=(aY[aW]+am)[w](a);switch(aW){case"translation":aY[aW]=[0,0];a0[aW]=[a1[0]/e,a1[1]/e];break;case"rotation":aY[aW]=(aS[1]==a1[1]&&aS[2]==a1[2])?aS:[0,a1[1],a1[2]];a0[aW]=[(a1[0]-aY[aW][0])/e,0,0];break;case"scale":R[aW]=a1;aY[aW]=(aY[aW]+am)[w](a);a0[aW]=[(a1[0]-aY[aW][0])/e,(a1[1]-aY[aW][1])/e,0,0];break;case"clip-rect":aY[aW]=(aY[aW]+am)[w](a);a0[aW]=[];var aT=4;while(aT--){a0[aW][aT]=(a1[aT]-aY[aW][aT])/e;}break;}aZ[aW]=a1;}}}}this.stop();this.in_animation=1;D[this.id]={start:R.start||+new Date,ms:e,easing:aX,from:aY,diff:a0,to:aZ,el:this,callback:a3,t:{x:0,y:0}};++D[l]==1&&aK();return this;};aq[aQ].stop=function(){D[this.id]&&D[l]--;delete D[this.id];return this;};aq[aQ].translate=function(e,i){return this.attr({translation:e+" "+i});};aq[aQ][at]=function(){return"Rapha\xebl\u2019s object";};ai.ae=D;var M=function(e){this.items=[];this[l]=0;if(e){for(var E=0,R=e[l];E<R;E++){if(e[E]&&(e[E].constructor==aq||e[E].constructor==M)){this[this.items[l]]=this.items[this.items[l]]=e[E];this[l]++;}}}};M[aQ][d]=function(){var S,e;for(var E=0,R=arguments[l];E<R;E++){S=arguments[E];if(S&&(S.constructor==aq||S.constructor==M)){e=this.items[l];this[e]=this.items[e]=S;this[l]++;}}return this;};M[aQ].pop=function(){delete this[this[l]--];return this.items.pop();};for(var v in aq[aQ]){if(aq[aQ][L](v)){M[aQ][v]=(function(e){return function(){for(var E=0,R=this.items[l];E<R;E++){this.items[E][e][aO](this.items[E],arguments);}return this;};})(v);}}M[aQ].attr=function(E,aT){if(E&&ai.is(E,"array")&&ai.is(E[0],"object")){for(var e=0,aS=E[l];e<aS;e++){this.items[e].attr(E[e]);}}else{for(var R=0,S=this.items[l];R<S;R++){this.items[R].attr[aO](this.items[R],arguments);}}return this;};M[aQ].animate=function(aS,E,aV,aU){(ai.is(aV,"function")||!aV)&&(aU=aV||null);var e=this.items[l],R=e,aT=this,S;aU&&(S=function(){!--e&&aU.call(aT);});this.items[--R].animate(aS,E,aV||S,S);while(R--){this.items[R].animateWith(this.items[e-1],aS,E,aV||S,S);}return this;};M[aQ].insertAfter=function(E){var e=this.items[l];while(e--){this.items[e].insertAfter(E);}return this;};M[aQ].getBBox=function(){var e=[],aT=[],E=[],S=[];for(var R=this.items[l];R--;){var aS=this.items[R].getBBox();e[d](aS.x);aT[d](aS.y);E[d](aS.x+aS.width);S[d](aS.y+aS.height);}e=aB[aO](0,e);aT=aB[aO](0,aT);return{x:e,y:aT,width:f[aO](0,E)-e,height:f[aO](0,S)-aT};};ai.registerFont=function(i){if(!i.face){return i;}this.fonts=this.fonts||{};var R={w:i.w,face:{},glyphs:{}},E=i.face["font-family"];for(var aT in i.face){if(i.face[L](aT)){R.face[aT]=i.face[aT];}}if(this.fonts[E]){this.fonts[E][d](R);}else{this.fonts[E]=[R];}if(!i.svg){R.face["units-per-em"]=B(i.face["units-per-em"],10);for(var S in i.glyphs){if(i.glyphs[L](S)){var aS=i.glyphs[S];R.glyphs[S]={w:aS.w,k:{},d:aS.d&&"M"+aS.d[aI](/[mlcxtrv]/g,function(aU){return{l:"L",c:"C",x:"z",t:"m",r:"l",v:"c"}[aU]||"M";})+"z"};if(aS.k){for(var e in aS.k){if(aS[L](e)){R.glyphs[S].k[e]=aS.k[e];}}}}}}return i;};aJ.getFont=function(aV,aW,E,S){S=S||"normal";E=E||"normal";aW=+aW||{normal:400,bold:700,lighter:300,bolder:800}[aW]||400;var aS=ai.fonts[aV];if(!aS){var R=new RegExp("(^|\\s)"+aV[aI](/[^\w\d\s+!~.:_-]/g,am)+"(\\s|$)","i");for(var e in ai.fonts){if(ai.fonts[L](e)){if(R.test(e)){aS=ai.fonts[e];break;}}}}var aT;if(aS){for(var aU=0,aX=aS[l];aU<aX;aU++){aT=aS[aU];if(aT.face["font-weight"]==aW&&(aT.face["font-style"]==E||!aT.face["font-style"])&&aT.face["font-stretch"]==S){break;}}}return aT;};aJ.print=function(S,R,e,aU,aV,a4){a4=a4||"middle";var a0=this.set(),a3=(e+am)[w](am),a1=0,aX=am,a5;ai.is(aU,"string")&&(aU=this.getFont(aU));if(aU){a5=(aV||16)/aU.face["units-per-em"];var E=aU.face.bbox.split(a),aT=+E[0],aW=+E[1]+(a4=="baseline"?E[3]-E[1]+(+aU.face.descent):(E[3]-E[1])/2);for(var aZ=0,aS=a3[l];aZ<aS;aZ++){var aY=aZ&&aU.glyphs[a3[aZ-1]]||{},a2=aU.glyphs[a3[aZ]];a1+=aZ?(aY.w||aU.w)+(aY.k&&aY.k[a3[aZ]]||0):0;a2&&a2.d&&a0[d](this.path(a2.d).attr({fill:"#000",stroke:"none",translation:[a1,0]}));}a0.scale(a5,a5,aT,aW).translate(S-aT,R-aW);}return a0;};ai.format=function(E){var i=ai.is(arguments[1],"array")?[0][aL](arguments[1]):arguments,e=/\{(\d+)\}/g;E&&ai.is(E,"string")&&i[l]-1&&(E=E[aI](e,function(S,R){return i[++R]==null?am:i[R];}));return E||am;};ai.ninja=function(){var E=an.Raphael,i;if(k.was){an.Raphael=k.is;}else{try{delete an.Raphael;}catch(R){an.Raphael=i;}}return E;};ai.el=aq[aQ];return ai;})();

var Diagram = function()
{
	this.rad = Math.PI / 180;
	
	this.oldBalloon = false,
	this.oldBalloonIndex = -1;
	
	this.colors = ["#FF3300", "#FF9900", "#CCFF00", "#33CC00", "#33CCCC", "#66CCFF", "#0066FF", "#CC33FF", "#CC0066", "#FF6633", "#CCFF66", "#33FF33", "#00CCCC", "#0099FF", "#0033CC", "#9933FF", "#CC3399", "#990033", "#FF9933", "#99CC00", "#33CC99", "#33CCFF", "#006699", "#660099"];
	this.colorCounter = 0;
}

Diagram.prototype.draw = function(parent, width, height)
{
	var graphID = 'graph' + Math.random();
	
	_(parent, [_div([_div(null,[['attr','id',graphID],['css','width',width + 'px'],['css','height',height + 'px']])])]);

	return Raphael(graphID, width, height);
}

Diagram.prototype.getNextColor = function()
{
	var color = this.colors[this.colorCounter % this.colors.length];
	
	++this.colorCounter;
	
	return color;
}

Diagram.prototype.resetColor = function()
{
	this.colorCounter = 0;
}

Diagram.prototype.createPieDiagram = function(parent, width, height, data)
{
	var graph = this.draw(parent, width, height),
		_this = this;
	
	this.resetColor()
	
	// определяем суммарное значение для масштабирования
	var countGraphValue = 0;
	for (var layer in data)
			countGraphValue += Number(data[layer]);
	
	// отсупы и размеры
	var cx = width / 2,
		cy = height / 2,
		r = height / 3.5;
	
	function sector(cx, cy, r, startAngle, endAngle, params)
	{
		if (Math.abs(endAngle - startAngle - 360) < 180 / (Math.PI * r))
			return graph.circle(cx, cy, r).attr(params);
		
		var x1 = cx + r * Math.cos(-startAngle * _this.rad),
			x2 = cx + r * Math.cos(-endAngle * _this.rad),
			y1 = cy + r * Math.sin(-startAngle * _this.rad),
			y2 = cy + r * Math.sin(-endAngle * _this.rad);
		
		return graph.path(["M", cx, cy, "L", x1, y1, "A", r, r, 0, +(endAngle - startAngle > 180), 0, x2, y2, "z"]).attr(params);
	}
	
	var angle = 0,
		startColor = 0,
		littleAngle = 0,
		littleValue = 0,
		delta = 20,
		ms = 300,
		startOpacity = 1,
		maxScale = 1.05,
		textTemplate = "text\nvalue (proc%)",
		process = function(layer)
		{
			var textData = layer,
				value = Number(data[layer]),
				proc = Number(100 * value / countGraphValue).toFixed(1),
	            angleplus = 360 * value / countGraphValue;
	        
	        if (angleplus < 180 / (Math.PI * r))
			{
				littleValue += value;
				littleAngle += angleplus;
				
				return;
			}
	        
	        var	popangle = angle + (angleplus / 2),
				bcolor = _diagram.getNextColor(),
				hsbBcolor = Raphael.rgb2hsb(bcolor),
				color = Raphael.hsb2rgb(hsbBcolor.h, hsbBcolor.s, hsbBcolor.b * 0.6).hex,
				p = sector(cx, cy, r, angle, angle + angleplus, {gradient: Math.abs(Math.round(angle + angleplus - 90)) + "-" + bcolor + "-" + color, stroke: color, "stroke-width": 1}).attr({id:layer}),
				txt = graph.text(cx + (r + delta) * Math.cos(-popangle * _this.rad), cy + (r + delta) * Math.sin(-popangle * _this.rad), textTemplate.replace(/text/g,textData).replace(/value/g, value).replace(/proc/g, proc))
	        					.attr({fill: "#153069", stroke: "none", opacity: startOpacity, "font-family": '"Arial"', "font-size": "13px", "text-anchor": (angle + angleplus /2 > 90 && angle + angleplus / 2 < 270) ? "end" : "start"});
	        
	        p.mouseover(function()
	        {
	        	p.animate({scale: [maxScale, maxScale, cx, cy]}, ms, "elastic");
				
			//	txt.animate({opacity: 1}, ms, "elastic");
				txt.node.setAttribute("fill","#FC830B")
	        }).mouseout(function()
	        {
	        	p.animate({scale: [1, 1, cx, cy]}, ms, "elastic");
	        	
			//	txt.animate({opacity: startOpacity}, ms);
				txt.node.setAttribute("fill","#153069")
	        });
	        angle += angleplus;
	        startColor += .1;
	        
	        if (startColor > 1)
	        	startColor = 0.1;
		},
		processLittle = function()
		{
			var textData = 'Остальное',
		    	value = littleValue,
				angleplus = littleAngle,
				popangle = angle + (angleplus / 2),
				color = "#CCCCCF",
				bcolor = "#99999B";
		       
			var p = sector(cx, cy, r, angle, angle + angleplus, {gradient: Math.abs(Math.round(angle + angleplus - 90)) + "-" + bcolor + "-" + color, stroke: color, "stroke-width": 1}).attr({id:data}),
			    txt = graph.text(cx + (r + delta) * Math.cos(-popangle * _this.rad), cy + (r + delta) * Math.sin(-popangle * _this.rad), textTemplate.replace(/text/g,textData).replace(/value/g, value))
			                                       .attr({fill: "#4970AC", stroke: "none", opacity: startOpacity, "font-family": '"Arial"', "font-size": "10px"});
		       
		//	txt.node.setAttribute("angle", -popangle)
		//	p.node.setAttribute("angle", 0)

			p.mouseover(function()
			{
				p.animate({scale: [maxScale, maxScale, cx, cy]}, ms, "elastic");
				       
				txt.animate({opacity: 1}, ms, "elastic");
			}).mouseout(function()
			{
				p.animate({scale: [1, 1, cx, cy]}, ms, "elastic");

				txt.animate({opacity: startOpacity}, ms);
			});
		}
	
	Raphael.getColor.reset();
	
	for (var layer in data)
		process(layer);
	
	if (littleAngle > 0)
		processLittle();	
}

Diagram.prototype.createDateTimeDiagram = function(parent, width, height, data)
{
	var graph = this.draw(parent, width, height);

	var dateTimeData = [],
		minValue = Number.MAX_VALUE,
		maxValue = -Number.MAX_VALUE,
		_this = this;
	
	for (var propName in data)
	{
		dateTimeData.push({date:Number(propName), value:data[propName]});
		
		if (data[propName] < minValue)
			minValue = data[propName];
		
		if (data[propName] > maxValue)
			maxValue = data[propName];
	}
	
	Raphael.getColor.reset();
	
	dateTimeData = dateTimeData.sort(function(a,b)
	{
		return a.date - b.date;
	});
	
	var cx = width - 50,
		cy = height - 40,
		firstDate = dateTimeData[0].date,
		lastDate = dateTimeData[dateTimeData.length - 1].date,
		scaleX = lastDate - firstDate,
		scaleY = maxValue - minValue != 0 ? maxValue - minValue : 1,
		firstDate = dateTimeData[0].date,
		funcPath = [],
		leaveTimer,
		isLabelVisible = false
		processPath = function(data, i)
		{
			var xCoord = 40 + cx * (data.date - firstDate) / scaleX,
				yCoord = 10 + cy - cy * (data.value - minValue) / scaleY;
			
			if (i == 0)
				funcPath = funcPath.concat(['M', xCoord, yCoord]);
			else
				funcPath = funcPath.concat(['L', xCoord, yCoord]);
		},
		process = function(data, i)
		{
			var xCoord = 40 + cx * (data.date - firstDate) / scaleX,
				yCoord = 10 + cy - cy * (data.value - minValue) / scaleY;
			
			var dot = graph.circle(xCoord, yCoord, 3).attr({fill: '#33AB33', stroke: '#88CB99'});
			
			dot.mouseover(function()
	        {
	            dot.attr("r", 5);

                var newWidth = String(data.value).length * 7 + 12 + 55,
					newcoord = {x: xCoord + 20, y: yCoord > 10 + cy - 24 ? 10 + cy - 24 : yCoord};
                
                if (newcoord.x + newWidth > cx + 40) 
                    newcoord.x -= (newWidth + 40);
				
				if (!$.browser.msie)
				{
		            clearTimeout(leaveTimer);
	                ttFrame.show().animate({x: newcoord.x, y: newcoord.y, width:newWidth}, 200 * isLabelVisible);
	                ttText.attr({text: stringDate(data.date) + ': ' + String(data.value)}).show().animate({x: newcoord.x + 6, y: newcoord.y + 9}, 200 * isLabelVisible);
	                isLabelVisible = true;
	                graph.safari();
	            }
	            else
	            {
   	               	ttFrame.show().attr({x: newcoord.x, y: newcoord.y, width:newWidth});
                	ttText.show().attr({text: stringDate(data.date) + ': ' + String(data.value),x: newcoord.x + 6, y: newcoord.y + 12});
	            }
	            
	        }).mouseout(function()
	        {
	            dot.attr("r", 3);
	            
	            if (!$.browser.msie)
				{
	                graph.safari();
	                leaveTimer = setTimeout(function ()
	                {
	                    ttFrame.hide();
	                    ttText.hide();
	                    isLabelVisible = false;
	                    graph.safari();
	                }, 1);
	            }
	            else
	            {
            		ttFrame.hide();
                    ttText.hide();
	            }
	        });
		};

	graph.path(["M", 40, 10, "L", 40, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 2, opacity: 0.7});
	graph.path(["M", 40, cy + 10, "L", cx + 40, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 2, opacity: 0.7});
	
	if (lastDate - firstDate > 2 * 1000 * 86400 * 365)
	{
		// разбивка по годам
		var year = new Date(firstDate).getFullYear() + 1,
			lastXYear = -1;
		
		while (new Date(year, 0, 1) < lastDate)
		{
			var xYear = 40 + cx * (new Date(year, 0, 1).valueOf() - firstDate) / scaleX;
			
			if (lastXYear < 0 || (xYear - lastXYear) > 40)
			{
				graph.path(["M", xYear, 10, "L", xYear, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 1, opacity: 0.2});
				graph.text(xYear, cy + 25, String(year)).attr({"font": '12px "Arial"', stroke: "none", fill: "#153069", "text-anchor": "middle"});
				
				lastXYear = xYear;
			}
			
			year++;
		}
	}
	else if (lastDate - firstDate > 2 * 1000 * 86400 * 30)
	{
		// разбивка по месяцам
		var year = new Date(firstDate).getFullYear(),
			month = new Date(firstDate).getMonth() + 1,
			monthNames = {'0':'январь','1':'февраль','2':'март','3':'апрель','4':'май','5':'июнь','6':'июль','7':'август','8':'сентябрь','9':'октябрь','10':'ноябрь','11':'декабрь'},
			lastXYear = -1;
		
		if (month > 11)
		{
			month = 0;
			year++;
		}
		
		while (new Date(year, month, 1) < lastDate)
		{
			var xYear = 40 + cx * (new Date(year, month, 1).valueOf() - firstDate) / scaleX;
			
			if (lastXYear < 0 || (xYear - lastXYear) > 40)
			{
				graph.path(["M", xYear, 10, "L", xYear, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 1, opacity: 0.2});
				graph.text(xYear, cy + 25, String(monthNames[month] + '\n' + year)).attr({"font": '12px "Arial"', stroke: "none", fill: "#153069", "text-anchor": "middle"});
				
				lastXYear = xYear;
			}
			
			month++;
			
			if (month > 11)
			{
				month = 0;
				year++;
			}
		}
	}
	else
	{
		// разбивка по дням
		var currDate = firstDate + 24 * 3600 * 1000,
			monthNames = {'0':'января','1':'февраля','2':'марта','3':'апреля','4':'мая','5':'июня','6':'июля','7':'августа','8':'сентября','9':'октября','10':'ноября','11':'декабря'},
			lastXYear = -1;
		
		if (new Date(currDate).getDate() == new Date(firstDate).getDate())
			currDate = firstDate + 25 * 3600 * 1000;
		
		currDate = new Date(currDate);
		currDate.setHours(0);
		currDate = currDate.valueOf();

		while (currDate < lastDate)
		{
			var xYear = 40 + cx * (currDate - firstDate) / scaleX;
			
			if (lastXYear < 0 || (xYear - lastXYear) > 40)
			{
				graph.path(["M", xYear, 10, "L", xYear, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 1, opacity: 0.2});
				graph.text(xYear, cy + 25, String(String(new Date(currDate).getDate()) + ' ' + monthNames[new Date(currDate).getMonth()] + '\n' + String(new Date(currDate).getFullYear()))).attr({"font": '12px "Arial"', stroke: "none", fill: "#153069", "text-anchor": "middle"});
				
				lastXYear = xYear;
			}
			
			var oldCurrDate = new Date(currDate).getDate();
			
			currDate = currDate + 24 * 3600 * 1000;
			
			if (new Date(currDate).getDate() == oldCurrDate)
				currDate = currDate + 25 * 3600 * 1000;
			
			currDate = new Date(currDate);
			currDate.setHours(0);
			currDate = currDate.valueOf();
		}

	}
	
	var yLabels = [],
		labelIndex = -1;;
	
	// "красивые метки" на ось y
	for (var i = 0; i < 13; i++)
	{
		yLabels.push(1 * Math.pow(10, i - 5));
		yLabels.push(2 * Math.pow(10, i - 5));
		yLabels.push(5 * Math.pow(10, i - 5));
	}
	
	for (var i = 0; i < yLabels.length; i++)
	{
		if (scaleY / yLabels[i] > cy / 100 &&
			scaleY / yLabels[i] < cy / 50)
		{
			labelIndex = i;
			
			break;
		}
	}
	
	if (labelIndex > 0)
	{
		var labelCount = Math.floor(scaleY / yLabels[labelIndex]),
			firstYLabel = (Math.floor(minValue / yLabels[labelIndex]) + 1) * yLabels[labelIndex];
		
		while (firstYLabel < maxValue)
		{
			var yLabel = 10 + cy - cy * (firstYLabel - minValue) / scaleY;
		
			graph.path(["M", 40, yLabel, "L", cx + 40, yLabel]).attr({stroke: "#ABABAB", "stroke-width": 1, opacity: 0.2});
			graph.text(35, yLabel, String(firstYLabel)).attr({"font": '12px "Arial"', stroke: "none", fill: "#153069", "text-anchor": "end"});
			
			firstYLabel += yLabels[labelIndex]
		}
	}
	
	for (var i = 0; i < dateTimeData.length; i++)
		processPath(dateTimeData[i], i);

	graph.path(funcPath).attr({stroke: '#88CB99', 'stroke-width':2})
		
	var ttFrame = graph.rect(10, 10, 120, 20, 5).attr({fill: "#CBCBEA", stroke: "#ABABFA", "stroke-width": 2, opacity: 1}).hide(),
		ttText = graph.text(60, 10, String(minValue)).attr({"font": '12px "Arial"', stroke: "none", fill: "#FFF", "text-anchor": "start"}).hide();

	for (var i = 0; i < dateTimeData.length; i++)
		process(dateTimeData[i], i);
	
	ttFrame = graph.rect(10, 10, 120, 20, 5).attr({fill: "#CBCBEA", stroke: "#ABABFA", "stroke-width": 2, opacity: 1}).hide(),
	ttText = graph.text(60, 10, String(minValue)).attr({"font": '12px "Arial"', stroke: "none", fill: "#FFF", "text-anchor": "start"}).hide();
}

// data: {'legend1':[], 'legend2':[], ..}
// dataColumns: "Октябрь, Ноябрь, .."

Diagram.prototype.createMultiLinesDiagram = function(parent, width, height, data, dataColumns, legendFlag)
{
	var graph = this.draw(parent, width, height);
	
	this.resetColor();
	
	var chartId = String(Math.random()).substr(2,12),
		minValue = Number.MAX_VALUE,
		maxValue = -Number.MAX_VALUE,
		layerNames = [],
		layerColors = {},
		curPosition = 0,
		legendCellHeight = 20,
		startColor = 0;
		
	for (var label in data)
	{
		layerNames.push(label.replace(/\s/g, ''));

		layerColors[label] = _diagram.getNextColor();

		for (var j = 0; j < data[label].length; j++)
		{
			if (data[label][j] > maxValue)
				maxValue = data[label][j];

			if (data[label][j] < minValue)
				minValue = data[label][j];
		}
		
		startColor += 0.1 * (1 + Math.random());
		
		if (startColor > 1)
	    	startColor = 0.1 * (1 + Math.random());
	}
	
	var cx = width - 55 - (legendFlag > 0 ? 130 : 0),
		cy = height - 40,
		namesByPage = Math.floor((cy - 40) / legendCellHeight),
		scaleY = maxValue - minValue != 0 ? maxValue - minValue : 1;
	
	// оси
	graph.path(["M", 40, 10, "L", 40, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 2, opacity: 0.7});
	graph.path(["M", 40, cy + 10, "L", cx + 40, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 2, opacity: 0.7});
	
	// "красивые метки" на ось x
	var columnTextLengths = [];
	
	for (var i = 0; i < dataColumns.length; i++)
	{
		var strs = dataColumns[i].split("\n"),
			maxLen = strs[0].length;
		
		for (var j = 1; j < strs.length; j++)
			if (strs[j].length > maxLen)
				maxLen = strs[j].length;
		
		columnTextLengths.push(maxLen * 7)
	}
	
	var lastTextCoord = -1;
	
	for (var i = 0; i < dataColumns.length; i++)
	{
		var currXCoord = 40 + cx * i / (dataColumns.length - 1);
		
		if (lastTextCoord < 0 || (currXCoord - lastTextCoord) > 10 + columnTextLengths[i] / 2)
		{
			graph.path(["M", currXCoord, 10, "L", currXCoord, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 1, opacity: 0.2});
			graph.text(currXCoord, cy + 25, String(dataColumns[i])).attr({"font": '12px "Arial"', stroke: "none", fill: "#153069", "text-anchor": "middle"});
			
			lastTextCoord = currXCoord + columnTextLengths[i] / 2;
		}
	}
	
	var yLabels = [],
		labelIndex = -1;;
	
	// "красивые метки" на ось y
	for (var i = 0; i < 13; i++)
	{
		yLabels.push(1 * Math.pow(10, i - 5));
		yLabels.push(2 * Math.pow(10, i - 5));
		yLabels.push(5 * Math.pow(10, i - 5));
	}
	
	for (var i = 0; i < yLabels.length; i++)
	{
		if (scaleY / yLabels[i] > cy / 200 &&
			scaleY / yLabels[i] < cy / 20)
		{
			labelIndex = i;
			
			break;
		}
	}
	
	if (labelIndex > 0)
	{
		var labelCount = Math.floor(scaleY / yLabels[labelIndex]),
			firstYLabel = (Math.floor(minValue / yLabels[labelIndex]) + 1) * yLabels[labelIndex];
		
		while (firstYLabel <= maxValue)
		{
			var yLabel = 10 + cy - cy * (firstYLabel - minValue) / scaleY;
		
			graph.path(["M", 40, yLabel, "L", cx + 40, yLabel]).attr({stroke: "#ABABAB", "stroke-width": 1, opacity: 0.2});
			graph.text(35, yLabel, String(firstYLabel)).attr({"font": '12px "Arial"', stroke: "none", fill: "#153069", "text-anchor": "end"});
			
			firstYLabel += yLabels[labelIndex]
		}
	}
	
	// сам график
	var	leaveTimer,
		isLabelVisible = false,
		process = function(label)
		{
			var values = data[label],
				funcPath = [];
			
			for (var i = 0; i < dataColumns.length; i++)
			{
				var xCoord = 40 + cx * i / (dataColumns.length - 1),
					yCoord = 10 + cy - cy * (values[i] - minValue) / scaleY;
			
				if (i == 0)
					funcPath = funcPath.concat(['M', xCoord, yCoord]);
				else
					funcPath = funcPath.concat(['L', xCoord, yCoord]);
			}
			
			var line = graph.path(funcPath).attr({stroke: layerColors[label], 'stroke-width':2});
			line.node.setAttribute('id', chartId + 'line_' + label);
			
			for (var i = 0; i < dataColumns.length; i++)
			{
				(function(i)
				{
					var xCoord = 40 + cx * i / (dataColumns.length - 1),
					yCoord = 10 + cy - cy * (values[i] - minValue) / scaleY;
					
					var dot = graph.circle(xCoord, yCoord, 3).attr({fill: layerColors[label], stroke: layerColors[label]});
					dot.node.setAttribute('id', chartId + 'dot_' + label + '_' + i);
					
					dot.mouseover(function()
			        {
			            dot.attr("r", 5);
			            
		                var newWidth = String(values[i]).length * 7 + 12,
		                	newcoord = {x: xCoord + 20, y: yCoord > 10 + cy - 24 ? 10 + cy - 24 : yCoord};
                		
                		if (newcoord.x + newWidth > cx + 40) 
                    		newcoord.x -= (newWidth + 40);
						
						if (!$.browser.msie)
						{
				            clearTimeout(leaveTimer);
			                ttFrame.show().animate({x: newcoord.x, y: newcoord.y, width:newWidth}, 200 * isLabelVisible);
			                ttText.attr({text: String(values[i])}).show().animate({x: newcoord.x + 6, y: newcoord.y + 9}, 200 * isLabelVisible);
			                isLabelVisible = true;
			                graph.safari();
			            }
			            else
			            {
		   	               	ttFrame.show().attr({x: newcoord.x, y: newcoord.y, width:newWidth});
		                	ttText.show().attr({text: String(values[i]),x: newcoord.x + 6, y: newcoord.y + 12});
			            }
			            
			        }).mouseout(function()
			        {
			            dot.attr("r", 3);
			            
			            if (!$.browser.msie)
						{
			                graph.safari();
			                leaveTimer = setTimeout(function ()
			                {
			                    ttFrame.hide();
			                    ttText.hide();
			                    isLabelVisible = false;
			                    graph.safari();
			                }, 1);
			            }
			            else
			            {
		            		ttFrame.hide();
		                    ttText.hide();
			            }
			        });
		        })(i);
			}
		},
		_this = this;

	var ttFrame = graph.rect(10, 10, 120, 20, 5).attr({fill: "#CBCBEA", stroke: "#ABABFA", "stroke-width": 2, opacity: 1}).hide(),
		ttText = graph.text(60, 10, String(minValue)).attr({"font": '12px "Arial"', stroke: "none", fill: "#FFF", "text-anchor": "start"}).hide();
	
	for (var label in data)
		process(label)
	
	ttFrame = graph.rect(10, 10, 120, 20, 5).attr({fill: "#CBCBEA", stroke: "#ABABFA", "stroke-width": 2, opacity: 1}).hide(),
	ttText = graph.text(60, 10, String(minValue)).attr({"font": '12px "Arial"', stroke: "none", fill: "#FFF", "text-anchor": "start"}).hide();
	
	// легенда
	if (legendFlag > 0)
	{
		var width = 130,
			height = Math.min(namesByPage, objLength(data)) * legendCellHeight + 40;
		
		graph.rect(cx + 50, 10, width, height, 5)
			.attr('fill','#FAFAFE')
			.attr('stroke','#BABABE')
			.attr('stroke-width',1);
		
		var up = graph.path(["M", cx + 50 + 5, 10 + 15, "L", cx + 50 + width - 5, 10 + 15, "L", cx + 50 + width / 2, 10 + 5, "L", cx + 50 + 5,  10 + 15,"Z"]).attr({fill: '#ABCDEF', opacity: 0.5}),
			down = graph.path(["M", cx + 50 + 5, 10 + height - 15, "L", cx + 50 + width - 5, 10 + height - 15, "L", cx + 50 + width / 2,  10 + height - 5, "L",cx + 50 + 5,  10 + height - 15, "Z"]).attr({fill: '#ABCDEF', opacity: 0.5});
		
		up.node.style.cursor = "pointer";
		down.node.style.cursor = "pointer";
		
		var drawCurrentPage = function(position, count, names)
		{
			var length = count,
				endPosition = (names.length < position + length) ? names.length : position + length;
			
			var attachEvent = function(elem, name)
			{
				$(elem.node).mousedown(function()
				{
					if (elem.attr('opacity') == 1)
					{
						for (var i = 0; i < dataColumns.length; i++)
						{
							var bar = $('#' + chartId + 'dot_' + name + '_' + i)[0];
							$(bar).hide();
						}
						
						$('#' + chartId + 'line_' + name).hide();
						$('#' + chartId + 'legRect_' + name).attr('fill','#999999');
						
						elem.attr('opacity', 0.2);
					}
					else
					{
						for (var i = 0; i < dataColumns.length; i++)
						{
							var bar = $('#' + chartId + 'dot_' + name + '_' + i)[0];
							$(bar).show();
						}
						
						$('#' + chartId + 'line_' + name).show();
						$('#' + chartId + 'legRect_' + name).attr('fill','#153069');
						
						elem.attr('opacity', 1);
					}
				})
			}
			
			if (position == 0)
				$(up.node).hide()
			else
				$(up.node).show()
				
			if (position + count >= names.length)
				$(down.node).hide()
			else
				$(down.node).show()

			for (var i = position; i < endPosition; i++)
			{
				var xCoord = cx + 50 + 50,
					yCoord = 14 + /*(height - 40) / length*/ legendCellHeight * (i - position) + 20,
					layerName = names[i],
					area = $('#' + chartId + 'dot_' + layerName + '_0')[0],
					opacity = area.style.display == 'none' ? 0.2 : 1,
					shownName = layerName.length > 12 ? layerName.substring(0, 12) + '...' : layerName;
				
				var txt = graph.text(xCoord - 20, yCoord + 5, shownName)
							.attr({fill: '#153069', stroke: "none", "font-family": '"Arial"',
									"font-size": "12px", "text-anchor": "start"});
				
				txt.node.setAttribute('id', chartId + 'legRect_' + layerName)
				
				var rect = graph.rect(xCoord - 45, yCoord, 20, 10)
									.attr({fill: layerColors[layerName], opacity: opacity, stroke: layerColors[layerName]});
				
				rect.node.setAttribute('id', chartId + 'legTxt_' + layerName)
									
				rect.node.style.cursor = "pointer";
				attachEvent(rect, layerName);
			}
		}
		
		$(up.node).mousedown(function()
		{
			if (curPosition == 0)
				return;
			
			for (var i = 0; i < layerNames.length; i++)
			{
				$('#' + chartId + 'legRect_' + layerNames[i]).remove();
				$('#' + chartId + 'legTxt_' + layerNames[i]).remove();
			}

			curPosition -= namesByPage;
			drawCurrentPage(curPosition, namesByPage, layerNames);
		})
		$(down.node).mousedown(function()
		{
			if (curPosition + namesByPage >= layerNames.length)
				return;
				
			for (var i = 0; i < layerNames.length; i++)
			{
				$('#' + chartId + 'legRect_' + layerNames[i]).remove();
				$('#' + chartId + 'legTxt_' + layerNames[i]).remove();
			}
			
			curPosition += namesByPage;
			drawCurrentPage(curPosition, namesByPage, layerNames);
		})
		
		drawCurrentPage(0, namesByPage, layerNames);
	}
}

Diagram.prototype.createBarsDiagram = function(parent, width, height, data, dataColumns, legendFlag, multipleFlag)
{
	var graph = this.draw(parent, width, height);
	
	this.resetColor();
	
	var chartId = String(Math.random()).substr(2,12),
		minValue = 0,
		maxValue = -Number.MAX_VALUE,
		layerNames = [],
		layerColors = {},
		curPosition = 0,
		legendCellHeight = 20,
		startColor = 0;
		
	for (var label in data)
	{
		layerNames.push(label);

		layerColors[label] = _diagram.getNextColor();

		for (var j = 0; j < data[label].length; j++)
		{
			if (data[label][j] > maxValue)
				maxValue = data[label][j];
		}
		
		startColor += 0.1 * (1 + Math.random());
		
		if (startColor > 1)
	    	startColor = 0.1 * (1 + Math.random());
	}
	
	var cx = width - 55 - (legendFlag > 0 ? 130 : 0),
		cy = height - 40,
		namesByPage = Math.floor((cy - 40) / legendCellHeight),
		scaleY = maxValue - minValue != 0 ? maxValue - minValue : 1;
	
	// оси
	graph.path(["M", 40, 10, "L", 40, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 2, opacity: 0.7});
	graph.path(["M", 40, cy + 10, "L", cx + 40, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 2, opacity: 0.7});
	
	// "красивые метки" на ось x
	var columnTextLengths = [];
	
	for (var i = 0; i < dataColumns.length; i++)
	{
		var strs = dataColumns[i].split("\n"),
			maxLen = strs[0].length;
		
		for (var j = 1; j < strs.length; j++)
			if (strs[j].length > maxLen)
				maxLen = strs[j].length;
		
		columnTextLengths.push(maxLen * 7)
	}
	
	var lastTextCoord = -1;
	
	for (var i = 0; i < dataColumns.length; i++)
	{
		var barWidth = 0.9 * cx / dataColumns.length,
			size = cx / dataColumns.length,
			currXCoord = 40 + size * i + size / 2 + 10;
		
		if (lastTextCoord < 0 || (currXCoord - lastTextCoord) > 10 + columnTextLengths[i] / 2)
		{
			graph.path(["M", currXCoord, 10, "L", currXCoord, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 1, opacity: 0.2});
			graph.text(currXCoord, cy + 25, String(dataColumns[i])).attr({"font": '12px "Arial"', stroke: "none", fill: "#153069", "text-anchor": "middle"});
			
			lastTextCoord = currXCoord + columnTextLengths[i] / 2;
		}
	}
	
	var yLabels = [],
		labelIndex = -1;;
	
	// "красивые метки" на ось y
	for (var i = 0; i < 13; i++)
	{
		yLabels.push(1 * Math.pow(10, i - 5));
		yLabels.push(2 * Math.pow(10, i - 5));
		yLabels.push(5 * Math.pow(10, i - 5));
	}
	
	for (var i = 0; i < yLabels.length; i++)
	{
		if (scaleY / yLabels[i] > cy / 200 &&
			scaleY / yLabels[i] < cy / 20)
		{
			labelIndex = i;
			
			break;
		}
	}
	
	if (labelIndex > 0)
	{
		var labelCount = Math.floor(scaleY / yLabels[labelIndex]),
			firstYLabel = (Math.floor(minValue / yLabels[labelIndex]) + 1) * yLabels[labelIndex];
		
		while (firstYLabel <= maxValue)
		{
			var yLabel = 10 + cy - cy * (firstYLabel - minValue) / scaleY;
		
			graph.path(["M", 40, yLabel, "L", cx + 40, yLabel]).attr({stroke: "#ABABAB", "stroke-width": 1, opacity: 0.2});
			graph.text(35, yLabel, String(firstYLabel)).attr({"font": '12px "Arial"', stroke: "none", fill: "#153069", "text-anchor": "end"});
			
			firstYLabel += yLabels[labelIndex]
		}
	}
	
	// сам график
	
	var	leaveTimer,
		isLabelVisible = false,
		process = function(i)
		{
			var barValues = [],
				size = cx / dataColumns.length;
			
			for (var label in data)
				barValues.push({label: label, value: data[label][i], color:layerColors[label]})
			
			if (!multipleFlag)	
				barValues = barValues.sort(function(a, b){return b.value - a.value});
			
			for (var j = 0; j < barValues.length; j++)
			{
				(function(i,j)
				{
					var barHeight = barValues[j].value / maxValue * cy,
						barWidth = multipleFlag ? Math.floor((0.9 * cx / dataColumns.length) / layerNames.length) : Math.floor(0.9 * cx / dataColumns.length),
						maxBarWidth = Math.floor(0.9 * cx / dataColumns.length),
						color = barValues[j].color,
						hsbFillColor = Raphael.rgb2hsb(color),
						xCoord = Math.floor(40 + size * i + size / 2 - maxBarWidth / 2 + 10 + (multipleFlag ? barWidth * j : 0)),
						yCoord =  cy + 10 - barHeight;
					
					var rect = graph.rect(xCoord, yCoord, barWidth, barHeight)
							.attr({stroke: Raphael.hsb2rgb(hsbFillColor.h, hsbFillColor.s, hsbFillColor.b * 0.75).hex, 'stroke-width': 1, fill : color, opacity: 1});
					
					rect.node.setAttribute('id',chartId + 'rect_' + barValues[j].label + '_' + i);

					rect.mouseover(function()
			        {
			            rect.attr("stroke", color);
			            
		                var newWidth = String(barValues[j].value).length * 7 + 12,
		                	newcoord = {x: xCoord + barWidth + 5, y: yCoord > 10 + cy - 24 ? 10 + cy - 24 : yCoord};
	            		
	            		if (newcoord.x + newWidth > cx + 40) 
	                		newcoord.x -= (newWidth + barWidth + 5);
						
						if (!$.browser.msie)
						{
				            clearTimeout(leaveTimer);
			                ttFrame.show().animate({x: newcoord.x, y: newcoord.y, width:newWidth}, 200 * isLabelVisible);
			                ttText.attr({text: String(barValues[j].value)}).show().animate({x: newcoord.x + 6, y: newcoord.y + 9}, 200 * isLabelVisible);
			                isLabelVisible = true;
			                graph.safari();
			            }
			            else
			            {
		   	               	ttFrame.show().attr({x: newcoord.x, y: newcoord.y, width:newWidth});
		                	ttText.show().attr({text: String(barValues[j].value),x: newcoord.x + 6, y: newcoord.y + 12});
			            }
			            
			        }).mouseout(function()
			        {
			            rect.attr("stroke", Raphael.hsb2rgb(hsbFillColor.h, hsbFillColor.s, hsbFillColor.b * 0.75).hex);
			            
			            if (!$.browser.msie)
						{
			                graph.safari();
			                leaveTimer = setTimeout(function ()
			                {
			                    ttFrame.hide();
			                    ttText.hide();
			                    isLabelVisible = false;
			                    graph.safari();
			                }, 1);
			            }
			            else
			            {
		            		ttFrame.hide();
		                    ttText.hide();
			            }
			        });
				})(i,j) 
			}
		},
		_this = this;
	
	var ttFrame = graph.rect(10, 10, 120, 20, 5).attr({fill: "#CBCBEA", stroke: "#ABABFA", "stroke-width": 2, opacity: 1}).hide(),
		ttText = graph.text(60, 10, String(minValue)).attr({"font": '12px "Arial"', stroke: "none", fill: "#FFF", "text-anchor": "start"}).hide();
	
	for (var i = 0; i < dataColumns.length; i++)
		process(i)
	
	ttFrame = graph.rect(10, 10, 120, 20, 5).attr({fill: "#CBCBEA", stroke: "#ABABFA", "stroke-width": 2, opacity: 1}).hide(),
	ttText = graph.text(60, 10, String(minValue)).attr({"font": '12px "Arial"', stroke: "none", fill: "#FFF", "text-anchor": "start"}).hide();
	
	// легенда
	if (legendFlag > 0)
	{
		var width = 130,
			height = Math.min(namesByPage, objLength(data)) * legendCellHeight + 40;
		
		graph.rect(cx + 50, 10, width, height, 5)
			.attr('fill','#FAFAFE')
			.attr('stroke','#BABABE')
			.attr('stroke-width',1);
		
		var up = graph.path(["M", cx + 50 + 5, 10 + 15, "L", cx + 50 + width - 5, 10 + 15, "L", cx + 50 + width / 2, 10 + 5, "L", cx + 50 + 5,  10 + 15,"Z"]).attr({fill: '#ABCDEF', opacity: 0.5}),
			down = graph.path(["M", cx + 50 + 5, 10 + height - 15, "L", cx + 50 + width - 5, 10 + height - 15, "L", cx + 50 + width / 2,  10 + height - 5, "L",cx + 50 + 5,  10 + height - 15, "Z"]).attr({fill: '#ABCDEF', opacity: 0.5});
		
		up.node.style.cursor = "pointer";
		down.node.style.cursor = "pointer";
		
		var drawCurrentPage = function(position, count, names)
		{
			var length = count,
				endPosition = (names.length < position + length) ? names.length : position + length;
			
			var attachEvent = function(elem, name)
			{
				$(elem.node).mousedown(function()
				{
					if (elem.attr('opacity') == 1)
					{
						for (var i = 0; i < dataColumns.length; i++)
						{
							var bar = $('#' + chartId + 'rect_' + name + '_' + i)[0];
							$(bar).hide();
						}
						
						$('#' + chartId + 'legRect_' + name).attr('fill','#999999');
						
						elem.attr('opacity', 0.2);
					}
					else
					{
						for (var i = 0; i < dataColumns.length; i++)
						{
							var bar = $('#' + chartId + 'rect_' + name + '_' + i)[0];
							$(bar).show();
						}
						
						$('#' + chartId + 'legRect_' + name).attr('fill','#153069');
						
						elem.attr('opacity', 1);
					}
				})
			}
			
			if (position == 0)
				$(up.node).hide()
			else
				$(up.node).show()
				
			if (position + count >= names.length)
				$(down.node).hide()
			else
				$(down.node).show()

			for (var i = position; i < endPosition; i++)
			{
				var xCoord = cx + 50 + 50,
					yCoord = 14 + legendCellHeight * (i - position) + 20,
					layerName = names[i],
					area = $('#' + chartId + 'rect_' + layerName + '_0')[0],
					opacity = area.style.display == 'none' ? 0.2 : 1,
					shownName = layerName.length > 12 ? layerName.substring(0, 12) + '...' : layerName;
				
				var txt = graph.text(xCoord - 20, yCoord + 5, shownName)
							.attr({fill: '#153069', stroke: "none", "font-family": '"Arial"',
									"font-size": "12px", "text-anchor": "start"});
				
				txt.node.setAttribute('id', chartId + 'legRect_' + layerName)
				
				var rect = graph.rect(xCoord - 45, yCoord, 20, 10)
									.attr({fill: layerColors[layerName], opacity: opacity, stroke: layerColors[layerName]});
				
				rect.node.setAttribute('id', chartId + 'legTxt_' + layerName)
									
				rect.node.style.cursor = "pointer";
				attachEvent(rect, layerName);
			}
		}
		
		$(up.node).mousedown(function()
		{
			if (curPosition == 0)
				return;
			
			for (var i = 0; i < layerNames.length; i++)
			{
				$('#' + chartId + 'legRect_' + layerNames[i]).remove();
				$('#' + chartId + 'legTxt_' + layerNames[i]).remove();
			}

			curPosition -= namesByPage;
			drawCurrentPage(curPosition, namesByPage, layerNames);
		})
		$(down.node).mousedown(function()
		{
			if (curPosition + namesByPage >= layerNames.length)
				return;
				
			for (var i = 0; i < layerNames.length; i++)
			{
				$('#' + chartId + 'legRect_' + layerNames[i]).remove();
				$('#' + chartId + 'legTxt_' + layerNames[i]).remove();
			}
			
			curPosition += namesByPage;
			drawCurrentPage(curPosition, namesByPage, layerNames);
		})
		
		drawCurrentPage(0, namesByPage, layerNames);
	}
}

Diagram.prototype.createBalloon = function(obj, htmlContent)
{
	if (this.oldBalloon)
		this.oldBalloon.remove();
	
	if (this.oldBalloonIndex == obj.objectId)
	{
		this.oldBalloonIndex = -1;
		
		this.oldBalloon = false;
		
		return false;
	}
	
	var coords = obj.getGeometry().coordinates,
		_this = this;
		
	this.oldBalloon = globalFlashMap.addBalloon();
	
	this.oldBalloon.setPoint(coords[0], coords[1]);
	
	_(this.oldBalloon.div, [htmlContent]);
	
	var remove = makeImageButton("img/close.png", "img/close_orange.png");
	remove.onclick = function()
	{
		_this.oldBalloon.remove();
		
		_this.oldBalloonIndex = -1;
		
		_this.oldBalloon = false;
	}
	
	remove.style.position = 'absolute';
	remove.style.right = '9px';
	remove.style.top = '5px';
	remove.style.cursor = 'pointer';
	
	_(this.oldBalloon.div, [remove])
	
	this.oldBalloon.resize();
	
	this.oldBalloonIndex = obj.objectId;
	
	return true;
}

Diagram.prototype.createDateTimeDiagramByAttrs = function(parent, width, height, attrs, regexp)
{
	var graphDataFunc;
	
	if (regexp.indexOf("%") > -1)
	{
		var replaceIndex = {},
			currReplaceIndex = 0;
		
		regexp = regexp.replace(/%y%y%y%y/, function(){currReplaceIndex++; replaceIndex['y'] = currReplaceIndex; return "(\\d\\d\\d\\d)"})
						.replace(/%m%m/, function(){currReplaceIndex++; replaceIndex['m'] = currReplaceIndex; return "(\\d\\d)"})
						.replace(/%d%d/, function(){currReplaceIndex++; replaceIndex['d'] = currReplaceIndex; return "(\\d\\d)"});
						
		graphDataFunc = function(x, reResult)
		{
			var year = reResult[replaceIndex['y']],
				month = reResult[replaceIndex['m']] - 1,
				date = reResult[replaceIndex['d']];
			
			return String(new Date(year, month, date).valueOf());
		};
	}
	else
		return false;
	
	var re = new RegExp(regexp),
		graphData = {};
	
	for (var prop in attrs)
	{
		var res = re.exec(prop);
		
		if (res && res.length == 4)
			graphData[graphDataFunc(prop, res)] = Number(attrs[prop]);
	}
	
	if (objLength(graphData) > 0)
	{
		_diagram.createDateTimeDiagram(parent, width, height, graphData);
		
		return true;
	}
	
	return false
}

Diagram.prototype.createDateTimeDiagramByAttrsText = function(width, height, attrs, regexp)
{
	var id = String(Math.random()).substr(2, 12),
		text = "<div style=\"width:" + width + "px;height:" + height + "px\">";
		
	text += "<div><div id=\"balloonGraph" + id + "\" style=\"width:" + width + "px;height:" + height + "px\"></div></div>";
	
	text += "<iframe src=\"blank.html\" onload=\"javascript:_diagram.createDateTimeDiagramByAttrs($$('balloonGraph" + id + "'), " + width + ", " + height + ", " + JSON.stringify(attrs).replace(/\"/g, "'") + ", '" + regexp + "')\" style=\"display:none\"/>";
	
	text += "</div>";
	
	return text;
}

Diagram.prototype.createPieDiagramByAttrs = function(parent, width, height, attrs, regexp)
{
	var graphDataFunc;
	
	if (regexp.indexOf("%") > -1)
	{
		var replaceIndex = {},
			currReplaceIndex = 0;
		
		regexp = regexp.replace(/%y%y%y%y/, function(){currReplaceIndex++; replaceIndex['y'] = currReplaceIndex; return "(\\d\\d\\d\\d)"})
						.replace(/%m%m/, function(){currReplaceIndex++; replaceIndex['m'] = currReplaceIndex; return "(\\d\\d)"})
						.replace(/%d%d/, function(){currReplaceIndex++; replaceIndex['d'] = currReplaceIndex; return "(\\d\\d)"});
						
		graphDataFunc = function(x, reResult)
		{
			var year = reResult[replaceIndex['y']],
				month = reResult[replaceIndex['m']] - 1,
				date = reResult[replaceIndex['d']];
			
			return stringDate(new Date(year, month, date).valueOf());
		};
	}
	
	var re = new RegExp(regexp),
		graphData = {};
	
	for (var prop in attrs)
	{
		var res = re.exec(prop);
		
		if (res)
		{
			if (res.length == 4)
				graphData[graphDataFunc(prop, res)] = Number(attrs[prop]);
			else
				graphData[prop] = Number(attrs[prop]);
		}
	}
	
	if (objLength(graphData) > 0)
	{
		_diagram.createPieDiagram(parent, width, height, graphData);
		
		return true;
	}
	
	return false
}

Diagram.prototype.createPieDiagramByAttrsText = function(width, height, attrs, regexp)
{
	var id = String(Math.random()).substr(2, 12),
		text = "<div style=\"width:" + width + "px;height:" + height + "px\">";
		
	text += "<div><div id=\"balloonGraph" + id + "\" style=\"width:" + width + "px;height:" + height + "px\"></div></div>";
	
	text += "<iframe src=\"blank.html\" onload=\"javascript:_diagram.createPieDiagramByAttrs($$('balloonGraph" + id + "'), " + width + ", " + height + ", " + JSON.stringify(attrs).replace(/\"/g, "'") + ", '" + regexp + "')\" style=\"display:none\"/>";
	
	text += "</div>";
	
	return text;
}

/*
	layersFilters :
	{
		'layerName1' : 'regexp1',
		'layerName2' : 'regexp2',
		...
	}
*/
Diagram.prototype.createMultiLinesDiagramText = function(width, height, data, dataColumns, legendFlag)
{
	var id = String(Math.random()).substr(2, 12),
		text = "<div style=\"width:" + width + "px;height:" + height + "px\">";
		
	text += "<div><div id=\"balloonGraph" + id + "\" style=\"width:" + width + "px;height:" + height + "px\"></div></div>";
	
	text += "<iframe src=\"blank.html\" onload=\"javascript:_diagram.createMultiLinesDiagram($$('balloonGraph" + id + "'), " + width + ", " + height + ", " + JSON.stringify(data).replace(/\"/g, "'") + ", " + JSON.stringify(dataColumns).replace(/\"/g, "'") + ", " + legendFlag + ")\" style=\"display:none\"/>";
	
	text += "</div>";
	
	return text;
}

Diagram.prototype.createBarsDiagramText = function(width, height, data, dataColumns, legendFlag, multipleFlag)
{
	var id = String(Math.random()).substr(2, 12),
		text = "<div style=\"width:" + width + "px;height:" + height + "px\">";
		
	text += "<div><div id=\"balloonGraph" + id + "\" style=\"width:" + width + "px;height:" + height + "px\"></div></div>";
	
	text += "<iframe src=\"blank.html\" onload=\"javascript:_diagram.createBarsDiagram($$('balloonGraph" + id + "'), " + width + ", " + height + ", " + JSON.stringify(data).replace(/\"/g, "'") + ", " + JSON.stringify(dataColumns).replace(/\"/g, "'") + ", " + legendFlag + ", " + multipleFlag + ")\" style=\"display:none\"/>";
	
	text += "</div>";
	
	return text;
}


var _diagram = new Diagram();

/*
var data = {'label1':[3,4,-1,2,3], 'label2': [2,-2,1,4,1],'label3':[1, -1, 3,3,4],'label4':[-2,4,1,-2,1],'label5':[1,0,-1,1,1],'label6':[-4,2,1,6,2],'label7':[-3,-2,5,1,-2],'label8':[-1,-3,4,1,0],'label9':[1,2,-5,-4,5],'label10':[1,1,-3,4,4],'label11':[0,0,-3,3,1]}
var dataColumns = ['Октябрь\n2009','Ноябрь\n2009','Декабрь\n2009','Январь\n2010','Февраль\n2010']

var div = _div()
showDialog("Graphics", div, 640, 340, false, false)

_diagram.createMultiLinesDiagram(div, 600, 300, data, dataColumns, 5)
*/

/*
function(map)
{
	var layer = map.layers["9A38F34E16FF446DA667FFAA55117C22"];

	layer.filters[0].enableHoverBalloon(function(o)
	{
		return _diagram.createDateTimeDiagramByAttrsText(500,300,o.properties,'D%y%y%y%y%m%m%d%d')
	});
	
	layer.filters[1].enableHoverBalloon(function(o)
	{
		var props = {};
			
		$.extend(props, o.properties);
		
		for (var name in props)
			if (!/D(1993)/.test(name))
				delete props[name];
			
		return _diagram.createPieDiagramByAttrsText(300,300,props,'D%y%y%y%y%m%m%d%d')
	});
	
	layer.filters[2].enableHoverBalloon(function(o)
	{
		var dataColumns = ['1992','1993','1995','1996','1997','1999','2000'],
			data = {'Слой1': [], 'Слой2': []};
		
		for (var i = 0; i < dataColumns.length; i++)
		{
			data['Слой1'].push(Number(o.properties['V_' + String(dataColumns[i])]));
			data['Слой2'].push(Number(o.properties['VSTD_' + String(dataColumns[i])]));
		}
		
		return _diagram.createMultiLinesDiagramText(500,300,data,dataColumns,1);
	});
	
	layer.filters[3].enableHoverBalloon(function(o)
	{
		var dataColumns = ['1995','1996','1997','1999','2000'],
			data = {'Слой1': [], 'Слой2': []};
		
		for (var i = 0; i < dataColumns.length; i++)
		{
			data['Слой1'].push(50 + Number(o.properties['V_' + String(dataColumns[i])]));
			data['Слой2'].push(50 + Number(o.properties['VSTD_' + String(dataColumns[i])]));
		}
		
		return _diagram.createBarsDiagramText(500,300,data,dataColumns,1,0);
	});
	
	layer.filters[4].enableHoverBalloon(function(o)
	{
		var dataColumns = ['1995','1996','1997','1999','2000'],
			data = {'Слой1': [], 'Слой2': []};
		
		for (var i = 0; i < dataColumns.length; i++)
		{
			data['Слой1'].push(50 + Number(o.properties['V_' + String(dataColumns[i])]));
			data['Слой2'].push(50 + Number(o.properties['VSTD_' + String(dataColumns[i])]));
		}
		
		return _diagram.createBarsDiagramText(500,300,data,dataColumns,1,1);
	});
	
	layer.filters[5].enableHoverBalloon(function(o)
	{
		var dataColumns = ['1992','1993','1995','1996'],
			data = {'Слой1': [], 'Слой2': []};
		
		for (var i = 0; i < dataColumns.length; i++)
		{
			data['Слой1'].push(50 + Number(o.properties['V_' + String(dataColumns[i])]));
			data['Слой2'].push(50 + Number(o.properties['VSTD_' + String(dataColumns[i])]));
		}
		
		return _diagram.createBarsDiagramText(400,300,data,dataColumns,0,1);
	});
}
*/


!(function(_) {
var KML = {
	KML: {}
}

var queryKML = function()
{
	this.parentCanvas = null;
    this._loadedKML = [];
    this._uniqueID = 0;
}

queryKML.prototype = new leftMenu();

queryKML.prototype.newID = function()
{
    var newID = "id" + this._uniqueID;
    this._uniqueID++;
    return newID;
}

queryKML.prototype.load = function()
{
	var inputField = _input(null, [['dir','className','inputStyle'],['css','width','200px']]),
		_this = this;
	
	this.parentCanvas = _div(null, [['dir','className','drawingObjectsCanvas']]);
	
	var goButton = makeButton(_gtxt("Загрузить")),
		_this = this;
	
	goButton.onclick = function()
	{
		if (inputField.value != '')
		{
			if (!nsGmx.AuthManager.isLogin())
			{
				nsGmx.widgets.authWidget.showLoginDialog();
				
				return;
			}
            
			var kmlURL = strip(inputField.value);
			gmxAPI._kmlParser.get(kmlURL, function(resp)
			{
				var info = gmxAPI._kmlParser.draw(resp.vals, globalFlashMap.addObject());
				
                var kmlInfo = {
                    id: _this.newID(), 
                    url: kmlURL, 
                    name: resp.name,
                    isVisible: true
                };
                _this._loadedKML.push(kmlInfo);
                
				_this.addFile(info, resp.name, true, kmlInfo.id);
			})
				
			inputField.value = '';
		}
		else
			inputError(inputField);
	}
	
	$(inputField).on('keydown', function(e)
	{
		if (e.keyCode === 13)
	  	{	
			if (inputField.value != '')
			{
				if (!nsGmx.AuthManager.isLogin())
				{
					nsGmx.widgets.authWidget.showLoginDialog();
					
					return;
				}
				
                var kmlURL = strip(inputField.value);
				gmxAPI._kmlParser.get(kmlURL, function(resp)
				{
					var info = gmxAPI._kmlParser.draw(resp.vals, globalFlashMap.addObject());
				
                    var kmlInfo = {
                        id: _this.newID(), 
                        url: kmlURL, 
                        name: resp.name,
                        isVisible: true
                    };
                    _this._loadedKML.push(kmlInfo);
					_this.addFile(info, resp.name, true, kmlInfo.id);
				})
					
				inputField.value = '';
			}
			else
				inputError(inputField);
	  		
	  		return false;
	  	}
	})
	
    
    
	var canvas = _div([_div([_span([_t(_gtxt("URL файла"))])], [['css','marginBottom','3px']]),_table([_tbody([_tr([_td([inputField],[['css','width','220px']]),_td([goButton])])])], [['css','marginBottom','5px']])],[['css','margin','3px 0px 0px 10px']])

	var attach = _input(null,[['attr','type','file'],['dir','name','rawdata'],['css','width','220px']]);
    var formFile = _form([attach], [['attr', 'method', 'POST'], ['attr', 'encoding', 'multipart/form-data'], ['attr', 'enctype', 'multipart/form-data'], ['attr', 'id', 'upload_shapefile_form']]);
    formFile.style.width = '200px';
	formFile.style.marginLeft = '3px';
	
	var loadButton = makeButton(_gtxt("Загрузить"));
	loadButton.onclick = function()
	{
        //если пользователь может загружать файлы и сохранять карту, то будем загружать KML к нему на диск и хранить в карте её адрес
        //иначе просто прокачаем через наш сервер без сохранения
		if (nsGmx.AuthManager.canDoAction(nsGmx.ACTION_UPLOAD_FILES) && nsGmx.AuthManager.canDoAction(nsGmx.ACTION_SAVE_MAP) && _queryMapLayers.currentMapRights() === "edit")
		{
        
            var shareKMLFolder = nsGmx.AuthManager.getUserFolder() + "\\share\\kml";
            sendCrossDomainJSONRequest(serverBase + 'FileBrowser/CreateFolder.ashx?WrapStyle=func&FullName=' + shareKMLFolder, function(response)
            {
                if (!parseResponse(response))
                    return;
                    
                var randomFilename = String(Math.random()).slice(2) + '.kml';
                sendCrossDomainPostRequest(serverBase + "FileBrowser/Upload.ashx", {WrapStyle: "window", ParentDir: shareKMLFolder, name: randomFilename}, function(response)
                {
                    var kmlURL = serverBase + "GetFile.ashx?nickname=" + encodeURIComponent(nsGmx.AuthManager.getNickname()) + "&file=" + encodeURIComponent("kml\\" + randomFilename);
                    sendCrossDomainJSONRequest(serverBase + 'ApiSave.ashx?get=' + encodeURIComponent(kmlURL), function(response)
                    {
                        if (!parseResponse(response))
                            return;
                        
                        var resp = gmxAPI._kmlParser.parse(response.Result);

                        var info = gmxAPI._kmlParser.draw(resp.vals, globalFlashMap.addObject());
                        
                        var kmlInfo = {
                            id: _this.newID(), 
                            url: kmlURL, 
                            name: resp.name,
                            isVisible: true
                        };
                        _this._loadedKML.push(kmlInfo);
                        _this.addFile(info, resp.name, true, kmlInfo.id);
                    });
                }, formFile)
            })
        }
        else
        {
            sendCrossDomainPostRequest(serverBase + "ApiSave.ashx", {WrapStyle: "window"}, function(response)
            {
                if (!parseResponse(response))
                    return;
                
                var resp = gmxAPI._kmlParser.parse(response.Result);

                var info = gmxAPI._kmlParser.draw(resp.vals, globalFlashMap.addObject());
                
                _this.addFile(info, resp.name, true)
            }, formFile);
        }
	}
	
	_(this.workCanvas, [canvas, _table([_tbody([_tr([_td([formFile],[['css','width','220px']]), _td([loadButton])])])],[['css','margin','5px 0px 10px 10px']]), this.parentCanvas])
}

queryKML.prototype.addFile = function(info, name, isVisible, kmlID)
{
	var canvas = _div(null, [['dir','className','canvas']]),
		title = makeLinkButton(name.length > 45 ? name.substr(0, 45) + '...' : name),
		remove = makeImageButton('img/closemin.png','img/close_orange.png'),
		box = _checkbox(isVisible, 'checkbox'),
		_this = this;
	
	_title(title, name);
    info.parent.setVisible(isVisible);
	
	box.onclick = function()
	{
		info.parent.setVisible(this.checked);
        
        for (var k = 0; k < _this._loadedKML.length; k++)
            if (_this._loadedKML[k].id == kmlID)
            {
                _this._loadedKML[k].isVisible = this.checked;
                break;
            }
	}
	
	title.onclick = function()
	{
		info.parent.setVisible(true);
		
		globalFlashMap.zoomToExtent(info.bounds.minX, info.bounds.minY, info.bounds.maxX, info.bounds.maxY);
		
		box.checked = true;
	}
	
	title.style.marginLeft = '5px';
	
	remove.onclick = function()
	{
		info.parent.remove();
        
        if (typeof kmlID !== 'undefined')
        {
            for (var k = 0; k < _this._loadedKML.length; k++)
                if (_this._loadedKML[k].id == kmlID)
                {
                    _this._loadedKML.splice(k, 1);
                    break;
                }
        }
		
		canvas.removeNode(true);
	}
	
	remove.className = 'remove';
	
	_(canvas, [_div([box, title], [['dir','className','item']]), remove])
	
	_(this.parentCanvas, [canvas]);
}

var _queryKML = new queryKML();

KML.KML.load = function()
{
	var alreadyLoaded = _queryKML.createWorkCanvas(arguments[0]);
	
	if (!alreadyLoaded)
		_queryKML.load()
}

KML.KML.unload = function()
{
}

nsGmx.userObjectsManager.addDataCollector('kml', {
    collect: function()
    {
        if (_queryKML.parentCanvas == null || _queryKML._loadedKML.length == 0)
            return null;
            
        var res = [];
        for (var k = 0; k < _queryKML._loadedKML.length; k++)
            res.push({url: _queryKML._loadedKML[k].url, isVisible: _queryKML._loadedKML[k].isVisible});
            
        return res;
    },
    
    load: function(data)
    {
        if (!data)
            return;
        
        KML.KML.load('kml');
        
        _queryKML._loadedKML = [];
        var loadedCount = 0;
        var allInfo = [];
        
        var showKML = function()
        {
            for (var k = 0; k < _queryKML._loadedKML.length; k++)
                _queryKML.addFile(allInfo[k], _queryKML._loadedKML[k].name, _queryKML._loadedKML[k].isVisible, _queryKML._loadedKML[k].id);
        }
        
        for (var k = 0; k < data.length; k++)
        (function(curKMLData, index)
        {
            gmxAPI._kmlParser.get(curKMLData.url, function(resp)
			{
				var info = gmxAPI._kmlParser.draw(resp.vals, globalFlashMap.addObject());
				
                _queryKML._loadedKML[index] = {id: _queryKML.newID(), url: curKMLData.url, name: resp.name, isVisible: curKMLData.isVisible};
                allInfo[index] = info;
                
                loadedCount++;
                
                //когда всё загрузили, можно показать пользователям
                if (loadedCount == data.length)
                    showKML();
			})
        })(data[k], k)
    }
});

window.KML = KML;
window.queryKML = queryKML;
window._queryKML = _queryKML;

})(nsGmx.Utils._);
var nsGmx = nsGmx || {};

(function() {

'use strict';

var SHARE_TYPES = ['public', 'private'];

nsGmx.Translations.addText('rus', {security: {
    ownerName: 'Владелец',
    defAccess: 'Доступ для всех',
    access: {
        empty: ' ',
        no: 'нет доступа',
        view: 'просмотр',
        linkview: 'просмотр по ссылке',
        edit: 'редактирование',
        editrows: 'редактирование объектов',
        preview: 'предпросмотр'
    },
    share: {
        'public': 'публичный',
        'private': 'частный'
    },
    addHeaderLabel: 'Введите пользователя или группу',
    addOkText: 'Добавить',
    select: {
        'selectedLayers': 'Выделено слоев для назначения прав: '
    }
}});

nsGmx.Translations.addText('eng', {security: {
    ownerName: 'Owner',
    defAccess: 'Public access',
    access: {
        empty: ' ',
        no: 'no access',
        view: 'view only',
        linkview: 'direct link view only',
        edit: 'edit',
        editrows: 'edit objects',
        preview: 'preview'
    },
    share: {
        'public': 'public',
        'private': 'private'
    },
    addHeaderLabel: 'Enter user or group',
    addOkText: 'Add',
    select: {
        'selectedLayers': 'Selected'
    }
}});

var usersHash = {};

var autocompleteLabelTemplate = Handlebars.compile(
    '<a class="security-autocomplete-item">' +
    '{{#if showIcon}}<span class="{{#if IsGroup}}security-group-icon{{else}}security-user-icon{{/if}}"></span>{{/if}}' +
        '<span>{{Nickname}}{{#if Login}}\u00A0({{Login}}){{/if}}</span>' +
    '</a>'
);

//на input вешается autocomplete со списком пользователей.
//кроме того, по нажатию enter происходит генерация события enterpress
var wrapUserListInput = function(input, options) {
    input.on('keydown', function(event) {
        if (event.keyCode === 13) {
            //setTimeout нужен чтобы autocomplete не дописывал выбранное значение в input после того, как мы его очистим
            setTimeout(function() {
                $(this).trigger('enterpress');
            }.bind(this), 0);
        }
    });
    input.autocomplete({
        source: function(request, cbResponse) {
            security.findUsers(request.term, {maxRecords: 7, type: options && options.type}).then(function(userInfos) {
                cbResponse(userInfos.map(function(userInfo) {
                    usersHash[userInfo.Nickname] = userInfo;
                    return {value: userInfo.Nickname, label: ''};
                }));
            }, cbResponse.bind(null, []));
        }
    });

    $(input).data("ui-autocomplete")._renderItem = function(ul, item) {
        var userInfo = usersHash[item.value],
            templateParams = $.extend({showIcon: options && options.showIcon}, userInfo);
        return $('<li></li>')
            .append($(autocompleteLabelTemplate(templateParams)))
            .appendTo(ul);
    }
}

var SecurityOwnerWidget = function(securityInfo, container) {
    var ui = $(SecurityOwnerWidget._template({
        ownerName: securityInfo.Owner
    })).appendTo(container);

    $('.security-owner-cancel', ui).click(function() {
        $('.changeOwnerLink', ui).click();
    });

    $('.changeOwnerLink', ui).click(function() {
        $(this).toggle();
        $('.security-owner-container', ui).toggle();
        $('.security-owner-input', ui).val('').focus();
    });

    var ownerAddInput = $('.security-owner-input', ui);
    ownerAddInput.on('enterpress', function() {
        $('.security-owner-ok', ui).click();
    });

    wrapUserListInput(ownerAddInput, {type: 'User'});

    $('.security-owner-ok', ui).click(function() {
        var input = $('.security-owner-input', ui),
            name = input.val();

        var doChangeUser = function(user) {
            $('.changeOwnerLink', ui).text(user.Nickname);
            securityInfo.NewOwnerID = user.UserID;
            $('.changeOwnerLink', ui).click();
        }

        if (name in usersHash) {
            doChangeUser(usersHash[name]);
        } else {
            security.findUsers(name, {maxRecords: 1}).then(function(userInfos) {
                if (userInfos[0] && userInfos[0].Nickname.toLowerCase() === name.toLowerCase()) {
                    doChangeUser(userInfos[0]);
                } else {
                    inputError(input[0]);
                }
            }, inputError.bind(null, input[0]));
        }
    });
}

SecurityOwnerWidget._template = Handlebars.compile(
    '<div class = security-owner>' +
        '<span>{{i "security.ownerName"}}: </span>' +
        '<span class="buttonLink changeOwnerLink security-owner-change">{{ownerName}}</span>' +
        '<div class="security-owner-container ui-front" style="display:none">' +
            '<input class="security-owner-input inputStyle">' +
            '<button class="security-owner-ok">Сменить</button>' +
            '<button class="security-owner-cancel">Отмена</button>' +
        '</div>' +
    '</div>');

// @param {String[]} options.accessTypes массив прав доступа
var SecurityUserListWidget = function(securityInfo, container, options) {
    var _this = this;

    this.options = options;

    var ui = $(SecurityUserListWidget._template()).appendTo(container);

    var sortFuncs = {};

    var genSortFunction = function(field)
    {
        return [
            function(a,b){if (a[field] > b[field]) return 1; else if (a[field] < b[field]) return -1; else return 0},
            function(a,b){if (a[field] < b[field]) return 1; else if (a[field] > b[field]) return -1; else return 0}
        ];
    }

    sortFuncs[_gtxt('Псевдоним')]  = genSortFunction('Nickname');
    sortFuncs[_gtxt('Полное имя')] = genSortFunction('FullName');
    sortFuncs[_gtxt('Доступ')]     = genSortFunction('Access');

    var fieldNames   = [_gtxt("Псевдоним"), _gtxt("Полное имя"), /*_gtxt("Роль"),*/ _gtxt("Доступ"), ""];
    var fieldWidthes = ['35%', '35%', '25%','5%'];

    this._securityTable = new nsGmx.ScrollTable({limit: 500, showFooter: false});
    this.securityUsersProvider = new nsGmx.ScrollTable.StaticDataProvider();

    this.securityUsersProvider.setSortFunctions(sortFuncs);
    this._securityTable.setDataProvider(this.securityUsersProvider);
    this._securityTable.createTable($('.access-table-placeholder', ui)[0], 'securityTable', 0, fieldNames, fieldWidthes, function(arg){
        return SecurityUserListWidget._drawMapUsers.call(this, arg, _this);
    }, sortFuncs);

    var addInput = $('.security-add-input', ui);
    addInput.on('enterpress', function() {
        $('.security-add-ok', ui).click();
    })
    wrapUserListInput(addInput, {showIcon: true});

    $('.security-add-ok', ui).click(function() {
        var input = $('.security-add-input', ui),
            name = input.val();

        var addedUsers = _this.securityUsersProvider.getOriginalItems();
        if (_.findWhere(addedUsers, {Nickname: name})) {
            inputError(input[0]);
            return;
        }

        var doAddUser = function(user) {
            _this._addMapUser(user);
            input.val('').focus();
        }

        if (name in usersHash) {
            doAddUser(usersHash[name]);
        } else {
            security.findUsers(name, {maxRecords: 1}).then(function(userInfos) {
                //TODO: обработать ситуацию, когда пользователь вводит email
                if (userInfos[0] && userInfos[0].Nickname.toLowerCase() === name.toLowerCase()) {
                    doAddUser(userInfos[0]);
                } else {
                    inputError(input[0]);
                }
            }, inputError.bind(null, input[0]));
        }
    });

    this.securityUsersProvider.setOriginalItems( securityInfo.Users );
}

SecurityUserListWidget.DEFAULT_ACCESS = 'view';

SecurityUserListWidget.prototype._addMapUser = function(user) {
    var existedUser = $.extend( {Access: SecurityUserListWidget.DEFAULT_ACCESS}, user );
    this.securityUsersProvider.addOriginalItem(existedUser);
}

SecurityUserListWidget.prototype.updateHeight = function(height) {
    this._securityTable.updateHeight(height);
}

SecurityUserListWidget._userRowTemplate = Handlebars.compile(
    '<tr>' +
        '<td class="security-row-nickname">' +
            '<span class="{{#if IsGroup}}security-group-icon{{else}}security-user-icon{{/if}}"></span>' +
            '<span title="{{Nickname}}">{{Nickname}}</span>' +
        '</td>' +
        '<td><div class="security-row-fullname" title="{{Fullname}}">{{Fullname}}</div></td>' +
        '<td><select class="selectStyle security-row-access">{{#access}}' +
            '<option value = "{{value}}"{{#if selected}} selected{{/if}}>{{title}}</option>' +
        '{{/access}}</select></td>' +
        '<td class="security-row-remove-cell"><div class="gmx-icon-recycle"></div></td>' +
    '</tr>'
);

SecurityUserListWidget._drawMapUsers = function(user, securityScope)
{
    var ui = $(SecurityUserListWidget._userRowTemplate({
        Nickname: user.Nickname,
        Fullname: user[user.IsGroup ? 'Description' : 'FullName'],
        IsGroup: user.IsGroup,
        access: securityScope.options.accessTypes
            .filter(function(type) {return type !== 'no';})
            .map(function(type) {
                return {
                    title: _gtxt('security.access.' + type),
                    value: type,
                    selected: type === user.Access
                }
            })
    }));

    var tr = ui[0];

    ui.find('.gmx-icon-recycle').click(function() {
        // уберем пользователя из списка
        securityScope.securityUsersProvider.filterOriginalItems(function(elem) {
            return elem.Nickname !== user.Nickname;
        });
    });

    ui.find('.security-row-access').change(function() {
        user.Access = this.value;
    });

    for (var i = 0; i < tr.childNodes.length; i++)
        tr.childNodes[i].style.width = this._fields[i].width;

    attachEffects(tr, 'hover');

    return tr;
}

SecurityUserListWidget._template = Handlebars.compile(
    '<div class = "security-userlist">' +
        '<div class="security-add-container ui-front">' +
            '<span class="security-access-label">{{i "security.addHeaderLabel"}}: </span>' +
            '<input class="security-add-input inputStyle">' +
            '<button class="security-add-ok">{{i "security.addOkText"}}</button>' +
        '</div>' +
        '<div class="access-table-placeholder"></div>' +
    '</div>');


var security = function()
{
    this.mapTypeSel = null;
    this.mapAccessSel = null;

    this.defaultAccess = null;

    this.getSecurityName = null;
    this.updateSecurityName = null;

    this.propertyValue = null;
    this.title = null;
}

var mapSecurity = function()
{
    this.getSecurityName = "Map/GetSecurity.ashx";
    this.updateSecurityName = "Map/UpdateSecurity.ashx";

    this.propertyName = "MapID";
    this.dialogTitle = "Редактирование прав доступа карты [value0]";

    this.accessTypes = ['no', 'view', 'linkview', 'edit'];
}

mapSecurity.prototype = new security();
mapSecurity.prototype.constructor = mapSecurity;

var layerSecurity = function(layerType)
{
    this.getSecurityName = "Layer/GetSecurity.ashx";
    this.updateSecurityName = "Layer/UpdateSecurity.ashx";

    this.propertyName = "LayerID";
    this.dialogTitle = "Редактирование прав доступа слоя [value0]";

    this.accessTypes = layerType === 'Raster' ? ['no', 'preview', 'view', 'edit'] : ['no', 'preview', 'view', 'editrows', 'edit'];
}

layerSecurity.prototype = new security();
layerSecurity.prototype.constructor = layerSecurity;

var multiLayerSecurity = function()
{
    this.getSecurityName = 'MultiLayer/GetSecurity.ashx';
    this.updateSecurityName = 'MultiLayer/UpdateSecurity.ashx';

    this.propertyName = 'MultiLayerID';
    this.dialogTitle = 'Редактирование прав доступа слоя [value0]';

    this.accessTypes = ['no', 'view', 'edit'];
}

multiLayerSecurity.prototype = new security();
multiLayerSecurity.prototype.constructor = multiLayerSecurity;

var layersGroupSecurity = function()
{
    this.getSecurityName = 'Map/GetSecurity.ashx';
    this.getGroupSecurityName = 'Layer/GetSecurity.ashx';
    this.updateSecurityName = 'Layer/LayersGroupUpdateSecurity';

    this.propertyName = 'MapID';
    this.groupPropertyName = 'Layers';

    this.mapLayers = [];
    this.mapLayersSecurityArray = [];
    this.selectedLayersSecurityArray = [];
    this.originalItems = [];

    this.dialogTitle = 'Редактирование прав доступа слоев карты [value0]';

    this.accessTypes = ['no', 'view', 'edit'];
}

layersGroupSecurity.prototype = new security();
layersGroupSecurity.prototype.constructor = layersGroupSecurity;

security.prototype.getSecurityFromServer = function(id) {
    var def = $.Deferred();

    sendCrossDomainJSONRequest(serverBase + this.getSecurityName + '?WrapStyle=func&IncludeAdmin=true&' + this.propertyName + '=' + id, function(response)
    {
        if (!parseResponse(response)) {
            def.reject(response);
            return;
        }
        def.resolve(response.Result);
    })

    return def;
}

// запрос security группы слоев
security.prototype.getGroupSecurityFromServer = function(postParams) {
    var def = $.Deferred();

    sendCrossDomainPostRequest(serverBase + this.getGroupSecurityName, postParams, function(response) {
        if (!parseResponse(response)) {
            def.reject(response);
            return;
        }
        def.resolve(response.Result);
    })

    return def;
}

security.prototype.getRights = function(value, title)
{
    var _this = this;

    this.propertyValue = value;
    this.title = title;

    this.getSecurityFromServer(value).then(this.createSecurityDialog.bind(this));
}

//ф-ция выделена из-за различий между диалогами прав слоёв и диалога состава группы
security.prototype.addCustomUI = function(ui, securityInfo) {
    var defAccessTemplate = Handlebars.compile(
        '<div class="security-def-access">{{i "security.defAccess"}}: ' +
            '<select class="security-defaccess-select selectStyle">' +
                '{{#defAccessTypes}}' +
                    '<option value="{{value}}"{{#isSelected}} selected{{/isSelected}}>{{title}}</option>' +
                '{{/defAccessTypes}}' +
            '</select>' +
        '</div>'
    );

    $(defAccessTemplate({
        defAccessTypes: this.accessTypes.map(function(type) {
            return {
                value: type,
                title: _gtxt('security.access.' + type),
                isSelected: type === securityInfo.SecurityInfo.DefAccess
            };
        })
    })).appendTo(ui.find('.security-custom-ui'));
}

//ф-ция выделена из-за различий между диалогами прав слоёв и диалога состава группы
security.prototype.saveCustomParams = function() {
    this._securityInfo.SecurityInfo.DefAccess = this._ui.find('.security-defaccess-select').val();
}

security.prototype._save = function() {
    var si = this._securityInfo;
    si.SecurityInfo.Users = this.securityUserListWidget.securityUsersProvider.getOriginalItems();

    nsGmx.widgets.notifications.startAction('securitySave');
    var postParams = {WrapStyle: 'window'};

    if (this.saveCustomParams()) {
        return;
    }

    postParams.SecurityInfo = JSON.stringify(si.SecurityInfo);

    postParams[this.propertyName] = this.propertyValue;
    sendCrossDomainPostRequest(serverBase + this.updateSecurityName, postParams, function(response) {
        if (!parseResponse(response)) {
            nsGmx.widgets.notifications.stopAction('securitySave');
            return;
        }

        nsGmx.widgets.notifications.stopAction('securitySave', 'success', _gtxt('Сохранено'));

        $(this).trigger('savedone', si);
    })
}

security.prototype.createSecurityDialog = function(securityInfo, options)
{
    options = $.extend({showOwner: true}, options);
    var _this = this;

    this._securityInfo = securityInfo;

    var uiTemplate = '<div id="securityDialog" class="security-canvas">' +
        '<div class="security-header">' +
            '<button class="security-save">{{i "Сохранить"}}</button>' +
                '{{#if showOwner}}<div class="security-owner-placeholder"></div>{{/if}}' +
        '</div>' +

        '<div class="security-custom-ui"></div>' +

        '<div class="security-userlist-placeholder"></div>' +
    '</div>';

    var canvas = this._ui = $(Handlebars.compile(uiTemplate)({
        showOwner: options.showOwner
    }));

    this.addCustomUI(canvas, securityInfo);

    $('.security-save', canvas).click(function(){
        _this._save();
    });

    if (options.showOwner) {
        new SecurityOwnerWidget(securityInfo.SecurityInfo, $('.security-owner-placeholder', canvas));
    }

    this.securityUserListWidget = new SecurityUserListWidget(securityInfo.SecurityInfo, $('.security-userlist-placeholder', canvas), {accessTypes: this.accessTypes});

    var resize = function()
    {
        var mapTableHeight;
        var dialogWidth = canvas[0].parentNode.parentNode.offsetWidth;

        var nonTableHeight =
            $('.security-header', canvas).height() +
            $('.security-custom-ui', canvas).height() +
            $('.security-add-container', canvas).height() + 15;

        mapTableHeight = canvas[0].parentNode.offsetHeight - nonTableHeight - 10;

        _this.securityUserListWidget.updateHeight(mapTableHeight);
    }

    this._dialogDiv = showDialog(_gtxt(this.dialogTitle, this.title), canvas[0], 571, 370, false, false, resize);

    resize();
}

//делает запрос на сервер и возвращает список пользователей по запросу query
//options = {maxRecords, type}; type: All / User / Group
security.findUsers = function(query, options) {
    var def = new L.gmx.Deferred();
    var maxRecordsParamStr = options && options.maxRecords ? '&maxRecords=' + options.maxRecords : '';
    var typeParamStr = '&type=' + (options && options.type || 'All');
    sendCrossDomainJSONRequest(serverBase + 'User/FindUser?query=' + encodeURIComponent(query) + maxRecordsParamStr + typeParamStr, function(response) {
        if (!parseResponse(response)) {
            def.reject(response);
            return;
        }

        def.resolve(response.Result);
    })

    return def;
}


layersGroupSecurity.prototype._save = function(originalItems) {
    var _this = this;

    if (!_this.selectedLayersSecurityArray.length) {
        return;
    }

    var si = _this._securityInfo,
        addedUsers = _this.securityUserListWidget.securityUsersProvider.getOriginalItems();

    si.SecurityInfo = {
        // Users: [],
        UsersAdd: addedUsers,
        UsersRemove: findRemovedUsers(originalItems, addedUsers)
    };

    nsGmx.widgets.notifications.startAction('securitySave');
    var postParams = {WrapStyle: 'window'};

    if (this.saveCustomParams()) {                                              // DefAccess: ''
        return;
    }

    postParams.SecurityInfo = JSON.stringify(si.SecurityInfo);

    postParams[this.groupPropertyName] = this.propertyValue;                    // Layers: {}

    sendCrossDomainPostRequest(serverBase + this.updateSecurityName, postParams, function(response) {
        if (!parseResponse(response)) {
            nsGmx.widgets.notifications.stopAction('securitySave');
            return;
        }
        originalItems = [];
        for (var i = 0; i < addedUsers.length; i++) {
            originalItems[i] = addedUsers[i];
        }
        // обновляем перечень общих пользователей
        _this.originalItems = originalItems;

        // обновляем права всех выделенных слоев
        updateselectedLayersSecurity(_this.selectedLayersSecurityArray);

        nsGmx.widgets.notifications.stopAction('securitySave', 'success', _gtxt('Сохранено'));
        $(this).trigger('savedone', si);
    })

    // обновляет массив выделенных слоев с правами после нажатия кнопки "сохранить",
    // затем обновляет массив всех слоев
    function updateselectedLayersSecurity(array) {
        var postParams = {
            WrapStyle: 'window',
            Layers: array.map(function(obj) {
                return obj.ID;
            })
        };

        _this.getGroupSecurityFromServer(postParams).then(updateSecurity);
    }
    // обновляет права на слои

    function updateSecurity(res) {
        var array = _this.selectedLayersSecurityArray;
        for (var i = 0; i < array.length; i++) {
            for (var j = 0; j < res.length; j++) {
                if (array[i].ID === res[j].ID) {
                    var options = {
                        type: array[i].type,
                        multiLayer: !!array[i].MultiLayerID
                    }
                    array.splice(i, 1, $.extend(res[j], options));
                }
            }
        }

        for (var k = 0; k < array.length; k++) {
            for (var l = 0; l < _this.mapLayersSecurityArray.length; l++) {
                if (array[k].ID === _this.mapLayersSecurityArray[l].ID) {
                    _this.mapLayersSecurityArray.splice(l, 1, array[k])
                }
            }
        }
    };

    // возвращает массив удаленных пользователей
    function findRemovedUsers(original, changed) {
        return _.difference(original, changed);
    }
}

// кастомный интерфейс - виджет группового редактирования слоев карты
layersGroupSecurity.prototype.createSecurityDialog = function(securityInfo, options)
{
    var _this = this,
        selectedLayersSecurityArray = this.selectedLayersSecurityArray;

    options = $.extend({showOwner: true}, options);
    this._securityInfo = securityInfo;

    var uiTemplate = '<div id="securityDialog" class="security-canvas">' +
        '<div class="security-header">' +
            '<button class="security-save">{{i "Сохранить"}}</button>' +
                '{{#if showOwner}}<div class="security-owner-placeholder"></div>{{/if}}' +
        '</div>' +
        '<div class="security-custom-ui"></div>' +
        '<div class="security-counter"></div>' +
        '<div class="security-default-access"></div>' +

        '<div class="security-userlist-placeholder"></div>' +

    '</div>';

    var canvas = this._ui = $(Handlebars.compile(uiTemplate)({
        showOwner: options.showOwner
    }));

    this.addCustomUI(canvas, resize);

    $('.security-save', canvas).click(function(){
        if (_this.groupPropertyName) {
            _this.propertyValue = selectedLayersSecurityArray.map(function(item){
                return item.ID;
            });
        }
        _this._save(_this.originalItems);
    });

    if (options.showOwner) {
        new SecurityOwnerWidget(securityInfo.SecurityInfo, $('.security-owner-placeholder', canvas));
    }

    this._dialogDiv = showDialog(_gtxt(this.dialogTitle, this.title), canvas[0], 571, 455, false, false, resize);
    function resize()
    {
        var mapTableHeight,
            nonTableHeight =
            $('.security-header', canvas).height() +
            $('.security-custom-ui', canvas).height() +
            $('.security-counter', canvas).height() +
            $('.security-default-access', canvas).height() +
            $('.security-add-container', canvas).height() + 25;

        mapTableHeight = canvas[0].parentNode.offsetHeight - nonTableHeight - 10;
        if (_this.securityUserListWidget) {
            _this.securityUserListWidget.updateHeight(mapTableHeight);
        }
    }

    resize();
}

// кастомный интерфейс - отдельная функция - дерево слоев для виджета группового редактирования слоев
layersGroupSecurity.prototype.addCustomUI = function(ui, resizeFunc) {
    var _this = this,
        mapLayers = _this.mapLayers,
        mapLayersSecurityArray = _this.mapLayersSecurityArray,
        selectedLayersSecurityArray = _this.selectedLayersSecurityArray,
        counter = 0,
        actualCounter = {counter: counter},
        countDiv = $('.security-counter', ui),
        countTemplate = Handlebars.compile(
            '<table class="security-count-table">' +
                '<tbody>' +
                    '<tr>' +
                        '<td>{{i "security.select.selectedLayers"}}</td>' +
                        '<td>{{counter}}</td>' +
                    '</tr>' +
                '</tbody>' +
            '</table>'
        ),
        templateSecurityInfo = {
            Users: []
        },
        tree,
        rawTree,
        drawnTree,
        defAccessDiv = $('.security-default-access', ui),
        defAccessTemplate = Handlebars.compile(
            '<div class="security-def-access">{{i "security.defAccess"}}: ' +
                '<select class="security-defaccess-select selectStyle">' +
                    '{{#defAccessTypes}}' +
                        '<option value="{{value}}"{{#isSelected}} selected{{/isSelected}}>{{title}}</option>' +
                    '{{/defAccessTypes}}' +
                '</select>' +
            '</div>'
        ),
        userList = $('.security-userlist-placeholder', ui),
        getMapLayersRights = function (callback) {
            var postParams = {
                WrapStyle: 'window',
                Layers: mapLayers.map(function(layer){
                    return layer.LayerID || layer.MultiLayerID;
                })
            };
            _this.getGroupSecurityFromServer(postParams).then(callback);
        },

        // сохраняем права слоев карты
        saveMapLayersRights = function (res) {
            for (var i = 0; i < res.length; i++) {
                for (var j = 0; j < mapLayers.length; j++) {
                    if (res[i].ID === mapLayers[j].LayerID || res[i].ID === mapLayers[j].MultiLayerID) {
                        var options = {
                            type: mapLayers[j].type,
                            multiLayer: !!mapLayers[j].MultiLayerID
                        };
                        mapLayersSecurityArray.push($.extend(res[i], options));
                    }
                }
            }
        };

    // модификация исходного дерева - остаются только слои с правами на редактирование
    rawTree = window._layersTree.treeModel.cloneRawTree(function(node) {
        var props = node.content.properties;
        props.visible = false;
        if (node.type === 'layer') {
            if (props.Access !== 'edit') {
                return null;
            }
            mapLayers.push(props);
            return node;
        }
        if (node.type === 'group') {
            var children = node.content.children;
            if (!children.length) {
                return null;
            }
            return node;
        }
    });

    // создание дерева слоев
    tree = new layersTree({
        showVisibilityCheckbox: true,
        allowActive: true,
        allowDblClick: false,
        showStyle: false,

        // обработка различных вариаций прав в группе слоев
        // если выделен один слой, рисуются его права
        // если у выделенных слоев есть юзеры с одинаковыми правами, то рисуются только эти юзеры
        // если у выделенных слоев разные права, рисуется пустой диалог
        // если у выделенных слоев разные дефолтные права, в выпадающий список выбора дефолтных прав проставляется пустое поле
        visibilityFunc: function(props, isVisible) {
            if (isVisible) {
                counter++;
                for (var i = 0; i < mapLayersSecurityArray.length; i++) {
                    if (mapLayersSecurityArray[i].ID === props.LayerID || mapLayersSecurityArray[i].ID === props.MultiLayerID) {
                        selectedLayersSecurityArray.push(mapLayersSecurityArray[i]);
                    }
                }
                addLayer();
            }

            if (!isVisible) {
                counter--;
                for (var i = 0; i < selectedLayersSecurityArray.length; i++) {
                    if (selectedLayersSecurityArray[i].ID === props.LayerID || selectedLayersSecurityArray[i].ID === props.MultiLayerID) {
                        selectedLayersSecurityArray.splice(i, 1);
                    }
                }
                removeLayer();
            }

            // показываем счетчик выделенных слоев под деревом
            actualCounter.counter = counter;
            $(countDiv).html(countTemplate(actualCounter));

            // добавляет слой в дерево слоев
            function addLayer() {
                drawAccess();
                resizeFunc();
            }

            // убирает слой из дерева слоев
            function removeLayer() {
                if (counter > 0 && selectedLayersSecurityArray.length) {
                    drawAccess();
                } else {
                    $(defAccessDiv).empty();
                        userList.empty();
                }
                resizeFunc();
            }

            // рисует оба виджета - доступа по умолчанию и списка пользователей для каждого слоя
            function drawAccess() {
                drawDefaultAccess(selectedLayersSecurityArray, defAccessDiv);
                drawUsersList(selectedLayersSecurityArray, userList);
            }

            // рисует доступ по умолчанию
            function drawDefaultAccess(array, container) {
                var accessTypes,
                    defTemplateJSON;

                if (checkSameLayersType(array)) {
                    accessTypes = array[0].type === 'Raster' ? ['no', 'preview', 'view', 'edit'] : ['no', 'preview', 'view', 'editrows', 'edit'];
                } else {
                    accessTypes = ['no', 'preview', 'view', 'edit'];
                }

                defTemplateJSON = {
                    defAccessTypes: accessTypes.map(function(type) {
                        return {
                            value: type,
                            title: _gtxt('security.access.' + type),
                            isSelected: undefined
                        };
                    })
                };

                $(container).empty();

                // протавляем значение в выпадающем списке прав по умолчанию
                if (checkSameDefaultAccess(array)) {
                    var types = defTemplateJSON.defAccessTypes;
                    for (var i = 0; i < types.length; i++) {
                        if (types[i].value === array[0].SecurityInfo.DefAccess) {
                            types[i].isSelected = true;
                        }
                    }
                    $(defAccessTemplate(defTemplateJSON)).appendTo(ui.find('.security-default-access'));
                } else {
                    accessTypes.unshift('empty');
                    defTemplateJSON = {
                        defAccessTypes: accessTypes.map(function(type) {
                            return {
                                value: type,
                                title: _gtxt('security.access.' + type),
                                isSelected: type === 'empty'
                            };
                        })
                    };
                    $(defAccessTemplate(defTemplateJSON)).appendTo(ui.find('.security-default-access'));
                }
            }

            // рисует список пользователей для каждого слоя
            function drawUsersList(array, container) {
                checkSameUsersAccess(array);
                var accessTypes;

                // запомним пересечения пользовательских прав для слоев,
                // в случае удаления / добавления пользователей, последующее состояние будет сравниваться с этим
                _this.originalItems = [];

                if (templateSecurityInfo.Users.length) {
                    accessTypes = array[0].type === 'Raster' ? ['no', 'preview', 'view', 'edit'] : ['no', 'preview', 'view', 'editrows', 'edit'];

                    for (var i = 0; i < templateSecurityInfo.Users.length; i++) {
                        _this.originalItems.push(templateSecurityInfo.Users[i]);
                    }
                } else {
                    accessTypes = ['no', 'preview', 'view', 'edit'];
                }

                container.empty();
                _this.securityUserListWidget = new SecurityUserListWidget(templateSecurityInfo, container, {accessTypes: accessTypes});
            }

            // проверяет, совпадают ли дефолтные права для всех выделенных слоев
            function checkSameDefaultAccess(array) {
                var first = array[0].SecurityInfo.DefAccess;
                return array.every(function(element) {
                    return element.SecurityInfo.DefAccess === first;
                });
            }

            // проверяет, совпадают ли отдельные права для всех выделенных слоев и создает массив пересечений
            function checkSameUsersAccess(array) {
                var userArray = array.map(function(obj){
                    return obj.SecurityInfo.Users;
                });

                templateSecurityInfo.Users = findCommonUsers(userArray);

                // нахождение одинаковых значений {пользователь: права} во всех слоях
                function findCommonUsers(array) {
                    var a = array.sort(sortArraysByLength),
                        first = a[0];

                    if (first.length) {
                        for (var i = 1; i < a.length; i++) {
                            first = first.filter(function (obj) {
                                return a[i].find(function (obj2) {
                                    return _.isEqual(obj, obj2)
                                })
                            })
                        }
                    } else {
                        first = [];
                    }
                    return first;
                }

                // сортировка массивов пользователей по длине для оптимизации времени
                function sortArraysByLength(a, b) {
                    return a.length - b.length;
                }
            }

            // проверяет, совпадают ли типы для всех выделенных слоев (вектор/растр)
            function checkSameLayersType(array) {
                var first = array[0].type;
                return array.every(function(element) {
                    return element.type === first;
                });
            }

        }
    });

    drawnTree = tree.drawTree(rawTree, 2);

    getMapLayersRights(saveMapLayersRights);

    $(drawnTree).treeview().appendTo(ui.find('.security-custom-ui'));
    $(countDiv).html(countTemplate(actualCounter));

}

nsGmx.mapSecurity = mapSecurity;
nsGmx.security = security;
nsGmx.layerSecurity = layerSecurity;
nsGmx.multiLayerSecurity = multiLayerSecurity;
nsGmx.layersGroupSecurity = layersGroupSecurity;

})();

!(function(_){

//для отслеживания того, что не открыли диалог редактирования одного и того же объекта несколько раз
var EditObjectControlsManager = {
    _editControls: [],
    _paramsHooks: [],

    find: function(layerName, oid)
    {
        for (var iD = 0; iD < this._editControls.length; iD++)
            if ( layerName == this._editControls[iD].layer && oid == this._editControls[iD].oid )
                return this._editControls[iD].control;
    },

    add: function(layerName, oid, control)
    {
        for (var iD = 0; iD < this._editControls.length; iD++)
            if ( layerName == this._editControls[iD].layer && oid == this._editControls[iD].oid )
            {
                this._editControls[iD].control = control;
                return;
            }
        this._editControls.push({ layer: layerName, oid: oid, control: control });
    },

    remove: function(layerName, oid)
    {
        for (var iD = 0; iD < this._editControls.length; iD++)
            if ( layerName == this._editControls[iD].layer && oid == this._editControls[iD].oid )
            {
                this._editControls.splice(iD, 1);
                return;
            }
    },

    addParamsHook: function(paramsHook) {
        this._paramsHooks.push(paramsHook);
    },

    applyParamsHook: function(layerName, objectId, params) {
        for (var h = 0; h < this._paramsHooks.length; h++) {
            params = this._paramsHooks[h](layerName, objectId, params);
        }

        return params;
    }
}

var getInputElement = function(type)
{
    var input = _input(null, [['dir','className','inputStyle edit-obj-input']]);

    if (type == 'date')
    {
        $(input).datepicker({
            changeMonth: true,
            changeYear: true,
            dateFormat: "dd.mm.yy"
        });
    }
    else if ( type == 'datetime' )
    {
        $(input).datetimepicker(
        {
            changeMonth: true,
            changeYear: true,
            dateFormat: "dd.mm.yy",
            timeFormat: "HH:mm:ss",
            showSecond: true,
            timeOnly: false
        })
    }
    else if ( type == "time" )
    {
        $(input).timepicker({
            timeOnly: true,
            timeFormat: "HH:mm:ss",
            showSecond: true
        });
    }

    return input;
}

//Коллекция полей с информацией для создания диалога редактирования
var FieldsCollection = function() {
    var _asArray = [];
    var _asHash = {};

    this.append = function(field) {
        if (field.name && _asHash[field.name]) {
            var origIndex = _asHash[field.name].origIndex;
            $.extend(true, _asHash[field.name], field);
            _asHash[field.name].origIndex = origIndex;
        } else {
            field.origIndex = _asArray.length;
            _asArray.push(field);
            if (field.name) {
                _asHash[field.name] = field;
            }
        }
    }

    this.get = function(name) {
        return _asHash[name];
    }

    this.each = function(callback) {
        _asArray.forEach(callback);
    }

    this.updateValue = function(name) {
        var field = _asHash[name];
        if (field && field.view) {
            field.value = field.view.getValue();
        }
        return field && field.value;
    }

    //Сначала isRequired, потом identityField, потом в порядке добавления
    this.sort = function() {
        _asArray = _asArray.sort(function(a, b) {
            if (!!a.isRequired !== !!b.isRequired) {
                return Number(!!b.isRequired) - Number(!!a.isRequired);
            }

            if (!!a.identityField !== !!b.identityField) {
                return Number(!!b.identityField) - Number(!!a.identityField);
            }

            var userZIndexDelta = (b.index || 0) - (a.index || 0);
            return userZIndexDelta || (b.origIndex - a.origIndex);
        })
    }
}

/** Объект, описывающий один атрибут слоя
 * @typedef {Object} nsGmx.EditObjectControl.FieldInfo
 * @property {String} name имя атрибута (обязательно)
 * @property {String|int} [value] значение атрибута в формате сервера
 * @property {bool} [constant=false] можно ли редактировать атрибут
 * @property {bool} [hide=false] совсем не показыавать этот атрибут
 * @property {String} [title=<совпадает с name>] что показывать вместо имени атрибута
 * @property {function(val):bool} [validate] ф-ция для валидации результата. На вход получает введённое пользователем значение
*      (до преобразования в серверный формат), должна вернуть валидно ли это значение.
 * @property {String} [isRequired=false] является ли значение атрибута обязательным. Обязательные атрибуты показываются выше всех остальных и выделяются жирным шрифтом.
 * @property {Number} [index=0] индекс для сортировки. Влияет на порядок показа полей в диалоге. Больше - выше.
*/

/** Контрол, который показывает диалог редактирования существующего или добавления нового объекта в слой.
*
* @memberOf nsGmx
* @class
* @param {String}   layerName ID слоя
* @param {Number}   objectId ID объекта (null для нового объекта)
* @param {Object}   [params] Дополнительные параметры контрола
* @param {gmxAPI.drawingObject} [params.drawingObject] Пользовательский объект для задании геометрии или null, если геометрия не задана
* @param {function} [params.onGeometrySelection] Внешняя ф-ция для выбора геометрии объекта.
         Сигнатура: function(callback), параметр callback(gmxAPI.drawingObject|geometry) должен быть вызван когда будет выбрана геометрия.
* @param {HTMLNode} [params.geometryUI] HTML элемент, который нужно использовать вместо стандартных контролов для выбора геометрии (надпись + иконка)
* @param {nsGmx.EditObjectControl.FieldInfo[]} [params.fields] массив с описанием характеристик атрибутов для редактирования . Должен содержать только атрибуты, которые есть в слое.
* @param {bool} [params.allowDuplicates=<depends>] Разрешать ли несколько диалогов для редактирования/создания этого объекта.
         По умолчанию для редактирования запрещено, а для создания нового разрешено.
* @param {HTMLNode | function(nsGmx.EditObjectControl): HTMLNode} [params.afterPropertiesControl] HTML элемент, который нужно поместить после списка атрибутов или ф-ция, которая возвращает этот элемент
*/
var EditObjectControl = function(layerName, objectId, params)
{
    /** Объект был изменён/добавлен
     * @event nsGmx.EditObjectControl#modify
     */

    /** Генерируется перед изменением/добавлением объекта. Может быть использован для сохранения в свойствах объекта каких-то внешних данных.
     * @event nsGmx.EditObjectControl#premodify
     */

    /** Закрытие диалога редактирования
     * @event nsGmx.EditObjectControl#close
     */

    if (_queryMapLayers.layerRights(layerName) !== 'edit' && _queryMapLayers.layerRights(layerName) !== 'editrows') {
        showErrorMessage(_gtxt('Недостаточно прав для редактирования объектов слоя'), true);
        return;
    }

    var isNew = objectId == null;
    var _params = $.extend({
            drawingObject: null,
            fields: [],
            validate: {},
            allowDuplicates: isNew,
            afterPropertiesControl: _span()
        }, params);

    _params = EditObjectControlsManager.applyParamsHook(layerName, objectId, _params);

    var _this = this;
    if (!_params.allowDuplicates && EditObjectControlsManager.find(layerName, objectId))
        return EditObjectControlsManager.find(layerName, objectId);

    EditObjectControlsManager.add(layerName, objectId, this);

    var lmap = nsGmx.leafletMap,
        layersByID = nsGmx.gmxMap.layersByID;
    var layer = layersByID[layerName];
    var geometryInfoContainer = _div(null, [['css','color','#215570'], ['css','fontSize','12px']]);

    var originalGeometry = null;
    var drawingBorderDialog = null;
    var identityField = layer._gmx.properties.identityField;

    var geometryInfoRow = null;

    var drawingObjectLeafletID = null;
    var bindDrawingObject = function(obj)
    {
        geometryInfoRow && geometryInfoRow.RemoveRow();

        if (!obj) return;

        var InfoRow = gmxCore.getModule('DrawingObjects').DrawingObjectInfoRow;
        geometryInfoRow = new InfoRow(
            lmap,
            geometryInfoContainer,
            obj,
            { editStyle: false, allowDelete: false }
        );
        drawingObjectLeafletID = obj._leaflet_id;
    }

    var objStyle = params ? params.event.gmx.target.currentStyle : null;
    var bindGeometry = function(geom) {
        if (geom) {
            var geojson = new L.GeoJSON(geom),
				styleParams = objStyle ? {
                    pointStyle: {
                        shape: 'box', color: objStyle.strokeStyle
                    },
                    lineStyle: {
                        color: objStyle.strokeStyle
                    }
                } : {},
                arr = lmap.gmxDrawing.addGeoJSON(geojson, styleParams);
            for (var i = 0, len = arr.length; i < len; i++) {
                bindDrawingObject(arr[i]);
            }
        }
    };

    var canvas = null;
    var fieldsCollection = new FieldsCollection();

    var createDialog = function()
    {
        var createButton = makeLinkButton(isNew ? _gtxt("Создать") : _gtxt("Изменить")),
            removeButton = makeLinkButton(_gtxt("Удалить")),
            trs = [],
            isSaving = false;

        var canvas = _div(null, [['dir', 'className', 'edit-obj']]);

        $(canvas).bind('dragover', function() {
            return false;
        });

        $(canvas).bind('drop', function(e) {
            var files = e.originalEvent.dataTransfer.files;
            nsGmx.Utils.parseShpFile(files[0]).done(function(objs) {
                bindGeometry(nsGmx.Utils.joinPolygons(nsGmx._.pluck(objs, 'geometry')));
            });
            return false;
        });

        removeButton.onclick = function()
        {
            _mapHelper.modifyObjectLayer(layerName, [{action: 'delete', id: objectId}]).done(function()
            {
                removeDialog(dialogDiv);
                closeFunc();
            })
        }

        removeButton.style.marginLeft = '10px';

        isNew && $(removeButton).hide();

        createButton.onclick = function()
        {
            if (isSaving) {
                return;
            }

            $(_this).trigger('premodify');

            var properties = {};
            var anyErrors = false;

            fieldsCollection.each(function(field) {
                var name = field.name;
                if (!name) {
                    return;
                }

                var isValid = field.view.checkValue();
                if (isValid) {
                    properties[name] = fieldsCollection.updateValue(name);
                }
                anyErrors = anyErrors || !isValid;
            })

            if (anyErrors) return;

            var obj = { properties: properties };

            var selectedGeom = _this.getGeometry();

            if (!selectedGeom)
            {
                showErrorMessage("Геометрия для объекта не задана", true, "Геометрия для объекта не задана");
                return;
            }

            if (!isNew)
            {
                obj.id = objectId;

                var curGeomString = JSON.stringify(selectedGeom);
                var origGeomString = JSON.stringify(originalGeometry);

                if (origGeomString !== curGeomString) {
                    obj.geometry = selectedGeom;
                }
            }
            else
            {
                obj.geometry = selectedGeom;
            }

            isSaving = true;

            _mapHelper.modifyObjectLayer(layerName, [obj], 'EPSG:4326').done(function()
            {
                $(_this).trigger('modify');
                removeDialog(dialogDiv);
                closeFunc();
            })
        }

        var resizeFunc = function(event, ui)
        {
            if (!isNew && $(canvas).children("[loading]").length)
                return;

            canvas.firstChild.style.height = canvas.parentNode.offsetHeight - 25 - 10 - 10 + 'px';
        }

        var closeFunc = function()
        {
            // search for opened styles editing dialog
            if (drawingObjectLeafletID) {
                var styleEditingDialog = $('.drawing-object-leaflet-id-' + drawingObjectLeafletID);
            }

            geometryInfoRow && geometryInfoRow.getDrawingObject() && nsGmx.leafletMap.gmxDrawing.remove(geometryInfoRow.getDrawingObject());

            originalGeometry = null;

            if (styleEditingDialog) {
                removeDialog(styleEditingDialog);
            }

            if (drawingBorderDialog)
                removeDialog(drawingBorderDialog);

            EditObjectControlsManager.remove(layerName, objectId);

            $(_this).trigger('close');
        }

        var drawAttrList = function(fields)
        {
            var trs = [],
                firstInput;

            //сначала идёт геометрия
            var geomTitleTmpl = Handlebars.compile('<span>' +
                '<span class="edit-obj-geomtitle">{{i "Геометрия"}}</span>' +
                '<span id = "choose-geom" class="gmx-icon-choose"></span>' +
            '</span>');

            var geometryUI = _params.geometryUI || $(geomTitleTmpl())[0];
            $('#choose-geom', geometryUI).click(function() {
                if (_params.onGeometrySelection) {
                    _params.onGeometrySelection(bindGeometry);
                } else {
                    nsGmx.Controls.chooseDrawingBorderDialog(
                        'editObject',
                        bindDrawingObject,
                        { geomType: layer.getGmxProperties().GeometryType }
                    );
                }
            })

            trs.push(_tr([_td([geometryUI],[['css','height','20px']]), _td([geometryInfoContainer])]));

            fields.sort();

            //потом все остальные поля
            fields.each(function(field) {
                var td = _td();
                if (field.constant)
                {
                    field.view = field.view || {
                        getUI: function() {
                            var span = _span(null,[['dir', 'className', 'edit-obj-constant-value']]);
                            span.rowName = field.name;
                            span.rowType = field.type;
                            if ('value' in field) {
                                _(span, [_t(nsGmx.Utils.convertFromServer(field.type, field.value))]);
                            }
                            return span;
                        },
                        getValue: function() {return field.value},
                        setValue: function() {},
                        checkValue: function() { return true; }
                    }
                }
                else
                {
                    field.view = field.view || {
                        getUI: function() {
                            if (!this._input) {
                                var input = this._input = getInputElement(field.type);
                                input.rowName = field.name;
                                input.rowType = field.type;

                                firstInput = firstInput || input;

                                if ('value' in field)
                                    input.value = nsGmx.Utils.convertFromServer(field.type, field.value);
                            }
                            return this._input;
                        },
                        getValue: function() {
                            return nsGmx.Utils.convertToServer(field.type, this._input.value);
                        },
                        setValue: function(value) {
                            this._input.value = nsGmx.Utils.convertFromServer(field.type, value);
                        },
                        checkValue: function() {
                            var validationFunc = field.validate || _params.validate[field.name];
                            var isValid = !validationFunc || validationFunc(this._input.value);
                            if (!isValid) {
                                inputError(this._input);
                            }
                            return isValid;
                        },
                        _input: null
                    }
                }

                _(td, [field.view.getUI(_this)]);

                var fieldHeader = _span([_t(field.title || field.name)],[['css','fontSize','12px']]);
                if (field.isRequired) {
                    fieldHeader.style.fontWeight = 'bold';
                }
                var tr = _tr([_td([fieldHeader]), td], [['css', 'height', '22px']]);

                field.hide && $(tr).hide();

                trs.push(tr);
            })

            var afterPropUI = typeof _params.afterPropertiesControl === 'function' ? _params.afterPropertiesControl(_this) : _params.afterPropertiesControl;

            _(canvas, [_div([_table([_tbody(trs)], [['dir', 'className', 'obj-edit-proptable']]), afterPropUI],[['dir', 'className', 'obj-edit-canvas'], ['css','overflow','auto']])]);

            _(canvas, [_div([createButton, removeButton],[['css','margin','10px 0px'],['css','height','20px']])]);

            firstInput && firstInput.focus();

            resizeFunc();
        }
var prop = layer._gmx.properties;

        var dialogDiv = showDialog(isNew ? _gtxt("Создать объект слоя [value0]", prop.title) : _gtxt("Редактировать объект слоя [value0]", prop.title), canvas, 520, 300, false, false, resizeFunc, closeFunc);

        if (!isNew)
        {
            var loading = _div([_img(null, [['attr','src','img/progress.gif'],['css','marginRight','10px']]), _t(_gtxt('загрузка...'))], [['css','margin','3px 0px 3px 20px'],['attr','loading',true]]);

            _(canvas, [loading])

            //получаем геометрию объекта
            sendCrossDomainJSONRequest(serverBase + "VectorLayer/Search.ashx?WrapStyle=func&layer=" + layerName + "&page=0&pagesize=1&orderby=" + identityField + "&geometry=true&query=[" + identityField + "]=" + objectId, function(response)
            {
                if (!parseResponse(response))
                    return;

                $(canvas).children("[loading]").remove();

                var columnNames = response.Result.fields;
                var drawingObject = null;
                var geometryRow = response.Result.values[0];
                var types = response.Result.types;

                for (var i = 0; i < geometryRow.length; ++i)
                {
                    if (columnNames[i] === 'geomixergeojson')
                    {
                        var geom = L.gmxUtil.geometryToGeoJSON(geometryRow[i], true);
                        if (geom) {
                            bindGeometry(geom);
                            originalGeometry = $.extend(true, {}, geom);
                        }
                    }
                    else
                    {
                        var field = {
                            value: geometryRow[i],
                            type: types[i],
                            name: columnNames[i],
                            constant: columnNames[i] === identityField,
                            identityField: columnNames[i] === identityField,
                            isRequired: false
                        };

                        fieldsCollection.append(field);
                    }
                }

                _params.fields.forEach(fieldsCollection.append);

                drawAttrList(fieldsCollection);

                _this.initPromise.resolve();
            })
        }
        else
        {
            for (var i = 0; i < prop.attributes.length; ++i)
            {
                fieldsCollection.append({type: prop.attrTypes[i], name: prop.attributes[i]})
            }

            _params.fields.forEach(fieldsCollection.append);

            if (_params.drawingObject) {
                bindDrawingObject(_params.drawingObject);
            }

            drawAttrList(fieldsCollection);

            _this.initPromise.resolve();
        }
    }

    /** Promise для отслеживания момента полной инициализации диалога. Только после полной инициализации можно полноценно пользоваться методами get/set
      * @memberOf nsGmx.EditObjectControl.prototype
      * @member {jQuery.Deferred} initPromise
    */
    this.initPromise = $.Deferred();

    /** Получить текущее значение атрибута из контрола
      @memberOf nsGmx.EditObjectControl.prototype
      @param {String} fieldName Имя атрибута
      @method get
    */
    this.get = function(fieldName) {
        return fieldsCollection.updateValue(fieldName);
    }

    this.getAll = function() {
        var res = {};
        fieldsCollection.each(function(field) {
            res[field.name] = fieldsCollection.updateValue(field.name);
        })

        return res;
    }

    /** Задать значение атрибута объекта из контрола
      @memberOf nsGmx.EditObjectControl.prototype
      @method set
      @param {String} fieldName Имя атрибута
      @param {String|Integer} value Значение в клиентском формате, который нужно установить для этого атрибута
    */
    this.set = function(fieldName, value) {
        var field = fieldsCollection.get(fieldName);
        if (field) {
            field.view.setValue(value);
        }
    }

    /** Задать геометрию для редактируемого объекта
      @memberOf nsGmx.EditObjectControl.prototype
      @method setGeometry
      @param {gmxAPI.DrawingObject|geometry} geometry Геометрия в виде drawing объекта или просто описание геометрии
    */
    this.setGeometry = function(geometry) {
        bindGeometry(geometry);
    }

    this.getGeometryObj = function() {
        return geometryInfoRow ? geometryInfoRow.getDrawingObject() : null;
    }

    this.getGeometry = function() {
        if (geometryInfoRow) {
            var geom = geometryInfoRow.getDrawingObject();
            var geojson = geom.toGeoJSON();
            return geojson.geometry;
        } else {
            return null;
        }
    }

    this.getLayer = function() { return layer; };

    this.add = function(field) {
        fieldsCollection.append(field);
    }

    createDialog();
}

nsGmx.EditObjectControl = EditObjectControl;

/** Добавить "хук" для модификации параметров при всех вызовах ф-ции {@link nsGmx.EditObjectControl}
    @function
    @param {function(Object): Object} {paramsHook} Ф-ция, которая принимает на вход параметры ф-ции {@link nsGmx.EditObjectControl}
        и возвращает модифицируемые параметры (возможна замена in place)
*/
nsGmx.EditObjectControl.addParamsHook = EditObjectControlsManager.addParamsHook.bind(EditObjectControlsManager);

})(nsGmx.Utils._);

var nsGmx = window.nsGmx || {};

var SidebarWidget = function (params) {
    this.container = params.container;
    this.tabsContainer = document.createElement('div');
    this.tabsContainer.className = "leftCollapser-icon leftCollapser-left";

    this.mainContainer = document.createElement('div');
    this.mainContainer.className = "leftMenu";

    this.tabsContainer.innerHTML = 'o_O';
    this.mainContainer.innerHTML = 'test test';

    this.container.appendChild(this.tabsContainer);
    this.container.appendChild(this.mainContainer);

    this.width = params.width;
};

SidebarWidget.prototype = {
    setPane: function () {

    },

    enable: function () {

    },

    close: function () {

    },

    getActiveTabId: function () {

    },

    setPane: function () {

    },

    setPane: function () {

    },

    isOpened: function () {

    },
}

nsGmx.SidebarWidget = SidebarWidget;

nsGmx.sqlFunctions = {
    string: [
        "length", "lower", "upper", "trim", "lTrim", "rTrim", "left", "position",
        "substring", "right"
    ],

    date: [
        "addDays", "addHours", "addMinutes", "addSeconds", "day", "month", "year",
        "now", "strToDateTime", "strToTime", "toString"
    ],

    math: [
        "round"
    ],

    agregate: [
        "avg", "count", "max", "min", "sum", "unionAggregate"
    ],

    transform: [
        "cast"
    ],

    geometry: [
        "STArea", "geometryFromVectorLayer", "geometryToWkbHex", "geometryFromWkbHex",
        "geometryFromWKT", "geometryFromGeoJson", "buffer", "makeValid", "STEnvelopeMinX",
        "STEnvelopeMaxX", "STEnvelopeMaxY", "STEnvelopeMinY", "STContains", "STIntersects",
        "STIntersection", "STDifference", "STUnion", "geomIsEmpty", "STCentroid", "STAsText"
    ],

    special: [
        "geometryFromVectorLayer", "geometryFromVectorLayerUnion", "geometryFromRasterLayer"
    ]
}

nsGmx.sqlTemplates = {
    "length": "length(string)",
    "lower": "lower(string)",
    "upper": "upper(string)",
    "trim": "trim(string)",
    "lTrim": "lTrim(string)",
    "rTrim": "rTrim(string)",
    "left": "left(string, [number_of_characters])",
    "position": "position(substring, string)",
    "substring": "substring(string, fist_character_index, characters_count)",
    "right": "right(string, [number_of_characters])",
    "contains": "string contains string",
    "contiansIgnoreCase": "string contiansIgnoreCase string",
    "startsWith": "string startsWith string",
    "endsWith": "string endsWith string",
    "between and": "expression between expression and expression",
    "addDays": "addDays(datetime|date,double)",
    "addHours": "addHours(datetime|time, double)",
    "addMinutes": "addMinutes(datetime|time, double)",
    "addSeconds": "addSeconds(datetime|time, double)",
    "day": "day(date)",
    "month": "month(date)",
    "year": "year(date)",
    "now": "now()",
    "strToDateTime": "strToDateTime(string)",
    "strToTime": "strToTime(string)",
    "toString": "toString(expression)",
    "avg": "avg()",
    "count": "count()",
    "max": "max()",
    "min": "min()",
    "sum": "sum()",
    "unionAggregate": "unionAggregate()",
    "cast": "cast(expression as <type>)",
    "STArea": "STArea(geometry)",
    "geometryFromVectorLayer": "geometryFromVectorLayer(layerID, countID)",
    "geometryToWkbHex": "geometryToWkbHex(geometry)",
    "geometryFromWkbHex": "geometryFromWkbHex(geometry, EPSG code)",
    "geometryFromWKT": "geometryFromWKT(string, EPSG code)",
    "geometryFromGeoJson": "geometryFromGeoJson(string, EPSG code)",
    "buffer": "buffer(geometry, buffer size)",
    "makeValid": "makeValid(geometry)",
    "STEnvelopeMinX": "STEnvelopeMinX(geometry)",
    "STEnvelopeMaxX": "STEnvelopeMaxX(geometry)",
    "STEnvelopeMaxY": "STEnvelopeMaxY(geometry)",
    "STEnvelopeMinY": "STEnvelopeMinY(geometry)",
    "STContains": "STContains(geometry, geometry)",
    "STIntersects": "STIntersects(geometry, geometry)",
    "STIntersection": "STIntersection(geometry, geometry)",
    "STDifference": "STDifference(geometry, geometry)",
    "STUnion": "STUnion(geometry, geometry)",
    "geomIsEmpty": "geomIsEmpty(geometry)",
    "STCentroid": "STCentroid(geometry)",
    "STAsText": "STAsText(geometry)",
    "geometryFromVectorLayer": "geometryFromVectorLayer(layerID, countID)",
    "geometryFromVectorLayerUnion": "geometryFromVectorLayerUnion(layerID)",
    "geometryFromRasterLayer": "geometryFromRasterLayer(layerID)"
}

!(function () {

nsGmx.SuggestWidget = function(attrNames, textarea, textTemplate, func, valuesArr, addValueFlag) {
    var _this = this;
    this.textArea = textarea;
    this.func = func;
    this.currentTextArea = textarea[0];

    if (valuesArr && !(valuesArr instanceof nsGmx.ILazyAttributeValuesProvider)) {
        valuesArr = new nsGmx.LazyAttributeValuesProviderFromArray(valuesArr);
    }

    var canvas = this.el = nsGmx.Utils._div(null, [['dir', 'className', 'suggest-helper']]);
    canvas.style.display = 'none';

    canvas.onmouseout = function(e) {
        var evt = e || window.event,
            target = evt.srcElement || evt.target,
            relTarget = evt.relatedTarget || evt.toElement;

        if (canvas.getAttribute('arr')) {
            try {
                while (relTarget && !$(relTarget).hasClass('suggest-helper-elem-group')) {
                    if (relTarget === canvas) { return; }
                    relTarget = relTarget.parentNode;
                }
                $(canvas).fadeOut(100, function() {$(this).remove();});
            } catch (ev) {
                if (target === canvas) {
                    $(canvas).fadeOut(100, function() {$(this).remove();});
				}
            }
        }
    };

    attrNames.forEach(function(name) {
        if (typeof name === 'object') {
            name = name.groupTag;
            var div = nsGmx.Utils._div([nsGmx.Utils._t(String(name))], [['dir', 'className', 'suggest-helper-elem'], ['dir', 'className', 'suggest-helper-elem-group']]);
            $(div).css('margin-top', '3px')

            $(canvas).append(div);
        } else {
            var div = nsGmx.Utils._div([nsGmx.Utils._t(String(name))], [['dir', 'className', 'suggest-helper-elem']]);

            div.onmouseover = function() {
                var _curDiv = this;
                $(this.parentNode).children('.suggest-helper-hover').removeClass('suggest-helper-hover');
                $(this).addClass('suggest-helper-hover');

                if (!valuesArr) { return; }

                $(canvas.parentNode).children('[arr]').each(function() {
                    if (this.getAttribute('arr') !== name) {
                        $(this).fadeOut(100, function() {
                            $(this).remove();
                        });
                    }
                });

                if (!valuesArr.isAttributeExists(name)) { return; }

                if (!$(canvas.parentNode).children('[arr=\'' + name + '\']').length) {
                    this.timer = setTimeout(function() {
                        valuesArr.getValuesForAttribute(name, function(attrValues) {

                            if (!attrValues || !$(_curDiv).hasClass('suggest-helper-hover')) { return; }

                            var arrSuggestCanvas = new nsGmx.SuggestWidget(attrValues, [_this.currentTextArea], 'suggest', function()
                            {
                                _this.func && _this.func();

                                $(canvasArr.parentNode.childNodes[2]).fadeOut(100);

                                canvasArr.removeNode(true);
                            }, false, addValueFlag);

                            var canvasArr = arrSuggestCanvas.el;

                            canvasArr.style.left = '86px';
                            canvasArr.style.height = '220px';
                            canvasArr.style.width = '100px';

                            $(canvasArr).children().css('width', '80px');

                            canvasArr.setAttribute('arr', name);

                            $(canvas.parentNode).append(canvasArr);

                            $(canvasArr).fadeIn(100);
                        });
                    }, 300);
                }
            };

            div.onmouseout = function(e) {
                var evt = e || window.event,
                target = evt.srcElement || evt.target,
                relTarget = evt.relatedTarget || evt.toElement;

                if ($(target).hasClass('suggest-helper-hover') && relTarget === this.parentNode) {
                    $(this).removeClass('suggest-helper-hover');
                }

                if (this.timer) {
                    clearTimeout(this.timer);
                }
            };

            div.onclick = function(e) {
                var val = textTemplate.replace(/suggest/g, name);
                if (this.parentNode.getAttribute('arr') != null)
                {
                    if (isNaN(Number(val))) {
                        val = '\'' + val + '\'';
                    }

                    if (addValueFlag) {
                        val = '"' + this.parentNode.getAttribute('arr') + '" = ' + val;
                    }
                }

                insertAtCursor(_this.currentTextArea, val, this.parentNode.sel);

                $(canvas).fadeOut(100);

                if (this.timer) {
                    clearTimeout(this.timer);
                }

                $(canvas.parentNode).children('[arr]').fadeOut(100, function()
                {
                    $(this).remove();
                });

                _this.func && _this.func();

                stopEvent(e);
            };

            window._title(div, nsGmx.sqlTemplates[name] || name);

            $(canvas).append(div);
        }

    });
};

nsGmx.SuggestWidget.prototype.setActiveTextArea = function (textArea) {

    for (var i = 0; i < this.textArea.length; i++) {
        if (this.textArea[i] === textArea) {
            this.currentTextArea = this.textArea[i];
            break;
        }
    }
};

nsGmx.SuggestWidget.prototype.setCallback = function (func) {
    this.func = func;
}

var template = Handlebars.compile('<div class="suggest-container">' +
    '<table><tbody><tr>' +
        '<td><div class="suggest-link-container selectStyle suggest-attr">{{i "Колонки"}}<span class="ui-icon ui-icon-triangle-1-s"></span></div></td>' +
        '<td><div class="suggest-link-container selectStyle suggest-op">{{i "Операторы"}}<span class="ui-icon ui-icon-triangle-1-s"></span></div></td>' +
        '<td><div class="suggest-link-container selectStyle suggest-func">{{i "Функции"}}<span class="ui-icon ui-icon-triangle-1-s"></span></div></td>' +
    '</tr></tbody></table>' +
'</div>');

nsGmx.AttrSuggestWidget = function(targetTextarea, attrNames, attrValuesProvider, changeCallback) {

    this.changeCallback = changeCallback;
    this.targetTextarea = targetTextarea;

    var ui = this.el = $(template());

    this.attrsSuggest = new nsGmx.SuggestWidget(attrNames, targetTextarea, '"suggest"', changeCallback, attrValuesProvider, true);
    this.functionsSuggest = new nsGmx.SuggestWidget(transformHash(nsGmx.sqlFunctions), targetTextarea, 'suggest()', this.changeCallback);
    this.opsSuggest = new nsGmx.SuggestWidget(['=', '>', '<', '>=', '<=', '<>', 'AND', 'OR', 'NOT', 'IN', 'CONTAINS', 'CONTAINSIGNORECASE', 'BETWEEN', 'STARTSWITH', 'ENDSWITH'], targetTextarea, 'suggest', this.changeCallback);

    ui.find('.suggest-attr').append(this.attrsSuggest.el);
    ui.find('.suggest-func').append(this.functionsSuggest.el);
    ui.find('.suggest-op').append(this.opsSuggest.el);

    var clickFunc = function(div) {
        if (document.selection) {
            targetTextarea.focus();
            var sel = document.selection.createRange();
            div.sel = sel;
            targetTextarea.blur();
        }

        ui.find('.attrsHelperCanvas').children('[arr]').fadeOut(100, function() {
            $(this).remove();
        });
    };

    ui.find('.suggest-link-container').click(function(e) {
        var evt = e || window.event,
            target = evt.srcElement || evt.target,
            relTarget = evt.relatedTarget || evt.toElement;

        if (!$(target).hasClass('suggest-helper-elem-group')) {
            var placeholder = $(this).children('.suggest-helper');
            clickFunc(placeholder[0]);

            ui.find('.suggest-helper').fadeOut(100);
            placeholder.fadeIn(100);
        }
    });

    $(targetTextarea).click(function() {
        ui.find('.suggest-helper').fadeOut(100);
        return true;
    });

    /**
     * SQLHASH TRANSFORM HELPER
     */
     function transformHash(hash) {
        var arr = [],
            res = [];

        for (var key in hash) {
            if (hash.hasOwnProperty(key)) {
                res.push({groupTag: key});

                arr = hash[key];
                for (var i = 0; i < arr.length; i++) {
                    res.push(arr[i]);
                }
            }
        }

        return res;
     }
};

nsGmx.AttrSuggestWidget.prototype.setActiveTextArea = function (textArea) {
    this.attrsSuggest.setActiveTextArea(textArea);
    this.functionsSuggest.setActiveTextArea(textArea);
    this.opsSuggest.setActiveTextArea(textArea);
}

nsGmx.AttrSuggestWidget.prototype.setCallback = function (callback) {
    this.attrsSuggest.setCallback(callback);
    this.functionsSuggest.setCallback(callback);
    this.opsSuggest.setCallback(callback);
}

})();

/** Параметры мультивременного слоя, связанные со временем
  @class
  @extends Backbone.Model
  @prop {number} [minPeriod=1] Минимальный период создания тайлов
  @prop {number} [maxPeriod=1] Максимальный период создания тайлов
  @prop {number} [columnName=null]  Название мультивременной колонки
  @prop {number} [isTemporal=false] Является ли слой мультивременным
*/
nsGmx.TemporalLayerParams = Backbone.Model.extend(
/** @lends nsGmx.TemporalLayerParams.prototype */
{
    defaults: {
        isTemporal: false,
        maxShowPeriod: 0,
        minPeriod: 1,
        maxPeriod: 256,
        columnName: null
    },

    /** Возвращает строчку с перечислением временнЫх периодов (для передачи серверу) */
    getPeriodString: function() {
        var periods = [1, 16, 256],
            minPeriod = Number(this.attributes.minPeriod),
            maxPeriod = Number(this.attributes.maxPeriod);

            minPeriod = (minPeriod > 1 && minPeriod < 16) ? 16 : minPeriod;
            minPeriod = (minPeriod > 16 && minPeriod < 256) ? 256 : minPeriod;
            maxPeriod = (maxPeriod > 1 && maxPeriod < 16) ? 16 : maxPeriod;
            maxPeriod = (maxPeriod > 16 && maxPeriod < 256) ? 256 : maxPeriod;

        return periods.splice(periods.indexOf(minPeriod), periods.indexOf(maxPeriod) + 1).join(',');
    }
}, {PERIOD_STEP: 4});

/** Связанные с квиклуками параметры векторных слоёв. Умеет сериализовать/десериализовать себя в строку для хранения на сервере.
 * @class
 * @memberOf nsGmx
 * @extends Backbone.Model
 * @property {String} template Шаблон URL квиклука
 * @property {Number} minZoom Минимальный зум показа квиклуков
 * @property {Number} X1-X4,Y1-Y4 Названия полей слоя, в которых хранятся координаты привязки 4 углов изображения. Если не указаны, будут использованы значения по умолчанию (поля "X1"-"X4", "Y1"-"Y4" или их аналоги в нижнем регистре)
 */
nsGmx.QuicklookParams = Backbone.Model.extend({
    /** Загружает параметры из строки с сервера.
     * @param {String} quicklookString Строка с параметрами с сервера
     */
    fromServerString: function(quicklookString) {
        if (quicklookString) {
            //раньше это была просто строка с шаблоном квиклука, а теперь стало JSON'ом
            if (quicklookString[0] === '{') {
                var p = JSON.parse(quicklookString);
                this.set({
                    template: p.template,
                    minZoom: p.minZoom,
                    X1: p.X1, Y1: p.Y1,
                    X2: p.X2, Y2: p.Y2,
                    X3: p.X3, Y3: p.Y3,
                    X4: p.X4, Y4: p.Y4
                });
            } else {
                this.set({
                    template: quicklookString
                });
            }
        }
    },
    /** Сохраняет все параметры в строку, которую можно передать серверу.
     * @return {String}
     */
    toServerString: function() {
        //$.extend чтобы удалить undefined поля
        return this.attributes.template ? JSON.stringify($.extend({}, this.attributes)) : '';
    }
});

(function() {

function capitaliseFirstLetter(str)
{
    return str.charAt(0).toUpperCase() + str.slice(1);
}

//events: newAttribute, delAttribute, updateAttribute, moveAttribute, change
nsGmx.ManualAttrModel = function(isRCLayer) {
    var _attributes = [];

    this.addAttribute = function(type, name)
    {
        _attributes.push({
            type: type,
            name: name,
            IsPrimary: false,
            IsIdentity: false,
            IsComputed: false
        });

        $(this).triggerHandler('newAttribute');
        $(this).triggerHandler('change');

        return _attributes.length - 1;
    };

    this.changeName = function(idx, newName)
    {
        _attributes[idx].name = newName;
        $(this).triggerHandler('updateAttribute');
        $(this).triggerHandler('change');
    };

    this.changeType = function(idx, newType)
    {
        _attributes[idx].type = newType;
        $(this).triggerHandler('updateAttribute');
        $(this).triggerHandler('change');
    };

    this.deleteAttribute = function(idx)
    {
        _attributes.splice(idx, 1);
        $(this).triggerHandler('delAttribute');
        $(this).triggerHandler('change');
    };

    this.getAttribute = function(idx) { return _attributes[idx]; };
    this.getCount = function() { return _attributes.length; };
    this.each = function(callback, addInternalColumns) {
        for (var k = 0; k < _attributes.length; k++) {
            var column = _attributes[k];
            var isInternal = column.IsPrimary || column.IsIdentity || column.IsComputed ||
                             column.type.server === 'geometry' || (isRCLayer && column.name === 'GMX_RasterCatalogID');

            if (!isInternal || addInternalColumns) {
                callback(column, k);
            }
        }
    };

    this.moveAttribute = function(oldIdx, newIdx) {
        if (newIdx > oldIdx) {
            newIdx--;
        }

        if (oldIdx !== newIdx) {
            _attributes.splice(newIdx, 0, _attributes.splice(oldIdx, 1)[0]);
            $(this).triggerHandler('moveAttribute');
            $(this).triggerHandler('change');
        }
    };

    this.initFromServerFormat = function(serverColumns) {
        _attributes = [];
        $.each(serverColumns || [], function(i, column) {
            var type = window._.find(nsGmx.ManualAttrModel.TYPES, function(elem) {return elem.server === column.ColumnSimpleType.toLowerCase();});
            _attributes.push({
                type: type || {server: column.ColumnSimpleType.toLowerCase()},
                name: column.Name,
                oldName: column.Name,
                IsPrimary: column.IsPrimary,
                IsIdentity: column.IsIdentity,
                IsComputed: column.IsComputed
            });
        });
        $(this).triggerHandler('newAttribute');
        $(this).triggerHandler('change');
    };

    this.toServerFormat = function() {
        var res = [];
        $.each(_attributes, function(i, attr) {
            res.push({
                Name: attr.name,
                OldName: attr.oldName,
                ColumnSimpleType: capitaliseFirstLetter(attr.type.server),
                IsPrimary: attr.IsPrimary,
                IsIdentity: attr.IsIdentity,
                IsComputed: attr.IsComputed});
        });

        return res;
    };
};

nsGmx.ManualAttrModel.TYPES = {
    DOUBLE:   {user: 'Float',    server: 'float'},
    INTEGER:  {user: 'Integer',  server: 'integer'},
    STRING:   {user: 'String',   server: 'string'},
    TIME:     {user: 'Time',     server: 'time'},
    DATE:     {user: 'Date',     server: 'date'},
    DATETIME: {user: 'DateTime', server: 'datetime'},
    BOOL:     {user: 'Boolean',  server: 'boolean'}
};

})();

(function() {
var utils = nsGmx.Utils;
_translationsHash.addtext('rus', {ManualAttrView: {
    headerName: 'Название',
    headerType: 'Тип'
}});

_translationsHash.addtext('eng', {ManualAttrView: {
    headerName: 'Name',
    headerType: 'Type'
}});


var selectorTemplate = Handlebars.compile('<select class="selectStyle customAttr-typesselect">' +
        '{{#each types}}' +
            '<option value="{{server}}" id="{{server}}"{{#if @root.isSelected}} selected{{/if}}>{{user}}</option>' +
        '{{/each}}' +
    '</select>'
);

nsGmx.ManualAttrView = function()
{
    var _parent = null;
    var _model = null;
    var _trs = [];
    var _isActive = true;
    var _this = this;
    var isAddingNew = false;

    var createTypeSelector = function(selectedType)
    {
        return $(selectorTemplate({
            types: nsGmx.ManualAttrModel.TYPES,
            isSelected: function() {
                return this.server === selectedType;
            }
        }));
    };

    var createRow = function(attr, i) {
        var typeSelector = createTypeSelector(attr.type.server)[0];
        $(typeSelector).data('idx', i);

        $(typeSelector).change(function() {
            var serverType = $('option:selected', this).val(),
                attrType = window._.findWhere(nsGmx.ManualAttrModel.TYPES, {server: serverType});

            _model.changeType($(this).data('idx'), attrType);
        });

        var nameSelector = utils._input(null, [['attr', 'class', 'customAttrNameInput inputStyle'], ['css', 'width', '120px']]);

        $(nameSelector).data('idx', i).val(attr.name);

        var deleteIcon = utils.makeImageButton('img/recycle.png', 'img/recycle_a.png');
        var tr = utils._tr([utils._td([nameSelector]), utils._td([typeSelector]), utils._td([deleteIcon])]);
        $(nameSelector).on('keyup', function()
        {
            var idx = $(this).data('idx');
            var name = $(this).val();

            if (idx >= 0) {
                _model.changeName(idx, name);
            } else if (name) {
                isAddingNew = true;
                $(tr).find('td:gt(0)').show();
                $(tr).removeClass('customAttributes-new');
                var newIdx = _model.addAttribute(nsGmx.ManualAttrModel.TYPES.STRING, name);
                $([nameSelector, typeSelector, deleteIcon]).data('idx', newIdx);
                isAddingNew = false;
            }
        });

        $(deleteIcon).addClass('removeIcon').data('idx', i);
        deleteIcon.onclick = function()
        {
            _model.deleteAttribute($(this).data('idx'));
        };

        return tr;
    };

    var redraw = function()
    {
        if (!_model || isAddingNew) { return; }

        $(_parent).empty();
        _trs = [];

        _model.each(function(attr, i) {
            _trs.push(createRow(attr, i));
        });

        var newAttr = createRow({name: '', type: nsGmx.ManualAttrModel.TYPES.STRING}, -1);
        $(newAttr).find('td:gt(0)').hide();
        $(newAttr).addClass('customAttributes-new');

        _trs.push(newAttr);

        var tbody = nsGmx.Utils._tbody(_trs);
        var theader = $(Handlebars.compile('<thead><tr><th>{{i "ManualAttrView.headerName"}}</th><th>{{i "ManualAttrView.headerType"}}</th></tr></thead>')());

        $(_parent).append($('<fieldset/>').css('border', 'none').append(nsGmx.Utils._table([theader[0], tbody], [['dir', 'className', 'customAttributes']])));
        _this.setActive(_isActive);
    };

    this.setActive = function(isActive) {
        _isActive = isActive;
        var fieldset = $(_parent).children('fieldset');
        if (isActive) {
            fieldset.removeAttr('disabled');
        } else {
            fieldset.attr('disabled', 'disabled');
        }
        $('.removeIcon, .customAttributes-new', fieldset).toggle(isActive);
    };

    this.init = function(parent, model)
    {
        _parent = parent;
        _model = model;
        $(_model).on('newAttribute delAttribute moveAttribute', redraw);

        $(_model).on('newAttribute', function() {
            if (!$(_parent).find('.customAttributes-new').length) {
                var newAttr = createRow({name: '', type: nsGmx.ManualAttrModel.TYPES.STRING}, -1);
                $(newAttr).find('td:gt(0)').hide();
                $(newAttr).addClass('customAttributes-new');
                $(_parent).find('tbody').append(newAttr);
            }
        });
        redraw();
    };
};

})();

(function() {

Handlebars.registerPartial('TemporalLayerWidgetOptions',
    '{{#periods}}<option name="{{.}}">{{.}}</option>{{/periods}}'
);

_translationsHash.addtext('rus', {
    'Макс. период на экране': 'На экране не более',
    'Тайлы с': 'Тайлы с',
    'Тайлы по дням до': 'Тайлы по дням до',
    'дней': 'дней'
});

_translationsHash.addtext('eng', {
    'Макс. период на экране': 'Max period to show',
    'Тайлы с': 'Tiles from',
    'Тайлы по дням до': 'Max tiling period',
    'дней': 'days'
});

/** Создаёт виджет для задания мультивременных параметров слоя
* @class
* @param {HTMLNode} parentDiv контейнер для размещения виджета
* @param {nsGmx.TemporalLayerParams} paramsModel начальные параметры
* @param {String[]} columns массив имён колонок, из которых можно выбрать врменнУю
*/
nsGmx.TemporalLayerParamsWidget = function(parentDiv, paramsModel, columns)
{
    var PERIODS = [1, 16, 256];
    // var optionsHtml = '{{#periods}}<option name="{{.}}">{{.}}</option>{{/periods}}';

    var template = Handlebars.compile(
        '<table><tbody>' +
            '<tr>' +
                '<td>{{i "Макс. период на экране"}}</td>' +
                '<td><input id="maxShownPeriod" class="inputStyle temporal-maxshow"></input> <span>{{i "дней"}}</span> </td>' +
            '</tr>' +
            '<tr class="temporal-columns">' +
                '<td>{{i "Колонка даты"}}</td>' +
                '<td><select id="columnSelect" class="selectStyle"></select></td>' +
            '</tr>' +
            // '<tr class="temporal-advanced">' +
            //     '<td>{{i "Тайлы с"}}</td>' +
            //     '<td><select id="minPeriod" class="selectStyle">{{>TemporalLayerWidgetOptions}}</select></td>' +
            // '</tr>' +
            '<tr class="temporal-advanced">' +
                '<td>{{i "Тайлы по дням до"}}</td>' +
                '<td><select id="maxPeriod" class="selectStyle">{{>TemporalLayerWidgetOptions}}</select></td>' +
            '</tr>' +
        '</tbody></table>' +
        '<span class="buttonLink RCCreate-advanced-link">{{i "LayerRCControl.advancedLink"}}</span>');

    $(parentDiv).html(template({periods: PERIODS}));

    var _columns = columns;
    var isAdvancedMode =
            paramsModel.get('minPeriod') !== paramsModel.defaults.minPeriod ||
            paramsModel.get('maxPeriod') !== paramsModel.defaults.maxPeriod;

    var wasInAdvancedMode = isAdvancedMode;
    var updateVisibility = function() {
        // var isTemporal = paramsModel.get('isTemporal');
        $('.temporal-advanced', parentDiv).toggle(isAdvancedMode);
        $('.RCCreate-advanced-link', parentDiv).toggle(!isAdvancedMode);
        $('.temporal-columns', parentDiv).toggle(_columns.length > 1);
    };

    var updateColumnsSelect = function()
	{
        var selectDateColumn = $('#columnSelect', parentDiv);
		var curColumn = paramsModel.get('columnName');
		var foundOption = null;

		selectDateColumn.empty();
		for (var i = 0; i < _columns.length; i++) {
			var option = $('<option></option>').text(_columns[i]);
			selectDateColumn.append(option);
			if (curColumn === _columns[i]) {
				foundOption = option;
			}
		}

		if (foundOption) {
			foundOption.attr('selected', 'selected');
		} else if (_columns.length) {
			paramsModel.set('columnName', _columns[0]);
		}
	};

    updateVisibility();

    $('.RCCreate-advanced-link', parentDiv).click(function() {
        isAdvancedMode = !isAdvancedMode;
        wasInAdvancedMode = true;
        updateVisibility();
    });

    paramsModel.on('change:isTemporal', updateVisibility);

    updateColumnsSelect();
    $('#columnSelect', parentDiv).change(function()
    {
        paramsModel.set('columnName', $('option:selected', this).val());
    });

    $('#minPeriod>option[name=' + paramsModel.get('minPeriod') + ']', parentDiv).attr('selected', 'selected');
    $('#minPeriod', parentDiv).change(function()
    {
        paramsModel.set('minPeriod', $('option:selected', this).val());
    });

    $('#maxPeriod>option[name=' + paramsModel.get('maxPeriod') + ']', parentDiv).attr('selected', 'selected');
    $('#maxPeriod', parentDiv).change(function()
    {
        paramsModel.set('maxPeriod', $('option:selected', this).val());
    });

    $('#maxShownPeriod', parentDiv).val(paramsModel.get('maxShownPeriod') || '').bind('keyup', function()
    {
        var val = parseInt(this.value) || 0;

        var paramsToSet = {maxShownPeriod: Math.max(0, val)};

        if (!wasInAdvancedMode) {
            if (val > 0) {
                var index = Math.ceil(Math.log(val) / Math.log(4));
                paramsToSet.maxPeriod = PERIODS[Math.min(PERIODS.length - 1, index)];
            } else {
                paramsToSet.maxPeriod = paramsModel.defaults.maxPeriod;
            }
            $('#maxPeriod>option[name=' + paramsToSet.maxPeriod + ']', parentDiv).attr('selected', 'selected');
        }

        paramsModel.set(paramsToSet);
    });

    /**
        Обновляет список доступных для выбора колонок даты
        @param {String[]} columns массив имён колонок
    */
	this.updateColumns = function(columns)
	{
		_columns = columns;
		updateColumnsSelect();
        updateVisibility();
	};
};

})();

!function($) {
    _translationsHash.addtext('rus', {LayerRCControl: {
        minZoom         : 'Мин. зум',
        titleTemplate   : 'Шаблон имени',
        pathTemplate    : 'Шаблон тайлов',
        advancedLink    : 'Дополнительно',
        layerTagTitle   : 'Параметр слоя',
        attributeTitle  : 'Атрибут объекта'
    }});

    _translationsHash.addtext('eng', {LayerRCControl: {
        minZoom         : 'Min zoom',
        titleTemplate   : 'Title template',
        pathTemplate    : 'Path template',
        advancedLink    : 'Advanced',
        layerTagTitle   : 'Layer parameter',
        attributeTitle  : 'Object Attribute'
    }});

    nsGmx.LayerRCProperties = Backbone.Model.extend({
        defaults: {
            IsRasterCatalog: false,
            RCMinZoomForRasters: 0,
            RCMaskForRasterTitle: '',
            RCMaskForRasterPath: '',
            ColumnTagLinks: {}
        },
        isAnyLinks: function() {
            return window._.size(this.attributes.ColumnTagLinks) > 0;
        }
    });

    /**
    Контрол для задания параметров каталогов растров
    @memberOf nsGmx
    @class
    */
    nsGmx.LayerRasterCatalogWidget = function(container, rcProperties)
    {
        var advancedMode = !!(
                rcProperties.get('RCMaskForRasterPath') ||
                rcProperties.get('RCMaskForRasterTitle') ||
                rcProperties.isAnyLinks()
            );

        var updateVisibility = function()
        {
            // var isRasterCatalog = rcProperties.get('IsRasterCatalog');
            $('.RCCreate-advanced', container).toggle(advancedMode);
            $('.RCCreate-advanced-link', container).toggle(!advancedMode);
            $('.RCCreate-tagContainer', container).toggle(advancedMode);
        };

        rcProperties.on('change:IsRasterCatalog', updateVisibility);

        var RCCheckbox = $('<input/>', {type: 'checkbox', 'class': 'RCCreate-checkbox'}).change(function() {
            rcProperties.set('IsRasterCatalog', RCCheckbox[0].checked);
        });

        var advancedParamsLink = $(window.makeLinkButton(_gtxt('LayerRCControl.advancedLink'))).addClass('RCCreate-advanced-link').click(function()
        {
            advancedMode = !advancedMode;
            updateVisibility();
        });

        RCCheckbox[0].checked = rcProperties.get('IsRasterCatalog');

        var minZoomInput = $('<input/>', {'class': 'inputStyle RCCreate-zoom-input'}).val(rcProperties.get('RCMinZoomForRasters') || '').bind('keyup change', function() {
            rcProperties.set('RCMinZoomForRasters', parseInt(this.value));
        });

        var titleInput = $('<input/>', {'class': 'inputStyle'}).val(rcProperties.get('RCMaskForRasterTitle') || '').bind('keyup change', function() {
            rcProperties.set('RCMaskForRasterTitle', this.value);
        });

        var pathInput = $('<input/>', {'class': 'inputStyle'}).val(rcProperties.get('RCMaskForRasterPath') || '').bind('keyup change', function() {
            rcProperties.set('RCMaskForRasterPath', this.value);
        });

        // var RCParamsTable =
            $('<table/>', {'class': 'RCCreate-params'})
                .append($('<tr/>')
                    .append($('<td/>').text(_gtxt('LayerRCControl.minZoom')).css('padding-right', '6px'))
                    .append($('<td/>').append(minZoomInput)))
                .append($('<tr/>', {'class': 'RCCreate-advanced'})
                    .append($('<td/>').text(_gtxt('LayerRCControl.titleTemplate')))
                    .append($('<td/>').append(titleInput)))
                .append($('<tr/>', {'class': 'RCCreate-advanced'})
                    .append($('<td/>').text(_gtxt('LayerRCControl.pathTemplate')))
                    .append($('<td/>').append(pathInput)))
                .appendTo(container);

        nsGmx.TagMetaInfo.loadFromServer(function(realTagInfo)
        {
            var realTagsInfo = realTagInfo.getTagArrayExt();
            var fakeTagsInfo = {};
            for (var iT = 0; iT < realTagsInfo.length; iT++)
            {
                var info = realTagsInfo[iT];
                fakeTagsInfo[info.name] = {Type: 'String', Description: info.descr};
            }
            var fakeTagManager = new nsGmx.TagMetaInfo(fakeTagsInfo);

            var initTags = {};

            var columnTagLinks = rcProperties.get('ColumnTagLinks');

            for (var iP in columnTagLinks)
                initTags[columnTagLinks[iP]] = {Value: iP};

            var layerTags = new nsGmx.LayerTagsWithInfo(fakeTagManager, initTags);

            var tagContainer = $('<div/>', {'class': 'RCCreate-tagContainer RCCreate-advanced'}).addClass().appendTo(container);
            var tagsControl = new nsGmx.LayerTagSearchControl(layerTags, tagContainer, {
                inputWidth: 100,
                tagHeader: _gtxt('LayerRCControl.layerTagTitle'),
                valueHeader: _gtxt('LayerRCControl.attributeTitle')
            });

            $(layerTags).change(function() {
                var columnTagLinks = {};
                layerTags.eachValid(function(id, tag, value) { columnTagLinks[value] = tag;});
                rcProperties.set('ColumnTagLinks', columnTagLinks);
            });

            advancedParamsLink.appendTo(container);

            updateVisibility();
        });
    };
}(jQuery);

!function($) {
    _translationsHash.addtext('rus', {LayerQuicklookWidget: {
        minZoom: 'Мин. зум',
        regTitle: 'Атрибуты привязки',
        title: 'Показать'
    }});

    _translationsHash.addtext('eng', {LayerQuicklookWidget: {
        minZoom: 'Min zoom',
        regTitle: 'Registration fields',
        title: 'Expand'
    }});

    var template = Handlebars.compile('<div>' +
        '{{#if isMinimized}}<span class="lqw-title buttonLink">{{i "LayerQuicklookWidget.title"}}</span>{{/if}}' +
        '<div class="lqw-container" {{#if isMinimized}}style="display:none"{{/if}}>' +
            '<div>{{i "LayerQuicklookWidget.minZoom"}}<input class="lqw-minzoom-input inputStyle" value="{{minZoom}}"></div>' +
            '<textarea class="inputStyle lqw-textarea">{{quicklook}}</textarea>' +
            '<div class="suggest-link-container">{{i "Атрибут >"}}</div>' +
            '<div class="lqw-registration-link">{{i "LayerQuicklookWidget.regTitle"}}</div>' +
            '<table class="lqw-registration-container">' +
                '{{#points}}' +
                    '<tr><td>X{{idx}}{{../regSelect "X"}}</td><td>Y{{idx}}{{../regSelect "Y"}}</td></tr>' +
                '{{/points}}' +
            '</table>' +
        '</div>' +
    '</div>');

    var selectTemplate = Handlebars.compile('<select data-name="{{targetName}}" class="lqw-point-select selectStyle">' +
        '{{#opts}}' +
            '<option value="{{name}}"{{#if isDefault}} selected{{/if}}>{{name}}</option>' +
        '{{/opts}}' +
    '</select>');

    /**
    Виджет для задания параметров слоя, связанных с показом квиклуков
    @memberOf nsGmx
    @class
    */
    nsGmx.LayerQuicklookWidget = function(container, layerProperties) {
        var DEFAULT_OPTION = {name: '', isDefault: false};

        var layerColumns = window._.pluck(layerProperties.get('Columns'), 'Name'),
            quicklookParams = layerProperties.get('Quicklook');

        var ui = $(template({
            isMinimized: !quicklookParams.get('template'),
            minZoom: quicklookParams.get('minZoom'),
            quicklook: quicklookParams.get('template'),
            points: Array.apply(null, {length: 4}).map(function(elem, index) { return {idx: index + 1};}),
            regSelect: function(label) {
                var targetName = (label + this.idx),
                    initValue = (quicklookParams.get(targetName) || targetName).toLowerCase();
                return new Handlebars.SafeString(selectTemplate({
                    targetName: targetName,
                    opts: [].concat(DEFAULT_OPTION, layerColumns.map(function(column) {
                        return {
                            name: column,
                            isDefault: column.toLowerCase() === initValue
                        };
                    }))
                }));
            }
        }));

        ui.find('.lqw-title').click(function() {
            ui.find('.lqw-title').hide();
            ui.find('.lqw-container').show();
        });

        var updateRegistrationStatus = function() {
            ui.find('td').each(function(index, td) {
                $(td).toggleClass('lqw-reg-error', !$(td).find('option:selected').val());
            });
        };

        ui.find('.lqw-minzoom-input').on('change keyup', function() {
            var minZoom = Number(this.value);
            quicklookParams.set('minZoom', minZoom);
        });

        ui.find('select').change(function() {
            updateRegistrationStatus();
            var name = $(this).data('name');
            quicklookParams.set(name, this.value || undefined);
        });

        updateRegistrationStatus();

        if (ui.find('.lqw-reg-error').length === 0) {
            ui.find('.lqw-registration-container').hide();
            ui.find('.lqw-registration-link').addClass('buttonLink').click(function() {
                $(this).removeClass('buttonLink');
                ui.find('.lqw-registration-container').show();
            });
        }

        var quicklookText = ui.find('.lqw-textarea');

        var setQuicklook = function() {
            layerProperties.get('Quicklook').set('template', quicklookText.val());
        };

        var suggestWidget = new nsGmx.SuggestWidget(layerProperties.get('Attributes') || [], quicklookText[0], '[suggest]', setQuicklook);

        quicklookText.on('focus', function() {
            $(suggestWidget.el).hide();
        });

        ui.find('.suggest-link-container')
            .append(suggestWidget.el)
            .click(function() {
                if (suggestWidget.el.style.display === 'none') {
                    $(suggestWidget.el).fadeIn(500);
                }
            });

        quicklookText.on('keyup change', setQuicklook);

        ui.appendTo(container);
    };
}(jQuery);

!(function() {

'use strict';

nsGmx.AttrTable = nsGmx.AttrTable || {};

var attrsTable = function(layerName, layerTitle)
{
	this.layerName = layerName;
	this.layerTitle = layerTitle || '';

	this.filterData = null;

	this.activeColumns = null;

	this.resizeFunc = function() {};

    this._updateVersionHandler = null;

    this._isLayerOnMap = this.layerName in nsGmx.gmxMap.layersByID;

    this.tableFields = {
        fieldsAsArray: [],
        fieldsAsHash: {},
        titleToField: {},
        init: function(fieldParams, info) {
            var _this = this;
            this.fieldsAsHash = {};
            this.titleToField = {};
            this.fieldsAsArray = [];
            if (!fieldParams) {
                this.fieldsAsArray = [info.identityField].concat(info.attributes);
                this.fieldsAsArray.forEach(function(name) {
                    _this.fieldsAsHash[name] = true;
                    _this.titleToField[name] = name;
                });
            } else {
                fieldParams.forEach(function(field) {
                    _this.fieldsAsArray.push(field.title);
                    _this.fieldsAsHash[field.title] = true;
                    _this.titleToField[field.title] = field.name;
                });
            }
        }
    };
};

attrsTable.prototype.getLayerInfo = function()
{
    return this._layerInfo;
};

attrsTable.prototype.getInfo = function(origCanvas, outerSizeProvider, params)
{
	if (!origCanvas && $('#attrsTableDialog' + this.layerName).length) {
		return;
	}

    origCanvas && $(origCanvas).empty();

	var canvas = origCanvas || nsGmx.Utils._div(null, [['attr', 'id', 'attrsTableDialog' + this.layerName], ['css', 'overflow', 'hidden']]),
		loading = nsGmx.Utils._div([nsGmx.Utils._img(null, [['attr', 'src', 'img/progress.gif'], ['css', 'marginRight', '10px']]), nsGmx.Utils._t(_gtxt('загрузка...'))], [['css', 'margin', '3px 0px 3px 20px']]),
		_this = this;

	nsGmx.Utils._(canvas, [loading]);

    if (!origCanvas)
    {
        outerSizeProvider = function() {
            return {
                width: canvas.parentNode.parentNode.offsetWidth,
                height: canvas.parentNode.offsetHeight
            };
        };

        nsGmx.Utils.showDialog(_gtxt('Таблица атрибутов слоя [value0]', this.layerTitle), canvas,
            {
                width: 820,
                height: 520,
                resizeFunc: function()
                {
                    this.resizeFunc.apply(this, arguments);
                }.bind(this),
                closeFunc: function()
                {
                    if (_this._updateVersionHandler !== null && _this._isLayerOnMap) {
                        nsGmx.gmxMap.layersByID[_this.layerName].off('versionchange', _this._updateVersionHandler);
                    }
                },
                setMinSize: false
            }
        );
    }

	sendCrossDomainJSONRequest(window.serverBase + 'Layer/GetLayerJson.ashx?WrapStyle=func&LayerName=' + this.layerName, function(response)
	{
		if (!window.parseResponse(response)) {
			return;
		}

		loading.removeNode(true);

        _this._layerInfo = response.Result.properties;

        _this._layerColumns = [
            {Value: 'GeomIsEmpty([geomixergeojson])', Alias: '__GeomIsEmpty__'},
            {Value: '[' + response.Result.properties.identityField + ']'}
        ];

        var attrs = response.Result.properties.attributes;
        for (var k = 0; k < attrs.length; k++) {
            _this._layerColumns.push({Value: '[' + attrs[k] + ']'});
        }

		_this.drawDialog(response.Result.properties, canvas, outerSizeProvider, params);
	});
};

attrsTable.prototype._updateSearchString = function(query) {
    this._serverDataProvider.setRequests(
        window.serverBase + 'VectorLayer/Search.ashx', {layer: this.layerName, query: query, count: true},
        window.serverBase + 'VectorLayer/Search.ashx', {layer: this.layerName, query: query, columns: JSON.stringify(this._layerColumns)}
    );
};

/*
* columnsList (extracted from searchParamsManager)
*/
attrsTable.prototype.createColumnsList = function(paramsManager) {
	var _this = this,
	 	info = this._layerInfo,
	 	paramsWidth = 300,
		columnsList = nsGmx.Utils._div(null, [['dir', 'className', 'attrsColumnsList'], ['css', 'overflowY', 'auto']]);//

	var attrTitles = this.tableFields.fieldsAsArray;
	   if (!paramsManager._activeColumns) {
	       paramsManager._activeColumns = {};

	       for (var i = 0; i < attrTitles.length; ++i) {
	           paramsManager._activeColumns[attrTitles[i]] = true;
			}
	   }

	   var presentColumns = false;

	   for (var key in paramsManager._activeColumns) {
		   if (paramsManager._activeColumns.hasOwnProperty(key)) {
			   if (paramsManager._activeColumns[key] === true) {
				   presentColumns = true;
				   break;
			   }
		   }
	   }

	   var showColumnsTemplate =
		   '<div class="attrs-table-show-columns-header">' +
			   '<label title="{{name}}" class="attrs-table-show-columns">' +
				   '<input type="checkbox" class="box attrs-table-show-columns-checkbox" {{#active}}checked{{/active}}></input>' +
				   '{{name}}' +
			   '</label>' +
		   '</div>';

	   var selectColumnsUI = $(Handlebars.compile(showColumnsTemplate)({
		   active: presentColumns,
		   name: (window._gtxt('Колонки') + ':')
	   })).appendTo(columnsList);

	   var rowTemplate =
		   '<label title="{{name}}" class="attrs-table-active-row">' +
			   '<input type="checkbox" class="box attrs-table-active-checkbox" {{#active}}checked{{/active}}></input>' +
			   '{{name}}' +
		   '</label>';

	   attrTitles.forEach(function(columnName) {
		   var rowUI = $(Handlebars.compile(rowTemplate)({
			   active: paramsManager._activeColumns[columnName],
			   name: columnName
		   })).appendTo(columnsList);

		   $('input', rowUI).click(function() {
			   paramsManager._activeColumns[columnName] = this.checked;
			   $(paramsManager).trigger('columnsChange');
		   });
	   });

	   $('input', selectColumnsUI).click(function() {
		   var checked = this.checked;
		   for (var key in paramsManager._activeColumns) {
			   if (paramsManager._activeColumns.hasOwnProperty(key)) {
				   paramsManager._activeColumns[key] = checked;
				   $(paramsManager).trigger('columnsChange');
				   $('input', columnsList).each(function (elem) {
					   $(this).prop('checked', checked);
				   });
			   }
		   }
	   });

	   columnsList.onmouseleave = function () {
		   this.style.display = 'none';
	   }

	   return columnsList;
};

attrsTable.prototype.drawDialog = function(info, canvas, outerSizeProvider, params)
{
    var _params = $.extend({
        hideDownload: false,
        hideActions: false,
        hideRowActions: false,
        hideSearchParams: false,
        onClick: null,
        searchParamsManager: new nsGmx.AttrTable.DefaultSearchParamsManager()
        /*attributes: [] */
    }, params);

	var paramsWidth = 300,
		tdParams = nsGmx.Utils._td(null, [['css', 'width', paramsWidth + 'px'], ['attr', 'vAlign', 'top']]),
		tdTable = nsGmx.Utils._td(null, [['attr', 'vAlign', 'top']]),
		findObjectsButton = nsGmx.Utils.makeLinkButton(_gtxt('Найти объекты')),
		updateObjectsButton = nsGmx.Utils.makeLinkButton(_gtxt('Обновить объекты')),
		addObjectButton = nsGmx.Utils.makeLinkButton(_gtxt('Добавить объекты')),
		changeFieldsListButton = nsGmx.Utils.makeLinkButton(_gtxt('Изменить колонки')),
		oldCanvasWidth = false,
		_this = this;

    var downloadSection = $(Handlebars.compile('<div>' +
        '<span class="buttonLink attrsDownloadLink" data-format="Shape">{{i "Скачать shp"}}</span>' +
        '{{#unless isPolygon}}' +
		'<span class="buttonLink attrsDownloadLink" data-format="gpx">{{i "Скачать gpx"}}</span>' +
		'{{/unless}}' +
        '<span class="buttonLink attrsDownloadLink" data-format="csv">{{i "Скачать csv"}}</span>' +
        '<span class="buttonLink attrsDownloadLink" data-format="geojson">{{i "Скачать geojson"}}</span>' +
        '<span class="buttonLink createLayerLink">{{i "Создать слой"}}</span>' +
        '{{#if isPolygon}}<span class="buttonLink attrs-table-square-link">{{i "Рассчитать площадь"}}</span>{{/if}}' +
    '</div>')({
        isPolygon: info.GeometryType === 'polygon'
    }));

	$(findObjectsButton).addClass('attr-table-find-button');
	$(updateObjectsButton).addClass('attr-table-update-button');
	/*temp*/
	// $(updateObjectsButton).addClass('gmx-disabled');
	/*temp end*/
	$(addObjectButton).addClass('attr-table-add-button');
	$(changeFieldsListButton).addClass('attr-table-list-button');

    downloadSection.find('.attrsDownloadLink').click(function() {
        downloadLayer($(this).data('format'));
    });

	// создание слоя из выборки (из атрибутивной таблицы)
    downloadSection.find('.createLayerLink').click(function() {
		sendCrossDomainJSONRequest(serverBase + "Layer/GetLayerInfo.ashx?WrapStyle=func&NeedAttrValues=false&LayerName=" + info.name, function(response) {
			if (!parseResponse(response)) {
				return;
			}

			createEditorFromSelection(response.Result);

			function createEditorFromSelection(props) {
				var query = _params.searchParamsManager.getQuery(),
					activeColumns = _params.searchParamsManager.getActiveColumns(),
					filteredColumns = [];

				// get columns list from search filter
				props.Columns.forEach(function(col) {
					if (col.Name in activeColumns && activeColumns[col.Name]) {
						filteredColumns.push(col);
					}
				})

				var parent = nsGmx.Utils._div(null, [['attr','id','new' + 'Vector' + 'Layer'], ['css', 'height', '100%']]),
					properties = {
						Title:  props.Title + ' ' + _gtxt('копия'),
						Copyright: props.Copyright,
						Description: props.Description,
						Date: props.Date,
						MetaProperties: props.MetaProperties,
						TilePath: {
							Path: ''
						},
						ShapePath: props.ShapePath,
						Columns: filteredColumns,
						IsRasterCatalog: props.IsRasterCatalog,
						SourceType: "file",
						Quicklook: props.Quicklook
					},
					dialogDiv = nsGmx.Utils.showDialog(_gtxt('Создать векторный слой'), parent, 340, 340, false, false),
					params = {
						copy: true,
						sourceLayerName: info.name,
						query: query,
						doneCallback: function(res) {
							nsGmx.Utils.removeDialog(dialogDiv);
						}
					};

				nsGmx.createLayerEditor(false, 'Vector', parent, properties, params);
			}
		});
    });

    this.tableFields.init(_params.attributes, info);

    this._serverDataProvider = new nsGmx.AttrTable.ServerDataProvider({titleToParams: $.extend(this.tableFields.titleToField, {'': '__GeomIsEmpty__'})});

    var squareLink = downloadSection.find('.attrs-table-square-link');

    new nsGmx.AttrTable.SquareCalc(squareLink, this.layerName, this._serverDataProvider, _params.searchParamsManager);

    var hostName = window.serverBase.match(/^https?:\/\/(.*)\/$/)[1];

    this._updateSearchString('');

	var searchParamsManager = _params.searchParamsManager;
	$(searchParamsManager).on({
		queryChange: function() {
			_this.offset = 0;
			_this._updateSearchString(searchParamsManager.getQuery());
		},
		columnsChange: function() {
			var columns = searchParamsManager.getActiveColumns ? searchParamsManager.getActiveColumns() : _this.tableFields.fieldsAsHash;
			for (var k in columns) {
				_this.table2.activateField(k, columns[k]);
			}
		}
	});

    var downloadLayer = function(format) {
        var activeColumns = searchParamsManager.getActiveColumns ? searchParamsManager.getActiveColumns() : _this.tableFields.fieldsAsHash,
            columnsForServer = [];

        for (var c in activeColumns) {
            if (activeColumns[c]) {
                columnsForServer.push({
                    Value: '[' + _this.tableFields.titleToField[c] + ']',
                    Alias: c
                });
            }
        }

        _mapHelper.downloadVectorLayer({
            name: _this.layerName,
            host: hostName,
            format: format,
            query: _params.searchParamsManager.getQuery(),
            columns: columnsForServer
        });
    };

	findObjectsButton.onclick = function() {
		tdParams.innerHTML = '';

		oldCanvasWidth = outerSizeProvider().width;

		searchParamsManager.drawSearchUI(tdParams, _this);

		if (tdParams.style.display === 'none') {
			tdParams.style.display = '';
		} else {
			return;
		}

		resizeFunc();
	};

   findObjectsButton.style.marginRight = '10px';

   updateObjectsButton.onclick = function() {
	   if ($(findObjectsButton).hasClass('gmx-disabled')) {
		   $(findObjectsButton).removeClass('gmx-disabled');
	   }

	   tdParams.innerHTML = '';

	   oldCanvasWidth = outerSizeProvider().width;

	   searchParamsManager.drawUpdateUI(tdParams, _this);

	   if (tdParams.style.display === 'none') {
		   tdParams.style.display = '';
	   } else {
		   return;
	   }

	   resizeFunc();
   };

   updateObjectsButton.style.marginRight = '10px';

	addObjectButton.onclick = function() {
        new nsGmx.EditObjectControl(_this.layerName);
	};

	addObjectButton.style.marginRight = '10px';

    if (_params.hideActions) {
        $(addObjectButton).hide();
	}

	changeFieldsListButton.onclick = function() {
		var div;
		if (info.MultiLayerID) {
			div = $(_queryMapLayers.buildedTree).find("div[MultiLayerID='" + info.MultiLayerID + "']")[0];
		} else {
			div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + info.name + "']")[0];
		}
		_mapHelper.createLayerEditor(div, false, 'attrs', div.gmxProperties.content.properties.styles.length > 1 ? -1 : 0);
	};

	changeFieldsListButton.style.marginRight = '10px';

	tdParams.style.display = 'none';

	var name = 'attrsTable' + info.name;

    var attrNames = this.tableFields.fieldsAsArray;
    var fielsWidth = new Array(_params.hideRowActions ? attrNames.length : attrNames.length + 1).join('0').split('0');
    var attrNamesHash = this.tableFields.fieldsAsHash;

    _params.hideDownload && downloadSection.hide();

    this.divTable2 = nsGmx.Utils._div(null, [['css', 'overflow', 'auto'], ['dir', 'className', 'attrsTableBody']]);

	var columnsList = this.createColumnsList(_params.searchParamsManager);
	columnsList.style.display = 'none';

    var selectAllItems = nsGmx.Utils._checkbox(false, 'checkbox'),
		selectedCount = nsGmx.Utils._span([], [['attr', 'class', 'selectedCount']]),
		selectedDelete = nsGmx.Utils.makeLinkButton(_gtxt('Удалить')),
		showColumnsListButton = nsGmx.Utils.makeLinkButton(_gtxt('Показывать колонки')),
		// selectedCopy = nsGmx.Utils.makeLinkButton(_gtxt('Скопировать')),
		// selectedDownload = nsGmx.Utils.makeLinkButton(_gtxt('Скачать')),
		selectedCont = nsGmx.Utils._span([
			nsGmx.Utils._t('Выбрано объектов:'),
			selectedCount,
			selectedDelete,
			// selectedCopy,
			// selectedDownload
		], [['attr', 'class', 'hiddenCommands']]),
		groupBox = nsGmx.Utils._div([
			selectAllItems,
			nsGmx.Utils._span([nsGmx.Utils._t('Выделить все на странице')], [['css', 'marginLeft', '5px'], ['css', 'verticalAlign', 'top']]),
			selectedCont,
			showColumnsListButton,
			columnsList
		], [
			['attr', 'class', 'attrsSelectedCont']
		]);

	selectAllItems.onchange = function() {
		var table2 = _this.table2;
		table2.getVisibleItems().forEach(function(it) {
			var id = it.values[1];
			if (selectAllItems.checked) { _this._selected[id] = true; }
			else  { delete _this._selected[id]; }
		});
		chkSelectedCount();
		table2.repaint();
	};
	selectedCount.innerHTML = 0;
    this._selected = {};

	selectedDelete.onclick = function() {
		var remove = nsGmx.Utils.makeButton(_gtxt('Удалить'));
		remove.onclick = function() {
            var arr = Object.keys(_this._selected).reduce(function(p, c) {
                p.push({action: 'delete', id: c});
                return p;
            }, []);
			_mapHelper.modifyObjectLayer(_this.layerName, arr).done(function() {
				nsGmx.Utils.removeDialog(jDialog);
				clearSelected();
			});
		};

		var offset = $(selectedDelete).offset();
		var jDialog = nsGmx.Utils.showDialog(_gtxt('Удалить отмеченные объекты?'), nsGmx.Utils._div([remove], [['css', 'textAlign', 'center']]), 280, 75, offset.left + 20, offset.top - 30);
	};

	$(showColumnsListButton).addClass('show-columns-list-button');

	showColumnsListButton.onclick = function() {
		if (columnsList.style.display === 'none') {
			$(columnsList).show();
		}
	}

	var manageSection = nsGmx.Utils._div([findObjectsButton, updateObjectsButton, addObjectButton, changeFieldsListButton], [['css', 'margin', '0px 0px 10px 1px']]);
    var tdTable2 = nsGmx.Utils._td([manageSection, groupBox, this.divTable2, downloadSection[0]], [['attr', 'vAlign', 'top']]);
    this.table2 = new nsGmx.ScrollTable({pagesCount: 10, limit: 20});

	this.prevLimit = this.table2.limit;
    var chkSelectedCount = function() {
		var cnt = Object.keys(_this._selected).length;
		if (cnt) {
			L.DomUtil.removeClass(selectedCont, 'hiddenCommands');
		} else {
			L.DomUtil.addClass(selectedCont, 'hiddenCommands');
		}
		selectedCount.innerHTML = cnt;
    };
    var clearSelected = function() {
		_this._selected = {};
		chkSelectedCount();
		selectAllItems.checked = false;
    };

	var drawTableItem2 = function(elem, curIndex, activeHeaders)
    {
        var tds = [];

        if (this.limit !== _this.prevLimit) {
            _this.prevLimit = this.limit;
			clearSelected();
		}

		var id = elem.values[elem.fields[info.identityField].index],
			showButton = nsGmx.Utils.makeImageButton('img/enlarge-circle.svg', 'img/enlarge-circle.svg'),
            editButton = nsGmx.Utils.makeImageButton('img/pen.svg'),
            deleteItem = nsGmx.Utils._checkbox(_this._selected[id], 'checkbox'),
            tdControl;

        if (info.Access !== 'edit' && info.Access !== 'editrows') {
            tdControl = nsGmx.Utils._td([nsGmx.Utils._div([showButton], [['css', 'width', '45px']])], [['css', 'width', '45px']]);
        } else {
            tdControl = nsGmx.Utils._td([nsGmx.Utils._div([deleteItem, showButton, editButton], [['css', 'width', '47px']])], [['css', 'width', '47px']]);
        }

        editButton.style.marginLeft = showButton.style.marginLeft = '5px';
        editButton.style.width = '12px';

        deleteItem.onchange = function() {
			if (deleteItem.checked) { _this._selected[id] = true; }
			else  {
				delete _this._selected[id];
				selectAllItems.checked = false;
			}
			chkSelectedCount();
        };

        editButton.onclick = function()
        {
            var id = elem.values[elem.fields[info.identityField].index];
            new nsGmx.EditObjectControl(_this.layerName, id);
        };

        showButton.onclick = function()
        {
            var id = elem.values[elem.fields[info.identityField].index];
            sendCrossDomainJSONRequest(window.serverBase + 'VectorLayer/Search.ashx?WrapStyle=func&layer=' + _this.layerName + '&page=0&pagesize=1&geometry=true&query=' + encodeURIComponent('[' + info.identityField + ']=' + id), function(response) {
                if (!window.parseResponse(response)) {
                    return;
				}
				var layer = nsGmx.gmxMap.layersByID[_this.layerName],
					props = layer.getGmxProperties(),
					isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                var columnNames = response.Result.fields;
                var row = response.Result.values[0];
                for (var i = 0; i < row.length; ++i)
                {
                    if (columnNames[i] === 'geomixergeojson' && row[i])
                    {

                        var fitBoundsOptions = layer ? {maxZoom: layer.options.maxZoom} : {};

                        var geom = L.gmxUtil.geometryToGeoJSON(row[i], true);
                        var bounds = L.gmxUtil.getGeometryBounds(geom);
                        nsGmx.leafletMap.fitBounds([
                            [bounds.min.y, bounds.min.x],
                            [bounds.max.y, bounds.max.x]
                        ], fitBoundsOptions);

						if (isTemporalLayer) {
							var tempColumn = props.TemporalColumnName,
								index = columnNames.indexOf(tempColumn),
								dayms = nsGmx.DateInterval.MS_IN_DAY,
								dateBegin, dateEnd,
								datems;

							if (index !== -1) {
								datems = row[index] * 1000;
								dateBegin = nsGmx.DateInterval.toMidnight(new Date(datems));
								dateEnd = nsGmx.DateInterval.toMidnight(new Date(datems + dayms));
								nsGmx.widgets.commonCalendar.setDateInterval(dateBegin, dateEnd, layer);
							}
						}
                    }
                }
            });
        };

        nsGmx.Utils._title(deleteItem, _gtxt('Удалить'));
        nsGmx.Utils._title(editButton, _gtxt('Редактировать'));
        nsGmx.Utils._title(showButton, _gtxt('Показать'));

        $(showButton).toggle(!elem.values[elem.fields['__GeomIsEmpty__'].index]);

        if (!_params.hideRowActions) {
            tds.push(tdControl);
		}

        for (var j = 0; j < activeHeaders.length; ++j)
        {
            if (activeHeaders[j] === '') {
                continue;
			}

            var fieldName = _this.tableFields.titleToField[activeHeaders[j]];

            if (fieldName in elem.fields)
            {
                var valIndex = elem.fields[fieldName].index,
                    td = nsGmx.Utils._td();

                nsGmx.Utils._(td, [nsGmx.Utils._t(nsGmx.Utils.convertFromServer(elem.fields[fieldName].type, elem.values[valIndex]))]);

                if (elem.fields[fieldName].type === 'integer') {
                    td.style.textAlign = 'right';
				}

                tds.push(td);
            }
            else
            {
                tds.push(nsGmx.Utils._td());
            }
        }

        var tr = nsGmx.Utils._tr(tds);

        if (curIndex % 2 !== 0) {
            tr.className = 'odd';
		}

        if (_params.onClick) {
            tr.onclick = function()
            {
                _params.onClick(elem);
            };
            tr.style.cursor = 'pointer';
        }

        return tr;
    };

    var tableFields = _params.hideRowActions ? attrNames : [''].concat(attrNames);

    this.table2.setDataProvider(this._serverDataProvider);
    this.table2.createTable(this.divTable2, 'attrs', 0, tableFields, fielsWidth, drawTableItem2, $.extend(attrNamesHash, {'': true}), true);

	nsGmx.Utils._(canvas, [nsGmx.Utils._table([nsGmx.Utils._tbody([nsGmx.Utils._tr([tdParams, tdTable2])])], ['css', 'width', '100%'])]);

	var tbl = $(this.divTable2).find('#attrsTableParent')[0],
		ths = $(this).find('th');

	if (L.Browser.ie || L.Browser.gecko) {
		var lastSTop = tbl.scrollTop;
		tbl.onscroll = function() {
			var stop = this.scrollTop;
			var ths = $(this).find('th');
			if (stop < lastSTop) {
				$(ths).each(function (elem) {
					$(this).css('transitionDelay', '0s');
					$(this).css('transform', "");
				})
			}
			lastSTop = stop;
			var translate = "translate(0,"+stop+"px)";

			$(ths).each(function (elem) {
				$(this).css('transitionDelay', '0.25s');
				$(this).css('transform', translate);
			})
		};
	} else {
		tbl.onscroll = function() {
			var translate = "translate(0,"+(this.scrollTop)+"px)";
			var ths = $(this).find('th');
			$(ths).each(function (elem) {
				$(this).css('transform', translate);
			})
		};
	}

	var resizeFunc = function()
	{
		var dialogWidth = oldCanvasWidth || outerSizeProvider().width;

		oldCanvasWidth = false;

		canvas.childNodes[0].style.width = dialogWidth - 21 - 10 + 'px';
		tdTable2.style.width = dialogWidth - tdParams.offsetWidth - 21 - 10 + 'px';
		_this.divTable2.style.width = dialogWidth - tdParams.offsetWidth - 21 - 10 + 'px';

        var dialogHeight = outerSizeProvider().height;
		_this.divTable2.style.height = dialogHeight -14 - 25 - 10 - 30 + 'px';

        _this.table2.updateHeight(parseInt(_this.divTable2.style.height));
        _params.searchParamsManager.resize && _params.searchParamsManager.resize({
            width: tdParams.offsetWidth,
            height: _this.divTable2.offsetHeight
        });
	};

	this.resizeFunc = resizeFunc;

	resizeFunc();

    if (this._isLayerOnMap)
    {
        this._updateVersionHandler = function() {
            _this._serverDataProvider.serverChanged();
        };

        nsGmx.gmxMap.layersByID[this.layerName].on('versionchange', this._updateVersionHandler);
    }
};

var attrsTableHash = function()
{
	this.hash = {};
    this.hooks = [];
    this._hookID = 0;
};

attrsTableHash.prototype.create = function(name, canvas, outerSizeProvider, params)
{
    params = params || {};
    this.hooks.forEach(function(hookInfo) {
        params = hookInfo.hook(params, name) || params;
    });

	if (name in this.hash)
	{
        this.hash[name].getInfo(canvas, outerSizeProvider, params);
	}
	else
	{
        var title = nsGmx.gmxMap.layersByID[name] ? nsGmx.gmxMap.layersByID[name].getGmxProperties().title : '';
        var newAttrsTable = new attrsTable(name, title);
		newAttrsTable.getInfo(canvas, outerSizeProvider, params);

		this.hash[name] = newAttrsTable;
	}

    return this.hash[name];
};

attrsTableHash.prototype.addHook = function(paramsHook) {
    var id = 'id' + this._hookID++;
    this.hooks.push({id: id, hook: paramsHook});
    return id;
};

attrsTableHash.prototype.removeHook = function(hookID) {
    for (var i = 0; i < this.hooks.length; i++) {
        if (this.hooks[i].id === hookID) {
            this.hooks.splice(i, 1);
            return;
        }
    }
};

window.nsGmx = window.nsGmx || {};

window._attrsTableHash = new attrsTableHash();

/** Менеджер поискового интерфейса таблицы атрибутов.
    Используется в таблице атрибутов для задания кастомизированного интерфейса поиска объектов слоя.
    Генерирует события queryChange и columnsChange
  @typedef IAttrTableSearchManager
  @memberOf nsGmx
  @prop {function(container, attrTable)} render Ф-ция для отрисовки кастомизированного интерфейса в контейнере. Параметры: container, attrTable
  @prop {function(): String} getQuery Получить SQL запрос за данными
  @prop {function(): Object} getActiveColumns Получить хеш с описанием активности колонок (имя колонки -> true/false)
  @prop {function(dims)} resize Ф-ция для реакции на изменения размера диалога. dims - целевые размеры контейнера (width, height)
*/

/** Показать таблицу атрибутов векторного слоя
  @func createAttributesTable
  @memberOf nsGmx
  @param {String} layerName ID слоя
  @param {DOMElement} canvas Контейнер, куда поместить таблицу атрибутов. Если не указано, будет создан новый диалог
  @param {function} outerSizeProvider Ф-ция для определения текущих размеров контейнера. Должна возвращать объект с полями width и height. Применяется только если указан canvas.
  @param {Object} params Дополнительные параметры
  @param {Boolean} [params.hideDownload=false] Скрыть секцию с вариантами скачивания данных
  @param {Boolean} [params.hideActions=false] Скрыть секцию с добавлением объекта
  @param {Boolean} [params.hideRowActions=false] Скрыть столбец таблицы с действиями над отдельными объектами
  @param {Boolean} [params.hideSearchParams=false] Скрыть секцию с параметрами поиска
  @param {function} [params.onClick] Ф-ция, которая будет вызываться при клике на строчке таблицы. Первым параметром передаётся объект, по которому кликнули
  @param {Array} [params.attributes] Массив, определяющий, какие атрибуты показывать. Каждый элемент - объект с полями "name" (исходное название атрибута) и title (как отображать в таблице).
                 Если атрибута нет в массиве, он не будет показан в таблице. Если массив не указан, показываются все атрибуты
  @param {nsGmx.IAttrTableSearchManager} [params.searchParamsManager] Менеджер UI для поиска в таблице атрибутов
  @return Интерфейс для управления таблицей атрибутов
*/

window.nsGmx.createAttributesTable = window._attrsTableHash.create.bind(window._attrsTableHash);


/** Добавить хук для изменения параметров при вызове таблицы атрибутов
  @func addAttributesTableHook
  @memberOf nsGmx
  @param {function(params, layerName):Object} paramsHook Хук, который вызывается при каждом вызове диалога редактирования.
         Первый параметр - параметры диалога (можно модифицировать), второй - ID слоя).
  @return {String} ID добавленного хука
*/
window.nsGmx.addAttributesTableHook = function(paramsHook) {
    return window._attrsTableHash.addHook(paramsHook);
};

/** Удаляет хук параметров
  @func removeAttributesTableHook
  @memberOf nsGmx
  @param {String} hookID ID хука для удаления
*/
window.nsGmx.removeAttributesTableHook = function(hookID) {
    window._attrsTableHash.removeHook(hookID);
};

})();

!(function() {

/** Провайдер данных для {@link nsGmx.ScrollTable}. Получает данные от сервера в формате ГеоМиксера
* @alias nsGmx.AttrTable.ServerDataProvider
* @class
* @extends nsGmx.ScrollTable.IDataProvider
*/
var ServerDataProvider = function(params)
{
    var _params = $.extend({
            defaultSortParam: 'ogc_fid',
            titleToParams: {}
        }, params);
    var _countURL = null,
        _dataURL = null,
        _countParams = null,
        _dataParams = null;

    var _lastCountResult;

    //IDataProvider interface
    this.getCount = function(callback)
    {
        if (!_countURL)
        {
            callback();
            return;
        }

        sendCrossDomainPostRequest(_countURL, _countParams, function(response)
        {
            if (!window.parseResponse(response))
            {
                callback();
                return;
            }
            _lastCountResult = response.Result;
            callback(response.Result);
        });
    };

    this.getItems = function(page, pageSize, sortParam, sortDec, callback)
    {
        if (!_dataURL)
        {
            callback();
            return;
        }

        var explicitSortParam = (sortParam || sortParam === '') ? (_params.titleToParams[sortParam] || sortParam) : _params.defaultSortParam;

        var params = $.extend({
            page: page,
            pagesize: pageSize,
            orderby: explicitSortParam,
            orderdirection: sortDec ? 'DESC' : 'ASC'
        }, _dataParams);

        sendCrossDomainPostRequest(_dataURL, params, function(response)
        {
            if (!window.parseResponse(response))
            {
                callback();
                return;
            }

            var fieldsSet = {};

            if (response.Result.fields)
            {
                for (var f = 0; f < response.Result.fields.length; f++) {
                    fieldsSet[response.Result.fields[f]] = {index: f, type: response.Result.types[f]};
				}
            }

            var res = [];
            for (var i = 0; i < response.Result.values.length; i++) {
                res.push({
                    fields: fieldsSet,
                    values: response.Result.values[i]
                });
			}

            callback(res);
        });
    };

    /** Задать endpoint для получения от сервера данных об объекта и их количестве
     * @param {String} countURL URL скрипта для запроса общего количества объектов
     * @param {Object} countParams Параметры запроса для количеством объектов
     * @param {String} dataURL URL скрипта для запроса самих объектов
     * @param {Object} dataParams Параметры запроса самих объектов. К этим параметрам будут добавлены параметры для текущей страницы в формате запросов ГеоМиксера
    */
    this.setRequests = function(countURL, countParams, dataURL, dataParams)
    {
        _countURL = countURL;
        _countParams = countParams || {};
        _countParams.WrapStyle = 'message';

        _dataURL = dataURL;
        _dataParams = dataParams || {};
        _dataParams.WrapStyle = 'message';

        $(this).change();
    };

    this.serverChanged = function()
    {
        $(this).change();
    };

    this.getLastCountResult = function() {
        return _lastCountResult;
    };
};

window.nsGmx.AttrTable.ServerDataProvider = ServerDataProvider;

})();

!(function() {

var template = Handlebars.compile('<div class="attrs-table-square-popover">' +
    '<div class="attrs-table-square-toomuch">Слишком много объектов</div>' +
    '<div class="attrs-table-square-process">Подсчитываем...</div>' +
    '<div class="attrs-table-square-result">Площадь: ' +
        '<span class="attrs-table-square"></span>' +
    '</div>' +
'</div>');

nsGmx.AttrTable.SquareCalc = function(container, layerName, dataProvider, searchParamsManager) {
    var popoverUI = $(template());

    popoverUI.find('.attrs-table-square-toomuch').hide();
    popoverUI.find('.attrs-table-square-result').hide();

    $(container).popover({
        content: popoverUI[0],
        placement: 'left',
        html: true
    });

    $(container).on('shown.bs.popover', function() {
        if (dataProvider.getLastCountResult() > 10000) {
            popoverUI.find('.attrs-table-square-toomuch').show();
            popoverUI.find('.attrs-table-square-process').hide();
            popoverUI.find('.attrs-table-square-result').hide();
            return;
        } else {
            popoverUI.find('.attrs-table-square-toomuch').hide();
            popoverUI.find('.attrs-table-square-process').show();
            popoverUI.find('.attrs-table-square-result').hide();
        }

        sendCrossDomainPostRequest(window.serverBase + 'VectorLayer/Search.ashx', {
            layer: layerName,
            query: searchParamsManager.getQuery(),
            columns: '[{value: "[GeomixerGeoJson]"}]',
            WrapStyle: 'message'
        }, function(response) {
            if (!window.parseResponse(response)) {
                return;
            }

            popoverUI.find('.attrs-table-square-process').hide();
            popoverUI.find('.attrs-table-square-result').show();

            var items = response.Result.values;
            var totalSquare = 0;
            for (var g = 0; g < items.length; g++) {
                totalSquare += L.gmxUtil.geoArea(items[g][0]);
            }

            popoverUI.find('.attrs-table-square').text(L.gmxUtil.prettifyArea(totalSquare));
        });
    });
};

})();

!(function() {

// events: queryChange, columnsChange
var DefaultSearchParamsManager = function() {
    this._activeColumns = null;
    this._queryTextarea = null; // textArea in search panel
    this._searchValue = '';     // value of this._queryTextarea
    this._valueTextarea = null; // upper textArea in update panel
    this._setValue = '';        // value of this._queryTextarea
    this._updateQueryTextarea = null; // lower textArea in update panel
    this._setUpdateQueryValue = '';   // value of this._updateQueryTextarea
    this._container = null;
};

DefaultSearchParamsManager.prototype.drawSearchUI = function(container, attributesTable) {
    var info = attributesTable.getLayerInfo(),
        paramsWidth = 320,
        _this = this;

    this._container = container;

    /* HIDE BUTTON */
    var hideButtonContainer = document.createElement('div'),
        hideButton = nsGmx.Utils.makeLinkButton(_gtxt('Скрыть'));

    $(hideButton).addClass('attr-table-hide-button');
    $(hideButtonContainer).addClass('attr-table-hide-button-container');
    $(hideButtonContainer).append(hideButton);

    hideButton.onclick = function() {
        var tableTd = container.nextSibling,
            originalButton = $(tableTd).find('.attr-table-find-button');

        if ($(originalButton).hasClass('gmx-disabled')) {
            $(originalButton).removeClass('gmx-disabled');
        }
        container.style.display = 'none';
        attributesTable.resizeFunc();
    };

    var middleContainer = document.createElement('div');
    $(middleContainer).addClass('attr-table-middle-container');

    /* SEARCH INSIDE POLYGON */
    this._geometryInfoRow = null;

    var geomUIContainer = document.createElement('div');
    $(geomUIContainer).addClass('attr-table-geometry-container');

    var geomUI = $(Handlebars.compile('<span>' +
        '<span class="attr-table-geomtitle">{{i "Искать по пересечению с объектом"}}</span>' +
        '<span class="gmx-icon-choose"></span>' +
        '<span class="attr-table-geom-placeholder"></span>' +
    '</span>')());

    $(geomUIContainer).append(geomUI);

    geomUI.find('.gmx-icon-choose').click(function() {
        nsGmx.Controls.chooseDrawingBorderDialog(
            'attrTable',
            function(drawingObject) {
                _this._geometryInfoRow && _this._geometryInfoRow.RemoveRow();
                var InfoRow = gmxCore.getModule('DrawingObjects').DrawingObjectInfoRow;
                _this._geometryInfoRow = new InfoRow(
                    nsGmx.leafletMap,
                    geomUI.find('.attr-table-geom-placeholder')[0],
                    drawingObject,
                    {
                        editStyle: false,
                        allowDelete: true
                    }
                );

                $(_this._geometryInfoRow).on('onRemove', function() {
                    _this._geometryInfoRow && _this._geometryInfoRow.RemoveRow();
                    _this._geometryInfoRow = null;
                });
            },
            {geomType: null}
        );
    });

    /*SQL TEXTAREA*/
    this._queryTextarea = nsGmx.Utils._textarea(null, [['dir', 'className', 'inputStyle'], ['dir', 'className', 'attr-table-query-area'], ['css', 'overflow', 'auto'], ['css', 'width', '300px']]);
    this._queryTextarea.placeholder = '"field1" = 1 AND "field2" = \'value\'';
    this._queryTextarea.value = _this._searchValue;
    this._queryTextarea.oninput = function(e) {_this._searchValue = e.target.value};

    var attrNames = [info.identityField].concat(info.attributes, [window._gtxt('gmx_geometry')]);
    var attrHash = {};
    for (var a = 0; a < attrNames.length; a++) {
        attrHash[attrNames[a]] = [];
    }

    var attrProvider = new nsGmx.LazyAttributeValuesProviderFromServer(attrHash, info.name);

    var suggestionCallback = function () {
        $(_this._queryTextarea).trigger('input');
    }

    var attrSuggestWidget = new nsGmx.AttrSuggestWidget([this._queryTextarea], attrNames, attrProvider);

    var suggestCanvas = attrSuggestWidget.el[0];

    $(suggestCanvas).css('margin-right', '9px');

    var suggestionCallback = function () {
        $(this.currentTextArea).trigger('input');
    }

    attrSuggestWidget.setCallback(suggestionCallback);

    container.onclick = function(evt) {
        if (evt.target === container) {
            $(suggestCanvas).find('.suggest-helper').fadeOut(100);
            return true;
        }
    };

    /*CLEAN/SEARCH BUTTONS*/
    var buttonsContainer = document.createElement('div'),
        searchButton = nsGmx.Utils.makeLinkButton(_gtxt('Найти')),
        cleanButton = nsGmx.Utils.makeLinkButton(_gtxt('Очистить'));

    $(buttonsContainer).addClass('clean-search-buttons-container');
    $(buttonsContainer).append(searchButton);

    searchButton.onclick = function() {

        $(_this).trigger('queryChange');
    };

    $(searchButton).addClass('search-button');
    $(cleanButton).addClass('clean-button');

    cleanButton.onclick = function() {
        _this._queryTextarea.value = '';
        _this._geometryInfoRow && _this._geometryInfoRow.RemoveRow();
        _this._geometryInfoRow = null;
        _this._searchValue = _this._queryTextarea.value;
        $(_this).trigger('queryChange');
    };

    /*COMPILE*/
    $(container).append(hideButtonContainer);
    $(container).append(middleContainer);
    nsGmx.Utils._(middleContainer, [nsGmx.Utils._div([nsGmx.Utils._span([nsGmx.Utils._t(_gtxt('WHERE'))], [['css', 'fontSize', '12px'], ['css', 'margin', '7px 0px 3px 1px']]), cleanButton, this._queryTextarea, suggestCanvas], [['dir', 'className', 'attr-query-container'], ['attr', 'filterTable', true]])]);
    $(middleContainer).append(geomUIContainer);
    $(container).append(buttonsContainer);
};

DefaultSearchParamsManager.prototype.drawUpdateUI = function(container, attributesTable) {
    var info = attributesTable.getLayerInfo(),
        paramsWidth = 320,
        _this = this;

    this.currentColumnName = "",
    this._container = container;


    /* HIDE BUTTON */
    var hideButtonContainer = document.createElement('div'),
        hideButton = nsGmx.Utils.makeLinkButton(_gtxt('Скрыть'));

    $(hideButton).addClass('attr-table-hide-button');
    $(hideButtonContainer).addClass('attr-table-hide-button-container');
    $(hideButtonContainer).append(hideButton);

    hideButton.onclick = function() {
        var tableTd = container.nextSibling,
            originalButton = $(tableTd).find('.attr-table-find-button');

        if ($(originalButton).hasClass('gmx-disabled')) {
            $(originalButton).removeClass('gmx-disabled');
        }
        container.style.display = 'none';
        attributesTable.resizeFunc();
    };

    var middleContainer = document.createElement('div');
    $(middleContainer).addClass('attr-table-middle-container');

    /* SELECT COLUMN */
    var selectColumnContainer = document.createElement('div'),
        attrsTemplate = Handlebars.compile('<select class="attrs-select selectStyle">' +
                            '{{#each this.attrs}}' +
                                '<option value="{{this}}">' +
                                    '{{this}}' +
                                '</option>' +
                            '{{/each}}' +
                        '</select>'),
        attrsUI = $(attrsTemplate({
            attrs: ['---' + window._gtxt("Выберите колонку").toLowerCase() + '---'].concat(info.attributes)
        }))[0],
        hideButton = nsGmx.Utils.makeLinkButton(_gtxt('Скрыть'));

    $(selectColumnContainer).append(window._gtxt("Обновить колонку"));
    $(selectColumnContainer).append(attrsUI);

    attrsUI.onchange = function (e) {
        _this.currentColumnName = e.target.value;
    }

    /* VALUE TEXTAREA */
    this._valueTextarea = nsGmx.Utils._textarea(null, [['dir', 'className', 'inputStyle'], ['dir', 'className', 'attr-table-query-area'], ['css', 'overflow', 'auto'], ['css', 'margin-top', '3px'], ['css', 'width', '300px'], ['css', 'height', '80px']]);
    this._valueTextarea.placeholder = '"field1" = 1 AND "field2" = \'value\'';
    this._valueTextarea.value = _this._setValue;
    this._valueTextarea.oninput = function(e) {_this._setValue = e.target.value};

    /* UPDATE QUERY TEXTAREA */
    this._updateQueryTextarea = nsGmx.Utils._textarea(null, [['dir', 'className', 'inputStyle'], ['dir', 'className', 'attr-table-query-area'], ['css', 'overflow', 'auto'], ['css', 'margin-top', '3px'], ['css', 'width', '300px'], ['css', 'height', '80px']]);
    this._updateQueryTextarea.placeholder = '"field1" = 1 AND "field2" = \'value\'';
    this._updateQueryTextarea.value = _this._setUpdateQueryValue;

    this._updateQueryTextarea.oninput = function(e) {_this._setUpdateQueryValue = e.target.value};

    var attrNames = [info.identityField].concat(info.attributes, [window._gtxt('gmx_geometry')]);
    var attrHash = {};
    for (var a = 0; a < attrNames.length; a++) {
        attrHash[attrNames[a]] = [];
    }

    var attrProvider = new nsGmx.LazyAttributeValuesProviderFromServer(attrHash, info.name);

    var attrSuggestWidget = new nsGmx.AttrSuggestWidget([this._valueTextarea, this._updateQueryTextarea], attrNames, attrProvider);
    var suggestCanvas = attrSuggestWidget.el[0];
    $(suggestCanvas).css('margin-right', '9px');


    var suggestionCallback = function () {
        $(this.currentTextArea).trigger('input');
    }

    attrSuggestWidget.setCallback(suggestionCallback);

    this._valueTextarea.onfocus = function(e) {attrSuggestWidget.setActiveTextArea(e.target)};
    this._updateQueryTextarea.onfocus = function(e) {attrSuggestWidget.setActiveTextArea(e.target)};


    container.onclick = function(evt) {
        if (evt.target === container) {
            $(suggestCanvas).find('.suggest-helper').fadeOut(100);
            return true;
        }
    };

    /*STATUS BAR*/

    var statusBar = $(Handlebars.compile(
        '<div class="column-update-spinholder">' +
            '<span class="spinHolder" style="display:none">' +
                '<img src="img/progress.gif"/>' +
                '<span class="spinMessage"></span>' +
                '</span>' +
            '<span class="spinErrorMessage" style="display:none"></span>' +
        '</div>')({}))[0];

    /*APPLY BUTTON*/
    var applyButtonContainer = document.createElement('div'),
        applyButton = nsGmx.Utils.makeLinkButton(_gtxt('Применить'));

    $(applyButtonContainer).addClass('apply-button-container');
    $(applyButtonContainer).append(applyButton);

    applyButton.onclick = function() {

        var spinHolder = $(statusBar).find('.spinHolder');
        var spinErrorMessage = $(statusBar).find('.spinErrorMessage');

        $(spinErrorMessage).hide();

        if (!_this.currentColumnName || _this.currentColumnName === '---' + window._gtxt("Выберите колонку").toLowerCase() + '---') {

            $(spinErrorMessage).html(window._gtxt('Выберите колонку'));
            $(spinErrorMessage).show();
            return;
        }

        $(spinHolder).show();

        var updateQuery = _this._valueTextarea && _this._valueTextarea.value ? _this._valueTextarea.value : '';
        var whereQuery = _this._updateQueryTextarea && _this._updateQueryTextarea.value ? _this._updateQueryTextarea.value : '';

        // updateQuery.match(/)

        var url = window.serverBase + 'VectorLayer/QueryScalar?sql=' +
            'UPDATE ' + '"' + attributesTable.layerName + '"' +
            'SET ' +  '"' + _this.currentColumnName + '"' + '=' + updateQuery + (whereQuery ? ('WHERE ' + whereQuery) : "");

        fetch(url, {
             method: 'POST',
             credentials: 'include',
             mode: 'cors'
          }).then(toJson)
          .then(resCallback)
          .catch(catchErr);

         function toJson(res) {
             return res.text();
         }

        function resCallback(res) {
            var json, result, fields, types, values;

            $(spinHolder).hide();
            res = res.substring(1, res.length-1);
            json = JSON.parse(res);
            result = json.Result;

            if (json.Status === 'error') {
                throw new Error(json.ErrorInfo.ErrorMessage);
            }

            $(attributesTable._serverDataProvider).change();
        }

        function catchErr(e) {
            $(spinHolder).hide();
            $(spinErrorMessage).html(window._gtxt('Ошибка'));
            $(spinErrorMessage).show();
        }
    };

    $(applyButton).addClass('apply-button');

    /*COMPILE*/
    $(container).append(hideButtonContainer);
    $(container).append(middleContainer);
    $(middleContainer).append(selectColumnContainer);
    $(middleContainer).append(selectColumnContainer);
    nsGmx.Utils._(middleContainer, [nsGmx.Utils._div([nsGmx.Utils._span([nsGmx.Utils._t(_gtxt('VALUE'))], [['css', 'fontSize', '12px'], ['css', 'margin', '4px 0px 3px 1px'], ['css', 'display', 'inline-block']]), this._valueTextarea], [['dir', 'className', 'attr-query-container'], ['attr', 'filterTable', true]])]);
    nsGmx.Utils._(middleContainer, [nsGmx.Utils._div([nsGmx.Utils._span([nsGmx.Utils._t(_gtxt('WHERE'))], [['css', 'fontSize', '12px'], ['css', 'margin', '4px 0px 3px 1px'], ['css', 'display', 'inline-block']]), this._updateQueryTextarea, suggestCanvas], [['dir', 'className', 'attr-query-container'], ['attr', 'filterTable', true]])]);
    $(middleContainer).append(statusBar);
    $(container).append(applyButtonContainer);
}

DefaultSearchParamsManager.prototype.getQuery = function() {
    var query = this._queryTextarea && this._queryTextarea.value,
        drawingObject = this._geometryInfoRow && this._geometryInfoRow.getDrawingObject(),
        geom = drawingObject && drawingObject.toGeoJSON().geometry,
        geomStr = geom ? 'intersects([geomixergeojson], GeometryFromGeoJson(\'' + JSON.stringify(geom) + '\', 4326))' : '',
        resQuery = (query && geomStr) ? '(' + query + ') AND ' + geomStr : (query || geomStr);
    return resQuery;
};

DefaultSearchParamsManager.prototype.getActiveColumns = function() {
    return this._activeColumns;
};

DefaultSearchParamsManager.prototype.resize = function(dims) {
};

nsGmx.AttrTable.DefaultSearchParamsManager = DefaultSearchParamsManager;

})();

var nsGmx = nsGmx || {};

(function() {
    window._translationsHash.addtext('rus', {
        gridPlugin: {
            gridSettings: 'Настройка координатной сетки',
            gridColorSettings: 'цвет',
            gridStepSettings: 'шаг',
            gridUnitsSettings: 'единицы',
            gridFormatSettings: 'формат вывода',
            set : 'установить',
            reset : 'сбросить',
            unitsKilometers : 'км',
            unitsDegrees : 'градусы',
            formatDecimal : 'десятичные градусы',
            formatDM : 'градусы, минуты',
            formatDMS : 'градусы, минуты, секунды',
            latitude : 'по широте',
            longitude : 'по долготе'
        }
    });
    window._translationsHash.addtext('eng', {
        gridPlugin: {
            gridSettings : 'Coordinate grid settings',
            gridColorSettings : 'color',
            gridStepSettings : 'step',
            gridUnitsSettings: 'units',
            gridFormatSettings: 'format',
            set : 'set',
            reset : 'reset',
            unitsKilometers : 'km',
            unitsDegrees : 'degrees',
            formatDecimal: 'decimal degrees',
            formatDM: 'degrees minutes',
            formatDMS : 'degrees minutes seconds',
            latitude : 'latitude',
            longitude: 'longitude'
        }
    });

    // создает левое меню с параметрами координатной сетки
    var ConfigureGridMenu = function (manager) {
        var control = manager.gridControl,
            tempStyle = {
                outline: {
                    color: control.options.color
                }
            },
            lm = new window.leftMenu();

        // заполняем левое меню
        function createGridLeftMenu() {
            var gridConfigLeftMenu = nsGmx.Utils._div(null, [['dir','className','gridConfigLeftMenu']]);
            createGridConfig(gridConfigLeftMenu);

            return gridConfigLeftMenu;
        }

        // создание элементов отображения настроек сетки
        function createGridConfig(menu) {
            var gridConfigCanvas = nsGmx.Utils._div(null, [['dir','className','gridSettings']]),
                gridConfigTitle = nsGmx.Utils._span(null, [['dir','className','gridSettingsTitle']]),
                gridConfigIcon = CreateGridConfigIcon(tempStyle, 'linestring');

            $(gridConfigIcon).find('.borderIcon')[0].style.borderColor = tempStyle.outline.color;
            $(gridConfigTitle).append(window._gtxt('gridPlugin.gridSettings'));
            $(gridConfigCanvas).append(gridConfigIcon, gridConfigTitle);
            $(menu).append(gridConfigCanvas);

            gridConfigIcon.onclick = function () {
                createConfigDialog(this);
            };
        }

        // диалоговое окно для редактирования координатной сетки
        function createConfigDialog(elem) {
            if (manager.configDialog) {
                return;
            }
            var map = nsGmx.leafletMap,
                gridConfigEditor = nsGmx.Utils._div(null, [['dir','className','gridConfigEditor']]);

            // редактирование цвета сетки - колорпикер
            var fcp = nsGmx.Controls.createColorPicker(tempStyle.outline.color,
                function (colpkr) {
                    $(colpkr).fadeIn(500);
                    return false;
                },
                function (colpkr) {
                    $(colpkr).fadeOut(500);
                    $(this).change();
                    return false;
                },
                function (hsb, hex) {
                    tempStyle.outline.color = '#' + hex;
                    fcp.style.backgroundColor = tempStyle.outline.color;
                    control.setColor(tempStyle.outline.color);
                    $(elem).find('.borderIcon')[0].style.borderColor = tempStyle.outline.color;
                    manager.saveOptions();
                    $(this).ColorPickerSetColor(tempStyle.outline.color);
                    $(this).change();
                }
            );

            $(fcp).ColorPickerSetColor(tempStyle.outline.color);
            $(fcp).css('background-color', tempStyle.outline.color);

            // редактирования шага сетки
            var gridStepYInputPanel = nsGmx.Utils._span(null, [['dir','className','gridStepConfig']]),
                gridStepXInputPanel = nsGmx.Utils._span(null, [['dir','className','gridStepConfig']]),
                gridStepYInput = nsGmx.Utils._input(null, [['dir','className','gridStepInput']]),
                gridStepXInput = nsGmx.Utils._input(null, [['dir','className','gridStepInput']]),
                gridUnitsConfig = nsGmx.Utils._span(null, [['dir','className','gridStepConfig']]),
                gridStepConfig = nsGmx.Utils._span(null, [['dir','className','gridStepConfig']]),
                gridFormatConfig = nsGmx.Utils._span(null, [['dir','className','gridFormatConfig']]),
                gridStepUnitsDegrees = nsGmx.Utils._input(null, [
                    ['dir','id','gridStepUnitsDegrees'],
                    ['attr', 'type', 'radio'],
                    ['attr', 'id', 'gridStepUnitsDegrees'],
                    ['attr', 'name', 'gridStepUnits'],
                    ['attr', 'value', 'degrees']
                ]),
                gridStepUnitsKilometers = nsGmx.Utils._input(null, [
                    ['dir','id','gridStepUnitsKilometers'],
                    ['attr', 'type', 'radio'],
                    ['attr', 'name', 'gridStepUnits'],
                    ['attr', 'value', 'kilometers']
                ]),
                gridFormatDD = nsGmx.Utils._input(null, [
                    ['dir','id','gridFormatDD'],
                    ['attr', 'type', 'radio'],
                    ['attr', 'name', 'gridFormat'],
                    ['attr', 'value', 0],
                    control.options.units === 'kilometers' ? ['attr', 'disabled', true] : []
                ]),
                gridFormatDM = nsGmx.Utils._input(null, [
                    ['dir','id','gridFormatDM'],
                    ['attr', 'type', 'radio'],
                    ['attr', 'name', 'gridFormat'],
                    ['attr', 'value', 1],
                    control.options.units === 'kilometers' ? ['attr', 'disabled', true] : []
                ]),
                gridFormatDMS = nsGmx.Utils._input(null, [
                    ['dir','id','gridFormatDMS'],
                    ['attr', 'type', 'radio'],
                    ['attr', 'name', 'gridFormat'],
                    ['attr', 'value', 2],
                    control.options.units === 'kilometers' ? ['attr', 'disabled', true] : []
                ]),
                gridSetStepButton = nsGmx.Utils._button([nsGmx.Utils._t(window._gtxt('gridPlugin.set'))], [['dir', 'className', 'gridStepButton']]),
                gridResetStepButton = nsGmx.Utils._button([nsGmx.Utils._t(window._gtxt('gridPlugin.reset'))], [['dir', 'className', 'gridStepButton']]);

            $(gridStepYInputPanel).append(
                gridStepYInput,
                nsGmx.Utils._t(window._gtxt('gridPlugin.latitude'))
            );

            $(gridStepXInputPanel).append(
                gridStepXInput,
                nsGmx.Utils._t(window._gtxt('gridPlugin.longitude'))
            );

            $(gridUnitsConfig).append(
              nsGmx.Utils._label(
                  [gridStepUnitsDegrees, nsGmx.Utils._t(window._gtxt('gridPlugin.unitsDegrees'))],
                  [['dir', 'className', 'gridUnitsLabel'], ['attr', 'for', 'gridStepUnitsDegrees']]

              ),
              nsGmx.Utils._label(
                  [gridStepUnitsKilometers, nsGmx.Utils._t(window._gtxt('gridPlugin.unitsKilometers'))],
                  [['dir', 'className', 'gridUnitsLabel'], ['attr', 'for', 'gridStepUnitsKilometers']]
              )
            );

            $(gridFormatConfig).append(
                nsGmx.Utils._label(
                    [gridFormatDD, nsGmx.Utils._t(window._gtxt('gridPlugin.formatDecimal'))],
                    [
                        ['dir', 'className', control.options.units === 'kilometers' ? 'gridFormatLabel disabledLabel' : 'gridFormatLabel'],
                        ['attr', 'for', 'gridFormatDD']
                    ]
                ),
                $('<br></br>'),
                nsGmx.Utils._label(
                    [gridFormatDM, nsGmx.Utils._t(window._gtxt('gridPlugin.formatDM'))],
                    [
                        ['dir', 'className', control.options.units === 'kilometers' ? 'gridFormatLabel disabledLabel' : 'gridFormatLabel'],
                        ['attr', 'for', 'gridFormatDM']
                    ]
                ),
                $('<br></br>'),
                nsGmx.Utils._label(
                    [gridFormatDMS, nsGmx.Utils._t(window._gtxt('gridPlugin.formatDMS'))],
                    [
                        ['dir', 'className', control.options.units === 'kilometers' ? 'gridFormatLabel disabledLabel' : 'gridFormatLabel'],
                        ['attr', 'for', 'gridFormatDMS']
                    ]
                )
            );

            $(gridStepConfig).append(
                gridSetStepButton,
                gridResetStepButton
            );

            $(gridConfigEditor).append(nsGmx.Utils._table([
                nsGmx.Utils._tbody([
                    nsGmx.Utils._tr([
                        nsGmx.Utils._td([nsGmx.Utils._t(window._gtxt('gridPlugin.gridColorSettings'))], [['css','width','70px']]),
                        nsGmx.Utils._td([fcp])
                    ]),
                    nsGmx.Utils._tr(
                        null, [['dir', 'className', 'bigEmptyTableRow']]
                    ),
                    nsGmx.Utils._tr([
                        nsGmx.Utils._td([nsGmx.Utils._t(window._gtxt('gridPlugin.gridStepSettings'))], [['attr', 'rowspan', '2'], ['css','width','70px']]),
                        nsGmx.Utils._td([gridStepYInputPanel])
                    ]),
                    nsGmx.Utils._tr([
                        nsGmx.Utils._td([gridStepXInputPanel])
                    ]),
                    nsGmx.Utils._tr(
                      null, [['dir', 'className', 'bigEmptyTableRow']]
                    ),
                    nsGmx.Utils._tr([
                        nsGmx.Utils._td([nsGmx.Utils._t(window._gtxt('gridPlugin.gridUnitsSettings'))], [['css','width','70px']]),
                        nsGmx.Utils._td([gridUnitsConfig])
                    ]),
                    nsGmx.Utils._tr(
                        null, [['dir', 'className', 'bigEmptyTableRow']]
                    ),
                    nsGmx.Utils._tr([
                        nsGmx.Utils._td([nsGmx.Utils._t(window._gtxt('gridPlugin.gridFormatSettings'))], [
                            ['css','width','70px'], ['css', 'vertical-align', 'middle']]),
                        nsGmx.Utils._td([gridFormatConfig])
                    ]),
                    nsGmx.Utils._tr(
                      null, [['dir', 'className', 'bigEmptyTableRow']]
                    ),
                    nsGmx.Utils._tr([
                        nsGmx.Utils._td(null, [['css','width','70px']]),
                        nsGmx.Utils._td([gridStepConfig])
                    ])
                ])
            ], [['dir', 'className', 'gridConfigTable']]));

            if (control.options.units === 'degrees') {
                gridStepUnitsDegrees.checked = true;
                enableFormats();
            } else if (control.options.units === 'kilometers') {
                gridStepUnitsKilometers.checked = true;
                disableFormats();
            }

            gridStepUnitsDegrees.onclick = handleUnits;
            gridStepUnitsKilometers.onclick = handleUnits;

            gridFormatDD.onclick = handleFormats;
            gridFormatDM.onclick = handleFormats;
            gridFormatDMS.onclick = handleFormats;

            gridSetStepButton.onclick = function () {
                control.setStep(gridStepXInput.value, gridStepYInput.value);
                updateInputsValues();
            };

            gridResetStepButton.onclick = function () {
                control.setTitleFormat(0);
                control.clearStep();
                enableFormats();
                gridStepUnitsDegrees.checked = true;
                gridFormatDD.checked = true;
                updateInputsValues();
            };

            gridStepUnitsDegrees.checked = true;
            gridFormatDD.checked = true;
            updateInputsValues();
            handleFormats();

            map.on('zoomend', function () {
                control.repaint();
                updateInputsValues();
            });

            var pos = nsGmx.Utils.getDialogPos(elem, false, 0);

            var closeFunc = function () {
                $(gridConfigEditor).find('.colorSelector').each(function() {
                    $('#' + $(this).data('colorpickerId')).remove();
                });
                manager.configDialog = null;
                control.options.units  === 'degrees' ? enableFormats() : disableFormats();

                // control.clearStep();
            };

            var params = {
                width: 280,
                height: 280,
                posX: pos.left,
                posY: pos.top,
                resizeFunc: false,
                closeFunc: closeFunc
            };

            manager.configDialog = nsGmx.Utils.showDialog(window._gtxt('gridPlugin.gridSettings'), gridConfigEditor, params);

            function updateInputsValues() {
                gridStepXInput.value = control.options.customStep.x ? Math.round(control.options.customStep.x * 100) / 100 : control.options.defaultStep.x;
                gridStepYInput.value = control.options.customStep.y ? Math.round(control.options.customStep.y * 100) / 100 : control.options.defaultStep.y;
            }

            function handleUnits() {
                var value = this.value;
                if (control.options.units !== value) {
                    control.setUnits(value);
                }
                value === 'degrees' ? enableFormats() : disableFormats();
                        updateInputsValues();
            }

            function handleFormats() {
                var value = this.value;
                if (control.options.titleFormat !== value) {
                    control.setTitleFormat(value);
                }
            }

            function disableFormats() {
                $('#gridFormatDD').prop('disabled', true);
                $('#gridFormatDM').prop('disabled', true);
                $('#gridFormatDMS').prop('disabled', true);

                $('.gridFormatLabel').addClass('disabledLabel');
            }

            function enableFormats() {
                $('#gridFormatDD').prop('disabled', false);
                $('#gridFormatDM').prop('disabled', false);
                $('#gridFormatDMS').prop('disabled', false);

                $('.gridFormatLabel').removeClass('disabledLabel');
            }
        }

        // создание иконки редактирования стиля
        function CreateGridConfigIcon(style, type) {
            var icon = nsGmx.Controls.createGeometryIcon(style, type);
            nsGmx.Utils._title(icon, window._gtxt('gridPlugin.gridSettings'));
            return icon;
        }

        this.Load = function () {
            if (lm != null){
                var alreadyLoaded = lm.createWorkCanvas('mapGrid', function () {
                    if (manager.state) {
                        manager.setState({isActive: false});
                    } else {
                        this.Unload();
                    }
                });
                if (!alreadyLoaded) {
                    $(lm.workCanvas).append(createGridLeftMenu());
                    control.setColor(tempStyle.outline.color);
                    manager.saveOptions();
                }
            }
        }
        this.Unload = function () {
            $(manager.configDialog).remove();
            manager.configDialog = null;
            $(lm.parentWorkCanvas).hide();
        };
    }

    var publicInterface = {
        pluginName: 'GridPlugin',
        ConfigureGridMenu: ConfigureGridMenu
  };

    window.gmxCore.addModule('GridPlugin',
        publicInterface
    );
})();

var nsGmx = window.nsGmx || {};

(function() {

    var MAX_SIZE = 10000;
    var EPS = 1E-9;

    // мы не хотим, чтобы рамка фигурировала в списке пользовательских объектов
    nsGmx.DrawingObjectCustomControllers.addDelegate({
        isHidden: function(obj) {
            if (obj.options.exportRect) {
                return true;
            }
            return false;
        }
    });

    window._translationsHash.addtext('rus', {
        mapExport: {
            settings: {
                settings: 'Настройки экспорта карты:',
                zoom: 'масштаб (зум)',
                size: 'размер',
                format: 'формат растра',
                fileType: 'тип файла',
                width: 'ширина (пк)',
                height: 'высота (пк)',
                name: 'имя файла'
            },
            formats: {
                jpeg: 'JPEG',
                png: 'PNG'
            },
            filetypes: {
                raster: 'растр',
                mbTiles: 'MBTiles',
                kmz: 'kmz'
            },
            select: 'Выделить область карты',
            unselect: 'Снять выделение',
            zoomToBox: 'Перейти к выделенному',
            zoomToLevel: 'Перейти на зум',
            exportMap: 'Экспорт',
            cancel: 'Отмена',
            sizeWarn: 'максимальный размер - 10000 пикселей',
            valueWarn: 'недопустимое значение',
            inQueue: 'в очереди',
            inProcess: 'файл формируется',
            exportError: 'ошибка экспорта'
        }
    });
    window._translationsHash.addtext('eng', {
        mapExport: {
            exportTooltip: 'Select area',
            settings: {
                settings: 'Map export settings:',
                zoom: 'zoom',
                size: 'size',
                format: 'raster format',
                fileType: 'file type',
                width: 'width (px)',
                height: 'height (px)',
                name: 'file name'
            },
            formats: {
                jpeg: 'JPEG',
                png: 'PNG'
            },
            filetypes: {
                raster: 'raster',
                mbTiles: 'MBTiles',
                kmz: 'kmz'
            },
            select: 'Select',
            unselect: 'Clear selection',
            zoomToBox: 'Zoom to selected',
            zoomToLevel: 'Zoom to level',
            exportMap: 'Export',
            cancel: 'Cancel',
            sizeWarn: 'incorrect size',
            valueWarn: 'incorrect value',
            inQueue: 'waiting',
            inProcess: 'processing file',
            exportError: 'export error'
        }
    });

    var formatTypes = [
        'jpeg',
        'png'
    ];

    var view;

    var MapExportMenu = function () {
        var canvas = nsGmx.Utils._div(null, [['dir','className','mapExportConfigLeftMenu']]);

        var ExportModel = window.Backbone.Model.extend({
            defaults: {
                lm: new window.leftMenu(),
                lmap: nsGmx.leafletMap,
                selArea: null,
                exportMode: true,
                width: 0,
                height: 0,
                widthValueErr: false,
                heightValueErr: false,
                widthSizeErr: false,
                heightSizeErr: false,
                format: null,
                fileType: null,
                x: null,
                y: null,
                z: null,
                latLng: null,
                coords: null,
                zoomLevels: getZoomLevels(),
                formatTypes: getTypes(formatTypes),
                fileTypes: null,
                name: '',
                taskInfo: null,
                exportErr: false
            }
        });

        var model = new ExportModel();

        var ExportView = window.Backbone.View.extend({
            el: $(canvas),
            model: model,
            template: window.Handlebars.compile(
                '<div class="selectButtons">' +
                        '<span class="buttonLink areaButton mapExportSelectButton"> {{i "mapExport.select"}}</span>' +
                        '<span class="zoomToBoxButton" style="display:none">' +
                        '</span>' +
                '</div>' +
                '<div class="exportSettings">' +
                    '<span>' +
                        '{{i "mapExport.settings.settings"}}' +
                    '</span>' +
                '</div>' +
                '<table class="settings">' +
                    '<tbody>' +
                        '<tr class="zoomSelect">' +
                            '<td class="eLabel">{{i "mapExport.settings.zoom"}}</td>' +
                            '<td class="eInput">' +
                                '<select class="zoomLevel">' +
                                    '{{#each this.zoomLevels}}' +
                                    '<option value="{{this.zoom}}"' +
                                        '{{#if this.current}} selected="selected"{{/if}}>' +
                                        '{{this.zoom}}' +
                                    '</option>' +
                                    '{{/each}}' +
                                '</select>' +
                            '</td>' +
                            '<td class="zoomToLevel">' +
                                '<span class="zoomToLevelButtonWrap" style="display:none">' +
                                '</span>' +
                            '</td>' +
                        '</tr>' +
                        '<tr class="dims">' +
                            '<td class="eLabel">{{i "mapExport.settings.width"}}</td>' +
                            '<td class="eInput">' +
                                '<input type="text" class="mapExportWidth" value="{{width}}"/>' +
                            '</td>' +
                            '<td class="mapExportWarn" rowspan=2></td>' +
                        '</tr>' +
                        '<tr class="dims">' +
                            '<td class="eLabel">{{i "mapExport.settings.height"}}</td>' +
                            '<td class="eInput">' +
                                '<input type="text" class="mapExportHeight" value="{{height}}"/>' +
                            '</td>' +
                        '</tr>' +
                        '<tr class="formatSelect">' +
                            '<td class="eLabel">{{i "mapExport.settings.format"}}</td>' +
                            '<td class="eInput">' +
                                '<select class="formatTypes">' +
                                    '{{#each this.formatTypes}}' +
                                    '<option value="{{this.type}}"' +
                                        '{{#if this.current}} selected="selected" {{/if}}>' +
                                        '{{this.type}}' +
                                    '</option>' +
                                    '{{/each}}' +
                                '</select>' +
                            '</td>' +
                        '</tr>' +
                        '<tr class="typeSelect">' +
                            '<td class="eLabel">{{i "mapExport.settings.fileType"}}</td>' +
                            '<td class="eInput">' +
                                '<select class="fileTypes">' +
                                    '{{#each this.fileTypes}}' +
                                    '<option value="{{this.type}}"' +
                                        '{{#if this.current}} selected="selected" {{/if}}>' +
                                        '{{this.type}}' +
                                    '</option>' +
                                    '{{/each}}' +
                                '</select>' +
                            '</td>' +
                        '</tr>' +
                        '<tr class="nameSelect">' +
                            '<td class="eLabel">{{i "mapExport.settings.name"}}</td>' +
                            '<td class="eInput">' +
                                '<input type="text" class="mapExportName" value=""/>' +
                            '</td>' +
                        '</tr>' +
                    '</tbody>' +
                '</table>' +
                '<div class="exportWrap">' +
                    '<div class="export">' +
                        '<span class="buttonLink mapExportButton"> {{i "mapExport.exportMap"}}</span>' +
                        '<span class="buttonLink cancelButton" style="display:none"> {{i "mapExport.cancel"}}</span>' +
                        '<span class="spinHolder" style="display:none">' +
                            // '<img src="img/progress.gif"/>' +
                            '<span class="spinMessage"></span>' +
                            '</span>' +
                        '<span class="exportErrorMessage" style="display:none">{{i "mapExport.exportError"}}</span>' +
                    '</div>' +
                    '<div class="export-progress-container" style="display:none">' +
                        '<div class="export-progressbar"></div>' +
                    '</div>' +
                '</div>'
            ),
            events: {
                'click .mapExportSelectButton': 'selectArea',
                'click .mapExportUnselectButton': 'unselectArea',
                'click .zoomToBoxButton': 'zoomToBox',
                'click .zoomToLevelButtonWrap': 'zoomToLevel',
                'input .mapExportWidth': 'resize',
                'input .mapExportHeight': 'resize',
                'change .zoomLevel': 'setZoom',
                'change .formatTypes': 'setFormat',
                'change .fileTypes': 'setFileType',
                'input .mapExportName': 'setName',
                'click .mapExportButton': 'exportMap',
                'click .cancelButton': 'cancelExport'
            },

            initialize: function () {
                var attrs = this.model.toJSON(),
                    currentZoom = attrs.lmap.getZoom(),
                    zoomLevels = attrs.zoomLevels,
                    formatTypes = attrs.formatTypes,

                    // объявление типов файлов происходит здесь, так как необходима обработка смены языка
                    // типы файлов хранятся в текущем языке
                    fileTypes = [
                        window._gtxt('mapExport.filetypes.raster'),
                        window._gtxt('mapExport.filetypes.mbTiles'),
                        window._gtxt('mapExport.filetypes.kmz')
                    ];
                    updatedFileTypes = getTypes(fileTypes);

                this.listenTo(this.model, 'change:selArea', this.updateArea);
                this.listenTo(this.model, 'change:width', this.updateSize);
                this.listenTo(this.model, 'change:height', this.updateSize);
                this.listenTo(this.model, 'change:widthValueErr', this.handleValueError);
                this.listenTo(this.model, 'change:heightValueErr', this.handleValueError);
                this.listenTo(this.model, 'change:widthSizeErr', this.handleSizeError);
                this.listenTo(this.model, 'change:heightSizeErr', this.handleSizeError);
                this.listenTo(this.model, 'change:name', this.updateName);
                this.listenTo(this.model, 'change:z', this.updateZoom);
                this.listenTo(this.model, 'change:exportErr', this.handleExportError);

                for (var i = attrs.lmap.getMinZoom(); i < zoomLevels.length; i++) {
                    zoomLevels[i].current = false;

                    if (i === currentZoom) {
                        zoomLevels[i].current = true;
                    }
                }

                for (var j = 0; j < formatTypes.length; j++) {
                    if (formatTypes[j].current === true) {
                        this.model.set('format', formatTypes[j].type);
                    }
                }

                for (var j = 0; j < updatedFileTypes.length; j++) {
                    if (updatedFileTypes[j].current === true) {
                        this.model.set('fileType', updatedFileTypes[j].type);
                    }
                }

                this.model.set({
                    z: currentZoom,
                    zoomLevels: zoomLevels,
                    formatTypes: formatTypes,
                    fileTypes: updatedFileTypes,
                    name: nsGmx.gmxMap.properties.title
                });

                this.updateArea();

                this.render();
            },

            render: function () {
                var zoomToBoxButton,
                    zoomToLevelButton;

                this.$el.html(this.template(this.model.toJSON()));
                this.$('.zoomLevel').prop('disabled', true)
                this.$('.mapExportWidth').prop('disabled', true);
                this.$('.mapExportHeight').prop('disabled', true);
                this.$('.formatTypes').prop('disabled', true);
                this.$('.fileTypes').prop('disabled', true);
                this.$('.mapExportName').val(this.model.get('name'));
                this.$('.mapExportName').prop('disabled', true);
                this.$('.mapExportButton').addClass('gmx-disabled');

                zoomToBoxButton = nsGmx.Utils.makeImageButton('img/zoom_to_box_tool_small.png', 'img/zoom_to_box_tool_small.png');
                nsGmx.Utils._title(zoomToBoxButton, window._gtxt('mapExport.zoomToBox'));

                this.$('.zoomToBoxButton').append(zoomToBoxButton);

                zoomToLevelButton = nsGmx.Utils.makeImageButton('img/zoom_to_level_tool_small.png', 'img/zoom_to_level_tool_small.png');
                $(zoomToLevelButton).addClass('zoomToLevelButton');
                nsGmx.Utils._title(zoomToLevelButton, (window._gtxt('mapExport.zoomToLevel') + ' ' + this.model.get('z')));

                this.$('.zoomToLevelButtonWrap').append(zoomToLevelButton);

                return this;
            },

            updateArea: function () {
                var attrs = this.model.toJSON(),
                    areaButton = this.$('.areaButton'),
                    zoomToBoxButton = this.$('.zoomToBoxButton'),
                    zoomToLevelButton = this.$('.zoomToLevelButtonWrap'),
                    zoomSelect = this.$('.zoomLevel'),
                    widthInput = this.$('.mapExportWidth'),
                    heightInput = this.$('.mapExportHeight'),
                    formatSelect = this.$('.formatTypes'),
                    fileSelect = this.$('.fileTypes'),
                    exportNameInput = this.$('.mapExportName'),
                    exportButton = this.$('.mapExportButton'),
                    inputs = [
                        zoomSelect,
                        widthInput,
                        heightInput,
                        formatSelect,
                        fileSelect,
                        exportNameInput,
                        exportButton
                    ];

                for (var i = 0; i < inputs.length; i++) {
                    if (!attrs.selArea) {
                        $(inputs[i]).prop('disabled', true);
                    } else {
                        $(inputs[i]).prop('disabled', false);
                    }
                }
                if (attrs.selArea) {
                    $(areaButton).removeClass('mapExportSelectButton');
                    $(areaButton).addClass('mapExportUnselectButton');
                    $(areaButton).text(window._gtxt('mapExport.unselect'));
                    $(zoomToBoxButton).show();
                    $(zoomToLevelButton).show();
                    if (!attrs.widthValueErr    &&
                        !attrs.widthSizeErr     &&
                        !attrs.heightValueErr   &&
                        !attrs.heightSizeErr    &&
                        attrs.name !== '') {
                            $(exportButton).removeClass('gmx-disabled');
                    }
                } else {
                    $(areaButton).removeClass('mapExportUnselectButton');
                    $(areaButton).addClass('mapExportSelectButton');
                    $(areaButton).text(window._gtxt('mapExport.select'));
                    $(zoomToBoxButton).hide();
                    $(zoomToLevelButton).hide();
                    $(exportButton).addClass('gmx-disabled');
                }
            },

            updateSize: function () {
                var attrs = this.model.toJSON(),
                    widthInput = this.$('.mapExportWidth'),
                    width = Number(attrs.width).toFixed(0),
                    heightInput = this.$('.mapExportHeight'),
                    height = Number(attrs.height).toFixed(0);

                if (!attrs.widthValueErr) {
                    $(widthInput).val((width));
                }

                if (!attrs.heightValueErr) {
                    $(heightInput).val((height));
                }
            },

            handleValueError: function () {
                var attrs = this.model.toJSON(),
                    widthInput = this.$('.mapExportWidth'),
                    heightInput = this.$('.mapExportHeight'),
                    exportButton = this.$('.mapExportButton'),
                    warn = this.$('.mapExportWarn');

                if (attrs.widthValueErr) {
                    $(widthInput).addClass('error');
                } else {
                    if (!attrs.widthSizeErr) {
                        $(widthInput).removeClass('error');
                    }
                }

                if (attrs.heightValueErr) {
                    $(heightInput).addClass('error');
                } else {
                    if (!attrs.heightSizeErr) {
                        $(heightInput).removeClass('error');
                    }
                }

                if (attrs.widthValueErr || attrs.heightValueErr) {
                    $(exportButton).addClass('gmx-disabled');
                    $(warn).html(window._gtxt('mapExport.valueWarn'));
                } else {
                    if (attrs.selArea && attrs.name) {
                        $(exportButton).removeClass('gmx-disabled');
                    }
                    if (attrs.widthSizeErr || attrs.heightSizeErr) {
                        $(warn).html(window._gtxt('mapExport.sizeWarn'));
                    } else {
                        $(warn).html('');
                    }
                }
            },

            handleSizeError: function () {
                var attrs = this.model.toJSON(),
                    widthInput = this.$('.mapExportWidth'),
                    heightInput = this.$('.mapExportHeight'),
                    exportButton = this.$('.mapExportButton'),
                    warn = this.$('.mapExportWarn');

                if (attrs.widthSizeErr) {
                    $(widthInput).addClass('error');
                } else {
                    if (!attrs.widthValueErr) {
                        $(widthInput).removeClass('error');
                    }
                }

                if (attrs.heightSizeErr) {
                    $(heightInput).addClass('error');
                } else {
                    if (!attrs.heightValueErr) {
                        $(heightInput).removeClass('error');
                    }
                }

                if (attrs.widthSizeErr || attrs.heightSizeErr) {
                    $(exportButton).addClass('gmx-disabled');
                    if (!attrs.widthValueErr && !attrs.heightValueErr) {
                        $(warn).html(window._gtxt('mapExport.sizeWarn'));
                    }
                } else {
                    if (!attrs.widthValueErr && !attrs.heightValueErr) {
                        if (attrs.selArea && attrs.name) {
                            $(exportButton).removeClass('gmx-disabled');
                        }
                        $(warn).html('');
                    }
                }
            },

            handleExportError: function () {
                var attrs = this.model.toJSON(),
                    exportButton = this.$('.mapExportButton'),
                    progressBarContainer = this.$('.export-progress-container'),
                    spinHolder = this.$('.spinHolder'),
                    cancelButton = this.$('.cancelButton'),
                    exportErrorMessage = this.$('.exportErrorMessage');

                if (attrs.selArea) {
                    $(exportButton).removeClass('gmx-disabled');
                } else {
                    $(exportButton).addClass('gmx-disabled');
                }

                if (attrs.exportErr) {
                    $(spinHolder).toggle();
                    $(progressBarContainer).toggle();
                    $(exportButton).toggle();
                    $(cancelButton).toggle();
                    $(exportErrorMessage).toggle();
                } else {
                    $(exportErrorMessage).toggle();
                }
            },

            updateName: function () {
                var attrs = this.model.toJSON(),
                    exportNameInput = this.$('.mapExportName'),
                    exportButton = this.$('.mapExportButton');

                if (attrs.name === '') {
                    $(exportNameInput).addClass('error');
                    $(exportButton).addClass('gmx-disabled');
                } else {
                    if (
                        attrs.selArea           &&
                        !attrs.widthValueErr    &&
                        !attrs.widthSizeErr     &&
                        !attrs.heightValueErr   &&
                        !attrs.heightSizeErr
                        ) {
                        $(exportButton).removeClass('gmx-disabled');
                    }

                    $(exportNameInput).removeClass('error');
                }
            },

            updateZoom: function () {
                var attrs = this.model.toJSON(),
                    levels = this.$('.zoomLevel'),
                    list = $(levels).find('option'),
                    zoomToLevelButton = this.$('.zoomToLevelButton')[0];

                for (var i = 0; i < list.length; i++) {
                    var el = list[i];

                    if (el.tagName === 'OPTION') {

                        if (Number($(el).val()) === attrs.z) {
                            $(el).prop('selected', true);
                        } else {
                            $(el).prop('selected', false);
                        }

                    }
                }

                if (zoomToLevelButton) {
                    nsGmx.Utils._title(zoomToLevelButton, (window._gtxt('mapExport.zoomToLevel') + ' ' + attrs.z));
                }
            },

            setZoom: function (e) {
                var attrs = this.model.toJSON(),
                    selectedZoom = Number(e.target.value),
                    zoomLevels = attrs.zoomLevels;

                for (var i = attrs.lmap.getMinZoom(); i < zoomLevels.length; i++) {
                    zoomLevels[i].current = false;

                    if (i === selectedZoom) {
                        zoomLevels[i].current = true;
                    }
                }

                this.model.set({
                    zoomLevels: zoomLevels,
                    z: selectedZoom
                });

                this._updateCoords();
            },

            setFormat: function (e) {
                var attrs = this.model.toJSON(),
                    formatTypes = attrs.formatTypes,
                    selectedFormat = e.target.value;

                for (var i = 0; i < formatTypes.length; i++) {
                    formatTypes[i].current = false;

                    if (formatTypes[i].type === selectedFormat) {
                        formatTypes[i].current = true;
                    }
                }

                this.model.set({
                    formatTypes: formatTypes,
                    format: selectedFormat
                });
            },

            setFileType: function (e) {
                var attrs = this.model.toJSON(),
                    fileTypes = attrs.fileTypes,
                    selectedFileType = e.target.value;

                for (var i = 0; i < fileTypes.length; i++) {
                    fileTypes[i].current = false;

                    if (fileTypes[i].type === selectedFileType) {
                        fileTypes[i].current = true;
                    }
                }

                this.model.set({
                    fileTypes: fileTypes,
                    fileType: selectedFileType
                });
            },

            setName: function (e) {
                this.model.set('name', e.target.value)
            },

            selectArea: function () {
                var attrs = this.model.toJSON();

                if (!attrs.lmap || attrs.selArea) {
                    return;
                }

                var currentZoom = attrs.lmap.getZoom(),
                    zoomLevels = attrs.zoomLevels,
                    mapBounds = attrs.lmap.getBounds(),
                    latLngs = [
                        mapBounds.getSouthWest(),
                        mapBounds.getNorthWest(),
                        mapBounds.getNorthEast(),
                        mapBounds.getSouthEast()
                    ],
                    n = mapBounds.getNorth(),
                    e = mapBounds.getEast(),
                    s = mapBounds.getSouth(),
                    w = mapBounds.getWest(),
                    mapHeight = n - s,
                    mapWidth = e - w,

                    // какую часть экрана отсекать с краев первоначальной рамки
                    scale = 4,
                    converted = this._convertFromLatLngs(latLngs, attrs.z),
                    dims = this._getDimensions(converted),
                    xx = [converted[0].x, converted[1].x, converted[2].x, converted[3].x],
                    yy = [converted[0].y, converted[1].y, converted[2].y, converted[3].y],
                    bottomLeft =    L.point(this._getMin(xx) + dims.width / scale,  this._getMax(yy) - dims.height / scale),
                    topLeft =       L.point(this._getMin(xx) + dims.width / scale,  this._getMin(yy) + dims.height / scale),
                    topRight =      L.point(this._getMax(xx) - dims.width / scale,  this._getMin(yy) + dims.height / scale),
                    bottomRight =   L.point(this._getMax(xx) - dims.width / scale,  this._getMax(yy) - dims.height / scale),
                    initialBounds = this._convertToLantLngs([bottomLeft, topLeft, topRight, bottomRight], attrs.z);

                for (var i = attrs.lmap.getMinZoom(); i < zoomLevels.length; i++) {
                    zoomLevels[i].current = false;

                    if (i === currentZoom) {
                        zoomLevels[i].current = true;
                    }
                }

                // прямоугольная рамка
                var rect = L.rectangle(initialBounds);

                this.model.set({
                    z: currentZoom,
                    zoomLevels: zoomLevels
                });

                this._createFrame(rect);

                this._updateCoords();
            },

            unselectArea: function () {
                var attrs = this.model.toJSON();
                this._removeFrame();

                this.model.set({
                    width: 0,
                    height: 0,
                    z: attrs.lmap.getZoom(),
                    widthValueErr: false,
                    widthSizeErr: false,
                    heightValueErr: false,
                    heightSizeErr: false,
                    exportErr: false
                });
            },

            zoomToBox: function () {
                var attrs = this.model.toJSON();

                attrs.lmap.fitBounds(attrs.selArea.getBounds());
            },

            zoomToLevel: function () {
                var attrs = this.model.toJSON(),
                    initialCoords = attrs.selArea.rings[0].ring._getLatLngsArr(),
                    converted = this._convertFromLatLngs(initialCoords, attrs.z),
                    dims = this._getDimensions(converted);

                attrs.lmap.setView(dims.latLng, attrs.z);
            },

            exportMap: function () {
                var _this = this,
                    attrs = this.model.toJSON(),
                    initialCoords = attrs.selArea.rings[0].ring._getLatLngsArr(),
                    screenCoords = !attrs.coords ? this._convertFromLatLngs(initialCoords, attrs.z) : this._convertFromLatLngs(attrs.coords, attrs.z),
                    dimensions = this._getDimensions(screenCoords),
                    mapStateParams = {
                        exportMode: true,
                        isFullScreen: true,
                        width: Math.floor(Number(attrs.width)) + 'px',
                        height: Math.floor(Number(attrs.height)) + 'px',
                        position: {
                            x: dimensions.mercCenter.x,
                            y: dimensions.mercCenter.y,
                            z: attrs.z ? 17 - attrs.z : 17 - attrs.lmap.getZoom()
                        },
                        latLng: dimensions.latLng,
                        exportBounds: attrs.selArea.getBounds(),
                        grid: attrs.fileType === window._gtxt('mapExport.filetypes.raster') ? nsGmx.gridManager.state : false
                    },
                    exportParams = {
                        width: Math.floor(Number(attrs.width)),
                        height: Math.floor(Number(attrs.height)),
                        filename: attrs.name,
                        container: attrs.fileType === window._gtxt('mapExport.filetypes.raster') ? 'grimage' : attrs.fileType,
                        format: attrs.format
                    },
                    exportButton = this.$('.mapExportButton'),
                    cancelButton = this.$('.cancelButton'),
                    progressBarContainer = this.$('.export-progress-container'),
                    progressBar = this.$('.export-progressbar'),
                    spinHolder = this.$('.spinHolder'),
                    spinMessage = this.$('.spinMessage'),
                    def;

                $(exportButton).toggle();
                $(cancelButton).toggle();

                window._mapHelper.createExportPermalink(mapStateParams, processLink);

                function processLink(id){
                    var url = window.serverBase + 'Map/Render?' + $.param(exportParams) + '&uri=' + 'http://' + window.location.host + window.location.pathname + '?permalink=' + id;

                    _this.model.set({
                        exportErr: false
                    });

                    $(exportButton).addClass('gmx-disabled');

                    $(progressBarContainer).toggle();
                    $(spinHolder).toggle();

                    $(progressBar).progressbar({
                        max: 100,
                        value: 0
                    });

                    def = nsGmx.asyncTaskManager.sendGmxPostRequest(url);

                    def.done(function(taskInfo){
                        var url2 = window.serverBase + taskInfo.Result.downloadFile,
                            selArea = _this.model.get('selArea');

                        if (selArea) {
                            $(exportButton).removeClass('gmx-disabled');
                        } else {
                            $(exportButton).addClass('gmx-disabled');
                        }

                        $(exportButton).toggle();
                        $(cancelButton).toggle();
                        $(spinHolder).toggle();
                        $(progressBarContainer).toggle();

                        downloadFile(url2);

                    }).fail(function(taskInfo){
                        if (taskInfo.ErrorInfo.ErrorMessage !== 'Task is canceled') {
                            $(exportButton).removeClass('gmx-disabled');

                            _this.model.set({
                                exportErr: true
                            });
                        }
                    }).progress(function(taskInfo){
                        _this.model.set({
                            taskInfo: taskInfo
                        });

                        if (taskInfo.Status === 'queue') {
                            $(spinMessage).html(window._gtxt('mapExport.inQueue'));
                        } else if (taskInfo.Status === 'progress') {
                            $(spinMessage).html(window._gtxt('mapExport.inProcess'));

                            $(progressBar).progressbar('value', taskInfo.Progress);
                        }
                    });

                    function downloadFile(url) {
                        var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1,
                            isSafari = navigator.userAgent.toLowerCase().indexOf('safari') > -1;

                        if (isChrome || isSafari) {
                            var link = document.createElement('a');
                            link.href = url;
                            link.download = attrs.name;

                            if (document.createEvent) {
                                var e = document.createEvent('MouseEvents');
                                e.initEvent('click', true, true);
                                link.dispatchEvent(e);
                                return true;
                            }
                        } else {
                            window.open(url, '_self');
                        }
                    }
                }
            },

            cancelExport: function() {
                var attrs = this.model.toJSON(),
                    taskInfo = this.model.get('taskInfo'),
                    exportButton = this.$('.mapExportButton'),
                    cancelButton = this.$('.cancelButton'),
                    progressBarContainer = this.$('.export-progress-container'),
                    spinHolder = this.$('.spinHolder'),
                    spinMessage = this.$('.spinMessage'),
                    url;


                url = window.serverBase + 'AsyncTaskCancel?' + $.param({TaskID: taskInfo.TaskID});

                sendCrossDomainJSONRequest(url, function(response) {
                    if (!parseResponse(response))
                        return;

                    if (response.Result) {
                        if (attrs.selArea) {
                            $(exportButton).removeClass('gmx-disabled');
                        };

                        $(exportButton).toggle();
                        $(cancelButton).toggle();
                        $(spinMessage).empty();
                        $(spinHolder).toggle();
                        $(progressBarContainer).toggle();
                    }
                })
            },

            resize: function(e) {
                var attrs = this.model.toJSON(),
                    start = e.target.selectionStart,
                    end = e.target.selectionEnd,
                    initialCoords,
                    scale,
                    screenCoords,
                    width, height,
                    bottomLeft, bottomRight,
                    topLeft, topRight,
                    newBounds,
                    value, valueErr, sizeErr;

                if (!attrs.lmap || !attrs.selArea) {
                    return;
                }

                initialCoords = attrs.selArea.rings[0].ring._getLatLngsArr();

                // разница между целевым и текущим зумом
                scale = Math.pow(2, (attrs.z - attrs.lmap.getZoom()));

                screenCoords = !attrs.coords ? this._revertCoords(this._convertFromLatLngs(initialCoords, attrs.z)) : this._revertCoords(this._convertFromLatLngs(attrs.coords, attrs.z));

                value = Number(e.target.value);
                valueErr = value <= 0 || isNaN(value);
                sizeErr = value - MAX_SIZE > EPS;

                // обработка инпута ширины
                if (e.target.className === 'mapExportWidth' || e.target.className === 'mapExportWidth error') {
                    if (valueErr) {
                        this.model.set('widthValueErr', true)
                    } else {
                        this.model.set('widthValueErr', false)
                        this.model.set('width', e.target.value);

                        if (sizeErr) {
                            this.model.set('widthSizeErr', true);
                        } else {
                            this.model.set('widthSizeErr', false);
                        }
                    }
                }

                // обработка инпута высоты
                if (e.target.className === 'mapExportHeight' || e.target.className === 'mapExportHeight error') {
                    if (valueErr) {
                        this.model.set('heightValueErr', true)
                    } else {
                        this.model.set('heightValueErr', false)
                        this.model.set('height', e.target.value);

                        if (sizeErr) {
                            this.model.set('heightSizeErr', true);
                        } else {
                            this.model.set('heightSizeErr', false);
                        }
                    }
                }

                attrs = this.model.toJSON();

                if (attrs.widthValueErr || attrs.heightValueErr) return;

                width = e.target.className === 'mapExportWidth' || e.target.className === 'mapExportWidth error' ? Number(e.target.value) : Number(attrs.width);
                height = e.target.className === 'mapExportHeight' || e.target.className === 'mapExportHeight error' ? Number(e.target.value) : Number(attrs.height);

                newBounds = [];

                // изменяем координаты объекта, учитывая изменившуюся ширину или высоту
                // геометрия изменяется в соответствии с введенными значениями
                // topLeft остается неизменным
                bottomLeft = screenCoords[0];
                topLeft = screenCoords[1];
                topRight = screenCoords[2];
                bottomRight = screenCoords[3];

                topRight.x = (topLeft.x + width);
                topRight.y = topLeft.y;

                bottomLeft.x = topLeft.x;
                bottomLeft.y = (topLeft.y + height);

                bottomRight.x = (topLeft.x + width);
                bottomRight.y = (topLeft.y + height);

                topLeft.x = topLeft.x;
                topLeft.y = topLeft.y;

                newBounds.push(
                    [attrs.lmap.unproject([bottomLeft.x / scale, bottomLeft.y / scale])],
                    [attrs.lmap.unproject([topRight.x / scale, topRight.y / scale])]
                );

                // измененная прямоугольная рамка
                var newRect = L.rectangle(newBounds);
                this.model.set('coords', L.version === "0.7.7" ? newRect.getLatLngs() : newRect.getLatLngs()[0]);

                attrs.lmap.gmxDrawing.remove(attrs.selArea);

                this._createFrame(newRect);
                this._updateCoords();

                // восстановим позицию курсора
                e.target.setSelectionRange(start, end);
            },

            _createFrame: function(rectangle) {
                var attrs = this.model.toJSON(),
                    options = {
                        editable: true,
                        map: true,
                        lineStyle: {
                            dashArray: '5 5',
                            color: '#f57c00',
                            weight: 3.5
                        },
                        pointStyle: {
                            size: L.Browser.mobile ? 40 : 8,
                            color: '#f57c00'
                        }
                    };

                this.model.set({
                    selArea: attrs.lmap.gmxDrawing.add(rectangle, L.extend(options, {
                        exportRect: true
                    }))
                });

                // навешивает обработчики на рамку выделения
                var frame = this.model.get('selArea'),
                    _this = this;

                frame.on('edit', _this._resizeFrame.bind(_this));
                frame.on('remove', function () {
                    var attrs = _this.model.toJSON();

                    _this.model.set({
                        width: 0,
                        height: 0,
                        widthValueErr: false,
                        widthSizeErr: false,
                        heightValueErr: false,
                        heightSizeErr: false,
                        exportErr: false
                    });
                });

            },

            _resizeFrame: function () {
                var attrs = this.model.toJSON(),
                    initialCoords,
                    screenCoords,
                    dimensions,
                    w, h;

                initialCoords = attrs.selArea.rings[0].ring._getLatLngsArr();
                screenCoords = this._convertFromLatLngs(initialCoords, attrs.z);
                dimensions = this._getDimensions(screenCoords);

                w = Math.abs(dimensions.width);
                h = Math.abs(dimensions.height);

                if (w - MAX_SIZE > EPS) {
                    this.model.set('widthSizeErr', true)
                } else {
                    this.model.set('widthSizeErr', false)
                }

                if (h - MAX_SIZE > EPS) {
                    this.model.set('heightSizeErr', true)
                } else {
                    this.model.set('heightSizeErr', false)
                }

                this.model.set({
                    coords: initialCoords,
                    width: String(w),
                    height: String(h)
                });
            },

            _removeFrame: function () {
                var attrs = this.model.toJSON();

                if (!attrs.selArea) {
                    return;
                }

                attrs.lmap.gmxDrawing.remove(attrs.selArea);

                this.model.set({
                    selArea: null,
                    coords: null
                });
            },

            _updateCoords: function () {
                var attrs = this.model.toJSON(),
                    initialCoords,
                    screenCoords,
                    dimensions,
                    w, h;

                if (!attrs.selArea) {
                    return;
                }

                initialCoords = attrs.selArea.rings[0].ring._getLatLngsArr();
                screenCoords = !attrs.coords ? this._convertFromLatLngs(initialCoords, attrs.z) : this._convertFromLatLngs(attrs.coords, attrs.z);
                dimensions = this._getDimensions(screenCoords);

                w = Math.abs(dimensions.width);
                h = Math.abs(dimensions.height);

                if (!attrs.coords) {
                    this.model.set('coords', initialCoords)
                }

                if (w - MAX_SIZE > EPS) {
                    this.model.set('widthSizeErr', true)
                } else {
                    this.model.set('widthSizeErr', false)
                }

                if (h - MAX_SIZE > EPS) {
                    this.model.set('heightSizeErr', true)
                } else {
                    this.model.set('heightSizeErr', false)
                }

                this.model.set({
                    width: String(w),
                    height: String(h)
                });
            },

            _revertCoords: function (coords) {
                var xx,
                    yy,
                    bottomLeft, topLeft,
                    topRight, bottomRight;

                xx = [coords[0].x, coords[1].x, coords[2].x, coords[3].x];
                yy = [coords[0].y, coords[1].y, coords[2].y, coords[3].y];
                bottomLeft = L.point(this._getMin(xx), this._getMax(yy));
                topLeft = L.point(this._getMin(xx), this._getMin(yy));
                topRight = L.point(this._getMax(xx), this._getMin(yy));
                bottomRight = L.point(this._getMax(xx), this._getMax(yy));

                return [bottomLeft, topLeft, topRight, bottomRight];

            },

            _convertFromLatLngs: function (latlngs, zoom) {
                var attrs = this.model.toJSON(),
                    converted = latlngs.map(function(ll) {
                        return attrs.lmap.project([ll.lat, ll.lng], zoom);
                    });

                return converted;
            },

            _convertToLantLngs: function (points, zoom) {
                var attrs = this.model.toJSON(),
                    converted = points.map(function(point) {
                        return attrs.lmap.unproject([point.x, point.y], zoom);
                    });

                return converted;
            },

            _getDimensions: function(points) {
                var attrs = this.model.toJSON(),
                    bottomLeft, topRight,
                    width, height,
                    x, y;

                points = this._revertCoords(points);
                bottomLeft = points[0];
                topRight = points[2];
                width = Math.abs(topRight.x - bottomLeft.x);
                height = Math.abs(bottomLeft.y - topRight.y);
                x = bottomLeft.x + width / 2;
                y = topRight.y + height / 2;

                return {
                    bottomLeft: bottomLeft,
                    topRight: topRight,
                    width: width,
                    height: height,
                    mercCenter: L.Projection.Mercator.project(attrs.lmap.unproject([x, y], attrs.z)),
                    latLng: attrs.lmap.unproject([x, y], attrs.z)
                }
            },

            _getMax: function(arr) {
                return Math.max.apply(null, arr);
            },

            _getMin: function(arr) {
                return Math.min.apply(null, arr);
            }
        });

        view = new ExportView();

        function getZoomLevels() {
            var zoomLevels = [],
                lmap = nsGmx.leafletMap,
                min = lmap.getMinZoom(),
                max = lmap.getMaxZoom(),
                currentZoom = lmap.getZoom();

            for (var i = min; i <= max; i++) {
                zoomLevels[i] = {zoom: i, current: false};

                if (i === currentZoom) {
                    zoomLevels[i].current = true;
                }
            }
            return zoomLevels;
        }

        function getTypes(types) {
            var arr = [];

            for (var i = 0; i < types.length; i++) {
                arr[i] = {type: types[i], current: false};

                if (i === 0) {
                    arr[i].current = true;
                }
            }
            return arr;
        }

        this.Load = function () {
            var lm = model.get('lm');

            if (lm != null) {
                var alreadyLoaded = lm.createWorkCanvas('export', this.Unload);
                if (!alreadyLoaded) {
                    $(lm.workCanvas).append(view.el);
                }
            }
        }
        this.Unload = function () {
            var attrs = model.toJSON();
            attrs.lmap.gmxDrawing.remove(attrs.selArea);
            model.set({
                selArea: null,
                width: 0,
                height: 0,
                widthValueErr: false,
                heightValueErr: false,
                widthSizeErr: false,
                heightSizeErr: false,
                format: null,
                x: null,
                z: attrs.lmap.getZoom(),
                y: null,
                latLng: null,
                coords: null,
                zoomLevels: getZoomLevels(),
                formatTypes: getTypes(formatTypes),
                fileTypes: null,
                exportErr: false
            });
        };
    }

    var publicInterface = {
        pluginName: 'MapExport',
        MapExportMenu: MapExportMenu
  };

    window.gmxCore.addModule('MapExport',
        publicInterface
    );
})();

var nsGmx = window.nsGmx || {};

(function() {

    var MAX_INDEX_COUNT = 10000;
    var KM_PER_DEGREE = 111.31949;

    nsGmx.DrawingObjectCustomControllers.addDelegate({
        isHidden: function(obj) {
            if (obj.options.exportRect) {
                return true;
            }
            return false;
        }
    });

    window._translationsHash.addtext('rus', {
        indexGrid: {
            settings: 'Настройки индексной сетки',
            select: 'Выделить область карты',
            unselect: 'Снять выделение',
            coordinates: 'координаты',
            lat: 'широта',
            lng: 'долгота',
            min: 'мин',
            max: 'макс',
            step: 'шаг (км)',
            onLat: 'по широте',
            onLng: 'по долготе',
            count: 'количество идексов',
            name: 'имя слоя',
            create: 'Создать слой индексной сетки',
            valueWarn: 'недопустимое значение',
            indexCountWarn: 'превышено допустимое число ячеек (10 000)',
            nameWarn: 'имя слоя не должно быть пустым'
        }
    });
    window._translationsHash.addtext('eng', {
        indexGrid: {
            settings: 'Index grid settings',
            select: 'Select',
            unselect: 'Clear selection',
            coordinates: 'coordinates',
            lat: 'latitude',
            lng: 'longitude',
            max: 'max',
            min: 'min',
            step: 'Step (km)',
            onLat: 'on latitude',
            onLng: 'on longitude',
            count: 'index count',
            name: 'layer name',
            create: 'Create index grid layer',
            valueWarn: 'incorrect value',
            valueWarn: 'incorrect value',
            indexCountWarn: 'max ceils number exceeded (10 000)',
            nameWarn: 'layer name cannot be empty'
        }
    });

    var view;

    var IndexGridMenu = function () {
        var canvas = nsGmx.Utils._div(null, [['dir','className','indexGridConfigLeftMenu']]);

        var IndexGridModel = window.Backbone.Model.extend({
            defaults: {
                lm: new window.leftMenu(),
                lmap: nsGmx.leafletMap,
                selArea: null,
                xStep: 1,
                yStep: 1,
                xCount: null,
                yCount: null,
                xStepErr: false,
                yStepErr: false,
                indexCount: null,
                indexCountErr: false,
                maxLat: null,
                maxLng: null,
                minLat: null,
                minLng: null,
                maxLatErr: false,
                maxLngErr: false,
                minLatErr: false,
                minLngErr: false,
                z: null,
                coords: null,
                name: '',
                nameErr: true
            }
        });

        var model = new IndexGridModel();

        var IndexGridView = window.Backbone.View.extend({
            el: $(canvas),
            model: model,
            template: window.Handlebars.compile(
                '<div class="selectButtons">' +
                        '<span class="buttonLink areaButton indexGridSelectButton"> {{i "indexGrid.select"}}</span>' +
                        '</span>' +
                '</div>' +
                '<div class="indexgridsettings">' +
                    '<span>' +
                        '{{i "indexGrid.settings"}}' +
                    '</span>' +
                '</div>' +
                '<table class="settings">' +
                    '<tbody>' +
                        // Широта / Долгота
                        '<tr class="dims">' +
                            '<td class="eLabel">{{i "indexGrid.coordinates"}}</td>' +
                            '<td class="eLabel colname">{{i "indexGrid.lat"}}</td>' +
                            '<td class="eLabel colname">{{i "indexGrid.lng"}}</td>' +
                        '</tr>' +
                        // Макс
                        '<tr class="dims">' +
                            '<td class="eLabel">{{i "indexGrid.max"}}</td>' +
                            '<td class="eInput">' +
                                '<input type="text" class="maxLat" value="{{maxLat}}"/>' +
                            '</td>' +
                            '<td class="eInput">' +
                                '<input type="text" class="maxLng" value="{{maxLng}}"/>' +
                            '</td>' +
                        '</tr>' +
                        // Мин
                        '<tr class="dims">' +
                            '<td class="eLabel">{{i "indexGrid.min"}}</td>' +
                            '<td class="eInput">' +
                                '<input type="text" class="minLat" value="{{minLat}}"/>' +
                            '</td>' +
                            '<td class="eInput">' +
                                '<input type="text" class="minLng" value="{{minLng}}"/>' +
                            '</td>' +
                        '</tr>' +
                        // Шаг
                        '<tr class="dims">' +
                            '<td class="eLabel" rowspan=2>{{i "indexGrid.step"}}</td>' +
                            '<td class="eLabel">{{i "indexGrid.onLat"}}</td>' +
                            '<td class="eInput">' +
                            '<input type="text" class="yStep" value="{{yStep}}"/>' +
                            '</td>' +
                        '</tr>' +
                        '<tr class="dims">' +
                            '<td class="eLabel">{{i "indexGrid.onLng"}}</td>' +
                            '<td class="eInput">' +
                            '<input type="text" class="xStep" value="{{xStep}}"/>' +
                            '</td>' +
                        '</tr>' +
                        // Количество индексов
                        '<tr class="dims">' +
                            '<td class="eLabel">{{i "indexGrid.count"}}</td>' +
                            '<td class="eLabel"></td>' +
                            '<td class="eLabel indexCount">{{indexCount}}</td>' +
                        '</tr>' +
                        // Имя
                        '<tr class="nameSelect">' +
                            '<td class="eLabel">{{i "indexGrid.name"}}</td>' +
                            '<td class="eInput" colspan=2>' +
                                '<input type="text" class="name" value=""/>' +
                            '</td>' +
                        '</tr>' +
                    '</tbody>' +
                '</table>' +
                '<div class="createWrap">' +
                    '<div class="create">' +
                        '<span class="buttonLink createIndexGridButton"> {{i "indexGrid.create"}}</span>' +
                        '<span class="spinHolder" style="display:none">' +
                            '<img src="img/progress.gif"/>' +
                            '<span class="spinMessage"></span>' +
                            '</span>' +
                        '<br/>' +
                        '<span class="warnMessage errorMessage" style="display:none"></span>' +
                    '</div>' +
                '</div>'
            ),
            events: {
                'click .indexGridSelectButton': 'selectArea',
                'click .indexGridUnelectButton': 'unselectArea',
                'input .minLat': 'resize',
                'input .maxLat': 'resize',
                'input .minLng': 'resize',
                'input .maxLng': 'resize',
                'input .xStep': 'setStep',
                'input .yStep': 'setStep',
                'input .name': 'setName',
                'click .createIndexGridButton': 'createIndexGrid'
            },

            initialize: function () {
                var attrs = this.model.toJSON(),
                    currentZoom = attrs.lmap.getZoom();

                this.listenTo(this.model, 'change:selArea', this.updateArea);
                this.listenTo(this.model, 'change:selArea', this.updateStepInput.bind(this, 'xStep'));
                this.listenTo(this.model, 'change:selArea', this.updateStepInput.bind(this, 'yStep'));

                this.listenTo(this.model, 'change:minLat', this.updateLatLngInput.bind(this, 'minLat'));
                this.listenTo(this.model, 'change:maxLat', this.updateLatLngInput.bind(this, 'maxLat'));
                this.listenTo(this.model, 'change:maxLng', this.updateLatLngInput.bind(this, 'maxLng'));
                this.listenTo(this.model, 'change:minLng', this.updateLatLngInput.bind(this, 'minLng'));

                this.listenTo(this.model, 'change:minLatErr', this.handleInputErr.bind(this, 'minLat'));
                this.listenTo(this.model, 'change:maxLatErr', this.handleInputErr.bind(this, 'maxLat'));
                this.listenTo(this.model, 'change:maxLngErr', this.handleInputErr.bind(this, 'maxLng'));
                this.listenTo(this.model, 'change:minLngErr', this.handleInputErr.bind(this, 'minLng'));

                this.listenTo(this.model, 'change:xStep', this.updateStepInput.bind(this, 'xStep'));
                this.listenTo(this.model, 'change:yStep', this.updateStepInput.bind(this, 'yStep'));

                this.listenTo(this.model, 'change:xStepErr', this.handleInputErr.bind(this, 'xStep'));
                this.listenTo(this.model, 'change:yStepErr', this.handleInputErr.bind(this, 'yStep'));
                this.listenTo(this.model, 'change:indexCount', this.updateIndexCount);
                this.listenTo(this.model, 'change:indexCountErr', this.handleIndexCountErr);
                this.listenTo(this.model, 'change:name', this.updateName);
                this.listenTo(this.model, 'change:nameErr', this.handleInputErr.bind(this, 'name'));

                this.model.set({
                    z: currentZoom,
                    name: nsGmx.gmxMap.properties.title,
                    nameErr: false
                });

                this.updateArea();

                this.render();
            },

            render: function () {
                this.$el.html(this.template(this.model.toJSON()));
                this.$('.minLat').prop('disabled', true);
                this.$('.maxLat').prop('disabled', true);
                this.$('.maxLng').prop('disabled', true);
                this.$('.minLng').prop('disabled', true);
                this.$('.xStep').prop('disabled', true);
                this.$('.yStep').prop('disabled', true);
                this.$('.name').val(this.model.get('name'));
                this.$('.name').prop('disabled', true);
                this.$('.createIndexGridButton').addClass('gmx-disabled');

                return this;
            },

            updateArea: function () {
                var attrs = this.model.toJSON(),
                    minLatInput = this.$('.minLat'),
                    maxLatInput = this.$('.maxLat'),
                    maxLngInput = this.$('.maxLng'),
                    minLngInput = this.$('.minLng'),
                    xStepInput = this.$('.xStep'),
                    yStepInput = this.$('.yStep'),
                    areaButton = this.$('.areaButton'),
                    nameInput = this.$('.name'),
                    createIndexGridButton = this.$('.createIndexGridButton'),
                    inputs = [
                        minLatInput,
                        maxLatInput,
                        maxLngInput,
                        minLngInput,
                        xStepInput,
                        yStepInput,
                        nameInput,
                        createIndexGridButton
                    ];

                for (var i = 0; i < inputs.length; i++) {
                    if (!attrs.selArea) {
                        $(inputs[i]).prop('disabled', true);
                    } else {
                        $(inputs[i]).prop('disabled', false);
                    }
                }
                if (attrs.selArea) {
                    $(areaButton).removeClass('indexGridSelectButton');
                    $(areaButton).addClass('indexGridUnelectButton');
                    $(areaButton).text(window._gtxt('indexGrid.unselect'));

                    if (
                        !attrs.minLatErr        &&
                        !attrs.maxLatErr        &&
                        !attrs.maxLngErr        &&
                        !attrs.minLngErr        &&
                        !attrs.xStepErr         &&
                        !attrs.yStepErr         &&
                        !attrs.indexCountErr    &&
                        attrs.name !== ''
                    ) {
                            $(createIndexGridButton).removeClass('gmx-disabled');
                    }
                } else {
                    $(areaButton).removeClass('indexGridUnelectButton');
                    $(areaButton).addClass('indexGridSelectButton');
                    $(areaButton).text(window._gtxt('indexGrid.select'));
                    $(createIndexGridButton).addClass('gmx-disabled');
                }
            },

            updateLatLngInput: function (latLng) {
                var attrs = this.model.toJSON(),
                    input = this.$('.' + latLng),
                    value = this.model.get(latLng);

                $(input).val(value !== null ? this._roundInputNumber(value) : '');
            },

            handleInputErr: function (inputName) {
                var input = this.$('.' + inputName);

                $(input).toggleClass('error', this.model.get(inputName + 'Err'));
                this.setCreateButtonStatus();
                this.setWarnMessage();
            },

            updateStepInput: function (inputName) {
                var attrs = this.model.toJSON(),
                    input = this.$('.' + inputName),
                    value = this.model.get(inputName);

                $(input).val(value);
            },

            updateXStep: function () {
                var attrs = this.model.toJSON(),
                    xStepInput = this.$('.xStep');

                $(xStepInput).val(attrs.xStep);
            },

            updateYStep: function () {
                var attrs = this.model.toJSON(),
                    yStepInput = this.$('.yStep');

                $(yStepInput).val(attrs.yStep);
            },

            updateIndexCount: function () {
                var attrs = this.model.toJSON(),
                    indexCount = this.$('.indexCount');

                $(indexCount).html(attrs.indexCount ? attrs.indexCount : '');
            },

            handleIndexCountErr: function () {
                var attrs = this.model.toJSON(),
                    indexCount = this.$('.indexCount');

                $(indexCount).toggleClass('errorMessage', attrs.indexCountErr);
                this.setCreateButtonStatus();
                this.setWarnMessage();
            },

            updateName: function () {
                var attrs = this.model.toJSON(),
                    nameInput = this.$('.name');

                $(nameInput).val(attrs.name);
            },

            setCreateButtonStatus: function () {
                var attrs = this.model.toJSON(),
                    createIndexGridButton = this.$('.createIndexGridButton'),
                    err = attrs.minLatErr
                        || attrs.maxLatErr
                        || attrs.maxLngErr
                        || attrs.minLngErr
                        || attrs.xStepErr
                        || attrs.yStepErr
                        || attrs.indexCountErr;

                    $(createIndexGridButton).toggleClass('gmx-disabled', err);
            },

            setWarnMessage: function () {
                var attrs = this.model.toJSON(),
                    warnMessage = this.$('.warnMessage'),
                    err = attrs.minLatErr
                        || attrs.maxLatErr
                        || attrs.maxLngErr
                        || attrs.minLngErr
                        || attrs.xStepErr
                        || attrs.yStepErr
                        || attrs.indexCountErr
                        || attrs.nameErr;

                    $(warnMessage).toggle(err);

                if (
                       attrs.minLatErr
                    || attrs.maxLatErr
                    || attrs.maxLngErr
                    || attrs.minLngErr
                    || attrs.xStepErr
                    || attrs.yStepErr
                ) {
                    $(warnMessage).text(window._gtxt('indexGrid.valueWarn'));
                } else if (attrs.indexCountErr) {
                    $(warnMessage).text(window._gtxt('indexGrid.indexCountWarn'));
                } else if (attrs.nameErr) {
                    $(warnMessage).text(window._gtxt('indexGrid.nameWarn'));
                } else {
                    $(warnMessage).text('');
                }
            },

            setName: function (e) {
                var value,
                    valueErr;

                value = e.target.value;
                valueErr = value === '';

                if (valueErr) {
                    this.model.set('nameErr', true);
                } else {
                    this.model.set('nameErr', false);
                    this.model.set('name', value)
                }
            },

            selectArea: function () {
                var attrs = this.model.toJSON();

                if (!attrs.lmap || attrs.selArea) {
                    return;
                }

                var currentZoom = attrs.lmap.getZoom(),
                    mapBounds = attrs.lmap.getBounds(),
                    latLngs = [
                        mapBounds.getSouthWest(),
                        mapBounds.getNorthWest(),
                        mapBounds.getNorthEast(),
                        mapBounds.getSouthEast()
                    ],
                    n = mapBounds.getNorth(),
                    e = mapBounds.getEast(),
                    s = mapBounds.getSouth(),
                    w = mapBounds.getWest(),
                    mapHeight = n - s,
                    mapWidth = e - w,

                    // какую часть экрана отсекать с краев первоначальной рамки
                    scale = 4,
                    converted = this._convertFromLatLngs(latLngs, attrs.z),
                    dims = this._getDimensions(converted),
                    xx = [converted[0].x, converted[1].x, converted[2].x, converted[3].x],
                    yy = [converted[0].y, converted[1].y, converted[2].y, converted[3].y],
                    bottomLeft =    L.point(this._getMin(xx) + dims.width / scale,  this._getMax(yy) - dims.height / scale),
                    topLeft =       L.point(this._getMin(xx) + dims.width / scale,  this._getMin(yy) + dims.height / scale),
                    topRight =      L.point(this._getMax(xx) - dims.width / scale,  this._getMin(yy) + dims.height / scale),
                    bottomRight =   L.point(this._getMax(xx) - dims.width / scale,  this._getMax(yy) - dims.height / scale),
                    initialBounds = this._convertToLantLngs([bottomLeft, topLeft, topRight, bottomRight], attrs.z);

                // прямоугольная рамка
                var rect = L.rectangle(initialBounds);

                this.model.set({
                    z: currentZoom
                });

                this._createFrame(rect);

                this._updateCoords();
                this._updateCorners();
                this._countIndex();
            },

            unselectArea: function () {
                var attrs = this.model.toJSON();
                this._removeFrame();

                this.model.set({
                    width: 0,
                    height: 0,
                    z: attrs.lmap.getZoom(),
                    xStep: 1,
                    yStep: 1,
                    xCount: null,
                    yCount: null,
                    xStepErr: false,
                    yStepErr: false,
                    indexCount: null,
                    indexCountErr: false,
                    minLat: null,
                    minLng: null,
                    maxLat: null,
                    maxLng: null,
                    minLatErr: false,
                    maxLatErr: false,
                    maxLngErr: false,
                    minLngErr: false
                });
            },

            createIndexGrid: function () {
                var attrs = this.model.toJSON(),
                    name = attrs.name,
                    columns = [
                        {
                            Name:"gmx_id",
                            ColumnSimpleType:"Integer",
                            IsIdentity:true,
                            IsComputed:false,
                            IsPrimary:true
                        },
                        {
                            Name:"index",
                            ColumnSimpleType:"String",
                            IsIdentity:false,
                            IsComputed:false,
                            IsPrimary:false
                        }
                    ],
                    layerParams = {
                        Title: name,
                        geometrytype: 'polygon',
                        Columns: JSON.stringify(columns),
                    },
                    indexes = this.generatePolygons(),
                    spinHolder = this.$('.spinHolder'),
                    def = nsGmx.asyncTaskManager.sendGmxPostRequest(window.serverBase + "VectorLayer/CreateVectorLayer.ashx", layerParams),
                    promise,
                    _this = this;

                def.done(function(response) {
                    var layerName = response.Result.properties.name;
                        mapProperties = _layersTree.treeModel.getMapProperties(),
                        targetDiv = $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0],
                        gmxProperties = {type: 'layer', content: response.Result},
                        def2 = _mapHelper.modifyObjectLayer(layerName, indexes, 'EPSG:4326');

                    gmxProperties.content.properties.mapName = mapProperties.name;
                    gmxProperties.content.properties.hostName = mapProperties.hostName;
                    gmxProperties.content.properties.visible = true;

                    gmxProperties.content.properties.styles = [{
                        MinZoom: 1,
                        MaxZoom:21,
                        RenderStyle:_mapHelper.defaultStyles[gmxProperties.content.properties.GeometryType]
                    }];

                    $(spinHolder).show();

                    def2.always(function(res) {
                        _layersTree.copyHandler(gmxProperties, targetDiv, false, true);
                        $(spinHolder).hide();
                        _this.unselectArea();
                    })
                });

            },

            generatePolygons: function () {
                var attrs = this.model.toJSON(),
                    xStep = this._convertXStep(attrs.xStep),
                    yStep = this._convertYStep(attrs.yStep),
                    xCount = attrs.xCount,
                    yCount = attrs.yCount,
                    proj = L.Projection.Mercator,
                    north = attrs.maxLat,
                    south = attrs.minLat,
                    west = attrs.minLng,
                    east = attrs.maxLng,
                    indexes = [],
                    index,
                    letterIndexes = this._getLetterIndexes(xCount),
                    letter,
                    n, s, e, w;

                for (var i = 0; i < yCount; i++) {
                    n = north - yStep * i;
                    s = north - yStep * (i+1);

                    for (var j = 0; j < xCount; j++) {
                        letter = letterIndexes[j];
                        w = west + xStep * j;
                        e = west + xStep * (j+1);

                        index = {
                            geometry: L.polygon(
                                [
                                    L.latLng(s, w),
                                    L.latLng(n, w),
                                    L.latLng(n, e),
                                    L.latLng(s, e)
                                ]
                            ).toGeoJSON(),
                            properties: {
                                index: letter + (i+1)
                            }
                        };
                        indexes.push(index);
                    }
                }

                return indexes;
            },

            setStep: function (e) {
                var value,
                    valueErr;

                value = Number(e.target.value);
                valueErr = value <= 0 || isNaN(value);

                // обработка xStep
                if (e.target.className === 'xStep' || e.target.className === 'xStep error') {
                    if (valueErr) {
                        this.model.set('xStepErr', true);
                    } else {
                        this.model.set('xStepErr', false);
                        this.model.set('xStep', value);
                    }
                }

                // обработка yStep
                if (e.target.className === 'yStep' || e.target.className === 'yStep error') {
                    if (valueErr) {
                        this.model.set('yStepErr', true);
                    } else {
                        this.model.set('yStepErr', false);
                        this.model.set('yStep', value);
                    }
                }

                this._countIndex();

            },

            resize: function (e) {
                var attrs = this.model.toJSON(),
                    initialCoords,
                    coords,
                    bounds,
                    scale,
                    screenCoords,
                    newBounds,
                    value, valueErr;

                if (!attrs.lmap || !attrs.selArea) {
                    return;
                }

                // разница между целевым и текущим зумом
                scale = Math.pow(2, (attrs.z - attrs.lmap.getZoom()));
                initialCoords = attrs.selArea.rings[0].ring.points._latlngs;
                coords = attrs.coords ? attrs.coords : initialCoords;

                value = Number(e.target.value);

                valueErr = !value || isNaN(value);

                // обработка ввода значений с плавающей точкой
                if (e.target.value.indexOf(".") === e.target.value.length - 1) {
                    valueErr = true;
                }
                // обработка minLat
                if (e.target.className === 'minLat' || e.target.className === 'minLat error') {
                    if (valueErr) {
                        this.model.set('minLatErr', true);
                    } else {
                        var north = this._getBounds(coords).getNorth();

                        if (value < north) {
                            this.model.set('minLatErr', false);

                            this.model.set('minLat', value);
                        } else {
                            this.model.set('minLatErr', true);
                        }
                    }
                }

                // обработка minLng
                if (e.target.className === 'minLng' || e.target.className === 'minLng error') {
                    if (valueErr) {
                        this.model.set('minLngErr', true);
                    } else {
                        var east = this._getBounds(coords).getEast();

                        if (value < east) {
                            this.model.set('minLngErr', false);
                            this.model.set('minLng', value);
                        } else {
                            this.model.set('minLngErr', true);
                        }
                    }
                }

                // обработка maxLat
                if (e.target.className === 'maxLat' || e.target.className === 'maxLat error') {
                    if (valueErr) {
                        this.model.set('maxLatErr', true);
                    } else {
                        var south = this._getBounds(coords).getSouth();

                        if (value > south) {
                            this.model.set('maxLatErr', false);
                            this.model.set('maxLat', value);
                        } else {
                            this.model.set('maxLatErr', true);
                        }
                    }
                }

                // обработка maxLng
                if (e.target.className === 'maxLng' || e.target.className === 'maxLng error') {
                    if (valueErr) {
                        this.model.set('maxLngErr', true);
                    } else {
                        var west = this._getBounds(coords).getWest();

                        if (value > west) {
                            this.model.set('maxLngErr', false);
                            this.model.set('maxLng', value);
                        } else {
                            this.model.set('maxLngErr', true);
                        }
                    }
                }

                attrs = this.model.toJSON();

                if (attrs.maxLngErr || attrs.minLngErr || attrs.minLatErr || attrs.maxLatErr) return;

                var newRect = L.rectangle([L.latLng(attrs.minLat, attrs.minLng), L.latLng(attrs.maxLat, attrs.maxLng)]);

                this.model.set({
                    'coords': newRect._latlngs
                });

                this._removeFrame();

                this._createFrame(newRect);
                // restore model attributes
                this.model.set({
                    xStep:          attrs.xStep,
                    yStep:          attrs.yStep,
                    xStepErr:       attrs.xStepErr,
                    yStepErr:       attrs.yStepErr,
                    minLatErr:      attrs.minLatErr,
                    maxLatErr:      attrs.maxLatErr,
                    maxLngErr:      attrs.maxLngErr,
                    minLngErr:      attrs.minLngErr
                });

                this._updateCoords();
                this._updateCorners();
                this._countIndex();

            },

            _createFrame: function(rectangle) {
                var attrs = this.model.toJSON(),
                    options = {
                        editable: true,
                        map: true,
                        lineStyle: {
                            dashArray: '5 5',
                            color: '#f57c00',
                            weight: 3.5
                        },
                        pointStyle: {
                            size: L.Browser.mobile ? 40 : 8,
                            color: '#f57c00'
                        }
                    };

                this.model.set({
                    selArea: attrs.lmap.gmxDrawing.add(rectangle, L.extend(options, {
                        exportRect: true
                    }))
                });

                // навешивает обработчики на рамку выделения
                var frame = this.model.get('selArea'),
                    _this = this;

                frame.on('edit', _this._resizeFrame.bind(_this));
                frame.on('remove', _this.unselectArea.bind(_this));

            },

            _resizeFrame: function () {
                var attrs = this.model.toJSON(),
                    initialCoords = attrs.selArea.rings[0].ring.points._latlngs,
                    bounds = this._getBounds(initialCoords),
                    err = attrs.minLatErr
                        || attrs.maxLatErr
                        || attrs.maxLngErr
                        || attrs.minLngErr;

                if (err) {
                    return;
                }

                this.model.set({
                    coords: initialCoords,
                    minLat: bounds.getSouth(),
                    minLng: bounds.getWest(),
                    maxLat: bounds.getNorth(),
                    maxLng: bounds.getEast()
                });

                // this.model.set({
                //     minLatErr: false,
                //     maxLatErr: false,
                //     minLngErr: false,
                //     maxLngErr: false
                // });


                this._countIndex();
            },

            _countIndex: function () {
                var attrs = this.model.toJSON();
                    initialCoords = attrs.selArea.rings[0].ring.points._latlngs;
                    coords = attrs.coords ? attrs.coords : initialCoords;
                    dims = this._getLatLngDimensions(coords);

                if (attrs.xStep && attrs.yStep) {
                    xCount = Math.ceil(dims.width / this._convertXStep(attrs.xStep));
                    yCount = Math.ceil(dims.height / this._convertYStep(attrs.yStep));
                    indexCount = xCount * yCount;

                    if (!attrs.xStepErr && !attrs.yStepErr) {
                        if (indexCount > MAX_INDEX_COUNT) {
                            this.model.set('indexCountErr', true);
                        } else {
                            this.model.set('indexCountErr', false);
                        }
                    this.model.set('xCount', xCount);
                    this.model.set('yCount', yCount);
                    this.model.set('indexCount', indexCount);
                    }
                } else {
                    this.model.set('xCount', null);
                    this.model.set('yCount', null);
                    this.model.set('indexCount', null);
                }
            },

            _getBounds: function (latLngs) {
                var lats,
                    lngs,
                    bottomLeft,
                    topRight;

                lats = [latLngs[0].lat, latLngs[1].lat, latLngs[2].lat, latLngs[3].lat];
                lngs = [latLngs[0].lng, latLngs[1].lng, latLngs[2].lng, latLngs[3].lng];
                bottomLeft = L.latLng(this._getMin(lats), this._getMin(lngs));
                topRight = L.latLng(this._getMax(lats), this._getMax(lngs));

                return L.latLngBounds(bottomLeft, topRight);
            },

            _removeFrame: function () {
                var attrs = this.model.toJSON();

                if (!attrs.selArea) {
                    return;
                }

                attrs.lmap.gmxDrawing.remove(attrs.selArea);

                this.model.set({
                    selArea: null,
                    coords: null
                });
            },

            _updateCoords: function () {
                var attrs = this.model.toJSON(),
                    initialCoords,
                    screenCoords,
                    dimensions,
                    bounds;

                if (!attrs.selArea) {
                    return;
                }

                initialCoords = attrs.selArea.rings[0].ring.points._latlngs;

                if (!attrs.coords) {
                    this.model.set('coords', initialCoords);
                }
            },

            _updateCorners: function () {
                var attrs = this.model.toJSON(),
                    initialCoords = attrs.selArea.rings[0].ring.points._latlngs,
                    bounds = this._getBounds(initialCoords);

                this.model.set({
                    minLat: bounds.getSouth(),
                    minLng: bounds.getWest(),
                    maxLat: bounds.getNorth(),
                    maxLng: bounds.getEast()
                });
            },

            _revertCoords: function (coords) {
                var xx,
                    yy,
                    bottomLeft, topLeft,
                    topRight, bottomRight;

                xx = [coords[0].x, coords[1].x, coords[2].x, coords[3].x];
                yy = [coords[0].y, coords[1].y, coords[2].y, coords[3].y];
                bottomLeft = L.point(this._getMin(xx), this._getMax(yy));
                topLeft = L.point(this._getMin(xx), this._getMin(yy));
                topRight = L.point(this._getMax(xx), this._getMin(yy));
                bottomRight = L.point(this._getMax(xx), this._getMax(yy));

                return [bottomLeft, topLeft, topRight, bottomRight];

            },

            _revertLatLngs: function (latlngs) {
                var lats,
                    lngs,
                    bottomLeft, topLeft,
                    topRight, bottomRight;

                lats = [latlngs[0].lat, latlngs[1].lat, latlngs[2].lat, latlngs[3].lat];
                lngs = [latlngs[0].lng, latlngs[1].lng, latlngs[2].lng, latlngs[3].lng];
                bottomLeft = L.latLng(this._getMin(lats), this._getMin(lngs));
                topLeft = L.latLng(this._getMax(lats), this._getMin(lngs));
                topRight = L.latLng(this._getMax(lats), this._getMax(lngs));
                bottomRight = L.latLng(this._getMin(lats), this._getMax(lngs));

                return [bottomLeft, topLeft, topRight, bottomRight];
            },

            _convertFromLatLngs: function (latlngs, zoom) {
                var attrs = this.model.toJSON(),
                    converted = latlngs.map(function(ll) {
                        return attrs.lmap.project([ll.lat, ll.lng], zoom);
                    });

                return converted;
            },

            _convertToLantLngs: function (points, zoom) {
                var attrs = this.model.toJSON(),
                    converted = points.map(function(point) {
                        return attrs.lmap.unproject([point.x, point.y], zoom);
                    });

                return converted;
            },

            _convertToMercator: function (latlngs) {
                var attrs = this.model.toJSON(),
                    converted = latlngs.map(function(ll) {
                        return attrs.lmap.options.crs.project(ll);
                    });

                return converted;
            },

            _convertYStep: function (value) {
                return value / KM_PER_DEGREE;
            },

            _convertXStep: function (value) {
                var attrs = this.model.toJSON(),
                    centerLat = attrs.minLat + ((attrs.maxLat - attrs.minLat) / 2),
                    centerY = (centerLat * Math.PI) / 180;

                return (value / KM_PER_DEGREE) / Math.cos(centerY);
            },

            _getLatLngDimensions: function (latlngs) {
                var bottomLeft, topRight,
                    width, height;

                latlngs = this._revertLatLngs(latlngs);

                bottomLeft = latlngs[0];
                topRight = latlngs[2];
                width = Math.abs(topRight.lng - bottomLeft.lng);
                height = Math.abs(topRight.lat - bottomLeft.lat);

                return {
                    width: width,
                    height: height
                }
            },

            // get array of string letters (['A'...'Z', 'AA'...'ZZ'...])
            _getLetterIndexes: function (number) {
                var convert = function(srcNum, scrDict, targetDict) {
                   var targetNum = "";
                   for (var idx in srcNum) {
                      var srcDictIdx = scrDict.search(srcNum[idx]);
                      targetNum += targetDict[srcDictIdx]
                   }
                   return targetNum;
                }

                var buildLettersArray = function (num) {
                    var xlsDict = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                        jsDict  = "0123456789abcdefghijklmnop",
                        radix = xlsDict.length,
                        numStart = 0,
                        numEnd = num,
                        rnt = [];

                    for (var col = numStart; col <= numEnd; col++) {
                       // Unfortunately, the situation is not ideal, we have A...Z and then
                       // AA ... AZ, while A represents the zero digit, so in numbers it is
                       // like having 0..9 and then 00..09 and only then 10...19
                       // so we artificially emulate 00...09 situation here
                       var prefix = "";
                       var numb = col;
                       if (col >= radix) {
                           numb = col - radix;
                       }
                       if (col >= radix && col < radix*2) {
                           prefix = "A";
                       }
                       var jsNum = Number(numb).toString(radix);
                       rnt.push(prefix + convert(jsNum, jsDict, xlsDict));
                    }
                    return rnt;
                };

                return buildLettersArray(number);
            },

            _getDimensions: function(points) {
                var attrs = this.model.toJSON(),
                    bottomLeft, topRight,
                    width, height,
                    x, y;

                points = this._revertCoords(points);
                bottomLeft = points[0];
                topRight = points[2];
                width = Math.abs(topRight.x - bottomLeft.x);
                height = Math.abs(bottomLeft.y - topRight.y);

                return {
                    width: width,
                    height: height
                }
            },

            _getMax: function(arr) {
                return Math.max.apply(null, arr);
            },

            _getMin: function(arr) {
                return Math.min.apply(null, arr);
            },

            _roundInputNumber: function (value) {
                value = (typeof(value) === 'String') ? value : String(value);
                if (value.indexOf(".") != '-1') {
                    value = value.substring(0,value.indexOf(".") + 5);
                }
                return value;
            }
        });

        view = new IndexGridView();

        this.Load = function () {
            var lm = model.get('lm');

            if (lm != null) {
                var alreadyLoaded = lm.createWorkCanvas('mapIndexGrid', this.Unload);
                if (!alreadyLoaded) {
                    $(lm.workCanvas).append(view.el);
                }
            }
        }
        this.Unload = function () {
            var attrs = model.toJSON();
            attrs.lmap.gmxDrawing.remove(attrs.selArea);
            model.set({
                selArea: null,
                xStep: 1,
                yStep: 1,
                xCount: null,
                yCount: null,
                xStepErr: false,
                yStepErr: false,
                indexCount: null,
                indexCountErr: false,
                maxLat: null,
                maxLng: null,
                minLat: null,
                minLng: null,
                maxLatErr: false,
                minLatErr: false,
                maxLngErr: false,
                minLngErr: false,
                z: attrs.lmap.getZoom(),
                coords: null
            });
        };
    }

    var publicInterface = {
        pluginName: 'IndexGrid',
        IndexGridMenu: IndexGridMenu
  };

    window.gmxCore.addModule('IndexGrid',
        publicInterface
    );
})();

var nsGmx = window.nsGmx || {},
    _gtxt = window._gtxt,
    Handlebars = window.Handlebars;

(function($) {

    window._translationsHash.addtext('rus', {
        photoLayer: {
            catalog: "Каталог",
            newCatalog: "в новый каталог",
            existingCatalog: "в существующий каталог",
            placeholder: "Введите имя каталога",
            name: "Имя каталога",
            available: "доступные каталоги",
            load: "Загрузить фотографии",
            loadShort: "ЗАГРУЗИТЬ",
            processing: "обработка изображений",
            error: "ошибка",
            successResult: "загружено фотографий",
            exifError: "ошибка чтения координат",
            ok: "готово"
        }
    });

    window._translationsHash.addtext('eng', {
        photoLayer: {
            catalog: "Catalog",
            newCatalog: "into new catalog",
            existingCatalog: "into existing catalog",
            placeholder: "Type catalog name",
            name: "name",
            available: "available catalogs",
            load: "Load photos",
            loadShort: "LOAD",
            processing: "image processing",
            error: "error",
            successResult: "images uploaded",
            exifError: "coordinates error",
            ok: "done"
        }
    });

    var PhotoLayer = function () {
        var dialog;

    var PhotoLayerModel = window.Backbone.Model.extend({
        defaults: {
            fileName: null,
            photoLayersFlag: false,
            currentPhotoLayer: null,
            photoLayers: [],
            sandbox: ''
        }
    });


    var PhotoLayerView = window.Backbone.View.extend({
        tagName: 'div',
        model: new PhotoLayerModel(),
        template: Handlebars.compile('' +
            '<div class="photolayer-ui-container photolayer-properties-container">' +
                '<div class="photolayer-ui-container photolayer-catalog-selector-container">' +
                    '{{#if photoLayersFlag}}' +
                    '<span class="select-catalog-button existing-catalog-button">{{i "photoLayer.existingCatalog"}}</span>' +
                    '{{/if}}' +
                    '<span class="select-catalog-button new-catalog-button">{{i "photoLayer.newCatalog"}}</span>' +
                '</div>' +
                '<div class="photolayer-ui-container photolayer-newlayer-input-container"' +
                '{{#if photoLayersFlag}}' +
                'style="display:none"' +
                '{{/if}}' +
                '>' +
                    '<span class="photolayer-title photolayer-name-title">{{i "photoLayer.name"}}</span>' +
                    '<input type="text" class="photolayer-name-input photolayer-newlayer-input minInputStyle"/>' +
                '</div>' +
                '<div class="photolayer-ui-container photolayer-existinglayer-input-container" ' +
                '{{#unless photoLayersFlag}}' +
                'style="display:none"' +
                '{{/unless}}' +
                '>' +
                    '<span class="photolayer-title photolayer-name-title">{{i "photoLayer.name"}}</span>' +
                    '<select class="photolayer-name-input photolayer-existinglayer-input">' +
                        '{{#each this.photoLayers}}' +
                        '<option value="{{this.layer}}"' +
                            '{{#if this.current}} selected="selected"{{/if}}>' +
                            '{{this.layer}}' +
                        '</option>' +
                        '{{/each}}' +
                    '</select>' +
                '</div>' +
                '<div class="photolayer-ui-block photolayer-loader-block">' +
                        '<label class="photo-uploader-label">' +
                        '<span class="photo-uploader-button">{{i "photoLayer.loadShort"}}</span>' +
                            '<form id="photo-uploader-form" name="photouploader" enctype="multipart/form-data" method="post">' +
                                '<input type="file" name="file" id="photo-uploader" accept="image/*" multiple></input>' +
                            '</form>' +
                        '</label>' +
                    '<span class="photolayer-progress-container">' +
                        '<span class="progressbar"></span>' +
                    '</span>' +
                    '<span class="photolayer-spin-container" style="display:none">' +
                        '<img src="img/progress.gif"/>' +
                        '<span class="spin-message">{{i "photoLayer.processing"}}</span>' +
                    '</span>' +
                    '<span class="photolayer-ui-container photolayer-ok-button-container" style="display:none">' +
                        '<span class="ok-button">{{i "photoLayer.ok"}}</span>' +
                    '</span>' +
                    '<span class="photolayer-error-message" style="display:none"></span>' +
                '</div>' +
                '<div class="photo-upload-result photo-upload-result-uploaded" style="display:none">' +
                '</div>' +
                '<div class="photo-upload-result photo-upload-result-error" style="display:none">' +
                '</div>' +
            '</div>'
        ),

        events: {
            'click .select-catalog-button': 'setCatalogType',
            'keyup .photolayer-newlayer-input': 'setName',
            'change .photolayer-existinglayer-input': 'setCurrentLayer',
            'change #photo-uploader': 'selectFile'
        },

        initialize: function () {
            this.getPhotoLayers();
            this.createSandbox();
            this.render();

            this.listenTo(this.model, 'change:fileName', this.updateName);
            this.listenTo(this.model, 'change:photoLayers', this.updatePhotoLayersList);
        },

        render: function () {
            var attrs = this.model.toJSON();

            this.$el.html(this.template(this.model.toJSON()));
            this.updatePhotoLayersList();

            var firstButton = this.$('.select-catalog-button')[0],
                uploadBlock = this.$('.photo-uploader-label').add(this.$('.photo-uploader-button'));

            $(firstButton).addClass('active');

            $(uploadBlock).toggleClass('gmx-disabled', !attrs.photoLayersFlag);
            this.$('.photolayer-newlayer-input').prop('placeholder', _gtxt('photoLayer.placeholder'))
        },

        getPhotoLayers: function (layers) {
            var layers = layers || nsGmx.gmxMap.layers,
                attrs = this.model.toJSON(),
                photoLayersFlag = attrs.photoLayersFlag,
                currentPhotoLayer,
                photoLayers = [];

            for (var i = 0; i < layers.length; i++) {
                var layer = layers[i],
                    props = layer.getGmxProperties(),
                    isPhotoLayer;

                if (props) {
                    isPhotoLayer = props.IsPhotoLayer;

                    if (isPhotoLayer && props.Access === 'edit') {
                        photoLayersFlag = true;

                        photoLayers.push({layer: props.title, LayerID: props.LayerID, current: false});
                    }
                }

                for (var j = 0; j < photoLayers.length; j++) {
                    photoLayers[j].current = j === 0;

                    if (j === 0) {
                        currentPhotoLayer = nsGmx.gmxMap.layersByID[photoLayers[j].LayerID];
                    }
                }
            }

            this.model.set({
                photoLayersFlag: photoLayersFlag,
                photoLayers: photoLayers,
                currentPhotoLayer: currentPhotoLayer
            });
        },

        setCatalogType: function (e) {
            var attrs = this.model.toJSON(),
                newCatalog = $(e.target).hasClass('new-catalog-button'),
                newContainer = $('.photolayer-newlayer-input-container'),
                existingContainer = $('.photolayer-existinglayer-input-container'),
                newLayerInput = this.$('.photolayer-newlayer-input'),
                uploadBlock = this.$('.photo-uploader-label').add(this.$('.photo-uploader-button'));

            if (newCatalog) {
                $(uploadBlock).toggleClass('gmx-disabled', !attrs.fileName);
                $(newContainer).toggle(true);
                $(existingContainer).toggle(false);
                $(e.target).toggleClass('active', true);
                $('.existing-catalog-button').toggleClass('active', false);
                $(newLayerInput).focus();

                this.model.set({
                    photoLayers: [],
                    fileName: null,
                    currentPhotoLayer: null
                });

                this.createSandbox();
            } else {
                this.getPhotoLayers();
                $(uploadBlock).toggleClass('gmx-disabled', false);
                $(existingContainer).toggle(true);
                $(newContainer).toggle(false);
                $(e.target).toggleClass('active', true);
                $('.new-catalog-button').toggleClass('active', false);
            }
        },

        createSandbox: function () {
            var _this = this;

            window.sendCrossDomainJSONRequest(window.serverBase + 'Sandbox/CreateSandbox', function(response) {
                if (parseResponse(response) && response.Result) {
                    _this.model.set('sandbox', response.Result.sandbox);
                }
            });
        },

        setName: function (e) {
            var layers = layers || nsGmx.gmxMap.layers,
                attrs = this.model.toJSON(),
                start = e.target.selectionStart,
                end = e.target.selectionEnd,
                matchingLayer;

            for (var i = 0; i < layers.length; i++) {
                var layer = layers[i],
                    props = layer.getGmxProperties();

                if (props) {
                    if (e.target.value === props.title) {
                        matchingLayer = layer;
                    }
                }
            }

            this.model.set('fileName', e.target.value);

            this.model.set('currentPhotoLayer', matchingLayer ? matchingLayer : null);

            // восстановим позицию курсора
            e.target.setSelectionRange(start, end);
        },

        setCurrentLayer: function (e) {
            var layers = nsGmx.gmxMap.layers,
                currentPhotoLayer;


            for (var i = 0, len = layers.length; i < len; i++) {
                var layer = layers[i],
                    props = layer.getGmxProperties();

                if (props && props.title === e.target.value) {
                    currentPhotoLayer = layer;
                    break;
                }
            }

            this.model.set({
                currentPhotoLayer: currentPhotoLayer
            });
        },

        updateName: function () {
            var attrs = this.model.toJSON(),
                newLayerInput = this.$('.photolayer-newlayer-input'),
                uploadBlock = this.$('.photo-uploader-label').add(this.$('.photo-uploader-button'));

            $(newLayerInput).val(attrs.fileName);
            $(uploadBlock).toggleClass('gmx-disabled', !attrs.fileName);
        },

        updatePhotoLayersList: function () {
            var attrs = this.model.toJSON(),
                photoLayers = attrs.photoLayers,
                currentPhotoLayerName = attrs.currentPhotoLayer && attrs.currentPhotoLayer.getGmxProperties().title,
                str = '',
                select = this.$('.photolayer-existinglayer-input');

            if (photoLayers.length) {
                for (var i = 0; i < photoLayers.length; i++) {
                    str += '<option>' + photoLayers[i].layer + '</option>';
                }
            }
            $(select).html(str);

            $('.photolayer-existinglayer-input option[value="' + currentPhotoLayerName + '"]').prop('selected', true);
        },

        selectFile: function (e) {
            var files = e.target.files,
                form = this.$('#photo-uploader-form'),
                arr = [],
                newLayerInput = this.$('.photolayer-newlayer-input'),
                uploadLabel = this.$('.photo-uploader-label'),
                uploadButton = this.$('.photo-uploader-button'),
                progressBarContainer = this.$('.photolayer-progress-container'),
                progressBar = this.$('.progressbar'),
                spinContainer = this.$('.photolayer-spin-container'),
                okButton = this.$('.photolayer-ok-button-container'),
                uploadResSuccess = this.$('.photo-upload-result-uploaded'),
                uploadResError = this.$('.photo-upload-result-error'),
                errorMessage = this.$('.photolayer-error-message');

            for (var key in files) {
                if (files.hasOwnProperty(key)) {
                    arr.push(files[key]);
                }
            }

            $(progressBarContainer).hide();
            $(spinContainer).hide();
            $(okButton).hide();
            $(errorMessage).hide();
            $(uploadResSuccess).hide();
            $(uploadResError).hide();

            var attrs = this.model.toJSON(),
                _this = this,
                files = e.target.files,
                sandbox,
                uploadParams = {
                    sandbox: attrs.sandbox
                },
                params,
                url, def;

                if (attrs.currentPhotoLayer) {
                    params = {
                        LayerID: attrs.currentPhotoLayer.getGmxProperties().LayerID,
                        PhotoSource: JSON.stringify({sandbox: attrs.sandbox})
                    }
                } else {
                    params = {
                        Columns: "[]",
                        Copyright: "",
                        Description: "",
                        SourceType: "manual",
                        title: attrs.fileName,
                        IsPhotoLayer: true,
                        PhotoSource: JSON.stringify({sandbox: attrs.sandbox})
                    }
                };

                $(form).prop('action', window.serverBase + 'Sandbox/Upload' + '?' + $.param(uploadParams));

                var formData = new FormData($(form)[0]);

                formData.append("sandbox", attrs.sandbox);

                for (var i = 0; i < files.length; i++) {
                    formData.append(i, files[i]);
                }

                $(progressBar).progressbar({
                    max: 100,
                    value: 0
                });

                $(progressBarContainer).show();
                var xhr = new XMLHttpRequest();

                xhr.upload.addEventListener("progress", function(e) {
                        $(progressBar).progressbar('option', 'value', e.loaded / e.total * 100);
                }, false);

                xhr.open('POST', window.serverBase + 'Sandbox/Upload');
                $(uploadButton).toggleClass('gmx-disabled', true);
                $(uploadLabel).toggleClass('gmx-disabled', true);
                xhr.withCredentials = true;
                xhr.onload = function () {
                    if (xhr.status === 200) {
                        var response = xhr.responseText;

                        if (!(response)) {
                            return;
                        }

                        $(progressBarContainer).hide();
                        $(spinContainer).show();

                        if (attrs.currentPhotoLayer) {
                            url = window.serverBase + 'Photo/AppendPhoto' + '?' + $.param(params);
                        } else {
                            url = window.serverBase + 'VectorLayer/Insert.ashx' + '?' + $.param(params);
                        }
                        def = nsGmx.asyncTaskManager.sendGmxPostRequest(url);

                        def.done(function(taskInfo){
                            if (!attrs.currentPhotoLayer) {
                                var mapProperties = window._layersTree.treeModel.getMapProperties(),
                                    targetDiv = $(window._queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0],
                                    gmxProperties = {type: 'layer', content: taskInfo.Result},
                                    imageUrlParams = {
                                        LayerID: gmxProperties.content.properties.LayerID,
                                        size: 'M'
                                    },
                                    bigImageUrlParams = {
                                        LayerID: gmxProperties.content.properties.LayerID,
                                        size: 'Native'
                                    },
                                    imageUrl = window.serverBase + 'rest/ver1/photo/getimage.ashx' + '?' + $.param(imageUrlParams) + '&rowId=[gmx_id]',
                                    bigImageUrl = window.serverBase + 'rest/ver1/photo/getimage.ashx' + '?' + $.param(bigImageUrlParams) + '&rowId=[gmx_id]',
                                    balloonString = '' +
                                        '<div style="min-width: 300px;">' +
                                            '<div style="width: 100%; text-align: center;">' +
                                                '<a href="' + bigImageUrl + '" target="_blank">' +
                                                    '<img class="popupImage" src="' + imageUrl + '" alt=""/>' +
                                                '</a>' +
                                            '</div>' +
                                            '<div>' +
                                                '<b>' + window._gtxt("Имя") + ':</b> ' + '[GMX_Filename]' +
                                            '</div>' +
                                            '<div>' +
                                                '<b>' + window._gtxt("Момент съемки") + ':</b> ' + '[GMX_Date]' +
                                            '</div>' +
                                            '<div>' +
                                                '[SUMMARY]' +
                                            '</div>' +
                                        '</div>';

                                gmxProperties.content.properties.mapName = mapProperties.name;
                                gmxProperties.content.properties.hostName = mapProperties.hostName;
                                gmxProperties.content.properties.visible = true;

                                gmxProperties.content.properties.styles = [{
                                    MinZoom: 1,
                                    MaxZoom:21,
                                    Balloon: balloonString,
                                    RenderStyle: _mapHelper.defaultPhotoIconStyles[gmxProperties.content.properties.GeometryType]
                                }];

                                // вставляем фотослой на карту
                                var modifyMapObjects = [{
                                        Action: 'insert',
                                        index: 'top',
                                        LayerName: gmxProperties.content.properties.LayerID,
                                        Styles: gmxProperties.content.properties.styles
                                    }],
                                    modifyMapParams = {
                                        MapName: mapProperties.MapID,
                                        Objects: JSON.stringify(modifyMapObjects)
                                    }
                                    modifyMapUrl = window.serverBase + 'Map/ModifyMap.ashx' + '?' + $.param(modifyMapParams);

                                // вставляем фотографии в пустой слой
                                var photoAppendParams = {
                                        LayerID: gmxProperties.content.properties.LayerID,
                                        PhotoSource: JSON.stringify({sandbox: attrs.sandbox})
                                    },
                                    photoAppendUrl = window.serverBase + 'Photo/AppendPhoto' + '?' + $.param(photoAppendParams);

                                window.sendCrossDomainJSONRequest(modifyMapUrl, function (res) {
                                    var def = nsGmx.asyncTaskManager.sendGmxPostRequest(photoAppendUrl);

                                    def.done(function(taskInfo) {

                                        parseGeometry(taskInfo, gmxProperties);

                                        window._layersTree.copyHandler(gmxProperties, targetDiv, false, true);

                                        var newLayer = nsGmx.gmxMap.layersByID[gmxProperties.content.properties.LayerID];

                                        newLayer.bindClusters({
                                            iconCreateFunction: function(cluster) {
                                                var photoClusterIcon = L.divIcon({
                                                    html: '<img src="img/camera18.png" class="photo-icon"/><div class="marker-cluster-photo">' + cluster.getChildCount() + '</div>',
                                                    className: 'photo-div-icon',
                                                    iconSize: [14, 12],
                                                    iconAnchor: [0, 0]
                                                });
                                                return photoClusterIcon;
                                            },
                                            maxClusterRadius: 40,
                                            spiderfyOnMaxZoom: true,
                                            spiderfyDistanceMultiplier: 1.2,
                                            disableClusteringAtZoom: 19,
                                            maxZoom: 19
                                        });

                                        // newLayer.updateVersion(gmxProperties.content);

                                        _this.model.set({
                                            currentPhotoLayer: newLayer
                                        });

                                        afterLoad(taskInfo);
                                    })
                                    .fail(function(taskInfo) {
                                        var message = taskInfo.ErrorInfo && taskInfo.ErrorInfo.ErrorMessage;

                                        $(errorMessage).html(message in _mapHelper.customErrorsHash  ? _gtxt(_mapHelper.customErrorsHash[message]) : _gtxt('photoLayer.error'));
                                        $(errorMessage).show();
                                        afterLoad(taskInfo);
                                    }).progress(function(taskInfo){
                                    });
                                });

                            $(newLayerInput).focus();

                            } else {
                                var curName = attrs.currentPhotoLayer.getGmxProperties().name;
                                // parseGeometry(taskInfo, gmxProperties);
                                // window.sendCrossDomainJSONRequest(window.serverBase + "Layer/GetLayerJson.ashx?WrapStyle=func&LayerName=" + curName, function(response) {
                                //     if (!parseResponse(response)) {
                                //         return;
                                //     }
                                //     debugger;
                                //     console.log(response);
                                //     // L.gmx.layersVersion.chkVersion(response.Result, null);
                                //     attrs.currentPhotoLayer.updateVersion(response.Result);
                                // });
                                // L.gmx.layersVersion.chkVersion(gmxProperties.content);
                                // attrs.currentPhotoLayer.updateVersion(gmxProperties.content);

                                afterLoad(taskInfo);
                            }

                        }).fail(function(taskInfo){
                            var message = taskInfo.ErrorInfo && taskInfo.ErrorInfo.ErrorMessage;

                            $(errorMessage).html(message in _mapHelper.customErrorsHash  ? _gtxt(_mapHelper.customErrorsHash[message]) : _gtxt('photoLayer.error'));
                            $(errorMessage).show();
                            afterLoad(taskInfo);

                        }).progress(function(taskInfo){
                        });
                    };

                    function parseGeometry(info, properties) {
                        var coords = [],
                            appended = info.Result.Appended,
                            updated = info.Result.Updated,
                            addCoords = function (objects, coordinates) {
                                for (var a = 0; a < objects.length; a++) {
                                    if (objects[a].longitude && objects[a].latitude) {
                                        var point = nsGmx.leafletMap.options.crs.project(L.latLng(objects[a].longitude, objects[a].latitude));
                                        coordinates.push([point.x, point.y]);
                                    }
                                }
                            };

                        addCoords(appended, coords);
                        addCoords(updated, coords);

                        if (!coords.length) {
                            properties.content.geometry = null;
                        } else {
                            properties.content.geometry.coordinates = coords.length === 1 ? coords[0] : coords;
                            properties.content.geometry.type = coords.length === 1 ? 'POINT' : 'POLYGON';
                        }
                    }

                    function afterLoad(taskInfo) {
                        var resObj = taskInfo.Result;

                        if (resObj) {
                            if (resObj.Appended.length) {
                                $(uploadResSuccess).html(_gtxt('photoLayer.successResult') + ": " + resObj.Appended.length);
                                $(uploadResSuccess).show();
                            }
                            if (resObj.NoCoords.length) {
                                $(uploadResError).html(_gtxt('photoLayer.exifError') + ": " + resObj.NoCoords.length);
                                $(uploadResError).show();
                            }
                        }

                        $(spinContainer).hide();

                        $(uploadButton).toggleClass('gmx-disabled', false);
                        $(uploadLabel).toggleClass('gmx-disabled', false);
                        _this.createSandbox();
                    }
                };

            xhr.send(formData);
        }
    });

    this.Load = function () {
        var view = new PhotoLayerView(),
            resizeFunc = function () {
            },
            closeFunc = function () {
                view.model.set({
                    photoLayersFlag: false,
                    photoLayers: [],
                    currentPhotoLayer: null,
                    photoLayers: []
                });
            };

        dialog = nsGmx.Utils.showDialog(_gtxt('photoLayer.load'), view.el, 340, 220, null, null, resizeFunc, closeFunc);
    }

    this.Unload = function () {
        $(dialog).remove();
    };
};

var publicInterface = {
    pluginName: 'PhotoLayer',
    PhotoLayer: PhotoLayer
};

window.gmxCore.addModule('PhotoLayer',
    publicInterface
);

})(jQuery);

var nsGmx = nsGmx || {};

(function($){

/**
Фильтрует слои со спутниковыми покрытиями по интервалу дат и облачности. Поддерживает фильтрацию дополнительных карт.
* @class 
*/
var CoverControl = function()
{
	this.cloudsIndexes = [];
	this.currCloudsIndex = 4;
	this.commonStyles = null;
	this.cloudsCount = 0;
	this.coverLayers = [];
}

/**
* @function
*/
CoverControl.prototype.saveState = function()
{
	return { currCloudsIndex: this.currCloudsIndex };
}

/**
* @function
*/
CoverControl.prototype.loadState = function( data )
{
	this.currCloudsIndex = data.currCloudsIndex;
	
	$("#MapCalendar .ui-slider").slider("value", data.currCloudsIndex );
	
	if (typeof this.cloudsIndexes[data.currCloudsIndex] !== 'undefined')
		_title($("#MapCalendar .ui-slider")[0].firstChild, this.cloudsIndexes[data.currCloudsIndex].name);
}

CoverControl.prototype._updateStyles = function()
{
	if ( this.commonStyles || this.coverLayers.length == 0 ) return;
	
	var commonStyles = globalFlashMap.layers[this.coverLayers[0]].properties.styles,
		cloudsCount = 0;
	
	for (var i = 0; i < this._icons.length; i++)
		this.cloudsIndexes.push({icon:this._icons[i]});
	
	for (var i = 0; i < commonStyles.length; ++i)
	{
		if (this.cloudsIndexes[i])
			this.cloudsIndexes[i].name = commonStyles[i].Name;
		
		cloudsCount++;
	}
	
	if ( typeof this._initCloudIndex !== 'undefined' )
		this.currCloudsIndex = this._initCloudIndex;
		
	this.cloudsCount = Math.round(cloudsCount / 2);
	this.commonStyles = commonStyles;
	
	if (typeof this.cloudsIndexes[this.currCloudsIndex] !== 'undefined' && $("#MapCalendar .ui-slider").length > 0)
		_title($("#MapCalendar .ui-slider")[0].firstChild, this.cloudsIndexes[this.currCloudsIndex].name);
}

CoverControl.prototype._updateLayers = function()
{
	if (typeof _mapHelper === 'undefined') return;
	//проверим основную карту
	this.coverLayers = nsMapCommon.selectLayersFromTree( globalFlashMap, _layersTree._mapTree, this._coverLayersDescription ).names();

	//и все дополнительные тоже будем фильтровать
	if (typeof _queryExternalMaps.mapsCanvas != 'undefined')
	{
		for (var m = 0; m < _queryExternalMaps.mapsCanvas.childNodes.length; m++)
		{
			var mapElem = _queryExternalMaps.mapsCanvas.childNodes[m].childNodes[0];
			if (mapElem.extLayersTree)
				this.coverLayers = this.coverLayers.concat( nsMapCommon.selectLayersFromTree( globalFlashMap, mapElem.extLayersTree._mapTree, this._coverLayersDescription ).names() );
		}
	}
}

CoverControl.prototype._addWidget = function()
{
	if (this.cloudsIndexes.length == 0 || !this._parent ) return;
	
	var	cloudsSlider = nsGmx.Controls.createSlider(this.currCloudsIndex, function(){}),
		_this = this;
	
	$(cloudsSlider).slider("option", "step", 1);
	$(cloudsSlider).slider("option", "min", 0);
	$(cloudsSlider).slider("option", "max", this.cloudsIndexes.length - 1);
	$(cloudsSlider).slider("option", "value", this.currCloudsIndex);
	$(cloudsSlider).bind("slidestop", function(event, ui)
	{
		_this.currCloudsIndex = ui.value;
		
		_this.setFilters();
		
		_title(cloudsSlider.firstChild, _this.cloudsIndexes[_this.currCloudsIndex].name);
	});
	
	cloudsSlider.style.margin = '10px 3px';
	
	// добавляем раскраску
	cloudsSlider.style.backgroundImage = '';
	var colorTds = [];
	for (var i = 1; i < this.cloudsCount; i++)
	{
		colorTds.push(_td(null,[['css','width', Math.round(100 / (this.cloudsCount - 1)) + 'px'], ['css','height','7px'], ['css','backgroundColor', nsGmx.Utils.convertColor(this.commonStyles[i].RenderStyle.fill.color)]]))
	}
	
	_(cloudsSlider, [_table([_tbody([_tr(colorTds)])],[['css','position','absolute'],['css','left','0px'],['css','top','0px'],['css','border','1px solid #999999']])])
	
	_title(cloudsSlider, _gtxt("Облачность"));
	_title(cloudsSlider.firstChild, this.cloudsIndexes[this.currCloudsIndex].name);
	
	var cloudsLabelDiv = _div(null,[['css','height','16px'],['css','position','relative']]);
	
	for (var i = 0; i < this.cloudsIndexes.length; ++i)
	{
		var img = _img(null,[['attr','src',this.cloudsIndexes[i].icon],['css','position','absolute']]);
		
		img.style.left = (25 * i - 5) + 'px';
		
		_title(img, this.cloudsIndexes[i].name)
		
		_(cloudsLabelDiv, [img])
	}
	
	var trs = [];
	
	trs.push(_tr([_td(),_td([_span([_t(_gtxt("Облачность"))],[['css','fontSize','12px'],['css','margin','0px 10px 0px 7px']])]), _td([cloudsLabelDiv,cloudsSlider],[['attr','colSpan',2]])]));
	trs.push(_tr([_td(null, [['attr','colSpan',2],['css','height','5px']])]));
	
	_(this._parent, [_table([_tbody(trs)],[['css','marginLeft','20px']])]);
	this._parent = null;
}

/**
* @function
* @param {Array} coverLayersDescription Массив имён слоёв для фильтрации
* @param {String} dateAttribute Имя аттрибута слоёв с датой
* @param {String} cloudsAttribute Имя аттрибута слоёв с облачностью
* @param {Array} icons Массив с именами иконок для облачности
* @param {Integer} initCloudIndex Начальная облачность
* @param {nsGmx.Calendar} calendar Календарик, из которого нужно быть интервал дат
* @param {Object} params Остальные параметры виджета (dateFormat, useTimePostfix)
*/
CoverControl.prototype.init = function(coverLayersDescription, dateAttribute, cloudsAttribute, icons, initCloudIndex, calendar, params)
{
	this._params = $.extend({dateFormat: 'yy-mm-dd', useTimePostfix: false}, params);
	this._coverLayersDescription = coverLayersDescription;
	this._initCloudIndex = initCloudIndex;
	this._icons = icons;
	this._calendar = calendar;
	
	this.dateAttribute = dateAttribute;
	this.cloudsAttribute = cloudsAttribute;
	
	this._updateLayers();
	
	this._updateStyles();
	
	var _this = this;
	
	if (typeof _queryExternalMaps !== 'undefined')
	{
		$(_queryExternalMaps).bind('map_loaded', function()
		{
			_this._updateLayers();
			_this._updateStyles();
			_this._addWidget();
			_this.setFilters();
		});
	}
	
	setInterval(function(){
		_this.fixLayers.apply(_this);
	}, 300);
	
	var updateDates = function()
	{
		_this.dateBegin = _this._calendar.getDateBegin();
		_this.dateEnd = _this._calendar.getDateEnd();
	
		_this.setFilters();
	}
	
	$(calendar).change( updateDates );
	updateDates();
}

CoverControl.prototype.fixLayers = function()
{
	for (var i = 0; i < this.coverLayers.length; ++i)
	{
		var layerId = globalFlashMap.layers[this.coverLayers[i]].properties.LayerID,
			div = $("[LayerID='" + layerId + "']");
		
		if (!div.length)
			continue;
		
		$(div[0]).children("[multiStyle]").hide();
		
		if (typeof _mapHelper == 'undefined') continue;
		
		if ($(div[0]).children("[styleType='multi']").length) {
			var icon = nsGmx.Controls.createGeometryIcon(globalFlashMap.layers[this.coverLayers[i]].properties.styles[0], "polygon");
				
			// if ($.browser.msie)
			// {
				// icon.style.width = '9px';
				// icon.style.height = '13px';
				// icon.style.margin = '0px 3px -3px 1px';
			// }
			
			_title(icon, _gtxt("Редактировать стили"));
			
			icon.geometryType = "polygon";
			
			icon.onclick = function()
			{
				_mapHelper.createLayerEditor(this.parentNode, _layersTree, 'styles', -1);
			}
			
			$(div[0]).children("[styleType='multi']").replaceWith(icon);
		}
	}
}

CoverControl.prototype.setFilters = function()
{
	for (var i = 0; i < this.coverLayers.length; ++i)
	{
		var name = this.coverLayers[i],
			layer = globalFlashMap.layers[name];
		
		if (!layer)
			continue;
		
		var	properties = layer.properties;
		
		var timePostfixBegin = this._params.useTimePostfix ? " 00:00:00" : "";
		var timePostfixEnd   = this._params.useTimePostfix ? " 23:59:59" : "";
		
		var filterString = "`" + this.dateAttribute + "` >= '" + $.datepicker.formatDate(this._params.dateFormat, this.dateBegin) + timePostfixBegin + "'" + " AND " + "`" + this.dateAttribute + "` <= '" + $.datepicker.formatDate(this._params.dateFormat, this.dateEnd) + timePostfixEnd + "'",
			filters = layer.filters;
		
		for (var j = 0; j < this.cloudsCount; j++)
		{
			var lastFilter = properties.styles[j].Filter;
			
			if (j <= this.currCloudsIndex)
			{
				filters[j].setVisible(true);
				filters[j + this.cloudsCount].setVisible(true);
				filters[j].setFilter((lastFilter && lastFilter != "") ? ("(" + lastFilter + ") AND" + filterString) : filterString);
				filters[j + this.cloudsCount].setFilter((lastFilter && lastFilter != "") ? ("(" + lastFilter + ") AND" + filterString) : filterString);
			}
			else
			{
				filters[j].setVisible(false);
				filters[j + this.cloudsCount].setVisible(false);
			}
		}
	}
}

/**
* Добавляет в DOM контрол фильтрации по облачности
* @function
* @param {DOMElement} parent Контейнер для добавляения контрола
*/
CoverControl.prototype.add = function(parent)
{
	this._parent = parent;
	this._updateLayers();
	this._updateStyles();
	this._addWidget();
	
}

if ( typeof gmxCore !== 'undefined' )
{
	gmxCore.addModule('CoverControl', {
		CoverControl: CoverControl
	});
}

nsGmx.CoverControl = CoverControl;

})(jQuery);
var nsGmx = nsGmx || {};

(function($){

/**
Фильтрует слои со спутниковыми покрытиями по облачности. Поддерживает фильтрацию дополнительных карт.
* @class 
*/
var CoverControl2 = function()
{
	this.cloudsIndexes = [];
	this.currCloudsIndex = 4;
	this.commonStyles = null;
	this.cloudsCount = 0;
	this.coverLayers = [];
    this._parent = null;
    
    CoverControlInstance.addInstance(this);
}

/**
* @function
*/
CoverControl2.prototype.saveState = function()
{
	return { currCloudsIndex: this.currCloudsIndex };
}

/**
* @function
*/
CoverControl2.prototype.loadState = function( data )
{
	this.currCloudsIndex = data.currCloudsIndex;
	
	$(".ui-slider", this._parent).slider("value", data.currCloudsIndex );
	
	if (typeof this.cloudsIndexes[data.currCloudsIndex] !== 'undefined')
		_title($(".ui-slider", this._parent)[0].firstChild, this.cloudsIndexes[data.currCloudsIndex].name);
}

CoverControl2.prototype._updateStyles = function()
{
	if ( this.commonStyles || this.coverLayers.length == 0 || !(this.coverLayers[0] in globalFlashMap.layers) ) return;
	
	var commonStyles = globalFlashMap.layers[this.coverLayers[0]].properties.styles,
		cloudsCount = 0;
	
	for (var i = 0; i < this._icons.length; i++)
		this.cloudsIndexes.push({icon:this._icons[i]});
	
	for (var i = 0; i < commonStyles.length; ++i)
	{
		if (this.cloudsIndexes[i])
			this.cloudsIndexes[i].name = commonStyles[i].Name;
		
		cloudsCount++;
	}
	
	if ( typeof this._initCloudIndex !== 'undefined' )
		this.currCloudsIndex = this._initCloudIndex;
		
	this.cloudsCount = Math.round(cloudsCount / 2);
	this.commonStyles = commonStyles;
	
	if (typeof this.cloudsIndexes[this.currCloudsIndex] !== 'undefined' && $(".ui-slider", this._parent).length > 0)
		_title($(".ui-slider", this._parent)[0].firstChild, this.cloudsIndexes[this.currCloudsIndex].name);
}

CoverControl2.prototype._updateLayers = function()
{
	if (typeof _mapHelper === 'undefined') return;
    
	//проверим основную карту
	this.coverLayers = nsMapCommon.selectLayersFromTree( globalFlashMap, _layersTree._mapTree, this._coverLayersDescription ).names();

	//и все дополнительные тоже будем фильтровать
	if (typeof _queryExternalMaps.mapsCanvas != 'undefined')
	{
		for (var m = 0; m < _queryExternalMaps.mapsCanvas.childNodes.length; m++)
		{
			var mapElem = _queryExternalMaps.mapsCanvas.childNodes[m].childNodes[0];
			if (mapElem.extLayersTree)
				this.coverLayers = this.coverLayers.concat( nsMapCommon.selectLayersFromTree( globalFlashMap, mapElem.extLayersTree._mapTree, this._coverLayersDescription ).names() );
		}
	}
}

CoverControl2.prototype._addWidget = function()
{
	if (this.cloudsIndexes.length == 0 || !this._parent ) return;
	
	var	cloudsSlider = nsGmx.Controls.createSlider(this.currCloudsIndex, function(){}),
		_this = this;
	
	$(cloudsSlider).slider("option", "step", 1);
	$(cloudsSlider).slider("option", "min", 0);
	$(cloudsSlider).slider("option", "max", this.cloudsIndexes.length - 1);
	$(cloudsSlider).slider("option", "value", this.currCloudsIndex);
	$(cloudsSlider).bind("slidestop", function(event, ui)
	{
		_this.currCloudsIndex = ui.value;
		
		_this.setFilters();
		
		_title(cloudsSlider.firstChild, _this.cloudsIndexes[_this.currCloudsIndex].name);
	});
	
	cloudsSlider.style.margin = '10px 3px';
	
	// добавляем раскраску
	cloudsSlider.style.backgroundImage = '';
	var colorTds = [];
	for (var i = 1; i < this.cloudsCount; i++)
	{
		colorTds.push(_td(null,[['css','width', Math.round(100 / (this.cloudsCount - 1)) + 'px'], ['css','height','7px'], ['css','backgroundColor', nsGmx.Utils.convertColor(this.commonStyles[i].RenderStyle.fill.color)]]))
	}
	
	_(cloudsSlider, [_table([_tbody([_tr(colorTds)])],[['css','position','absolute'],['css','left','0px'],['css','top','0px'],['css','border','1px solid #999999']])])
	
	_title(cloudsSlider, _gtxt("Облачность"));
	_title(cloudsSlider.firstChild, this.cloudsIndexes[this.currCloudsIndex].name);
	
	var cloudsLabelDiv = _div(null,[['css','height','16px'],['css','position','relative']]);
	
	for (var i = 0; i < this.cloudsIndexes.length; ++i)
	{
		var img = _img(null,[['attr','src',this.cloudsIndexes[i].icon],['css','position','absolute']]);
		
		img.style.left = (25 * i - 5) + 'px';
		
		_title(img, this.cloudsIndexes[i].name)
		
		_(cloudsLabelDiv, [img])
	}
    
	var trs = [];
	
	trs.push(_tr([_td(),_td([_span([_t(_gtxt("Облачность"))],[['css','fontSize','12px'],['css','margin','0px 10px 0px 7px']])]), _td([cloudsLabelDiv,cloudsSlider],[['attr','colSpan',2]])]));
	trs.push(_tr([_td(null, [['attr','colSpan',2],['css','height','5px']])]));
	
	_(this._parent, [_table([_tbody(trs)],[['css','marginLeft','20px']])]);
}

/**
* @function
* @param {Array} coverLayersDescription Массив имён слоёв для фильтрации
* @param {String} cloudsAttribute Имя атрибута слоёв с облачностью
* @param {Array} icons Массив с именами иконок для облачности
* @param {Integer} initCloudIndex Начальная облачность
*/
CoverControl2.prototype.init = function(coverLayersDescription, cloudsAttribute, icons, initCloudIndex)
{
	this._coverLayersDescription = coverLayersDescription;
	this._initCloudIndex = initCloudIndex;
	this._icons = icons;
	
	this.cloudsAttribute = cloudsAttribute;
	
	this._updateLayers();
	
	this._updateStyles();
	
	var _this = this;
	
	if (typeof _queryExternalMaps !== 'undefined')
	{
		$(_queryExternalMaps).bind('map_loaded', function()
		{
			_this._updateLayers();
			_this._updateStyles();
			_this._addWidget();
			_this.setFilters();
		});
	}
	
	setInterval(function(){
		_this.fixLayers.apply(_this);
	}, 300);
}

CoverControl2.prototype.fixLayers = function()
{
    if (typeof _mapHelper == 'undefined') return;
    
	for (var i = 0; i < this.coverLayers.length; ++i)
	{
        if (!globalFlashMap.layers[this.coverLayers[i]])
            continue;
            
		var layerId = globalFlashMap.layers[this.coverLayers[i]].properties.LayerID,
			div = $("[LayerID='" + layerId + "']");
		
		if (!div.length)
			continue;
		
		$(div[0]).children("[multiStyle]").hide();
		
		if ($(div[0]).children("[styleType='multi']").length) 
        {
			var icon = nsGmx.Controls.createGeometryIcon(globalFlashMap.layers[this.coverLayers[i]].properties.styles[0], "polygon");
				
			// if ($.browser.msie)
			// {
				// icon.style.width = '9px';
				// icon.style.height = '13px';
				// icon.style.margin = '0px 3px -3px 1px';
			// }
			
			_title(icon, _gtxt("Редактировать стили"));
			
			icon.geometryType = "polygon";
			
            $(div[0]).children("[styleType='multi']").empty().append(icon);
		}
	}
}

CoverControl2.prototype.setFilters = function()
{
	for (var i = 0; i < this.coverLayers.length; ++i)
	{
		var name = this.coverLayers[i],
			layer = globalFlashMap.layers[name];
		
		if (!layer)
			continue;
		
		var filters = layer.filters;
        
		for (var j = 0; j < this.cloudsCount; j++)
		{
			if (j <= this.currCloudsIndex)
			{
				filters[j].setVisible(true);
				filters[j + this.cloudsCount].setVisible(true);
			}
			else
			{
				filters[j].setVisible(false);
				filters[j + this.cloudsCount].setVisible(false);
			}
		}
	}
}

/**
* Добавляет в DOM контрол фильтрации по облачности
* @function
* @param {DOMElement} parent Контейнер для добавляения контрола
*/
CoverControl2.prototype.add = function(parent)
{
	this._parent = parent;
	this._updateStyles();
	this._addWidget();
    $(this).triggerHandler('init');
}

CoverControl2.prototype.getContainer = function()
{
	return this._parent;
}

//предосталяет доступ к первому созданному инстансу CoverControl2
var CoverControlInstance = (function()
{
    var deffered = new $.Deferred();
    var theInstance = null;
    return {
        addInstance: function(coverControl)
        {
            if (theInstance) return;
            
            theInstance = coverControl;
            $(coverControl).bind('init', function()
            {
                deffered.resolve();
            });
        },
        getInstance: function()
        {
            return theInstance;
        },
        whenInited: function(callback)
        {
            deffered.done(callback);
        }
    };
})();

if ( typeof gmxCore !== 'undefined' )
{
	gmxCore.addModule('CoverControl2', {
		CoverControl2: CoverControl2,
        CoverControlInstance: CoverControlInstance
	});
}

nsGmx.CoverControl2 = CoverControl2;

})(jQuery);
var nsGmx = nsGmx || {};

(function($){

/** Управляет видимостью слоёв в зависимости от диапазона дат. 
    Может фильтровать слои только из определённой группы. Работает только с вьюером. Поддерживает фильтрацию в доп. картах.
	@memberOf cover
	@class 
*/
var LayerFiltersControl = function()
{
	var _calendar = null;
	var _groupTitle = null;
	var _layers = null;
	var _map = null;
	
	//по умолчанию слои фильтруются по дате
	var _defaultFilterFunc = function(layer, dateBegin, dateEnd)
	{
		var layerDate = $.datepicker.parseDate('dd.mm.yy', layer.properties.date);
		return dateBegin <= layerDate && layerDate <= dateEnd;
	}
	
	var _filterFunc = _defaultFilterFunc;
	
	var _IterateElems = function(treeElem, callback, parentVisible)
	{
		var visible = parentVisible && (treeElem.content ? treeElem.content.properties.visible : true);
		var childsArr = treeElem.content ? treeElem.content.children : treeElem.children;
		
		for (var i = 0; i < childsArr.length; i++)
		{
			var child = childsArr[i];
			
			if (child.type == 'group')
			{
				callback(child, visible);
				
				_IterateElems(child, callback, visible)
			}
			else
				callback(child, visible);
		}
	}
	
	var _getMapLayersAsHash = function()
	{
		var res = {};
		for (var l = 0;l < _map.layers.length; l++)
			res[_map.layers[l].properties.name] = _map.layers[l];
			
		return res;
	}
	
	var _update = function()
	{
		if (typeof _queryExternalMaps.mapsCanvas != 'undefined')
		{
			for (var m = 0; m < _queryExternalMaps.mapsCanvas.childNodes.length; m++)
			{
				var mapElem = _queryExternalMaps.mapsCanvas.childNodes[m].childNodes[0];
				if (mapElem.extLayersTree)
					_updateTree(mapElem.extLayersTree, mapElem.extLayersTree._mapTree, mapElem);
			}
		}
		
		_updateTree(_layersTree, _layersTree._mapTree, _queryMapLayers.buildedTree);
	}
	
	var _updateTree = function(layersTree, mapTree, domTreeRoot)
	{
		var dateBegin = _calendar.getDateBegin();
		var dateEnd = _calendar.getDateEnd();
		
		var layers = [];
		
		if (_layers)
			layers = nsMapCommon.selectLayersFromTree(_map, mapTree, _layers).asHash();
		else 
			layers = _groupTitle ? nsMapCommon.selectLayersFromTree(_map, mapTree, [{group: _groupTitle}]).asHash() : _getMapLayersAsHash();
		
		_IterateElems( mapTree, function(elem, parentVisible)
		{
			if (elem.content.properties.name in layers)
			{
				var isShowLayer = _filterFunc( layers[elem.content.properties.name], dateBegin, dateEnd );
                layersTree.treeModel.setNodeVisibility(elem, isShowLayer);
			}
		}, true);
	}
	
	/**
	 * @function Инициализитует фильтрацию слоёв. Далее классом будут отслеживаться события календарика.
	 * @param map Основная карта
	 * @param {cover.Calendar} calendar Календарик, который используется для задания дат
	 * @param {Object} params Дополнительные параметры: <br/>
	 *    groupTitle - имя группы, слои в которой нужно фильтровать. Устарело, используйте layers <br/>
	 *    layers - вектор из имён слоёв или указаний на группу, которые нужно фильтровать. Если не задано, будут фильтроваться все слои на карте.<br/>
	 *    filterFunc - ф-ция filterFunc(layer, dateBegin, dateEnd) -> Bool. Возвращает true, если слой нужно показать, false чтобы скрыть. По умолчанию происходит фильтрация по дате слоя.
	 */
	this.init = function(map, calendar, params)
	{
		_map = map;
		
		if ( typeof params != 'undefined' )
		{
			_groupTitle = params.groupTitle;
			_layers = params.layers;
			if (params.filterFunc) 
				_filterFunc = params.filterFunc;
		}
		
		if (_calendar)
			$(_calendar).unbind('change', _update);
			
		_calendar = calendar;
		$(_calendar).bind('change', _update);
		_update();
		
		$(_queryExternalMaps).bind('map_loaded', _update);
	}
	
	this.update = function() { _update() };
}

if ( typeof gmxCore !== 'undefined' )
{
	gmxCore.addModule('LayerFiltersControl', {
		LayerFiltersControl: LayerFiltersControl
	});
}

nsGmx.LayerFiltersControl = LayerFiltersControl;

})(jQuery);
var nsGmx = nsGmx || {};

(function($){

/** Фильтрует объекты внутри векторных слоёв по интервалу дат
* @class
*/
var FiltersControl = function()
{
	var _layers = [];
	var _dateAttribute = null;
	var _dateBegin = null;
	var _dateEnd = null;
	var _type = null;
	var _params = null;
	
	var _setFilters = function()
	{
		var filterLayer = function(layer)
		{
			var	properties = layer.properties;
			
			var timePostfixBegin = _params.useTimePostfix ? " 00:00:00" : "";
			var timePostfixEnd   = _params.useTimePostfix ? " 23:59:59" : "";

			var filterString = "`" + _dateAttribute + "` >= '" + $.datepicker.formatDate(_params.dateFormat, _dateBegin) + timePostfixBegin + "'" + " AND " + "`" + _dateAttribute + "` <= '" + $.datepicker.formatDate(_params.dateFormat, _dateEnd) + timePostfixEnd + "'",
				filters = layer.filters;
			
			for (var j = 0; j < filters.length; j++)
			{
				var lastFilter = properties.styles[j].Filter;
				
				filters[j].setFilter((lastFilter && lastFilter != "") ? ("(" + lastFilter + ") AND" + filterString) : filterString);
			}			
		}
		
		if (_type)
		{ //фильтруем все слои данного типа 
			for (var i = 0; i < globalFlashMap.layers.length; ++i)
				if (globalFlashMap.layers[i].properties.type === _type)
					filterLayer(globalFlashMap.layers[i]);
		}
		else
		{ //фильтруем конкретные слои
			for (var i = 0; i < _layers.length; ++i)
			{
				var name = _layers[i],
					layer = globalFlashMap.layers[name];
				
				if (!layer)
					continue;
					
				filterLayer(layer);
			}
		}
	}

	/** Инициализировать контрол
	* @function
	* @param {Array|string} layers Вектор имён слоёв для фильтрации или тип слоёв для фильтрации (Raster или Vector). В последнем случае фильтруются все слои данного типа
	* @param {String} dateAttribute Имя аттрибута даты в слоях
	*/
	this.init = function(layers, dateAttribute, calendar, params)
	{
		_params = $.extend({dateFormat: 'yy-mm-dd', useTimePostfix: false}, params);
		if (typeof layers === 'string')
			_type = layers;
		else
			_layers = layers;
		
		_dateAttribute = dateAttribute;
		
		var updateDate = function()
		{
			_dateBegin = calendar.getDateBegin();
			_dateEnd = calendar.getDateEnd();
		
			_setFilters();
		}
		
		$(calendar).change(updateDate);
		updateDate();
	}
	
	if (typeof _queryExternalMaps !== 'undefined')
		$(_queryExternalMaps).bind('map_loaded', _setFilters);
}

if ( typeof gmxCore !== 'undefined' )
{
	gmxCore.addModule('FiltersControl', {
		FiltersControl: FiltersControl
	});
}

nsGmx.FiltersControl = FiltersControl;

})(jQuery);
var nsGmx = nsGmx || {};

/** 
* Контроллёр глобального буфера обмена
* @memberOf nsGmx
* @class Синглетон. Позволяет хранить массивы объектов разного типа. Тип объектов - строка. В рамках одного типа объекты упорядочены.
*/
nsGmx.ClipboardController = (function()
{
    var _clipboard = {};
    return {
        addItem: function(type, item)
        {
            _clipboard[type] = _clipboard[type] || [];
            _clipboard[type].push(item);
        },
        
        popItem: function(type)
        {
            if (typeof _clipboard[type] === 'undefined' || _clipboard[type].length == 0) return null;
            return _clipboard[type].pop();
        },
        
        //количество объектов данного типа
        getCount: function(type)
        {
            if ( typeof _clipboard[type] === 'undefined' ) 
                return 0;
            
            return _clipboard[type].length;
        },
        
        //получить объект типа type с индексом index. Если index < 0, то индексация с конца (-1 - последний элемент)
        get: function(type, index)
        {
            if ( typeof _clipboard[type] === 'undefined' ) return null;
            
            if (index < 0) index += _clipboard[type].length;
            
            if (index < 0 || _clipboard[type].length <= index )
                return null;
                
            return _clipboard[type][index];
        }
    }
})();
var nsGmx = nsGmx || {};

(function($){

"use strict";

_translationsHash.addtext("rus", {
                        "pluginsEditor.selectedTitle" : "Плагины карты",
                        "pluginsEditor.availableTitle" : "Доступные плагины",
                        "pluginsEditor.add" : "Добавить плагин",
                        "pluginsEditor.paramsTitle" : "Параметры плагина"
                     });

_translationsHash.addtext("eng", {
                        "pluginsEditor.selectedTitle" : "Map plugins",
                        "pluginsEditor.availableTitle" : "Available plugins",
                        "pluginsEditor.add" : "Add plugin",
                        "pluginsEditor.paramsTitle" : "Parameter of plugin"
                     });


var MapPlugins = function()
{
    var _plugins = [];
    var _params = {};

    //вместо массива из одного элемента передаём сам элемент
    var normalizeParams = function(params) {
        var res = {};
        for (var p in params) {
            res[p] = params[p].length === 1 ? params[p][0] : params[p];
        }

        return res;
    }

    this.addPlugin = function(pluginName, pluginParams, onlyParams)
    {
        _params[pluginName] = pluginParams || _params[pluginName] || {};

        if (!onlyParams && _plugins.indexOf(pluginName) === -1) {
            _plugins.push(pluginName);
        }

        $(this).change();

        return true;
    }

    this.each = function(callback) {
        for (var p = 0; p < _plugins.length; p++) {
            callback(_plugins[p], _params[_plugins[p]] || {});
        }
    }

    this.remove = function(pluginName) {
        var nameIndex = _plugins.indexOf(pluginName);
        if (nameIndex !== -1) {
            _plugins.splice(nameIndex, 1);
            $(this).change();
        }
    }

    this.isExist = function(pluginName)
    {
        return _plugins.indexOf(pluginName) !== -1;
    }

    this.getPluginParams = function(pluginName) {
        return _params[pluginName];
    }

    this.setPluginParams = function(pluginName, pluginParams) {
        _params[pluginName] = pluginParams;
        $(this).change();
    }

    //обновляем используемость и параметры плагинов
    this.updateGeomixerPlugins = function() {
        for (var p = 0; p < _plugins.length; p++) {
            var plugin = nsGmx.pluginsManager.getPluginByName(_plugins[p]),
                lazyLoad = plugin && plugin.lazyLoad;

            nsGmx.pluginsManager.setUsePlugin(_plugins[p], !lazyLoad);
        }

        for (var p in _params) {
            nsGmx.pluginsManager.updateParams(p, normalizeParams(_params[p]));
        }
    }

    this.load = function(data, version) {
        if (version === 1) {
            _plugins = data;
            _params = {};
        } else if (version === 2) {
            _plugins = [];
            _params = {};
            for (var p = 0; p < data.length; p++) {
                _plugins.push(data[p].name);
                _params[data[p].name] = data[p].params;
            }
        } else if (version === 3) {
            _plugins = data.plugins;

            //поддержка ошибки, которая прокралась в базу...
            if ($.isArray(data.params) && data.params.length === 0) {
                _params = {};
            } else {
                _params = data.params;
            }
        }
    }

    this.save = function(version) {
        if (version === 1) {
            return _plugins;
        } else if (version === 2) {
            var res = [];
            _plugins.forEach(function(name) {
                res.push({name: name, params: _params[name]});
            })
            return res;
        } else if (version === 3) {
            return {
                plugins: _plugins,
                params: _params
            }
        }
    }
}

var GeomixerPluginsWidget = function(container, mapPlugins)
{
    var template = Handlebars.compile('<div class="pluginsEditor-allPlugins-container">' +
        '<div class="pluginEditor-widgetHeader">{{i "pluginsEditor.availableTitle"}}</div>' +
        '<div class="pluginEditor-treePlaceholder"></div>' +
        '<div class="pluginEditor-controls">' +
            '<input class="inputStyle inputFullWidth pluginEditor-pluginInput"><br>' +
            '<button class="pluginEditor-addButton">{{i "pluginsEditor.add"}}</button>' +
        '</div>' +
    '</div>');

    var lang = window.nsGmx.Translations.getLanguage();

    var DEFAULT_GROUP_NAME = {
        eng: 'Main',
        rus: 'Основные'
    };

    var _allPluginGroups = {},
        configGroups = window.gmxPluginGroups || [],
        groupByPluginName = [],
        groupOrder = {};

    configGroups.forEach(function(group, index) {
        groupOrder[group[lang]] = index;
        group.plugins.forEach(function(plugin) {
            groupByPluginName[plugin] = group[lang];
        })
    })

    nsGmx.pluginsManager.forEachPlugin(function(plugin)
    {
        if ( plugin.pluginName && plugin.mapPlugin && (plugin.isPublic || nsGmx.AuthManager.isRole(nsGmx.ROLE_ADMIN)) )
        {
            var groupName = groupByPluginName[plugin.pluginName] || DEFAULT_GROUP_NAME[lang];
            _allPluginGroups[groupName] = _allPluginGroups[groupName] || {groupName: groupName, plugins: []};
            _allPluginGroups[groupName].plugins.push({name: plugin.pluginName, isPublic: plugin.isPublic});
            //_allPlugins.push({name: plugin.pluginName, isPublic: plugin.isPublic});
        }
    })

    //по алфавиту
    for (var g in _allPluginGroups) {
        _allPluginGroups[g].plugins.sort(function(a, b) {
            return a.name > b.name ? 1 : -1;
        })
    }

    var isListActive = false;
    var update = function()
    {
        $(container).empty();

        var filteredGroups = [];
        for (var g in _allPluginGroups) {
            var plugins = _allPluginGroups[g].plugins.filter(function(plugin) {return !mapPlugins.isExist(plugin.name);});
            //если в группе нет плагинов, не показываем её
            plugins.length && filteredGroups.push({
                groupName: _allPluginGroups[g].groupName,
                plugins: plugins
            });
        };

        //сохраняем порядок, как в конфиге, default group - первой
        filteredGroups.sort(function(a, b) {
            return groupOrder[a.groupName] - groupOrder[b.groupName];
        });

        var pluginGroupTemplate = Handlebars.compile('<ul class="pluginEditor-pluginsTree ui-helper-noselect">{{#groups}}' +
            '<li>' +
                '<div class="pluginEditor-groupTitle">{{groupName}}</div>' +
                '<ul>{{#plugins}}' +
                    '<li class="pluginEditor-pluginItem ui-helper-noselect" data-plugin-name="{{name}}">{{name}}</li>' +
                '{{/plugins}}</ul>' +
            '</li>' +
            '{{/groups}}</ul>');

        var pluginsTree = $(pluginGroupTemplate({groups: filteredGroups}));

        pluginsTree.find('.pluginEditor-pluginItem').click(function(e) {
            isListActive = true;
            var pluginName = $(this).data('pluginName');

            if (e.ctrlKey) {
                $(this).toggleClass('pluginEditor-activePluginItem');
            } else {
                pluginsTree.find('.pluginEditor-pluginItem').removeClass('pluginEditor-activePluginItem');
                $(this).addClass('pluginEditor-activePluginItem');
            }
        });

        pluginsTree.find('.pluginEditor-groupTitle').click(function() {
            $(this).siblings('.hitarea').click();
        })

        var ui = $(template());

        ui.find('.pluginEditor-treePlaceholder').append(pluginsTree);

        ui.find('.pluginEditor-pluginInput').bind('focus', function() {
            isListActive = false;
        });

        ui.find('.pluginEditor-addButton').click(function() {
            var selected = [];

            if (isListActive) {
                pluginsTree.find('.pluginEditor-activePluginItem').each(function(i, elem) {
                    selected.push($(elem).data('pluginName'));
                });
            } else {
                var pluginInput = ui.find('.pluginEditor-pluginInput');
                if (nsGmx.pluginsManager.getPluginByName(pluginInput.val())) {
                    selected.push(pluginInput.val());
                } else {
                    inputError(pluginInput[0]);
                }
            }

            for (var sp = 0; sp < selected.length; sp++)
                mapPlugins.addPlugin( selected[sp] );
        });

        ui.appendTo(container);

        pluginsTree.treeview(/*{collapsed: true}*/);
    }

    $(mapPlugins).change(update);
    update();
}

var paramsWidgets = {};

var MapPluginParamsWidget = function(mapPlugins, pluginName) {

    if (paramsWidgets[pluginName]) {
        return;
    };

    var FakeTagMetaInfo = function()
    {
        this.isTag = function(tag) { return true; }
        this.getTagType = function(tag) { return 'String'; }
        this.getTagDescription = function(tag) { return ''; }
        this.getTagArray = function() { return []; }
        this.getTagArrayExt = function() { return []; }
    };
    var fakeTagMetaInfo = new FakeTagMetaInfo();

    var pluginParams =  mapPlugins.getPluginParams(pluginName);
    var tagInitInfo = {};

    for (var tagName in pluginParams) {
        tagInitInfo[tagName] = {Value: pluginParams[tagName]};
    }

    var layerTags = new nsGmx.LayerTagsWithInfo(fakeTagMetaInfo, tagInitInfo);

    var container = $('<div/>');

    var pluginValues = new nsGmx.LayerTagSearchControl(layerTags, container);

    var updateParams = function() {
        var newParams = {};
        layerTags.eachValid(function(tagid, tag, value) {
            newParams[tag] = newParams[tag] || [];
            newParams[tag].push(value);
        })

        mapPlugins.setPluginParams(pluginName, newParams);
    }

    var dialogDiv = showDialog(
            _gtxt('pluginsEditor.paramsTitle') + " " + pluginName,
            container[0],
            {
                width: 320,
                height: 200,
                closeFunc: function() {
                    updateParams();
                    delete paramsWidgets[pluginName];
                }
            }
        );

    paramsWidgets[pluginName] = {
        update: updateParams,
        closeDialog: function() {
            $(dialogDiv).dialog('close');
        }
    };

}

var MapPluginsWidget = Backbone.View.extend({
    template: Handlebars.compile(
        '<div class="pluginEditor-widgetHeader">{{i "pluginsEditor.selectedTitle"}}</div>' +
        '<div class="pluginEditor-currentMapPlugins">' +
            '{{#plugins}}' +
                '<div class="pluginEditor-widgetElem">' +
                    '{{#unless isCommon}}' +
                        '<span class="pluginEditor-remove gmx-icon-close" data-plugin-name="{{name}}"></span>' +
                    '{{/unless}}' +
                    '<span class="pluginEditor-edit gmx-icon-edit" data-plugin-name="{{name}}"></span>' +
                    '<span class="pluginEditor-title {{#if isCommon}} pluginEditor-commonPlugin{{/if}}">{{name}}</span>' +
                '</div>' +
            '{{/plugins}}' +
        '</div>'
    ),

    events: {
        'click .gmx-icon-close': function(event) {
            var pluginName = $(event.target).data('pluginName');
            this._mapPlugins.remove(pluginName);
        },

        'click .gmx-icon-edit': function(event) {
            var pluginName = $(event.target).data('pluginName');
            new MapPluginParamsWidget(this._mapPlugins, pluginName);
        }
    },

    initialize: function(options) {
        this._mapPlugins = options.mapPlugins;
        $(this._mapPlugins).change(this.render.bind(this));
        this.render();
    },

    render: function() {
        var mapPlugins = this._mapPlugins,
            pluginsToShow = [];

        nsGmx.pluginsManager.forEachPlugin(function(plugin) {
            if ( plugin.pluginName && !plugin.mapPlugin && !mapPlugins.isExist(plugin.pluginName) ) {
                pluginsToShow.push({
                    name: plugin.pluginName,
                    isCommon: true
                });
            }
        });

        mapPlugins.each(function(name) {
            pluginsToShow.push({
                name: name,
                isCommon: false
            });
        });

        pluginsToShow.sort(function(a, b) {
            return a.isCommon != b.isCommon ? Number(b.isCommon) - Number(a.isCommon) : (a.name > b.name ? 1 : -1);
        });

        this.$el.empty().append(this.template({plugins: pluginsToShow}));
    }
});

var createPluginsEditor = function(container, mapPlugins)
{
    var widgetContainer = $('<div/>', {'class': 'pluginEditor-widgetContainer'});
    var allPluginsContainer = $('<div/>', {'class': 'pluginEditor-allContainer'});
    var mapPluginsWidget = new MapPluginsWidget({
        el: widgetContainer,
        mapPlugins: mapPlugins
    });
    var allPluginsWidget = new GeomixerPluginsWidget(allPluginsContainer, mapPlugins);

    $(container)
        .append($('<table/>', {'class': 'pluginEditor-table'}).append($('<tr/>')
            .append($('<td/>', {'class': 'pluginEditor-allTD'}).append(allPluginsContainer))
            .append($('<td/>', {'class': 'pluginEditor-widgetTD'}).append(widgetContainer))
        ));

    return {
        update: function() {
            for (var name in paramsWidgets) {
                paramsWidgets[name].update();
            }
        },
        closeParamsDialogs: function() {
            for (var name in paramsWidgets) {
                paramsWidgets[name].closeDialog();
            }
        }
    };
}

gmxCore.addModule('PluginsEditor', {
    createPluginsEditor: createPluginsEditor,
    MapPlugins: MapPlugins
})

nsGmx.createPluginsEditor = createPluginsEditor;
_mapHelper.mapPlugins = new MapPlugins();

//Cтарая версия информации о плагинах карты. Поддерживается для обратной совместимости (например, загрузка доп. карт)
//Формат: {String[]} массив имён плагинов
nsGmx.userObjectsManager.addDataCollector('mapPlugins', {
    load: function(data)
    {
        if (data) {
            _mapHelper.mapPlugins.load(data, 1);
            _mapHelper.mapPlugins.updateGeomixerPlugins();
        }
    },
    collect: function() {
        return _mapHelper.mapPlugins.save(1);
    }
})

//Вторая версия информации о плагинах карты.
//Формат: [{name: pluginName1, params: {param: value, ...}}, ...]
nsGmx.userObjectsManager.addDataCollector('mapPlugins_v2', {
    load: function(data)
    {
        if (data) {
            _mapHelper.mapPlugins.load(data, 2);
            _mapHelper.mapPlugins.updateGeomixerPlugins();
        }
    },
    collect: function()
    {
        return _mapHelper.mapPlugins.save(2);
    }
})

//Третья версия информации о плагинах карты.
//Формат: {plugins: [name1, ....], params: {name1: {param1: value1, ...}, ...}}
nsGmx.userObjectsManager.addDataCollector('mapPlugins_v3', {
    load: function(data)
    {
        if (data) {
            _mapHelper.mapPlugins.load(data, 3);
            _mapHelper.mapPlugins.updateGeomixerPlugins();
        }
    },
    collect: function()
    {
        return _mapHelper.mapPlugins.save(3);
    }
})

})(jQuery);

(function()
{
    var getZoomValue = function(zoomControl)
    {
        var isNotValid = zoomControl.value == '' ||
                    isNaN(Number(zoomControl.value)) ||
                    Number(zoomControl.value) != Math.floor(Number(zoomControl.value)) ||
                    Number(zoomControl.value) < 1;

        if (isNotValid)
        {
            $(zoomControl).addClass("error");
            return null;
        }
        else
        {
            $(zoomControl).removeClass("error");
            return Number(zoomControl.value);
        }
    }

    var checkZoom = function(minZoomInput, maxZoomInput)
    {
        var minVal = getZoomValue(minZoomInput);
        var maxVal = getZoomValue(maxZoomInput);

        if (minVal && maxVal && minVal > maxVal)
        {
            $(minZoomInput).addClass("error");
            $(maxZoomInput).addClass("error");
            return false;
        }

        return !!(minVal && maxVal);
    }

    /**
     Контрол для задания максимального и минимального зумов слоя/стиля.
     Выдаёт два 'li' элемента, которые клиент сам помещает куда-нибудь.
     Генерит событие "change", когда изменились валидные значения зумов
     @memberOf nsGmx
     @class
     @param minZoom {int} Начальный минимальный зум
     @param maxZoom {int} Начальный максимальный зум
    */
    var ZoomPropertiesControl = function(minZoom, maxZoom)
    {
        var _this = this;
        var minZoomInput = _input(null, [['dir','className','inputStyle'],['attr','paramName','MinZoom'],['css','width','30px'],['attr','value', minZoom || 1]]);
        var maxZoomInput = _input(null, [['dir','className','inputStyle'],['attr','paramName','MaxZoom'],['css','width','30px'],['attr','value', maxZoom || 17]]);
        checkZoom(minZoomInput, maxZoomInput);

        var liMinZoom = _li([_div([_table([_tbody([_tr([_td([_span([_t(_gtxt("Мин. зум"))],[['css','fontSize','12px']])],[['css','width','60px']]),_td([minZoomInput])])])])])]);
		var liMaxZoom = _li([_div([_table([_tbody([_tr([_td([_span([_t(_gtxt("Макс. зум"))],[['css','fontSize','12px']])],[['css','width','60px']]),_td([maxZoomInput])])])])])]);

        minZoomInput.onkeyup = maxZoomInput.onkeyup = function()
        {
            if (checkZoom(minZoomInput, maxZoomInput))
                $(_this).change();

            return true;
        }

        this.getMinLi = function() { return liMinZoom; };

        this.getMaxLi = function() { return liMaxZoom; };

        /** Получить минимальный зум
        */
        this.getMinZoom = function() { return Number(minZoomInput.value) };

        /** Получить максимальный зум
        */
        this.getMaxZoom = function() { return Number(maxZoomInput.value) };
    }

    nsGmx.ZoomPropertiesControl = ZoomPropertiesControl;
})();

/**
    Возвращает массив ссылок в верхнее левое мета-меню в формате HeaderWidget из CommonComponents.
    Считывает информацию из window.gmxViewerUI.headerLinkItems в формате [{icon: iconPath, title: TITLE, href: HREF}, ...] (формат ГеоМиксера)
    Если переменной нет, подставляет значения по умолчению ("Карта пожаров", "Поиск снимков", "Платформа Геомиксер")
    @memberOf nsGmx
*/
nsGmx.addHeaderLinks = function()
{
    var isHeaderLinks = false;
    if ( typeof window.headerLinks === 'boolean' ) isHeaderLinks = window.headerLinks; //совместимость с предыдущими версиями
    if ( typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.headerLinks !== 'undefined' )
        isHeaderLinks = window.gmxViewerUI.headerLinks;

    if (!isHeaderLinks) {
        return [];
    }

    var items = (window.gmxViewerUI && window.gmxViewerUI.headerLinkItems) ||
        [
            {title: _gtxt("Карта пожаров"), href: _gtxt("http://fires.ru"), newWindow: true},
            {title: _gtxt("Поиск снимков"), href: _gtxt("http://search.kosmosnimki.ru"), newWindow: true},
            {title: _gtxt("Платформа Геомиксер"), newWindow: true, id: 'HeaderLinkGeoMixer'}
        ];

    return $.extend(true, [], items).map(function(item, index, array) {
        item.link = item.href;
        return {
            id: 'headerLinksItem' + index,
            title: item.title,
            func: function(){
                if (item.link) {
                    window.open(item.link, '_blank');
                }
            }.bind(item)
        }
    })
}

!(function()
{
    _translationsHash.addtext("rus", {
							"clusterControl.maxMembers" : "Макс. объектов",
							"clusterControl.radius" : "Радиус кластеризации",
                            "clusterControl.title": "Стиль кластера"
						 });
						 
    _translationsHash.addtext("eng", {
							"clusterControl.maxMembers" : "Max. members in cluster",
							"clusterControl.radius" : "Clustering radius",
                            "clusterControl.title": "Cluster style"
						 });
                         
    var ClusterParamsControl = function(container, initStyle)
    {
        var _this = this;
        var isApplyClusters = typeof initStyle !== 'undefined';
        var clusterView = {        // Атрибуты отображения членов кластера (при отсутствии не отображать)
            'maxMembers': 10,    // максимальное колич.обьектов в кластере (по умолчанию '10')
            'radius': 40,        // максимальный радиус сдвига координат обьектов попавших в кластер (по умолчанию '50')
            'delta': 10,        // разброс сдвига координат (по умолчанию '0')
            'bgStyle': {        // Стиль подложки отображения (по умолчанию '0')
                'fill': { 'color': 0xffff00, 'opacity': 20 },
                'outline': { 'color': 0x00ff00, 'opacity': 1, 'thickness': 10 }
            },
            'lineStyle': { 'color': 0x0600ff, 'opacity': 30, 'thickness': 1 }    // Стиль линии соединяющей центр кластера с отображаемым обьектом
        };
    
        var clusterStyle = {
        }
        
        var ph = {
            radius: 50,                // радиус кластеризации в пикселах (по умолчанию 20)
            iterationCount: 1,        // количество итераций K-means (по умолчанию 1)
            clusterView: clusterView, // Атрибуты отображения членов кластера (при отсутствии не отображать)
            RenderStyle: null,      // стили кластеров
            HoverStyle: null        // стили кластеров при наведении
        };
        
        ph = $.extend(true, ph, initStyle);
                
        var clusterStyleControl = $('<div/>', {'class': 'clusterStyleControl'});
        var clusterStyleContainer = $('<div/>');
        clusterStyleControl.append($('<span/>').text(_gtxt('clusterControl.title'))).append(clusterStyleContainer);
        
        var clusterRadiusInput = $('<input/>', {'class': 'inputStyle'}).val(ph.radius).bind('keyup', function()
        {
            if (ph.radius != this.value)
            {
                ph.radius = Number(this.value);
                $(_this).change();
            }
        });
        
        var maxMembersInput = $('<input/>', {'class': 'inputStyle'}).val(ph.clusterView.maxMembers).bind('keyup', function()
        {
            if (ph.clusterView.maxMembers != this.value)
            {
                ph.clusterView.maxMembers = Number(this.value);
                $(_this).change();
            }
        });
        
        var clusterViewTable = $('<table/>')
            .append($('<tr/>')
                .append($('<td/>').append($('<span/>').text(_gtxt('clusterControl.radius'))))
                .append($('<td/>').append(clusterRadiusInput))
            ).append($('<tr/>')
                .append($('<td/>').append($('<span/>').text(_gtxt('clusterControl.maxMembers'))))
                .append($('<td/>').append(maxMembersInput))
            );
            
        var clusterViewContainer = $('<div/>', {'class': 'clusterViewContainer'}).append(clusterViewTable);
        
        $(container).append(clusterStyleControl).append(clusterViewContainer);
        
        var initRenderStyle = ph.RenderStyle || {marker:{size:3}, outline: {color: 0xff0000, opacity: 100, thickness: 2}};
        
        //предполагаем что модуль уже загружен
        //TODO: или это не так?
        var resObject = gmxCore.getModule('LayerStylesEditor').createStyleEditor(clusterStyleContainer[0], initRenderStyle, "point", true);
        
        $(resObject).change(function()
        {
            ph.RenderStyle = ph.HoverStyle = initRenderStyle;
            $(_this).change();
        });
        
        this.isApplyCluster = function()
        {
            return isApplyClusters;
        }
        
        this.getClusterStyle = function()
        {
            return ph;
        }
        
        this.applyClusters = function(isApply)
        {
            if (isApply != isApplyClusters)
            {
                ph.RenderStyle = initRenderStyle;
                isApplyClusters = isApply;
                $(_this).change();
            }
        }
    }
    
    nsGmx.ClusterParamsControl = ClusterParamsControl;
})();
(function()
{
    /**
    Хранит информацию о тегах: типы и описание
    @memberOf nsGmx
    @class
    @param {Object} initTagsInfo - описание тегов вида tagName: {Type: , Description: }
    */
    var TagMetaInfo = function(initTagsInfo)
    {
        var tags = initTagsInfo || {};

        this.isTag = function(tag)
        {
            return tag in tags;
        }

        this.getTagType = function(tag)
        {
            return tag in tags ? tags[tag].Type : null;
        }

        this.getTagDescription = function(tag)
        {
            return tag in tags ? tags[tag].Description : null;
        }

        this.getTagArray = function()
        {
            var res = [];
            for (var t in tags)
                res.push(t);
            return res;
        }

        this.getTagArrayExt = function()
        {
            var res = [];
            for (var t in tags)
                res.push( {name: t, type: tags[t].Type, desc: tags[t].Description} );

            return res;
        }
    };

    (function()
    {
        var def;

        /** Загружает данные о доступных тегах с сервера
        * @memberOf nsGmx.TagMetaInfo
        * @name loadFromServer
        * @function
        * @param {function(tagInfo)} [callback] Ф-ция, которая будет вызвана после загрузки информации о типах.
        * @return {jQuery.Deferred} Будет заресолвен после получения информации о типах
        */
        TagMetaInfo.loadFromServer = function(callback)
        {
            if (!def)
            {
                def = $.Deferred();
                sendCrossDomainJSONRequest(serverBase + 'Layer/MetaKeys.ashx', function(response)
                {
                    if (!parseResponse(response))
                    {
                        def.resolve();
                        return;
                    }
                    def.resolve(new TagMetaInfo(response.Result));
                })
            }
            callback && def.done(callback);
            return def;
        }
    })();

    var extendClass = function(base, sub) {
        function ctor() {}

        ctor.prototype = base.prototype;
        sub.prototype = new ctor();
        sub.prototype.constructor = sub;
    }

    var LayerTags = function(initTags)
    {
        /** Вызывается при изменении набора тегов слоя
            @name nsGmx.LayerTags.change
            @event
        */

        this._uniqueID = 1;
        this._tags = {};

        for (var tag in initTags) {
            var values = initTags[tag].Value;
            if (!$.isArray(values)) {
                values = [values];
            }

            for (var i = 0; i < values.length; i++) {
                this.addNewTag(tag, values[i]);
            }
        }
    }

    LayerTags.prototype = {
        _verificationFunctions: {
            'Number': function(value)
            {
                return value.length && !isNaN(Number(value));
            },
            'String': function(value)
            {
                return true;
            },
            'Date': function(value)
            {
                try {
                    $.datepicker.parseDate('dd.mm.yy', value);
                    return true;
                }
                catch(err) {
                    return false;
                }
            }
        },

        _isValidTypeValue: function(type, value)
        {
            return !(type in this._verificationFunctions) || this._verificationFunctions[type](value);
        },

        updateTag: function(id, tag, value, type)
        {
            var tags = this._tags;
            if ( !(id in tags) ) return false;
            if ( tags[id].tag !== tag || tags[id].value !== value || tags[id].type !== type)
            {
                tags[id] = {tag: tag, value: value, type: type};
                $(this).change();
            }

            return true;
        },

        deleteTag: function(id)
        {
            if ( !(id in this._tags) ) return;

            delete this._tags[id];
            $(this).change();
        },

        each: function(callback)
        {
            var tags = this._tags;
            for (var tagId in tags)
                callback(tagId, tags[tagId].tag, tags[tagId].value, tags[tagId].type);
        },

        eachValid: function(callback, allowUnknownTags)
        {
            var tags = this._tags;
            for (var tagId in tags)
                if ((allowUnknownTags || this.isValidValue(tagId)) && !this.isEmptyTag(tagId))
                    callback(tagId, tags[tagId].tag, tags[tagId].value, tags[tagId].type);
        },

        addNewTag: function(tag, value, type)
        {
            if (typeof value === 'undefined' || value === null) {
                value = '';
            };

            var newId = 'id' + (++this._uniqueID);
            this._tags[newId] = {tag: tag || '', value: value, type: type};
            $(this).change();
            return newId;
        },

        isTag: function(tagId)
        {
            return tagId in this._tags;
        },

        isEmptyTag: function(tagId)
        {
            var tags = this._tags;
            return tagId in tags && tags[tagId].tag === '' && tags[tagId].value === '';
        },

        isValidValue: function(tagId)
        {
            var tags = this._tags;
            return tagId in tags && this._isValidTypeValue(tags[tagId].type, tags[tagId].value);
        },

        getTag: function(tagId)
        {
            return this._tags[tagId];
        },

        getTagByName: function(tagName)
        {
            var tags = this._tags;
            for (var tagId in tags)
                if (tags[tagId].tag == tagName)
                    return tags[tagId];
        },

        getTagIdByName: function(tagName)
        {
            var tags = this._tags;
            for (var tagId in tags)
                if (tags[tagId].tag == tagName)
                    return tagId;
        }
    }

    /**
        Набор тегов (метаданных) слоя из определённого набора тегов
        @memberOf nsGmx
        @class
        @param {nsGmx.TagMetaInfo} tagMetaInfo описание типов тегов
        @param {Object} initTags теги для инициализации. Формат: {tagName: {Value: tagValue}, ...}. tagValue может быть массивом
    */
    var LayerTagsWithInfo = function(tagMetaInfo, initTags) {

        // чтобы можно было расширять существующий объект LayerTags
        if (this instanceof LayerTagsWithInfo) {
            LayerTags.call(this, initTags);
        }

        this.getTagMetaInfo = function()
        {
            return tagMetaInfo;
        }

        this.isKnownTagname = function(tagname)
        {
            return tagMetaInfo.isTag(tagname);
        }

        this.addNewTag = function(tag, value, type)
        {
            type = type || tagMetaInfo.getTagType(tag) || '';
            LayerTags.prototype.addNewTag.call(this, tag, value, type);
        }

        this.updateTag = function(id, tag, value) {
            var type = tagMetaInfo.getTagType(tag);
            LayerTags.prototype.updateTag.call(this, id, tag, value, type);
        }
    }

    extendClass(LayerTags, LayerTagsWithInfo);

    /**
        Контрол для задания набора тегов (например, для слоя)
        @memberOf nsGmx
        @class
    */
    var LayerTagSearchControl = function(layerTags, container, params)
    {
        var _params = $.extend({
            inputWidth: 130,
            tagHeader: _gtxt('Параметр'),
            valueHeader: _gtxt('Значение')
        }, params )
        var mainTable = $('<table/>', {'class': 'layertags-table'}).appendTo(container);
        mainTable.append($('<tr/>')
            .append($('<th/>').text(_params.tagHeader))
            .append($('<th/>').text(_params.valueHeader))
            .append($('<th/>'))
        );

        //добавляем к body элемент с id чтобы добавить к нему jQuery autocomplete и задать стили
        //к текущему виджету добавить нельзя, так как он ещё не добавлен в общее дерево, а виджет ac требует глобального селектора
        if ($('#layertagstable').length == 0)
            $('body').append($('<div id="layertagstable"></div>'));

        var rows = {}; //ссылки на контролы для каждого элемента
        var rowsVector = [];

        //в зависимости от типа ввода (type), прикрепляет к valueInput виджет выбора даты, время или даты/время
        var updateInput = function(valueInput, type)
        {
            if ( type == 'Date' )
            {
                $(valueInput).timepicker('destroy');
                $(valueInput).datetimepicker('destroy');

                $(valueInput).datepicker(
                {
                    onSelect: function(dateText, inst) {
                        $(this).change();
                    },
                    changeMonth: true,
                    changeYear: true,
                    dateFormat: "dd.mm.yy"
                });

            }
            else if ( type == 'DateTime' )
            {
                $(valueInput).timepicker('destroy');
                $(valueInput).datepicker('destroy');

                $(valueInput).datetimepicker(
                {
                    changeMonth: true,
                    changeYear: true,
                    dateFormat: "dd.mm.yy",
                    timeFormat: "HH:mm:ss",
                    showSecond: true,
                    timeOnly: false
                }).addClass('layertags-datetimeinput');
            }
            else if ( type == "Time" )
            {

                $(valueInput).datepicker('destroy');
                $(valueInput).datetimepicker('destroy');

                $(valueInput).timepicker({
                    timeOnly: true,
                    timeFormat: "HH:mm:ss",
                    showSecond: true
                });
            }
            else
            {
                $(valueInput).timepicker('destroy');
                $(valueInput).datetimepicker('destroy');
                $(valueInput).datepicker('destroy');
            }
        }

        var validateRow = function(row)
        {
            if ( !layerTags.isEmptyTag(row.id) && !layerTags.isKnownTagname(row.tag.val()) )
                row.tag.addClass('error');
            else
                row.tag.removeClass('error');

            if (!layerTags.isEmptyTag(row.id) && !layerTags.isValidValue(row.id) )
                row.value.addClass('error');
            else
                row.value.removeClass('error');
        }

        var addNewRow = function(tagId, tag, value)
        {
            var tagInput = $('<input/>', {'class': 'inputStyle'}).val(tag).css('width', _params.inputWidth).autocomplete({
                source: layerTags.getTagMetaInfo().getTagArrayExt(),
                minLength: 0,
                delay: 0,
                appendTo: "#layertagstable",
                select: function(event, ui)
                {
                    tagInput.val(ui.item.name);
                    updateModel(ui.item.name, valueInput.val().trim());
                    return false;
                }
            }).bind('click', function(){
                $(tagInput).autocomplete("search", "");
            });

            tagInput.data( "ui-autocomplete" )._renderItem = function( ul, item )
            {
                return $( "<li/>")
                    .append($("<a/>", {title: item.desc}).text(item.name))
                    .appendTo( ul );
            }

            var valueInput = $('<input/>', {'class': 'inputStyle'}).val(value).css('width', _params.inputWidth);

            var type = layerTags.getTagMetaInfo().getTagType(tag);
            updateInput(valueInput, type);


            var updateModel = function()
            {
                layerTags.updateTag(tagId, tagInput.val().trim(), valueInput.val().trim());
            }

            tagInput.bind('keyup change', updateModel);
            valueInput.bind('keyup change', updateModel);

            var deleteButton = makeImageButton('img/recycle.png', 'img/recycle_a.png');
            deleteButton.onclick = function()
            {
                layerTags.deleteTag(tagId);
            }

            var tr = $('<tr/>')
                .append($('<td/>').append(tagInput))
                .append($('<td/>').append(valueInput))
                .append($('<td/>', {'class': 'layertags-delete'}).append(deleteButton));

            mainTable.append(tr);

            rows[tagId] = {id: tagId, tr: tr, tag: tagInput, value: valueInput, type: type};
            rowsVector.push(rows[tagId]);
            validateRow(rows[tagId]);
        }

        var moveEmptyLayersToBottom = function()
        {
            var lastEmptyId = -1;
            for (var irow = 0; irow < rowsVector.length; irow++)
                if (layerTags.isEmptyTag(rowsVector[irow].id))
                    lastEmptyId = irow;

            if (lastEmptyId >= 0 && lastEmptyId < rowsVector.length)
            {
                var tr = rowsVector[lastEmptyId].tr;
                $(tr).detach();
                mainTable.append(tr);
            }
        }

        $(layerTags).change(function()
        {
            var isAnyEmpty = false;
            layerTags.each(function(tagId, tag, value)
            {
                if (tag == '' && value == '')
                    isAnyEmpty = true;

                if (!(tagId in rows))
                    addNewRow(tagId, tag, value);
                else
                {
                    if (rows[tagId].tag.val() !== tag)
                        rows[tagId].tag.val(tag)

                    if (rows[tagId].value.val() !== value)
                        rows[tagId].value.val(value)


                    var type = layerTags.getTagMetaInfo().getTagType(tag);
                    if (rows[tagId].type !== type)
                    {
                        rows[tagId].type = type;
                        updateInput(rows[tagId].value, type);
                    }

                    validateRow(rows[tagId]);
                }
            });

            for (var tagId in rows)
            {
                if (!(layerTags.isTag(tagId)))
                {
                    rows[tagId].tr.remove();
                    delete rows[tagId];
                }
            }

            if (!isAnyEmpty)
                layerTags.addNewTag();

            moveEmptyLayersToBottom();
        });

        layerTags.addNewTag();
    }

    nsGmx.LayerTagSearchControl = LayerTagSearchControl;
    nsGmx.LayerTags = LayerTags;
    nsGmx.LayerTagsWithInfo = LayerTagsWithInfo;
    nsGmx.TagMetaInfo = TagMetaInfo;
})();

// Контрол для добавления в каталог растров новых слоёв. 
// Позволяет выбирать из существующих на сервере слоёв, слоёв внутри карты и создавать новый слой
nsGmx.RCAddLayerControl = function(map, layerName)
{
    var currRCName = '';
    var currAttrControl = null;
    var infoContainer = $('<div/>').css('margin-top', '5px');
    var InfoControl = function(container)
    {
        var curProcID = 0;
        var loaderImage = $('<img/>', {src: 'img/loader2.gif'}).hide();
        var statusContainer = $('<span/>', {'class': 'RCAdd-info-container'});
        var warningContainer = $('<span/>', {'class': 'RCAdd-warning-container'});
        
        container.append(loaderImage, statusContainer, warningContainer);
        
        this.startProcess = function()
        {
            loaderImage.show();
            return curProcID++;
        }
        
        this.doneProcess = function(message)
        {
            loaderImage.hide();
            $(statusContainer).empty().show().text(message).fadeOut(2000, 'easeInExpo');
        }
        
        this.failProcess = function(message)
        {
            //$(container).empty().show().text(message).fadeOut(2000, 'easeInExpo');
        }
        
        this.warning = function(message) {
            $(warningContainer).empty().show().text(message).fadeOut(2000, 'easeInExpo');
        }
    }
    var infoControl = new InfoControl(infoContainer);
    
    var LayersToAddWidget = function(parent) {
        var objsByLayer = {};
        var dataProvider = new nsGmx.ScrollTable.StaticDataProvider();
        var table = new nsGmx.ScrollTable();
        table.setDataProvider(dataProvider);
        
        table.createTable({
            parent: parent[0],
            name: 'objtoadd',
            fields: [_gtxt('Каталог Растров'), _gtxt('Растр'), ''],
            fieldsWidths: ['50%', '50%', '20px'],
            drawFunc: function(item) {
                var removeIcon = makeImageButton("img/recycle.png", "img/recycle_a.png");
                removeIcon.onclick = function() {
                    var identityField = item.layerprops.identityField;
                    var id = item.obj[identityField];
                    dataProvider.filterOriginalItems(function(addedItem) {
                        return addedItem.obj[identityField] !== id;
                    })
                }
                //либо однострочное имя, либо просто id
                var objname;

                if (item.layerprops.NameObject) {
                    objname = L.gmxUtil.parseBalloonTemplate(item.layerprops.NameObject, {
                        properties: item.obj, 
                        tileAttributeTypes: item.attrTypes
                    });
                } else {
                    objname = item.obj[item.layerprops.identityField];
                }
                
                var tr = _tr([
                    _td([_t(item.layerprops.title)], [['dir', 'className', 'RCAdd-vis-td']]),
                    _td([_t(objname)],               [['dir', 'className', 'RCAdd-vis-td']]),
                    _td([removeIcon],                [['dir', 'className', 'RCAdd-vis-remove']])
                ])
                
                for (var i = 0; i < tr.childNodes.length; i++)
                    tr.childNodes[i].style.width = this._fields[i].width;
                    
                return tr;
            }
        })
        
        this.addObject = function(layerprops, attrTypes, obj) {
            objsByLayer[layerprops.name] = objsByLayer[layerprops.name] || {};
            objsByLayer[layerprops.name][obj[layerprops.identityField]] = true;
            dataProvider.addOriginalItem({layerprops: layerprops, attrTypes: attrTypes, obj: obj});
        }
        
        this.getObjects = function() {
            return dataProvider.getOriginalItems();
        }
        
        this.clear = function() {
            dataProvider.setOriginalItems([]);
            objsByLayer = {};
        }
        
        this.isExist = function(layerprops, obj) {
            return objsByLayer[layerprops.name] && objsByLayer[layerprops.name][obj[layerprops.identityField]];
        }
    }
    
    var id = layerName;
    var existLayerCanvas = $('<div/>', {id: 'existlayer' + id});
    var mapLayerCanvas   = $('<div/>', {id: 'maplayer' + id, 'class': 'RCAdd-maplayers-container'});
    var RCLayerCanvas    = $('<div/>', {id: 'rclayer' + id});
    var newLayerCanvas   = $('<div/>', {id: 'newlayer' + id}).css('height', '465px');
    var visLayerCanvas   = $('<div/>', {id: 'vislayer' + id});
    
    var tabMenu = _div([_ul([_li([_a([_t(_gtxt("Существующие слои"))],[['attr','href','#existlayer' + id]])]),
                             _li([_a([_t(_gtxt("Слои из карты"))],[['attr','href','#maplayer' + id]])]),
                             _li([_a([_t(_gtxt("Слои из КР"))],[['attr','href','#rclayer' + id]])]),
                             _li([_a([_t(_gtxt("Новый слой"))],[['attr','href','#newlayer' + id]])]),
                             _li([_a([_t(_gtxt("С экрана"))],[['attr','href','#vislayer' + id]])])
                            ])]);
        
    $(tabMenu).append(existLayerCanvas, newLayerCanvas, RCLayerCanvas, mapLayerCanvas, visLayerCanvas);
    var dialogCanvas = $('<div/>').append(tabMenu, infoContainer);
    
    var suggestLayersControl = new nsGmx.LayerManagerControl(existLayerCanvas, 'addimage', {
            fixType: 'raster', 
            enableDragging: false,
            onclick: function(clickContext) {
                infoControl.startProcess();
                _mapHelper.modifyObjectLayer(layerName, [{source: {layerName: clickContext.elem.name}}])
                    .done(function()
                    {
                        infoControl.doneProcess(_gtxt('Добавлен растр') + ' "' + clickContext.elem.title + '"');
                    })
            }
        });
        
    var RCLayerLayerCanvas = $('<div/>').appendTo(RCLayerCanvas);
    var RCLayerObjectCanvas = $('<div/>').appendTo(RCLayerCanvas).css({
        'border-top-width': '1px', 
        'border-top-style': 'solid',
        'border-top-color': '#216B9C'
    });
    
    var sizeProvider = function() {
        console.log(dialogCanvas[0].parentNode.offsetHeight, dialogCanvas[0].parentNode.parentNode.offsetWidth);
        return {
            width: dialogCanvas[0].parentNode.parentNode.offsetWidth - 1,
            height: dialogCanvas[0].parentNode.offsetHeight - RCLayerLayerCanvas[0].offsetHeight - 9
        }
    }
    
    var RCLayersControl = new nsGmx.LayerManagerControl(RCLayerLayerCanvas, 'addrclayer', {
            fixType: 'catalog',
            enableDragging: false,
            height: 300,
            onclick: function(clickContext) {
                currRCName = clickContext.elem.name;
                currAttrControl = nsGmx.createAttributesTable(currRCName, RCLayerObjectCanvas[0], sizeProvider, {
                    hideActions: true,
                    hideRowActions: true,
                    hideDownload: true,
                    onClick: function(elem) {
                        var idfield = currAttrControl.getLayerInfo().identityField;
                        var objid = elem.values[elem.fields[idfield].index];
                        
                        var dstProps = map.layersByID[layerName].getGmxProperties();
                        
                        var properties = {};
                        
                        //переносим все атрибуты объекта, у которых совпадает имя и тип
                        for (var srcAttr in elem.fields) {
                            if (srcAttr !== idfield) {
                                for (var k = 0; k < dstProps.attributes.length; k++) {
                                    if (dstProps.attributes[k] === srcAttr && dstProps.attrTypes[k] === elem.fields[srcAttr].type ) {
                                        properties[srcAttr] = elem.values[elem.fields[srcAttr].index];
                                        break;
                                    }
                                }
                            }
                        }
                        
                        _mapHelper.modifyObjectLayer(layerName, [{source: {rc: currRCName, rcobj: objid}, properties: properties}]);
                    }
                });
            }
        });
        
    var newLayerProperties = {Title:'', Description: '', Date: '', TilePath: {Path:''}, ShapePath: {Path:''}};
    nsGmx.createLayerEditor(null, 'Raster', newLayerCanvas[0], newLayerProperties,
        {
            addToMap: false, 
            doneCallback: function(promise)
            {
                infoControl.startProcess();
                promise.done(function(taskInfo)
                {
                    _mapHelper.modifyObjectLayer(layerName, [{source: {layerName: taskInfo.Result.properties.name}}])
                        .done(function()
                        {
                            infoControl.doneProcess(_gtxt('Добавлен растр') + ' "' + taskInfo.Result.properties.title + '"');
                        })
                })
            }
        }
    );
    
    var visLayersWidget = new LayersToAddWidget($('<div/>').appendTo(visLayerCanvas));
    var addVisLayersButton = makeLinkButton(_gtxt("Добавить выбранные растры"));
    addVisLayersButton.onclick = function() {
        infoControl.startProcess();
        var objs = $.map(visLayersWidget.getObjects(), function(item) {
            return {source: {rc: item.layerprops.name, rcobj: item.obj[item.layerprops.identityField] }}; 
        });
        _mapHelper.modifyObjectLayer(layerName, objs).done(function() {
            visLayersWidget.clear();
            infoControl.doneProcess(_gtxt('Добавлены растры') + ' (' + objs.length + ')');
        });
    }
    
    $(addVisLayersButton).appendTo(visLayerCanvas);
    
    var previewLayersTree = new layersTree({showVisibilityCheckbox: false, allowActive: true, allowDblClick: false});
    
    var treeContainer = $('<div/>').css({'overflow-y': 'scroll', 'height': 400, 'margin-bottom': 10});
    
    var ul = previewLayersTree.drawTree(_layersTree.treeModel.getRawTree(), 2);
    $(ul).treeview().appendTo(treeContainer);
    
    var addMapButton = makeLinkButton(_gtxt("Добавить выбранные растры"));
    
    addMapButton.onclick = function()
    {
        var activeElem = previewLayersTree.getActive();
        if (!activeElem) return;
        
        var objectsToAdd = [];
        
        //если выбрали карту, то elem тут окажется равным undefined
        var elem = activeElem.gmxProperties.content && previewLayersTree.treeModel.findElemByGmxProperties(activeElem.gmxProperties).elem;
        
        if (!elem || elem.type === 'group') {
            previewLayersTree.treeModel.forEachLayer(function(layerElem) {
                var props = layerElem.properties;
                if (props.type === 'Raster' && props.LayerID) {
                    objectsToAdd.push({source: {layerName: props.name}});
                }
            }, elem);
        } else {
            objectsToAdd.push({source: {layerName: elem.content.properties.name}});
        }
        
        if (objectsToAdd.length > 0)
        {
            infoControl.startProcess();
            _mapHelper.modifyObjectLayer(layerName, objectsToAdd)
                .done(function()
                {
                    infoControl.doneProcess(_gtxt('Добавлены растры') + ' (' + objectsToAdd.length + ')');
                })
        }
    }
    
    mapLayerCanvas.append(treeContainer, addMapButton);
    
    var listeners = [];
    var clearListeners = function() {
        for (var i = 0; i < listeners.length; i++) {
            var pt = listeners[i];
            var layer = map.layersByID[pt.layerName];
            layer && layer.off('click', pt.listener);
        }
        listeners = [];
    }
    
    var clickListener = function(event) {
        
        var layerProps = event.gmx.layer.getGmxProperties(),
            attrTypes = event.gmx.layer._gmx.tileAttributeTypes,
            objProps = event.gmx.properties;
        
        if (!objProps['GMX_RasterCatalogID']) {
            infoControl.warning(_gtxt('Выбранный объект не имеет растра'));
            return true;
        }
        
        if (visLayersWidget.isExist(layerProps, objProps)) {
            infoControl.warning(_gtxt('Этот растр уже был выбран'));
            return true;
        }
        
        visLayersWidget.addObject(layerProps, attrTypes, objProps);
        return true;	// Отключить дальнейшую обработку события
    }
    
    $(tabMenu).tabs({
        activate: function(event, ui) {
            var index = $(tabMenu).tabs('option', 'active');
            if (index === 4) { //выбираем на карте - добавляем ко всем растрам listeners
                listeners = [];
                map.layers.forEach(function(layer) {
                    var props = layer.getGmxProperties();
                    if (props.type === 'Vector' && props.IsRasterCatalog)
                    {
                        //тут нужна уникальная ф-ция для дальнейшей очистки слушателей
                        var listener = clickListener.bind(null); 
                        
                        layer.on('click', listener);
                        listeners.push({layerName: props.name, listener: listener});
                    }
                })
            } else {
                clearListeners();
            }
        }
    });
    
    showDialog(_gtxt('Добавить снимки'), dialogCanvas[0], {
        width: 550, 
        height: 550, 
        resizeFunc: function() {
            currAttrControl && currAttrControl.resizeFunc();
        },
        closeFunc: function() {
            clearListeners();
        }
    });
}
//Необходимо подключить JS-библиотеки: jquery, jquery-ui, api.js, utilites.js, treeview.js, translations.js, gmxCore.js, 	файл локализации
//						стили: jquery, jquery-ui, search.css, treeview.css, buttons.css

// ищем только по базе ОСМ
// глобальный конфиг не учитываем,
// поскольку поиск по базе Геоцентра на январь 2017 давно умер
var GLOBAL_USE_OSM = 1;
/**
* @namespace Search
* @description Содержит необходимое для поиска
*/
!(function($){

//TODO: переписать генерацию UI на шаблонах

//Очень суровое решение для разруливания конфликтов с глобальными переменными.
var _, _input, _td, _tr, _div, _t, _table, _tbody, _img, _span, _li, _ul, _form;

$('#flash').droppable({
    drop: function(event, ui) {
        var obj = ui.draggable[0].gmxDrawingObject;

        if (obj) {
            var text = Functions.GetFullName(obj.TypeName, obj.ObjName);
            nsGmx.leafletMap.gmxDrawing.addGeoJSON({
                type: 'Feature',
                geometry: L.gmxUtil.geometryToGeoJSON(obj.Geometry)
            }, {text: text});
        }
    }
})

var initTranslations = function() {
    _translationsHash.addtext("rus", {
        "Текущее местоположение отображается только для России и Украины": "Текущее местоположение отображается только для России и Украины",
        "Следующие [value0] страниц": "Следующие [value0] страниц",
        "Следующие [value0] страницы": "Следующие [value0] страницы",
        "Следующая страница": "Следующая страница",
        "Следующая [value0] страница": "Следующая [value0] страница",
        "Предыдущие [value0] страниц" : "Предыдущие [value0] страниц",
        "Первая страница" : "Первая страница",
        "Последняя страница" : "Последняя страница"
    });

    _translationsHash.addtext("eng", {
        "Текущее местоположение отображается только для России и Украины": "Current location is shown only for Russia and Ukraine",
        "Следующие [value0] страниц": "Next [value0] pages",
        "Следующие [value0] страницы": "Next [value0] pages",
        "Следующая страница": "Next page",
        "Следующая [value0] страница": "Next [value0] pages",
        "Предыдущие [value0] страниц" : "Previous [value0] pages",
        "Первая страница" : "First page",
        "Последняя страница" : "Last page"
    });
}


/** Вспомогательные функции
 @namespace Functions
 @memberOf Search
*/
var Functions = {

	/** Возвращает полное наименование объекта, состоящее из типа и наименования
	 @static
	 @param sType Наименование типа объекта
	 @param sName Наименование объекта
    */
	GetFullName: function(/** string */sType, /** string */sName){
		var sFullName = "";

		if (sType==null || sType == "государство" || sType == "г." || /[a-zA-Z]/.test(sName))
			sFullName = sName;
		else if ((sType.indexOf("район") != -1) || (sType.indexOf("область") != -1) || (sType.indexOf("край") != -1))
			sFullName = sName + " " + sType;
		else
			sFullName = sType + " " + sName;

		return sFullName;
	},

	/** Возвращает полный путь к объекту
    * @memberOf Search.Functions
    *
	* @param oFoundObject найденный объект
	* @param sObjectsSeparator разделитель между дочерним элементом и родителем в строке пути
	* @param bParentAfter признак того, что родительский элемент идет после дочернего
	* @param sObjNameField название свойства, из которого брать наименование
    */
	GetPath: function(/*object*/ oFoundObject,/* string */ sObjectsSeparator, /* bool */ bParentAfter, /* string */ sObjNameField){
		if (sObjNameField == null) sObjNameField = "ObjName";
		if (oFoundObject == null) return "";
		var oParentObj = oFoundObject.Parent;
		if (oParentObj != null && (oParentObj.ObjName == "Российская Федерация" || oParentObj.TypeName == "административный округ")) {
			oParentObj = oParentObj.Parent;
		}
		var sObjectName = (oFoundObject.CountryCode != 28000 && oFoundObject.CountryCode != 310000183) ? oFoundObject[sObjNameField] : this.GetFullName(oFoundObject.TypeName, oFoundObject[sObjNameField]);
		if (oParentObj != null && oParentObj[sObjNameField] != null && oParentObj[sObjNameField]){
			if (bParentAfter){
				return sObjectName + sObjectsSeparator + this.GetPath(oParentObj, sObjectsSeparator,  bParentAfter, sObjNameField);
			}
			else{
				return this.GetPath(oParentObj, sObjectsSeparator,  bParentAfter, sObjNameField) + sObjectsSeparator + sObjectName;
			}
		}
		else{
			return sObjectName;
		}
	},

	/** Возвращает строку, соединяющую переданные свойства
	 @static
	 @param oProps - Свойства
	 @param sObjectsSeparator Разделитель 2х свойств в строке*/
	GetPropertiesString: function(/**object[]*/oProps,/**string*/ sPropSeparator, /**object[]*/arrDisplayFields){
		var sResultString = "";
		if (oProps != null){
			for (var sPropName in oProps){
				if (sResultString != "") sResultString += sPropSeparator;
				sResultString += sPropName + ": " + oProps[sPropName];
			}
		}
		return sResultString;
	}
}

/** Конструктор
 @memberOf Search
 @class Контрол, состоящий из поля поиска с подсказками и кнопкой поиска по векторным слоям
 @param oInitContainer Объект, в котором находится контрол (div) - обязательный
 @param params Параметры: <br/>
	<i>layersSearchFlag</i> - {bool} Признак видимости кнопки поиска по векторным слоям <br/>
	<i>Search</i> = function(event, SearchString, layersSearchFlag) -  осуществляет поиск по строке поиска и признаку "Искать по векторным слоям" <br/>
	<i>AutoCompleteSource</i> = function(request, response) - возвращает данные для автозаполнения: [{label:..., category: ...}] <br/>
	<i>AutoCompleteSelect</i> = function(event, oAutoCompleteItem) - вызывается при выборе из строки автозаполнения*/
var SearchInput = function (oInitContainer, params) {
	/**Объект, в котором находится контрол (div)*/
	var Container = oInitContainer;
	/**Признак видимости кнопки поиска по векторным слоям*/
	var layersSearchFlag = params.layersSearchFlag;
	var _this = this;
	if (Container == null) throw "SearchInput.Container is null";
	var _sDefalutAddressVectorLabel = _gtxt("$$search$$_1");
	var _sDefalutAddressLabel = _gtxt("$$search$$_2");
	/** Возвращает содержимое поля поиска
	@function
	@see Search.SearchInput#SetSearchString*/
	this.GetSearchString = function(){return searchField.value};

	/** Устанавливает содержимое поля поиска
	@function
	@see Search.SearchInput#GetSearchString*/
	this.SetSearchString = function(value) {searchField.value = value;};

	/** Устанавливает содержимое поля поиска
	@function
	@see Search.SearchInput#SetSearchStringFocus*/
	this.SetSearchStringFocus = function(flag) {if (flag) searchField.focus(); else searchField.blur();};

	/** Устанавливает подсказку поля поиска
	@function
	@see Search.SearchInput#SetPlaceholder*/
	this.SetPlaceholder = function(value) {
        searchField.value = searchField.placeholder = sDefaultValue = value;
    };

	if (params.Search != null) $(this).bind('Search', params.Search);
	if (params.AutoCompleteSelect != null) $(this).bind('AutoCompleteSelect', params.AutoCompleteSelect)

	var dtLastSearch = new Date();
	/**Текстовое поле для ввода поискового запроса*/
	var searchField = _input(null, [['dir', 'className', 'searchCenter']]);
	var sDefaultValue;

	var divSearchBegin, tdSearchBegin;
	var tdSearchButton = _td([_div(null, [['dir', 'className', 'searchEnd']])], [['dir', 'className', 'searchEndTD']]);

	/**Вызывает событие необходимости начать поиск*/
	var fnSearch = function(){
		/** Вызывается при необходимости начать поиск (обработчик события его осуществляет)
		@name Search.SearchInput.Search
		@event
		@param {string} SearchString строка для поиска
		@param {bool} layersSearchFlag признак необходимости осуществлять поиск по векторным слоям*/
		$(_this).triggerHandler('Search', [searchField.value, layersSearchFlag]);
	}
    tdSearchButton.onclick = fnSearch;

	/** Смена признака необходимости проводить поиск по векторным слоям*/
	var updateSearchType = function() {
		var bChangeValue = (searchField.value == sDefaultValue);

		if (layersSearchFlag) {
			sDefaultValue = _sDefalutAddressVectorLabel;
			divSearchBegin.className = 'searchBeginOn';
		}
		else {
			sDefaultValue = _sDefalutAddressLabel;
			divSearchBegin.className = 'searchBeginOff';
		}

		if (bChangeValue) searchField.value = sDefaultValue;
	}

	if (!layersSearchFlag) {
        sDefaultValue = _sDefalutAddressLabel;
		divSearchBegin = _div(null, [['dir', 'className', 'searchBegin']]);
        tdSearchBegin = _td([divSearchBegin], [['dir', 'className', 'searchBeginTD']]);
    }
    else {
        sDefaultValue = _sDefalutAddressVectorLabel;
		divSearchBegin = _div(null, [['dir', 'className', 'searchBeginOn']]);
		tdSearchBegin = _td([divSearchBegin], [['dir', 'className', 'searchBeginOnTD']]);
        divSearchBegin.onclick = function() {
            layersSearchFlag = !layersSearchFlag;

            updateSearchType(layersSearchFlag);
        }
        attachEffects(divSearchBegin, 'active');
        _title(divSearchBegin, _gtxt('Изменить параметры поиска'));
    }
	searchField.value = sDefaultValue;

    var searchFieldCanvas = _table(	[_tbody([_tr([tdSearchBegin, _td([searchField], [['dir', 'className', 'searchCenterTD']]), tdSearchButton])])],
									[['dir', 'className', 'SearchInputControl']]);

    $(searchField).on('keyup', function(event) {
        if (event.keyCode === 13) {
			if (Number(new Date()) - dtLastSearch < 1000 || $("#ui-active-menuitem").get().length > 0) return; //Если уже ведется поиск по автозаполнению, то обычный не ведем
			dtLastSearch = new Date();
			if($(searchField).data('ui-autocomplete')) {
                $(searchField).autocomplete("close");
            }
            fnSearch();
            return true;
        }
    });

    searchField.onfocus = function() {
        if (this.value == sDefaultValue) {
            this.value = '';

			$(this).addClass('searchCenterValueExists');
        }
    }

    searchField.onblur = function() {
        if (this.value == '') {
            this.value = sDefaultValue;

			$(this).removeClass('searchCenterValueExists');
        }
    }

    _(Container, [searchFieldCanvas]);

	//Добавляем автокомплит только если задана функция источника данных для него
	if (params.AutoCompleteSource != null)
	{

		/** выбор значения из подсказки
		@param {object} event Событие
		@param {object} ui Элемент управления, вызвавший событие*/
		function fnAutoCompleteSelect(event, ui) {
			if (ui.item) {
				dtLastSearch = new Date();
				/** Вызывается при выборе значения из всплывающей подсказки
				@name Search.SearchInput.AutoCompleteSelect
				@event
				@param {object} AutoCompleteItem Выбранное значение*/
				if (ui.item.GeoObject && ui.item.GeoObject.ObjNameShort){
					var nameProp = ui.item.GeoObject.ObjNameShort.search(/[a-zA-Zа-яА-Я]/)<0?"ObjName":"ObjNameShort";
                    			ui.item.label = ui.item.GeoObject[nameProp];
                    			ui.item.value = ui.item.GeoObject[nameProp];
                    //ui.item.label = ui.item.GeoObject.ObjNameShort;
                    //ui.item.value = ui.item.GeoObject.ObjNameShort;
				}
				$(_this).triggerHandler('AutoCompleteSelect', [ui.item]);
			}
		}

		/** Возвращает данные подсказки
		@param {object} request запрос (request.term - строка запроса)
		@param {object[]} Массив значений для отображения в подсказке*/
		function fnAutoCompleteSource(request, response){
			/** Слова, содержащиеся в строке поиска */
			$(searchField).autocomplete("widget")[0].arrSearchWords = request.term.replace(/[^\wа-яА-Я]+/g, "|").split("|");
			params.AutoCompleteSource(request, function(arrResult){
				if (Number(new Date()) - dtLastSearch > 5000) {
					response(arrResult);
				}
				else
				{
					response([]);
				}
			});
		}

		$(function() {
			$(searchField).autocomplete({
				minLength: 3,
				source: fnAutoCompleteSource,
				select: fnAutoCompleteSelect,
                appendTo: searchField.parentNode
			});

            /** Слова, содержащиеся в строке поиска */
            $(searchField).autocomplete("widget")[0].arrSearchWords = [];

            $(searchField).data("ui-autocomplete")._renderItem = function( ul, item) {
                var t = item.label;
                for (var i=0; i<ul[0].arrSearchWords.length; i++){
                    if(ul[0].arrSearchWords[i].length > 1){
                        var re = new RegExp(ul[0].arrSearchWords[i], 'ig') ;
                        t = t.replace(re, function(str, p1, p2, offset, s){
                            return "<span class='ui-autocomplete-match'>" + str + "</span>";
                        });
                    }
                }
                return $( "<li></li>" )
                    .data( "item.autocomplete", item )
                    .append( "<a>" + t + "</a>" )
                    .appendTo( ul );
            };
		});

	}
	/** Возвращает контрол, в котором находится данный контрол*/
	this.getContainer = function(){return Container;}

	/** Устанавливает значение по умолчанию вместо "Поиск по адресной базе"*/
	this.setAddressVectorDefault = function(value){
		if(searchField.value == _sDefalutAddressLabel) searchField.value = value;
		if(sDefaultValue == _sDefalutAddressLabel) sDefaultValue = value;
		_sDefalutAddressVectorLabel = value;
	}

	/** Устанавливает значение по умолчанию вместо "Поиск по векторным слоям и адресной базе"*/
	this.setAddressDefault = function(value){
		if(searchField.value == _sDefalutAddressLabel) searchField.value = value;
		if(sDefaultValue == _sDefalutAddressLabel) sDefaultValue = value;
		_sDefalutAddressLabel = value;
	}
};

/** Конструктор
 @class Контрол, отображающий результаты поиска в виде списка
 @memberOf Search
 @param {object} oInitContainer Объект, в котором находится контрол (div), обязательный
 @param {string} ImagesHost - строка пути к картинкам*/
var ResultList = function(oInitContainer, ImagesHost){
	/**Объект, в котором находится контрол (div)*/
	var Container = oInitContainer;
	var _this = this;
	var sImagesHost = ImagesHost || "http://maps.kosmosnimki.ru/api/img";

	var arrDisplayedObjects = []; //Объекты, которые отображаются на текущей странице
	var iLimit = 10; //Максимальное количество результатов на странице
	var iPagesCount = 7; //Количество прокручиваемых страниц при нажатии на двойные стрелки
	if (Container == null) throw "ResultList.Container is null";

	var oResultCanvas;
	var arrTotalResultSet = [];

	if(oResultCanvas == null)
	{
		oResultCanvas = _div(null, [['dir', 'className', 'searchResultCanvas']]);
		_(Container, [oResultCanvas]);
	}
	var oLoading = _div([_img(null, [['attr', 'src', sImagesHost + '/progress.gif'], ['dir', 'className', 'searchResultListLoadingImg']]), _t(_gtxt("загрузка..."))], [['dir', 'className', 'searchResultListLoading']]);
	var fnNotFound = function(){_(oResultCanvas, [_div([_t(_gtxt("Поиск не дал результатов"))], [['dir', 'className', 'SearchResultListNotFound']])]);};

	/**Удаляет все найденные объекты из результатов поиска*/
	var unload = function(){
		for(i=0; i<arrDisplayedObjects.length; i++){
			SetDisplayedObjects(i, []);
		}
		$(oResultCanvas).empty();
	}
    /** Переход на следующие страницы*/
    var next = function(iDataSourceN, divChilds, divPages) {
        var button = makeImageButton(sImagesHost + '/next.png', sImagesHost + '/next_a.png');

        button.style.marginBottom = '-7px';

        button.onclick = function() {
			var oDataSource = arrTotalResultSet[iDataSourceN];
            oDataSource.start += iPagesCount;
            oDataSource.reportStart = oDataSource.start * iLimit;

            drawPagesRow(iDataSourceN, divChilds, divPages);
        }

        _title(button, _gtxt('Следующие [value0] страниц', iPagesCount));

        return button;
    }

    /** Переход на предыдущие страницы*/
    var previous = function(iDataSourceN, divChilds, divPages) {
        var button = makeImageButton(sImagesHost + '/prev.png', sImagesHost + '/prev_a.png');

        button.style.marginBottom = '-7px';

        button.onclick = function() {
			var oDataSource = arrTotalResultSet[iDataSourceN];
            oDataSource.start -= iPagesCount;
            oDataSource.reportStart = oDataSource.start * iLimit;

            drawPagesRow(iDataSourceN, divChilds, divPages);
        }

        _title(button, _gtxt('Предыдущие [value0] страниц', iPagesCount));

        return button;
    }

    /** Переход на первую страницу*/
    var first = function(iDataSourceN, divChilds, divPages) {
        var _this = this,
			button = makeImageButton(sImagesHost + '/first.png', sImagesHost + '/first_a.png');

        button.style.marginBottom = '-7px';

        button.onclick = function() {
			var oDataSource = arrTotalResultSet[iDataSourceN];
            oDataSource.start = 0;
            oDataSource.reportStart = oDataSource.start * iLimit;

            drawPagesRow(iDataSourceN, divChilds, divPages);
        }

        _title(button, _gtxt('Первая страница'));

        return button;
    }

    /** Переход на последнюю страницу*/
    var last = function(iDataSourceN, divChilds, divPages) {
        var _this = this,
			button = makeImageButton(sImagesHost + '/last.png', sImagesHost + '/last_a.png');

        button.style.marginBottom = '-7px';

        button.onclick = function() {
			var oDataSource = arrTotalResultSet[iDataSourceN];
            oDataSource.start = Math.floor((oDataSource.SearchResult.length - 1)/ (iPagesCount * iLimit)) * iPagesCount;
            oDataSource.reportStart = Math.floor((oDataSource.SearchResult.length - 1)/ (iLimit)) * iLimit;

            drawPagesRow(iDataSourceN, divChilds, divPages);
        }

        _title(button, _gtxt('Последняя страница'));

        return button;
    }

	/**Добавляет объект в список найденных результатов*/
	var drawObject = function(oFoundObject, elemDiv, bIsParent)
	{
		var	realPath = (oFoundObject.CountryCode != 28000 && oFoundObject.CountryCode != 310000183)  ? oFoundObject.ObjName : Functions.GetFullName(oFoundObject.TypeName, oFoundObject.ObjName);
		if (oFoundObject.Parent != null) realPath += ",";

		var searchElemHeader = _span([_t(realPath)], [['dir', 'className', bIsParent?'searchElemParent':'searchElem']]);

		/** Вызывается при клике на найденный объект в списке результатов поиска
		@name Search.ResultList.onObjectClick
		@event
		@param {object} oFoundObject Найденный объект*/
		searchElemHeader.onclick = function(){$(_this).triggerHandler('onObjectClick', [oFoundObject]);};

		_(elemDiv, [searchElemHeader]);
		if (oFoundObject.Parent != null) drawObject(oFoundObject.Parent, elemDiv, true);
		if (oFoundObject.properties != null) _(elemDiv, [document.createTextNode(" " + Functions.GetPropertiesString(oFoundObject.properties, "; "))]);
	}

	/** Рисует строки списка*/
	var drawRows = function(iDataSourceN, divChilds) {
		var arrObjects = arrDisplayedObjects[iDataSourceN];
		$(divChilds).empty();
		var tbody = _tbody();
		for (var i = 0; i < arrObjects.length; i++) {
			var elemTR = _tr(null, [['dir', 'className', 'SearchResultRow']]);
			var elemTD = _td(null, [['dir', 'className', 'SearchResultText']]);
			_(elemTR, [_td([_t((i+1).toString() + ".")], [['dir', 'className','searchElemPosition']]), elemTD]);
			drawObject(arrObjects[i], elemTD);

			// загрузка SHP Файла
			if (window.gmxGeoCodeShpDownload && arrObjects[i].Geometry != null) {
			    var shpFileLink = _span([_t(".shp")], [['dir', 'className', 'searchElem'], ['attr', 'title', 'скачать SHP-файл'], ['attr', 'number', i]]);

			    shpFileLink.onclick = function () {
			        var obj = arrObjects[$(this).attr('number')];
			        var objsToDownload = [obj];
			        $(_this).triggerHandler('onDownloadSHP', [obj.ObjCode, objsToDownload]);
			    };
			    _(elemTD, [_t(" ")]);
			    _(elemTD, [shpFileLink]);
			}

            elemTD.gmxDrawingObject = arrObjects[i];

            $(elemTD).draggable({
                scroll: false,
                appendTo: document.body,
                helper: 'clone',
                distance: 10
            });

			_(tbody, [elemTR]);
		}
		_(divChilds, [_table([tbody])]);

	}

	/**рисует номера страниц списка
	@param end - последний номер
	@param iDataSourceN - номер источника данных
	@param divChilds - раздел для элементов списка
	@param divPages - раздел для номеров страниц списка*/
	var drawPages = function(end, iDataSourceN, divChilds, divPages) {
		var oDataSource = arrTotalResultSet[iDataSourceN];
		for (var i = oDataSource.start + 1; i <= end; i++) {
			// текущий элемент
			if (i - 1 == oDataSource.reportStart / iLimit) {
				var el = _span([_t(i.toString())]);
				_(divPages, [el]);
				$(el).addClass('page');
			}
			else {
				var link = makeLinkButton(i.toString());

				link.setAttribute('page', i - 1);
				link.style.margin = '0px 2px';

				_(divPages, [link]);

				link.onclick = function() {
					arrTotalResultSet[iDataSourceN].reportStart = this.getAttribute('page') * iLimit;

					drawPagesRow(iDataSourceN, divChilds, divPages);
				};
			}

		}
	}

	/**Рисует одну из страниц списка
	@param iDataSourceN - номер источника данных
	@param divChilds - раздел для элементов списка
	@param divPages - раздел для номеров страниц списка*/
	var drawPagesRow = function(iDataSourceN, divChilds, divPages) {
		var oDataSource = arrTotalResultSet[iDataSourceN];

		// перерисовывем номера страниц
		$(divPages).empty();

		var end = (oDataSource.start + iPagesCount <= oDataSource.allPages) ? oDataSource.start + iPagesCount : oDataSource.allPages;

		if (oDataSource.start - iPagesCount >= 0)
			_(divPages, [first(iDataSourceN, divChilds, divPages), previous(iDataSourceN, divChilds, divPages)]);

		drawPages(end, iDataSourceN, divChilds, divPages);

		if (end + 1 <= oDataSource.allPages)
			_(divPages, [next(iDataSourceN, divChilds, divPages), last(iDataSourceN, divChilds, divPages)]);

		SetDisplayedObjects(iDataSourceN, oDataSource.SearchResult.slice(oDataSource.reportStart, oDataSource.reportStart + iLimit));
		drawRows(iDataSourceN, divChilds);
	}

	/**Рисует таблицу для результатов источника данных
	@param iDataSourceN - номер источника данных
	@param divChilds - раздел для элементов списка
	@param divPages - раздел для номеров страниц списка*/
	var drawTable = function(iDataSourceN, divChilds, divPages) {
		var oDataSource = arrTotalResultSet[iDataSourceN];

		if (oDataSource.SearchResult.length <= iLimit) {
			$(divPages).empty();
			SetDisplayedObjects(iDataSourceN, oDataSource.SearchResult);
			drawRows(iDataSourceN, divChilds);
		}
		else {
			oDataSource.allPages = Math.ceil(oDataSource.SearchResult.length / iLimit);

			drawPagesRow(iDataSourceN, divChilds, divPages);
		}
	}

	/**Обрабатывает событие нажатия на кнопку "Скачать SHP-файл"
	@param iDataSourceN - номер источника данных*/
	var downloadMarkers = function(iDataSourceN) {
		var oDataSource = arrTotalResultSet[iDataSourceN];
		var canvas = _div(),
			filename = _input(null, [['dir', 'className', 'filename'], ['attr', 'value', oDataSource.name]]);

		var downloadButton = makeButton(_gtxt("Скачать"));
		downloadButton.onclick = function() {
			if (filename.value == '') {
				inputError(filename, 2000);

				return;
			}

			/** Вызывается при необходимости осуществить загрузку SHP-файла с результатами поиска
			@name Search.ResultList.onDownloadSHP
			@event
			@param {string} filename Имя файла, которой необходимо будет сформировать
			@param {object[]} SearchResult Результаты поиска, которые необходимо сохранить в файл*/
			$(_this).triggerHandler('onDownloadSHP', [filename.value, oDataSource.SearchResult]);

			$(canvas.parentNode).dialog("destroy").remove();
		}

		_(canvas, [_div([_t(_gtxt("Введите имя файла для скачивания")), filename], [['dir', 'className', 'DownloadSHPButtonText']]), _div([downloadButton], [['dir', 'className', 'DownloadSHPButton']])]);

		var area = getOffsetRect(Container);
		showDialog(_gtxt("Скачать shp-файл"), canvas, 291, 120, 30, area.top + 10);
	}

	/**Отображает результаты поиска с источника данных
	@param iDataSourceN - номер источника данных*/
	var drawSearchResult = function(iDataSourceN) {
		var oDataSource = arrTotalResultSet[iDataSourceN];

		var arrDataSourceList = oDataSource.SearchResult;
		var header = oDataSource.name;

		var divChilds = _div(null, [['dir', 'className', 'SearchResultListChildsCanvas']]),
			divPages = _div(),
			liInner = _li([divChilds, divPages]),
			li;
		if (arrTotalResultSet.length == 1){
			li = _ul([liInner]);
		}
		else{
			li = _li([_div([_t(header), _span([_t("(" + arrDataSourceList.length + ")")])], [['dir', 'className', 'searchLayerHeader']]), _ul([liInner])]);
		}

		oDataSource.start = 0;
		oDataSource.reportStart = 0;
		oDataSource.allPages = 0;

		drawTable(iDataSourceN, divChilds, divPages);

		if (oDataSource.CanDownloadVectors) {
			var downloadVector = makeLinkButton(_gtxt("Скачать shp-файл"));

			downloadVector.onclick = function() {
				downloadMarkers(iDataSourceN);
			}

			liInner.insertBefore(_div([downloadVector], [['dir', 'className', 'SearchDownloadShpLink']]), liInner.firstChild);
		}

		return li;
	}

	/**Отображает результаты поиска в списке
	@param sTotalListName - заголовок итогового результата
	@param {Array.<Object>} arrTotalList. Массив объектов со следующими свойствами{name:DataSourceName, CanDownloadVectors:CanDownloadVectors, SearchResult:arrDataSourceList[oObjFound,...]}
	@returns {void}
	*/
	this.ShowResult = function(sTotalListName, arrTotalList){
		arrTotalResultSet = arrTotalList;
	    $(oResultCanvas).empty();
		arrDisplayedObjects = [];
		if (!objLength(arrTotalResultSet)) {
			fnNotFound();
			return;
		}
		else {
			var foundSomething = false;

			for (var i = 0; i < arrTotalResultSet.length; i++) {
				if (arrTotalResultSet[i].SearchResult.length > 0) {
					foundSomething = true;
					break;
				}
			}
			if (!foundSomething) {
				fnNotFound();
				return;
			}
		}

		var ulSearch = _ul();

		for (var iDataSourceN  = 0; iDataSourceN < arrTotalResultSet.length; iDataSourceN++)
			_(ulSearch, [drawSearchResult(iDataSourceN)]);

		if (arrTotalResultSet.length == 1){
			_(oResultCanvas, [ulSearch]);
		}
		else{
			_(oResultCanvas, [_li([_div([_t(sTotalListName)], [['dir', 'className', 'SearchTotalHeader']]), ulSearch])]);
		}

        if (typeof($.fn.treeview) === 'function') {
            $(oResultCanvas).treeview();
        }

		$(oResultCanvas).find(".SearchResultListChildsCanvas").each(function() {
			this.parentNode.style.padding = '0px';
			this.parentNode.style.background = 'none';
		})
	}


    /**Создается переключатель страниц
    @param results - набор результатов
    @param onclick - обработчик нажатия переключателя страниц
    @returns {void}*/
    this.CreatePager = function (results, onclick) {

        function makeNavigButton(pager, img, imga, id, title) {
            var b = makeImageButton(sImagesHost + img, sImagesHost + imga);
            b.style.marginBottom = '-7px';
            $(b).attr('id', id)
            _title(b, title);
            _(pager, [b]);
            return b;
        }

        containerList = Container;
        $('#respager').remove();
        //var pager = _div([_t('всего: ' + results[0].ResultsCount)], [["attr", "id", "respager"]]);
        var pager = _div([_t('')], [["attr", "id", "respager"]]);
        _(containerList, [pager]);

        var pcount = results[0].SearchResult[0] ? Math.ceil(results[0].SearchResult[0].OneOf / iLimit) : 0;
        if (pcount > 1) {
            var first = makeNavigButton(pager, '/first.png', '/first_a.png', 'firstpage', _gtxt('Первая страница'));
            $(first).bind('click', function () {
                fnShowPage(0);
            });
            var prev = makeNavigButton(pager, '/prev.png', '/prev_a.png', 'prevpages', _gtxt('Предыдущие [value0] страниц', iPagesCount));
            $(prev).bind('click', function () {
                fnShowPage(parseInt($('#page1').text()) - iPagesCount - 1);
            });
            $(first).hide();
            $(prev).hide();

            for (var i = 0; i < iPagesCount && i < pcount; ++i) {
                var pagelink = makeLinkButton(i + 1);
                $(pagelink).attr('id', 'page' + (i + 1));
                if (i == 0){
                    $(pagelink).attr('class', 'page')
                    attachEffects(pagelink, '');
                }
                $(pagelink).bind('click', onclick);
                _(pager, [pagelink, _t(' ')]);
            }

            var remains = pcount % iPagesCount;
            var nextPages = pcount/iPagesCount<2 ? remains : iPagesCount
            var nextButTitle = 'Следующие [value0] страниц';
            if (nextPages == 1)
                nextButTitle = 'Следующая страница';
            if (nextPages % 10 == 1 && nextPages != 1 && nextPages != 11)
                nextButTitle = 'Следующая [value0] страница';
            if (1 < nextPages % 10 && nextPages % 10 < 5 && (nextPages<10 || nextPages > 20))
                nextButTitle = 'Следующие [value0] страницы';
            var next = makeNavigButton(pager, '/next.png', '/next_a.png', 'nextpages', _gtxt(nextButTitle, nextPages));
            $(next).bind('click', function () {
                fnShowPage(parseInt($('#page' + iPagesCount).text()));
            });
            var last = makeNavigButton(pager, '/last.png', '/last_a.png', 'lastpage', _gtxt('Последняя страница'));
            $(last).bind('click', function () {
                var lastindex = (remains == 0 ? iPagesCount : remains)
                fnShowPage(pcount - lastindex, $('#page' + lastindex));
            });

            if (iPagesCount >= pcount) {
                $(next).hide();
                $(last).hide();
            }
        }

        var fnShowPage = function (n, active) {
            //alert(n + "\n" + pcount);
            for (var i = 0; i < iPagesCount; ++i) {//pcount
                if (i + n < pcount) {
                    $('#page' + (i + 1)).text(i + n + 1);
                    $('#page' + (i + 1)).show();
                }
                else
                    $('#page' + (i + 1)).hide();
            }

            if (n < iPagesCount) {
                $('#prevpages').hide(); $('#firstpage').hide();
            }
            else {
                $('#prevpages').show(); $('#firstpage').show();
            }

            if (n + iPagesCount < pcount) {
                $('#nextpages').show(); $('#lastpage').show();
                var rest = pcount - n - iPagesCount;
                var nextPages = rest < iPagesCount ? rest : iPagesCount
                var nextButTitle = 'Следующие [value0] страниц';
                if (nextPages == 1)
                    nextButTitle = 'Следующая страница';
                if (nextPages % 10 == 1 && nextPages != 1 && nextPages != 11)
                    nextButTitle = 'Следующая [value0] страница';
                if (1 < nextPages % 10 && nextPages % 10 < 5 && (nextPages < 10 || nextPages > 20))
                    nextButTitle = 'Следующие [value0] страницы';
                $('#nextpages').attr('title', _gtxt(nextButTitle, nextPages));
            }
            else {
                $('#nextpages').hide(); $('#lastpage').hide();
            }

            if (active == null) active = $('#prevpages~span')[0];
            $(active).trigger('click');
        }
    }
    /*----------------------------------------------------------*/

	/**Возвращает список объектов, которые отображаются на текущей странице во всех разделах*/
	this.GetDisplayedObjects = function(){return arrDisplayedObjects; };
	var SetDisplayedObjects = function(iDataSourceN, value) {
		arrDisplayedObjects[iDataSourceN] = value;

		/** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
		@name Search.ResultList.onDisplayedObjectsChanged
		@event
		@param {int} iDataSourceN № источника данных(группы результатов поиска)
		@param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/
		$(_this).triggerHandler('onDisplayedObjectsChanged',[iDataSourceN, arrDisplayedObjects[iDataSourceN]]);
	};

	/** Показывает режим загрузки
	@returns {void}*/
	this.ShowLoading = function(){
	    $('#respager').remove();
        $(oResultCanvas).empty();
		_(oResultCanvas, [oLoading]);
	}

	/**Показывает сообщение об ошибке
	@returns {void}*/
	this.ShowError = function(){
		$(oResultCanvas).empty();
		_(oResultCanvas, [_t("Произошла ошибка")]);
	}

	/**Очищает результаты поиска
	@returns {void}*/
	this.Unload = function(){unload();};
	/** Возвращает контрол, в котором находится данный контрол*/
	this.getContainer = function(){return Container;};
};

/** Конструктор
 @class Предоставляет функции, отображающие найденные объекты на карте
 @memberof Search
 @param {L.Map} map карта, на которой будут рисоваться объекты
 @param {string} sInitImagesHost - строка пути к картинкам
 @param {bool} bInitAutoCenter - если true, карта будет центрироваться по 1ому найденному объекту*/
var ResultRenderer = function(map, sInitImagesHost, bInitAutoCenter){
	if (map == null)  throw "ResultRenderer.Map is null";

	var sImagesHost = sInitImagesHost || "http://maps.kosmosnimki.ru/api/img";
	var bAutoCenter = (bInitAutoCenter == null) || bInitAutoCenter;

	var arrContainer = [];
	var counts = [];

	/** возвращает стили найденных объектов, используется только для точки*/
	var getSearchIcon = function(iPosition) {
        iPosition = Math.min(iPosition, 9);
        return L.icon({
            iconUrl: sImagesHost + "/search/search_" + (iPosition + 1).toString() + ".png",
            iconAnchor: [15, 38],
            popupAnchor: [0, -28]
        });

		// return [
						// { marker: { image: sImagesHost + "/search/search_" + (iPosition + 1).toString() + ".png", dx: -14, dy: -38} },
						// { marker: { image: sImagesHost + "/search/search_" + (iPosition + 1).toString() + "a.png", dx: -14, dy: -38} }
				// ];
	}

    var bindHoverPopup = function(layer, content) {
        layer.bindPopup(content);
    }

	/**Помещает объект на карту
	@param {MapObject} oContainer контейнер, содержащий в себе объекты текущей группы результатов поиска
	@param {MapObject} oFoundObject добавляемый объект
	@param {int} iPosition порядковый номер добавляемого объекта в группе
	@param {int} iCount общее количество объектов в группе
    @return {Object} Нарисованные на карте объекты: хеш с полями center и boundary */
	var DrawObject = function(oContainer, oFoundObject, iPosition, iCount){
        var color = Math.round(0x22 + 0x99*iPosition/iCount);
		var sDescr = "<b>" + Functions.GetFullName(oFoundObject.TypeName, oFoundObject.ObjName) + "</b><br/>" + Functions.GetPath(oFoundObject.Parent, "<br/>", true);
		if (oFoundObject.properties != null) sDescr += "<br/>" + Functions.GetPropertiesString(oFoundObject.properties, "<br/>");

        sDescr = sDescr.replace(/;/g, "<br/>");

		var fnBaloon = function(o) {
			return o.properties.Descr.replace(/;/g, "<br/>");
		};
		var centerMapElem,
            boundaryMapElem;
		//Рисуем центр объекта
		if (oFoundObject.Geometry != null && oFoundObject.Geometry.type == 'POINT') {
            centerMapElem = L.marker([oFoundObject.Geometry.coordinates[1], oFoundObject.Geometry.coordinates[0]], {
                icon: getSearchIcon(iPosition)
            });
            bindHoverPopup(centerMapElem, sDescr);
            oContainer.addLayer(centerMapElem);
		}
		else if (oFoundObject.CntrLon != null && oFoundObject.CntrLat != null){
            centerMapElem = L.marker([oFoundObject.CntrLat, oFoundObject.CntrLon], {
                icon: getSearchIcon(iPosition)
            });

            bindHoverPopup(centerMapElem, sDescr);
            oContainer.addLayer(centerMapElem);
		}


		//Рисуем контур объекта
		if (oFoundObject.Geometry != null && oFoundObject.Geometry.type != 'POINT') {
            boundaryMapElem = L.geoJson(L.gmxUtil.geometryToGeoJSON(oFoundObject.Geometry), {
                style: function(feature) {
                    return
                },
                onEachFeature: function(feature, layer) {
                    layer.setStyle({
                        color: '#' + (0x1000000 + (color << 16) + (color << 8) + color).toString(16).substr(-6),
                        weight: 3,
                        opacity: 0.6,
                        fill: false
                    });

                    bindHoverPopup(layer, sDescr)
                }
            });

            oContainer.addLayer(boundaryMapElem);
		}

        return {center: centerMapElem, boundary: boundaryMapElem};
	};

	/**Центрует карту по переданному объекту*/
	var CenterObject = function(oFoundObject){
		if (!oFoundObject) return;
		var iZoom = oFoundObject.TypeName == "г." ? 9 : 15;
        if (oFoundObject.Geometry == null) {
		    if (oFoundObject.MinLon != null && oFoundObject.MaxLon != null && oFoundObject.MinLat != null && oFoundObject.MaxLat != null
                && oFoundObject.MaxLon - oFoundObject.MinLon < 1e-9 && oFoundObject.MaxLat - oFoundObject.MinLat < 1e-9)
			    map.setView([oFoundObject.CntrLat, oFoundObject.CntrLon], iZoom);
		    else
			    map.fitBounds([[oFoundObject.MinLat, oFoundObject.MinLon], [oFoundObject.MaxLat, oFoundObject.MaxLon]]);
        }
		else
		{
           if (oFoundObject.Geometry.type == 'POINT') {
		        if (oFoundObject.MinLon != oFoundObject.MaxLon && oFoundObject.MinLat != oFoundObject.MaxLat) {
			        map.fitBounds([[oFoundObject.MinLat, oFoundObject.MinLon], [oFoundObject.MaxLat, oFoundObject.MaxLon]]);
                } else {
                    var c = oFoundObject.Geometry.coordinates;
			        map.setView([c[1], c[0]], iZoom);
                }
		    }
		    else {
                var bounds = L.gmxUtil.getGeometryBounds(oFoundObject.Geometry);
			    //var oExtent = getBounds(oFoundObject.Geometry.coordinates);
			    map.fitBounds([[bounds.min.y, bounds.min.x], [bounds.max.y, bounds.max.x]]);
            }
		}
	};

	/**Центрует карту по переданному объекту
	@param {MapObject} oFoundObject объект, который нужно поместить в центр
	@returns {void}*/
	this.CenterObject = function(oFoundObject){
		CenterObject(oFoundObject);
	}

	/** Рисует объекты на карте.
	@param {int} iDataSourceN № источника данных (группы результатов поиска)
	@param {Array} arrFoundObjects Массив объектов для отрисовки. Каждый объект имеет свойства
	@param {bool} [options.append=false] Добавить к существующим объектам для источника данных, а не удалять их
	@return {Array} Нарисованные на карте объекты: массив хешей с полями center и boundary
    */
	this.DrawObjects = function(iDataSourceN, arrFoundObjects, options){
        options = $.extend({append: false}, options);

        if (!options.append && arrContainer[iDataSourceN]) {
            map.removeLayer(arrContainer[iDataSourceN]);
            delete arrContainer[iDataSourceN];
        }

        if (!arrContainer[iDataSourceN]) {
            arrContainer[iDataSourceN] = L.layerGroup();
            counts[iDataSourceN] = 0;
        }

		iCount = arrFoundObjects.length;

        var mapObjects = [];

        counts[iDataSourceN] += arrFoundObjects.length;

		//Отрисовываем задом наперед, чтобы номер 1 был сверху от 10ого
		for (var i = arrFoundObjects.length - 1; i >= 0; i--){
			mapObjects.unshift(DrawObject(arrContainer[iDataSourceN], arrFoundObjects[i], counts[iDataSourceN] + i - arrFoundObjects.length, counts[iDataSourceN]));
		}

		arrContainer[iDataSourceN].addTo(map);
		if (bAutoCenter && iDataSourceN == 0) CenterObject(arrFoundObjects[0]);

        return mapObjects;
	}
};

/** Конструктор
 @class Предоставляет функции, отображающие найденные объекты на карте
 @memberof Search
 @param {object} oInitMap карта, на которой будут рисоваться объекты
 @param {function} fnSearchLocation = function({Geometry, callback})- функция поиска объектов по переданной геометрии*/
var LocationTitleRenderer = function(oInitMap, fnSearchLocation){
	var _this = this;
	var oMap = oInitMap;
	var dtLastSearch;

	/**Добавляет объект в список найденных результатов*/
	var drawObject = function(oFoundObject, elemDiv)
	{
		if (oFoundObject.Parent != null) drawObject(oFoundObject.Parent, elemDiv, true);
		var	realPath = oFoundObject.IsForeign ? oFoundObject.ObjName : Functions.GetFullName(oFoundObject.TypeName, oFoundObject.ObjName);

		var searchElemHeader = _span([_t(realPath)], [['dir', 'className', 'searchLocationPath']]);

		/** Вызывается при клике на найденный объект в списке результатов поиска
		@name Search.ResultList.onObjectClick
		@event
		@param {object} oFoundObject Найденный объект*/
		searchElemHeader.onclick = function(){$(_this).triggerHandler('onObjectClick', [oFoundObject]);};

		if (oFoundObject.Parent != null) _(elemDiv, [_t("->")]);
		_(elemDiv, [searchElemHeader]);
	}

	var setLocationTitleDiv = function(div, attr) {
		if (dtLastSearch && Number(new Date()) - dtLastSearch < 300) return;
		dtLastSearch = new Date();

		var locationTitleDiv = div;

		fnSearchLocation({Geometry: attr['screenGeometry'], callback: function(arrResultDataSources){
			$(locationTitleDiv).empty();
			if(arrResultDataSources.length>0 && arrResultDataSources[0].SearchResult.length>0){
				drawObject(arrResultDataSources[0].SearchResult[0], locationTitleDiv);
			}
			else{
				_(locationTitleDiv, [_t(_gtxt("Текущее местоположение отображается только для России и Украины"))]);
			}
		}});
	};

	if (oMap.coordinates) oMap.coordinates.addCoordinatesFormat(setLocationTitleDiv);
}

/** Возвращает контрол, отображающий результаты поиска в виде списка с нанесением на карту
 @memberof Search
 @param {object} oInitContainer Объект, в котором находится контрол результатов поиска в виде списка(div)
 @param {object} oInitMap карта, на которой будут рисоваться объекты
 @param {string} ImagesHost - строка пути к картинкам
 @param {bool} bInitAutoCenter - если true, карта будет центрироваться по 1ому найденному объекту
 @returns {Search.ResultListMap}*/
var ResultListMapGet = function(oInitContainer, oInitMap, sImagesHost, CustomResultList, bInitAutoCenter){
	var oRenderer = new ResultRenderer(oInitMap, sImagesHost, bInitAutoCenter),
        lstResult;

    if (typeof CustomResultList === 'function') {
        lstResult = new CustomResultList(oInitContainer, sImagesHost);
    } else {
        lstResult = new ResultList(oInitContainer, sImagesHost);
    }

	ResultListMap.call(this, lstResult, oRenderer);
}

ResultListMapGet.prototype = ResultListMap;

/** Конструктор
 @class Контрол, отображающий результаты поиска в виде списка с нанесением на карту
 @memberof Search
 @param lstResult Контрол результатов поиска в виде списка
 @param oRenderer Объект, предоставляющий функции отрисовки найденных объектов на карте*/
var ResultListMap = function(lstResult, oRenderer){
	var _this = this;

	var fnDisplayedObjectsChanged = function(event, iDataSourceN, arrFoundObjects){
		oRenderer.DrawObjects(iDataSourceN, arrFoundObjects);
		/** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
		@name Search.ResultListMap.onDisplayedObjectsChanged
		@event
		@param {int} iDataSourceN № источника данных(группы результатов поиска)
		@param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/
		$(_this).triggerHandler('onDisplayedObjectsChanged', [iDataSourceN, arrFoundObjects]);
	}

	var fnObjectClick = function(event, oFoundObject){
		oRenderer.CenterObject(oFoundObject);

		/** Вызывается при клике на найденный объект в списке результатов поиска
		@name Search.ResultListMap.onObjectClick
		@event
		@param {object} oFoundObject Найденный объект*/
		$(_this).triggerHandler('onObjectClick', [oFoundObject]);
	}

	var fnDownloadSHP = function(event, filename, arrObjectsToDownload){
		/** Вызывается при необходимости осуществить загрузку SHP-файла с результатами поиска
		@name Search.ResultListMap.onDownloadSHP
		@event
		@param {string} filename Имя файла, которой необходимо будет сформировать
		@param {object[]} SearchResult Результаты поиска, которые необходимо сохранить в файл*/
		$(_this).triggerHandler('onDownloadSHP', [filename, arrObjectsToDownload]);
	}

	$(lstResult).bind('onDisplayedObjectsChanged', fnDisplayedObjectsChanged);
	$(lstResult).bind('onObjectClick', fnObjectClick);
	$(lstResult).bind('onDownloadSHP', fnDownloadSHP);

	/**Отображает результаты поиска в списке
	@param sTotalListName - заголовок итогового результата
	@param {Array.<Object>} arrTotalList Массив объектов со следующими свойствами {name:DataSourceName, CanDownloadVectors:CanDownloadVectors, SearchResult:arrDataSourceList[oObjFound,...]}
	@returns {void}*/
	this.ShowResult = function(sTotalListName, arrTotalList){
		lstResult.ShowResult(sTotalListName, arrTotalList);
	}


    /**Создается переключатель страниц
    @param results - набор результатов
    @param onclick - обработчик нажатия переключателя страниц
    @returns {void}*/
    this.CreatePager = function (results, onclick) {
        lstResult.CreatePager(results, onclick);
    }

	/**Показывает режим загрузки
	@returns {void}*/
	this.ShowLoading = function(){
		lstResult.ShowLoading();
	}

	/**Показывает сообщение об ошибке
	@returns {void}*/
	this.ShowError = function(){
		lstResult.ShowError();
	}

	/**Центрует карту по переданному объекту
	@param {MapObject} oFoundObject объект, который нужно поместить в центр
	@returns {void}*/
	this.CenterObject = function(oFoundObject){
		oRenderer.CenterObject(oFoundObject);
	}

	/**Очищает результаты поиска
	@returns {void}*/
	this.Unload = function(){lstResult.Unload();};
	/** Возвращает контейнер, содержащий список найденных объектов*/
	this.getContainerList = function(){return lstResult.getContainer();};
}

/**Конструктор
 @class SearchDataProvider Посылает запрос к поисковому серверу
 @memberof Search
 @param {string} sInitServerBase Адрес сервера, на котором установлен поисковый модуль Geomixer'а
 @param {L.gmxMap} gmxMap карта, содержащая слои, по которым должен производиться поиск
 @param {string[]} arrDisplayFields список атрибутов векторных слоев, которые будут отображаться в результатах поиска*/
var SearchDataProvider = function(sInitServerBase, gmxMap, arrDisplayFields){
	var sServerBase = sInitServerBase;
	if (sServerBase == null || sServerBase.length < 7) {throw "Error in SearchDataProvider: sServerBase is not supplied"};
	// var oMap = oInitMap;
	var iDefaultLimit = 100;
	var _this = this;
	/**Осуществляет поиск по произвольным параметрам
	@param {object} params Параметры: </br>
		<i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
		<i>SearchString</i> - строка для поиска </br>
		<i>IsStrongSearch</i> - признак того, что искать только целые слова </br>
		<i>Geometry</i> - искать только объекты, пересекающие данную геометрию </br>
		<i>Limit</i> - максимальное число найденных объектов
		<i>WithoutGeometry<i> - не передавать геометрию в результатах поиска
		<i>RequestType<i> - Тип запроса к серверу
        <i>PageNum<i> - Показать страницу
        <i>ShowTotal<i> - Сообщить сколько найдено всего записей
        <i>UseOSM<i> - Искать в базе OSM
	@returns {void}*/
	var fnSearch = function(params)	{
		var callback = params.callback;
		var sQueryString = "RequestType=" + encodeURIComponent(params.RequestType);
		if (params.SearchString != null) sQueryString += "&SearchString=" + encodeURIComponent(params.SearchString);
		if (params.Geometry != null) sQueryString += "&GeometryJSON=" + encodeURIComponent(JSON.stringify(params.Geometry));
		if (params.Limit != null) sQueryString += "&Limit=" + encodeURIComponent(params.Limit.toString());
		if (params.ID != null) sQueryString += "&ID=" + encodeURIComponent(params.ID.toString());
		if (params.TypeCode != null) sQueryString += "&TypeCode=" + encodeURIComponent(params.TypeCode.toString());
		if (params.IsStrongSearch != null) sQueryString += "&IsStrongSearch=" + encodeURIComponent(params.IsStrongSearch ? "1" : "0");
		if (params.WithoutGeometry != null) sQueryString += "&WithoutGeometry=" + encodeURIComponent(params.WithoutGeometry ? "1" : "0");
		if (params.PageNum != null) sQueryString += "&PageNum=" + params.PageNum;
		if (params.ShowTotal != null) sQueryString += "&ShowTotal=" + params.ShowTotal;
		if (params.UseOSM != null) sQueryString += "&UseOSM=" + params.UseOSM;
		//if (sFormatName != null) sQueryString += "&Format=" + encodeURIComponent(sFormatName);

		var key = window.KOSMOSNIMKI_SESSION_KEY;
		if (key == null || key == "INVALID")
			key = false;
		sendCrossDomainJSONRequest(sServerBase + "SearchObject/SearchAddress.ashx?" + sQueryString + (key ? ("&key=" + encodeURIComponent(key)) : ""), function (response) {
			if (response.Status == 'ok') {callback(response.Result);}
			else {throw response.ErrorInfo.ErrorMessage;}
		});
	};

	/**Осуществляет поиск по переданной строке
	@param {object} params Параметры: </br>
		<i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
		<i>SearchString</i> - строка для поиска </br>
		<i>IsStrongSearch</i> - признак того, что искать только целые слова </br>
		<i>Limit</i> - максимальное число найденных объектов
		<i>WithoutGeometry<i> - не передавать геометрию в результатах поиска
        <i>PageNum<i> - Показать страницу
        <i>ShowTotal<i> - Сообщить сколько найдено всего записей
        <i>UseOSM<i> - Искать в базе OSM
	@returns {void}*/
	this.SearchByString = function(params){
	    fnSearch({ callback: params.callback, SearchString: params.SearchString, IsStrongSearch: params.IsStrongSearch, Limit: params.Limit, WithoutGeometry: params.WithoutGeometry, RequestType: "SearchObject",
        PageNum: params.PageNum, ShowTotal: params.ShowTotal, UseOSM: params.UseOSM });
	};

	/**Получает информацию об объекте
	@param {object} params Параметры: </br>
		<i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
		<i>ID</i> - идентификатор объекта </br>
	@returns {void}*/
	this.SearchID = function(params){
		fnSearch({callback: params.callback, ID: params.ID, RequestType: "ID", TypeCode: params.TypeCode, UseOSM: params.UseOSM});
	}

	/**Осуществляет поиск текущего местонахождения
	@param {object} params Параметры: </br>
		<i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
		<i>Geometry</i> - искать только объекты, пересекающие данную геометрию </br>
	@returns {void}*/
	this.SearchLocation = function(params){
		fnSearch({callback: params.callback, Geometry: params.Geometry, WithoutGeometry: true, RequestType: "Location"});
	}

    /**Осуществляет поиск ближайшего объекта к центру указанной области
    @param {object} params Параметры: </br>
    <i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
    <i>Geometry</i> - искать только объекты, пересекающие данную геометрию </br>
    @returns {void}*/
    this.SearchNearest = function (params) {
        fnSearch({ callback: params.callback, Geometry: params.Geometry, WithoutGeometry: true, RequestType: "Nearest" });
    }

	/**Осуществляет поиск по произвольным параметрам
	@param {object} params Параметры: </br>
		<i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
		<i>SearchString</i> - строка для поиска </br>
		<i>IsStrongSearch</i> - признак того, что искать только целые слова </br>
		<i>Geometry</i> - искать только объекты, пересекающие данную геометрию </br>
		<i>Limit</i> - максимальное число найденных объектов
		<i>WithoutGeometry<i> - не передавать геометрию в результатах поиска
	@returns {void}*/
	this.Search = function(params){
		fnSearch({
			callback: params.callback,
			SearchString: params.SearchString,
			IsStrongSearch: params.IsStrongSearch,
			Limit: params.Limit == null ? iDefaultLimit : params.Limit,
			Geometry: params.Geometry,
			WithoutGeometry: params.WithoutGeometry,
			RequestType: "SearchObject"
		});
	};

	/**Осуществляет поиск по векторным слоям
	@returns {void}*/
	this.LayerSearch = function(sInitSearchString, oInitGeometry, callback){
		if (!gmxMap){
			callback([]);
			return;
		}
		var arrResult = [];

		var layersToSearch = [];
		for (var i=0; i< gmxMap.layers.length; i++) {
            //свойства мы берём из дерева слоёв, а не из API. Cвойство AllowSearch относится к карте и не поддерживаются API
            var searchRes = _layersTree.treeModel.findElem('name', gmxMap.layers[i].getGmxProperties().name);

            if (searchRes) {
                var props = searchRes.elem.content.properties;

                if (props.type == "Vector" && props.AllowSearch) {
                    layersToSearch.push(props);
                }
            }
        }
		var iRespCount = 0;

		if (layersToSearch.length > 0){
            layersToSearch.forEach(function(props) {
                var mapName = gmxMap.layersByID[props.name].options.mapID;
                var url = "http://" + props.hostName + "/SearchObject/SearchVector.ashx" +
                    "?LayerNames=" + props.name +
                    "&MapName=" + mapName +
                    (sInitSearchString ? ("&SearchString=" + encodeURIComponent(sInitSearchString)) : "") +
                    (oInitGeometry ? ("&border=" + encodeURIComponent(JSON.stringify(L.gmxUtil.convertGeometry(oInitGeometry)))) : "");
                sendCrossDomainJSONRequest(
                    url,
                    function(searchReq)
                    {
                        iRespCount++;
                        var arrLayerResult = [];
                        if (searchReq.Status == 'ok')
                        {
                            for (var iServer = 0; iServer < searchReq.Result.length; iServer++)
                            {
                                var limitSearchResults = typeof(LayerSearchLimit)=="number" ? LayerSearchLimit : 100;
                                var req = searchReq.Result[iServer];
                                for (var j = 0; j<limitSearchResults && j < req.SearchResult.length; j++)
                                {
                                    var arrDisplayProperties = {};
                                    if (!arrDisplayFields) {
                                        arrDisplayProperties = req.SearchResult[j].properties;
                                    }
                                    else {
                                        for (var iProperty=0; iProperty<arrDisplayFields.length; iProperty++){
                                            var sPropName = arrDisplayFields[iProperty];
                                            if(sPropName in req.SearchResult[j].properties) {
                                                arrDisplayProperties[sPropName] = req.SearchResult[j].properties[sPropName];
                                            }
                                        }
                                    }

                                    for (var p in arrDisplayProperties) {
                                        var type = props.attrTypes[props.attributes.indexOf(p)];
                                        arrDisplayProperties[p] = nsGmx.Utils.convertFromServer(type, arrDisplayProperties[p]);
                                    }

                                    arrLayerResult.push({
                                        ObjName: req.SearchResult[j].properties.NAME || req.SearchResult[j].properties.Name || req.SearchResult[j].properties.name || req.SearchResult[j].properties.text || req.SearchResult[j].properties["Название"] || "[объект]",
                                        properties: arrDisplayProperties,
                                        Geometry: L.gmxUtil.convertGeometry(req.SearchResult[j].geometry, true)
                                    });
                                }
                            }
                        }
                        if(arrLayerResult.length > 0) arrResult.push({name: props.title, SearchResult: arrLayerResult, CanDownloadVectors: true});

                        if (iRespCount == layersToSearch.length){
                            callback(arrResult);
                            return;
                        }
                    }
                );
            })
		}
		else{
			callback(arrResult);
		}
	}

	/**Возвращает адрес сервера, на котором установлен поисковый модуль Geomixer'а*/
	this.GetServerBase = function(){
		return sServerBase;
	}
}

/**Возращает класс, который предоставляет функции обработки найденных данных
 @memberof Search
 @param {string} ServerBase Адрес сервера, на котором установлен поисковый модуль Geomixer'а
 @param {L.gmxMap} gmxMap карта с векторными слоями для поиска
 @param {bool} WithoutGeometry - по умолчанию не передавать геометрию в результатах поиска
 @param {object} [params] дополнительные параметры
 @param {object} [params.UseOSM] использовать ли геокодер OSM
 @returns {Search.SearchLogic}*/
var SearchLogicGet = function(ServerBase, gmxMap, WithoutGeometry, params){
    SearchLogic.call(this, new SearchDataProvider(ServerBase, gmxMap), WithoutGeometry, params);
}

SearchLogicGet.prototype = SearchLogic;

/**Конструктор
 @class Предоставляет функции обработки найденных данных
 @memberof Search
 @param {object} oInitSearchDataProvider источник данных для обработки
 @param {bool} WithoutGeometry - по умолчанию не передавать геометрию в результатах поиска
 @param {Object} [params] - дополнительные параметры
 @param {Object} [params.UseOSM] - Искать ли в базе OSM
*/
var SearchLogic = function(oInitSearchDataProvider, WithoutGeometry, params){
    var oSearchDataProvider = oInitSearchDataProvider;
    var iLimitAutoComplete = typeof (AutoCompleteLimit) == "number" ? AutoCompleteLimit : 10; //Максимальное количество результатов
	var _this = this;
	if(oSearchDataProvider == null) throw "Error in SearchLogic: oSearchDataProvider is not supplied";

    var useOSMDefault = 0;
    if (GLOBAL_USE_OSM) {
        useOSMDefault = GLOBAL_USE_OSM;
    } else  if (typeof gmxGeoCodeUseOSM !== 'undefined') {
        useOSMDefault = Number(gmxGeoCodeUseOSM);
    } else if (params && 'UseOSM' in params) {
        useOSMDefault = Number(params.UseOSM);
    }

	/** Возращает полный путь к объекту для отображения в подсказке
	@param oFoundObject Найденный объект
	@param sObjNameField название свойства, из которого брать наименование
	@param sObjNameField название свойства, из которого брать наименование родительского объекта
	*/
	var fnGetLabel = function(oFoundObject, sObjNameField, sObjNameFieldParent){
		var sLabel = Functions.GetFullName(oFoundObject.TypeName, oFoundObject[sObjNameField]);
		if (oFoundObject.Parent != null) sLabel += ", " + Functions.GetPath(oFoundObject.Parent, ", ", true, sObjNameFieldParent);
		if (oFoundObject.Parent == null && oFoundObject.Path != null) {
		    for (var i = oFoundObject.Path.length-2; i >=0; --i)
		        sLabel += (i<oFoundObject.Path.length-1?", ":"") + Functions.GetFullName(oFoundObject.Path[i][0], oFoundObject.Path[i][1])
        }
		return sLabel;
	}

    /** Cинхронное последовательное обращение к наблюдателям
        @param queue {Array} очередь наблюдателей
    */
    var deferredsChain = function(queue, params){
        var deferred = $.Deferred(),
        promise = $.when(deferred);
        if(queue.length>0){
            queue[0](1, deferred, params);
            for (var i=1; i<queue.length; ++i) {
                promise = promise.then(function(current) {
                    if (current<0) return current;
                    var d = $.Deferred();
                    queue[current](current+1, d, params);
                    return d;
                });
            }
        }
        else{
            deferred.resolve(0);
        }
        return promise;
    }

    /** Очередь наблюдателей за началом обработки запроса для подсказки
    */
    var AutoCompleteDataSearchStarting = [];

    /** Событие в начале обработки запроса для подсказки  (перед обращением к геокдеру)
        @param {{add:bool, remove:bool, observer:function(next, deferred, params)}}
        observer возвращает $.Deferred() для асинхронной последовательной обработки, $.Deferred().resolve(next)
        для перехода к очередному наблюдателю или $.Deferred().resolve(-1) для остановки всей обработки
    */
    this.AutoCompleteDataSearchStarting = function(params){
        for (var i = 0; i < AutoCompleteDataSearchStarting.length; i++)
            if(AutoCompleteDataSearchStarting[i] === params.observer)
                if(params.remove){
                    //console.log("remove observer");
                    AutoCompleteDataSearchStarting.splice(i, 1);
                }
                else
                    return;
        if(params.add){
            //console.log("add observer");
            AutoCompleteDataSearchStarting.push(params.observer);
        }
    }

	/**Возращает сгуппированные данные для отображения подсказок поиска в функции callback
	    @param {String} SearchString строка, по которой надо выдать подсказку
	    @param {function(arrResult)} callback вызывается когда подсказка готова
    */
	this.AutoCompleteData = function (SearchString, callback){
            deferredsChain(AutoCompleteDataSearchStarting, {searchString:SearchString, callback:callback}).done(function(fin){
            //console.log('finally ' + fin);
            if (fin!=-1)
	            _this.SearchByString({
                    SearchString: SearchString,
                    IsStrongSearch: 0,
                    Limit: iLimitAutoComplete,
                    WithoutGeometry: 1,
	                UseOSM: useOSMDefault,
                callback: function(arrResultDataSources){
			        var arrResult = [];
			        var sSearchRegExp = new RegExp("("+SearchString.replace(/^\s|\s$/, "").replace(/[^\wа-яА-Я]+/g, "|")+")", "i");
			        for(var iDS=0; iDS<arrResultDataSources.length; iDS++){
				        for(var iFoundObject=0; iFoundObject<arrResultDataSources[iDS].SearchResult.length; iFoundObject++){
					        var oFoundObject = arrResultDataSources[iDS].SearchResult[iFoundObject];
						var nameProp = oFoundObject.ObjNameShort.search(/[a-zA-Zа-яА-Я]/)<0?"ObjName":"ObjNameShort";
					        var sLabel = fnGetLabel(oFoundObject, nameProp, nameProp), sValue = Functions.GetFullName(oFoundObject.TypeName, oFoundObject[nameProp]);
					        //var sLabel = fnGetLabel(oFoundObject, "ObjName", "ObjName"), sValue = Functions.GetFullName(oFoundObject.TypeName, oFoundObject.ObjName);
					        if(/[a-zA-Z]/.test(SearchString)){
                                if(oFoundObject.ObjAltNameEng || oFoundObject.ObjNameEng){
						            if(oFoundObject.ObjAltNameEng && oFoundObject.ObjAltNameEng.match(sSearchRegExp)){
							            sLabel = fnGetLabel(oFoundObject, "ObjAltNameEng", "ObjNameEng");
							            sValue = sLabel;
							            //if (oFoundObject.ObjAltName && !/[a-zA-Z]/.test(oFoundObject.ObjName)) sLabel += ' | ' + fnGetLabel(oFoundObject, "ObjAltName", "ObjName");
						            }
						            else{
							            sLabel = fnGetLabel(oFoundObject, "ObjNameEng", "ObjNameEng");
							            sValue = sLabel;
							            //if (oFoundObject.ObjName && !/[a-zA-Z]/.test(oFoundObject.ObjName)) sLabel += ' | ' + fnGetLabel(oFoundObject, "ObjName", "ObjName");
						            }
						        }
					        }
					        else{
						        if(oFoundObject.ObjAltName && oFoundObject.ObjAltName.match(sSearchRegExp)){
							        sLabel = fnGetLabel(oFoundObject, "ObjAltName", "ObjName");
							        sValue = sLabel;
							        //if (oFoundObject.ObjAltNameEng) sLabel += ' | ' + fnGetLabel(oFoundObject, "ObjAltNameEng", "ObjNameEng");
						        }
						        else{
							        sLabel = fnGetLabel(oFoundObject, nameProp, nameProp);
							        //sLabel = fnGetLabel(oFoundObject, "ObjName", "ObjName");
							        sValue = sLabel;
							        //if (oFoundObject.ObjNameEng) sLabel += ' | ' + fnGetLabel(oFoundObject, "ObjNameEng", "ObjNameEng");
						        }
					        }
					        arrResult.push({
						        label: sLabel,
						        value: sValue,
						        GeoObject: oFoundObject});
				        }
				        if(arrResult.length>0) break;
			        }
			        callback(arrResult);
		        }
            });
        });
	}

	/** Группирует по категории
	@param {Array} arrInitDataSources Массив ответов от поисковых серверов
	@returns {Array} Массив сгруппированых по категориям данных*/
	this.GroupByCategory = function(arrInitDataSources)	{
		var arrResultDataSources = [];
		for(var i=0; i<arrInitDataSources.length; i++){
			arrResultDataSources[i] = {	name: arrInitDataSources[i].name,
										CanDownloadVectors: arrInitDataSources[i].CanDownloadVectors,
										SearchResult: []};
			var oDataSource = arrInitDataSources[i].SearchResult;
			var Categories = arrResultDataSources[i].SearchResult;
			var CategoriesIndex = {};
			for(var j=0; j<oDataSource.length; j++){
				var sCategory = "";
				var sCategoryDesc = "";
				var iPriority = 9999999;
				var iCatID = 0;
				if(oDataSource[j].Parent != null)
				{
					iCatID = oDataSource[j].Parent.ObjCode;
					sCategory = Functions.GetPath(oDataSource[j].Parent, ", ", false);
					sCategoryDesc = Functions.GetPath(oDataSource[j].Parent, ", ", true);
					iPriority = oDataSource[j].Parent.Priority;
				}
				if(CategoriesIndex[iCatID]==null) {
					CategoriesIndex[iCatID] = Categories.push({Name: sCategory, Priority: iPriority, GeoObjects: []}) - 1;
				}
				Categories[CategoriesIndex[iCatID]].GeoObjects.push(oDataSource[j]);
			}
			for(var j in Categories){
				if(Categories[j].GeoObjects.length == 1 && Categories[j].Name != ""){
					if(CategoriesIndex["0"]==null) {
						CategoriesIndex["0"] = Categories.push({Name: "", Priority: 9999999, GeoObjects: []})-1;
					}
					Categories[CategoriesIndex["0"]].GeoObjects.push(Categories[j].GeoObjects[0]);
					Categories[j] = null;
				}
			}
			Categories.sort(function(a, b){
				if (a == null || b == null) return 0;
				if (a.Priority < b.Priority)
					return 1;
				if (a.Priority > b.Priority)
					return -1;
				if (a.Name > b.Name)
					return 1;
				if (a.Name < b.Name)
					return -1;
				return 0;
			});
		}
		return arrResultDataSources;
	}

	/**Осуществляет поиск по переданной строке
	@param {object} params Параметры: </br>
		<i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
		<i>layersSearchFlag</i> - признак необходимости искать по векторным слоям </br>
		<i>SearchString</i> - строка для поиска </br>
		<i>IsStrongSearch</i> - признак того, что искать только целые слова </br>
		<i>Limit</i> - максимальное число найденных объектов
		<i>WithoutGeometry<i> - не передавать геометрию в результатах поиска
		<i>RequestType<i> - Тип запроса к серверу
        <i>PageNum<i> - Показать страницу
        <i>ShowTotal<i> - Сообщить сколько найдено всего записей
        <i>UseOSM<i> - Искать в базе OSM
	@returns {void}*/
	this.SearchByString = function(params){
	    oSearchDataProvider.SearchByString({
            SearchString: params.SearchString,
            IsStrongSearch: params.IsStrongSearch,
            Limit: params.Limit,
            WithoutGeometry: params.WithoutGeometry || WithoutGeometry,
            PageNum: params.PageNum,
            ShowTotal: params.ShowTotal,
            UseOSM: 'UseOSM' in params ? params.UseOSM : useOSMDefault,
			layersSearchFlag: params.layersSearchFlag,
			callback: function(response) {
				for(var i=0; i<response.length; i++)	response[i].CanDownloadVectors = false;
				if (params.layersSearchFlag){
					var arrLayerSearchResult = oSearchDataProvider.LayerSearch(params.SearchString, null, function(arrLayerSearchResult){
						params.callback(response.concat(arrLayerSearchResult));
					});
				}
				else {
					params.callback(response);
				}
			}
		});
	};

	/**Получает информацию об объекте
	@param {object} params Параметры: </br>
		<i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
		<i>ID</i> - идентификатор объекта </br>
	@returns {void}*/
	this.SearchID = function(params){
		oSearchDataProvider.SearchID({
            callback: params.callback,
            ID: params.ID,
            TypeCode: params.TypeCode,
            UseOSM: 'UseOSM' in params ? params.UseOSM : useOSMDefault
        });
	}

	/**Осуществляет поиск текущего местонахождения
	@param {object} params Параметры: </br>
		<i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
		<i>Geometry</i> - искать только объекты, пересекающие данную геометрию </br>
	@returns {void}*/
	this.SearchLocation = function(params){
		oSearchDataProvider.SearchLocation({callback: params.callback, Geometry: params.Geometry});
	}

    /**Осуществляет поиск ближайшего объекта к центру указанной области
    @param {object} params Параметры: </br>
    <i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
    <i>Geometry</i> - область </br>
    @returns {void}*/
    this.SearchNearest = function (params) {
        oSearchDataProvider.SearchNearest({ callback: params.callback, Geometry: params.Geometry });
    }

	/**Осуществляет поиск по произвольным параметрам
	@param {object} params Параметры: </br>
		<i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
		<i>SearchString</i> - строка для поиска </br>
		<i>IsStrongSearch</i> - признак того, что искать только целые слова </br>
		<i>Geometry</i> - искать только объекты, пересекающие данную геометрию </br>
		<i>Limit</i> - максимальное число найденных объектов
		<i>WithoutGeometry<i> - не передавать геометрию в результатах поиска
		<i>RequestType<i> - Тип запроса к серверу
	@returns {void}*/
	this.Search = function(params){
		oSearchDataProvider.Search({
			callback: params.callback,
			SearchString: params.SearchString,
			IsStrongSearch: params.IsStrongSearch,
			Limit: params.Limit == null ? iDefaultLimit : params.Limit,
			Geometry: params.Geometry,
			WithoutGeometry: params.WithoutGeometry
		});
	};

	/** Возвращает адрес сервера, на котором установлен поисковый модуль Geomixer'а */
	this.GetServerBase = function(){
		return oSearchDataProvider.GetServerBase();
	}
}

/** Возвращает контрол, содержащий все все компоненты поиска и обеспечивающий их взаимодействие между собой
* @memberof Search
* @param {object} params Параметры:
*
*  * ServerBase - Адрес сервера, на котором установлен поисковый модуль Geomixer'а
*  * ImagesHost - строка пути к картинкам
*  * ContainerInput - Объект, в котором находится контрол поискового поля (div)
*  * layersSearchFlag - Признак видимости кнопки поиска по векторным слоям
*  * ContainerList - Объект, в котором находится контрол результатов поиска в виде списка(div)
*  * Map - карта, на которой будут рисоваться объекты
*  * gmxMap - карта с векторными слоями
*  * WithoutGeometry - не передавать геометрию в результатах поиска
*
* @returns {Search.SearchControl}
*/
var SearchControlGet = function (params){
    var map = params.Map;
	var oLogic = new SearchLogicGet(params.ServerBase, params.gmxMap, params.WithoutGeometry);
	var fnAutoCompleteSource = function (request, response) {
		oLogic.AutoCompleteData(request.term, response);
	}
	/**Результаты поиска*/
	var lstResult = new ResultListMapGet(params.ContainerList, map, params.ImagesHost, params.ResultList);
	/**Строка ввода поискового запроса*/
	var btnSearch = new SearchInput(params.ContainerInput, {
		ImagesHost: params.ImagesHost,
		layersSearchFlag: params.layersSearchFlag,
		AutoCompleteSource: fnAutoCompleteSource
	});
    var oLocationTitleRenderer = new LocationTitleRenderer(map, typeof (gmxGeoCodeShowNearest) != "undefined" && gmxGeoCodeShowNearest ? oLogic.SearchNearest:oLogic.SearchLocation);
	SearchControl.call(this, btnSearch, lstResult, oLogic, oLocationTitleRenderer);

    this.addSearchByStringHook(function(searchString) {
        var pos = L.gmxUtil.parseCoordinates(searchString);
        if (pos) {
            map.panTo(pos);

            // Добавим иконку по умолчанию
            // L.Icon.Default.imagePath = 'leaflet/images';
            map.gmxDrawing.add(L.marker(pos, { draggable: true, title: searchString }));

            // Либо задать свою иконку
            // map.gmxDrawing.add(L.marker(pos, {
                // draggable: true, title: searchString,
                // icon: L.icon({ iconUrl: 'img/flag_blau1.png', iconAnchor: [6, 36] })
            // }));

            //map.moveTo(pos[0], pos[1], map.getZ());
            //map.drawing.addObject({ type: "POINT", coordinates: pos }, { text: searchString });
            return true;
        }
    })
}
SearchControlGet.prototype = SearchControl;

/** Конструктор
 @class Контрол, содержащий все все компоненты поиска и обеспечивающий их взаимодействие между собой
 @memberof Search
 @param oInitInput Текстовое поле ввода
 @param oInitResultListMap Отображение результатов поиска
 @param oInitLogic Слой бизнес-логики
 @param oInitLocationTitleRenderer Отображение на карте текущего местоположения
*/
var SearchControl = function(oInitInput, oInitResultListMap, oInitLogic, oInitLocationTitleRenderer){
	var _this = this;

	var oLogic = oInitLogic;
	/**Результаты поиска*/
	var lstResult = oInitResultListMap;
	/**Строка ввода поискового запроса*/
	var btnSearch = oInitInput;
    /**Максимальное количество результатов на странице*/
	var iLimit = typeof (GeocodePageResults) == "number" ? GeocodePageResults : 10;

	var oLocationTitleRenderer = oInitLocationTitleRenderer;

    var searchByStringHooks = [];

	/**Осуществляет загрузку SHP-файла*/
	var fnDownloadSHP = function(event, filename, arrObjectsToDownload){
        var features = arrObjectsToDownload.map(function(obj) {
            return {
                type: 'Feature',
                geometry: L.gmxUtil.geometryToGeoJSON(obj.Geometry),
                properties: {title: '' + obj.Path}
            }
        });

        nsGmx.Utils.downloadGeometry(features, {FileName: filename});
	};

	var fnBeforeSearch = function(){
		/** Генерируется перед началом поиска
		@name Search.SearchControl.onBeforeSearch
		@event*/
		$(_this).triggerHandler('onBeforeSearch');
	}

	var fnAfterSearch = function(){
		/** Генерируется после окончания поиска
		@name Search.SearchControl.onAfterSearch
		@event*/
		$(_this).triggerHandler('onAfterSearch');
	}

	/**Осуществляет поиск*/
	var fnSearchByString = function(event, SearchString, layersSearchFlag)
	{
		try{
            for (var h = 0; h < searchByStringHooks.length; h++) {
                if (searchByStringHooks[h].hook(SearchString)) {
                    return;
                }
            }
			fnBeforeSearch();
            lstResult.ShowLoading();
            oLogic.SearchByString({ SearchString: SearchString, IsStrongSearch: true, layersSearchFlag: layersSearchFlag, Limit: iLimit, PageNum: 0, ShowTotal: 1,
            callback: function (response) {
                lstResult.ShowResult(SearchString, response);
                lstResult.CreatePager(response, function (e) {
                    var evt = e || window.event,
                    active = evt.srcElement || evt.target
                    oLogic.SearchByString({ SearchString: SearchString, IsStrongSearch: true, Limit: iLimit, PageNum: parseInt($(this).text()) - 1, ShowTotal: 0,
                        callback: function (response) {
                            lstResult.ShowResult(SearchString, response);
                            $('#prevpages~span:visible').attr('class', 'buttonLink');
                            for (var i=0; i<$('#prevpages~span:visible').length; ++i) attachEffects($('#prevpages~span:visible')[i], 'buttonLinkHover');
                            $(active).attr('class', 'page');
                            attachEffects(active, '');
							fnAfterSearch();
                        }
                    });
                });
                fnAfterSearch();
            }});
		}
		catch (e){
			lstResult.ShowError(e);
		}
	}

	/**Осуществляет выбор объекта из подсказки*/
	var fnSelect = function(event, oAutoCompleteItem){
        if(oAutoCompleteItem.GeoObject==null)
            return;
	    if (fnBeforeSearch != null) fnBeforeSearch();
	    $('#respager').remove();
	    oLogic.SearchID({ID: oAutoCompleteItem.GeoObject.ObjCode, RequestType: "ID", TypeCode: oAutoCompleteItem.GeoObject.TypeCode,
                            callback: function (response) {
                                lstResult.ShowResult(oAutoCompleteItem.label, [{ name: "Выбрано", SearchResult: response[0].SearchResult}]);
                        }
                        });
		if (fnAfterSearch != null) fnAfterSearch();
	}


	var onDisplayedObjectsChanged = function(event, iDataSourceN, arrFoundObjects){
		/** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
		@name Search.SearchControl.onDisplayedObjectsChanged
		@event
		@param {int} iDataSourceN № источника данных(группы результатов поиска)
		@param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/
		$(_this).triggerHandler('onDisplayedObjectsChanged', [iDataSourceN, arrFoundObjects]);
	}

	var onObjectClick = function(event, oFoundObject){
		/** Вызывается при клике на найденный объект в списке результатов поиска
		@name Search.SearchControl.onObjectClick
		@event
		@param {object} oFoundObject Найденный объект*/
		$(_this).triggerHandler('onObjectClick', [oFoundObject]);
	}

	$(lstResult).bind('onDisplayedObjectsChanged', onDisplayedObjectsChanged);
	$(lstResult).bind('onObjectClick', onObjectClick);
	$(lstResult).bind('onDownloadSHP', fnDownloadSHP);
	$(btnSearch).bind('Search', fnSearchByString);
	$(btnSearch).bind('AutoCompleteSelect', fnSelect);
	if (oLocationTitleRenderer != null) {
		$(oLocationTitleRenderer).bind('onObjectClick', function(event, oFoundObject){
			lstResult.CenterObject(oFoundObject);
			onObjectClick(event, oFoundObject);
		});
	}
	/**Осуществляет поиск по произвольным параметрам по адресной базе
	@param {object} params Параметры: </br>
		<i>SearchString</i> - строка для поиска </br>
		<i>IsStrongSearch</i> - признак того, что искать только целые слова </br>
		<i>Geometry</i> - искать только объекты, пересекающие данную геометрию </br>
		<i>Limit</i> - максимальное число найденных объектов
	@returns {void}*/
	this.Search = function(params){
		try{
			var sSearchString = params.SearchString || '';
			if (sSearchString == '' && params.Geometry == null) throw "Error in SearchControl: Не заданы параметры поиска!";
			if (sSearchString == '') sSearchString = 'Поиск по выделенной области';
			lstResult.ShowLoading();
			if (fnBeforeSearch != null) fnBeforeSearch();
			oLogic.Search({
				SearchString: params.SearchString,
				IsStrongSearch: params.IsStrongSearch,
				Limit: params.Limit,
				Geometry: params.Geometry,
				callback: function(arrResultDataSources){
					lstResult.ShowResult(sSearchString, arrResultDataSources);
					if (fnAfterSearch != null) fnAfterSearch();
				}
			});
		}
		catch (e){
			lstResult.ShowError();
		}
	};

	/**Возвращает стоку поиска*/
	this.GetSearchString = function(){
		return btnSearch.GetSearchString();
	}

	/**Устанавливает строку поиска*/
	this.SetSearchString = function(value){
		btnSearch.SetSearchString(value);
	}
	this.SetSearchStringFocus = function(value){
		btnSearch.SetSearchStringFocus(value);
	}

	/**Устанавливает подсказку строки поиска*/
	this.SetPlaceholder = function(value){
		btnSearch.SetPlaceholder(value);
	}

	/**Показывает режим загрузки
	@returns {void}*/
	this.ShowLoading = function(){
		lstResult.ShowLoading();
	}

	/**Очищает результаты поиска
	@returns {void}*/
	this.Unload = function(){lstResult.Unload();};

    /**
    Добавление наблюдателя события начала оработки запроса для подсказки
    */
    this.onAutoCompleteDataSearchStarting = function(params){
        oLogic.AutoCompleteDataSearchStarting(params.observer);
        $(btnSearch).bind('AutoCompleteSelect', params.selectItem);
    }

    /**Добавляет хук поиска объектов по строке. Хуки выполняются в порядке их добавления с учётом приоритета
    @param {function} hook - ф-ция, которая принимает на вход строку поиска и возвращает признак прекращения дальнейшего поиска (true - прекратить)
    @param {Number} [priority=0] - приоритет хука. Чем больше значение, тем раньше будет выполняться
	@returns {void}*/
    this.addSearchByStringHook = function(hook, priority) {
        searchByStringHooks.push({
            hook: hook,
            priority: priority || 0,
            index: searchByStringHooks.length
        });

        searchByStringHooks.sort(function(a, b) {
            return b.priority - a.priority || a.index - b.index;
        })
    }

    /**Удаляет хук поиска объектов по строке
    @param {function} hook - хук, который нужно удалить
	*/
    this.removeSearchByStringHook = function(hook) {
        for (var h = 0; h < searchByStringHooks.length; h++) {
            if (searchByStringHooks[h].hook === hook) {
                searchByStringHooks.splice(h, 1);
                return;
            }
        }
    }
}

/**Конструктор без параметров
 @class SearchGeomixer Контрол, содержащий все все компоненты поиска и встраивающий их во Viewer
 @memberof Search*/
var SearchGeomixer = function(){
	var _this = this;
	var oMenu;
	var oSearchControl;

	var oSearchInputDiv = _div();
	var oSearchResultDiv = _div();
	var workCanvas;

	_title(oSearchInputDiv, _gtxt('Изменить параметры поиска'));

	var fnLoad = function(){
		if (oMenu != null){
			var alreadyLoaded = oMenu.createWorkCanvas("search", fnUnload);
			if(!alreadyLoaded) _(oMenu.workCanvas, [oSearchResultDiv]);
		}
	}
	var fnUnload = function(){
		if (oSearchControl != null)oSearchControl.Unload();
	}

	var fnBeforeSearch = function(event){
		/** Вызывается перед началом поиска
		@name Search.SearchGeomixer.onBeforeSearch
		@event */
		$(_this).triggerHandler('onBeforeSearch');
		fnLoad();
	}

	var fnAfterSearch = function(event){
		/** Вызывается после окончания поиска
		@name Search.SearchGeomixer.onAfterSearch
		@event */
		$(_this).triggerHandler('onAfterSearch');
	}

	var onDisplayedObjectsChanged = function(event, iDataSourceN, arrFoundObjects){
		/** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
		@name Search.SearchGeomixer.onDisplayedObjectsChanged
		@event
		@param {int} iDataSourceN № источника данных(группы результатов поиска)
		@param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/
		$(_this).triggerHandler('onDisplayedObjectsChanged', [iDataSourceN, arrFoundObjects]);
	}

	var onObjectClick = function(event, oFoundObject){
		/** Вызывается при клике на найденный объект в списке результатов поиска
		@name Search.SearchGeomixer.onObjectClick
		@event
		@param {object} oFoundObject Найденный объект*/
		$(_this).triggerHandler('onObjectClick', [oFoundObject]);
	}

	/**Инициализирует контрол
	@param {object} params Параметры: </br>
		<i>ServerBase</i> - Адрес сервера, на котором установлен поисковый модуль Geomixer'а </br>
		<i>ContainerInput</i> - Объект, в котором находится контрол поискового поля (div) </br>
		<i>layersSearchFlag</i> - Признак видимости кнопки поиска по векторным слоям </br>
		<i>ContainerList</i> - Объект, в котором находится контрол результатов поиска в виде списка(div) </br>
		<i>Map</i> - карта, на которой будут рисоваться объекты </br>
		<i>MapHelper</i> - вспомогательный компонент для работы с картой </br>
	@returns {void}*/
	this.Init = function(params){
		if (oMenu == null) oMenu = params.Menu;
		// if (oMenu == null) throw "Error in SearchGeomixer: Menu is null";
		_(params.ContainerInput, [oSearchInputDiv]);
		oSearchControl = new SearchControlGet({ServerBase: params.ServerBase,
											ImagesHost: params.ServerBase + "/api/img",
											ContainerInput: oSearchInputDiv,
											layersSearchFlag: params.layersSearchFlag,
											ContainerList: oSearchResultDiv,
											Map: params.Map,
                                            gmxMap: params.gmxMap,
                                            ResultList: params.ResultList});
		$(oSearchControl).bind('onBeforeSearch', fnBeforeSearch);
		$(oSearchControl).bind('onAfterSearch', fnAfterSearch);
		$(oSearchControl).bind('onDisplayedObjectsChanged', onDisplayedObjectsChanged);
		$(oSearchControl).bind('onObjectClick', onObjectClick);
	}

	/** Загружает контрол в левое меню
	@returns {void}*/
	this.Load = function(){
		fnLoad();
	}

	/** Выгружает контрол из левого меню
	@returns {void}*/
	this.Unload = function(){
		fnUnload();
	}

	/**Осуществляет поиск по произвольным параметрам по адресной базе
	@param {object} params Параметры: </br>
		<i>SearchString</i> - строка для поиска </br>
		<i>IsStrongSearch</i> - признак того, что искать только целые слова </br>
		<i>Geometry</i> - искать только объекты, пересекающие данную геометрию </br>
		<i>Limit</i> - максимальное число найденных объектов
	@returns {void}*/
	this.Search = function(params){
		oSearchControl.Search({
			SearchString: params.SearchString,
			IsStrongSearch: params.IsStrongSearch,
			Limit: params.Limit,
			Geometry: params.Geometry
		});
	};

	/**Возвращает стоку поиска*/
	this.GetSearchString = function(){
		return oSearchControl.GetSearchString();
	}

	/**Устанавливает строку поиска*/
	this.SetSearchString = function(value){
		oSearchControl.SetSearchString(value);
	}
	this.SetSearchStringFocus = function(value){
		oSearchControl.SetSearchStringFocus(value);
	}
	/**Устанавливает подсказку строки поиска*/
	this.SetPlaceholder = function(value){
		oSearchControl.SetPlaceholder(value);
	}

    this.getSearchControl = function() {
        return oSearchControl;
    }
}

var publicInterface = {
	SearchGeomixer: SearchGeomixer,
	SearchControl: SearchControl,
	SearchControlGet: SearchControlGet,
	SearchInput: SearchInput,
	ResultList: ResultList,
	ResultRenderer: ResultRenderer,
	ResultListMap: ResultListMap,
	ResultListMapGet: ResultListMapGet,
	SearchDataProvider: SearchDataProvider,
	SearchLogic: SearchLogic,
	SearchLogicGet: SearchLogicGet,
	LocationTitleRenderer: LocationTitleRenderer,
	Functions: Functions
}

gmxCore.addModule("search", publicInterface, {
    require: ['utilities', 'translations'],
    init: function() {
        //Очень суровое решение для разруливания конфликтов с глобальными переменными.
        _ = nsGmx.Utils._;
        _input = nsGmx.Utils._input;
        _td = nsGmx.Utils._td;
        _tr = nsGmx.Utils._tr;
        _div = nsGmx.Utils._div;
        _t = nsGmx.Utils._t;
        _table = nsGmx.Utils._table;
        _tbody = nsGmx.Utils._tbody;
        _img = nsGmx.Utils._img;
        _span = nsGmx.Utils._span;
        _li = nsGmx.Utils._li;
        _ul = nsGmx.Utils._ul;
        _form = nsGmx.Utils._form;

        initTranslations();
    }
});

})(jQuery);

(function() {
    window.nsGmx = window.nsGmx || {};
    window.nsGmx.widgets = window.nsGmx.widgets || {};
    nsGmx.widgets.notifications = {
        _container: null,
        _actions: [],
        _messagesToShow: [],
        _messageTimer: null,
        _currentStatusClass: '',
        
        startAction: function(actionId) {
            this._initContainerLazy();
            if (this._actions.indexOf(actionId) === -1) {
                this._actions.push(actionId);
                this._container.find('.notification-process').show();
            }
        },
        
        //supported statuses: success, failure, warning
        stopAction: function(actionId, status, message, timeout) {
            var index = this._actions.indexOf(actionId);
            
            if (index !== -1) {
                this._actions.splice(index, 1);
                this._container.find('.notification-process').toggle(this._actions.length);
            }
                
            if (message) {
                timeout = typeof timeout !== 'undefined' ? timeout : 1500;
                this._messagesToShow.push({text: message, status: status, timeout: timeout});
                this._checkMessages();
            }
        },
        
        _checkMessages: function() {
            if (this._messageTimer || !this._messagesToShow.length) {
                return;
            }
            
            var msg = this._messagesToShow.shift();
            var statusClass = 'notification-' + msg.status;
            this._initContainerLazy();
            this._container.find('.notification-message')
                .show().text(msg.text)
                .removeClass(this._currentStatusClass)
                .addClass(statusClass);
                
            if (msg.timeout) {
                this._messageTimer = setTimeout(function(){
                    this._messageTimer = null;
                    this._container.find('.notification-message').hide();
                    this._checkMessages();
                }.bind(this), msg.timeout);
            }
        },
        
        _initContainerLazy: function() {
            if (this._container) {
                return;
            }
            
            this._container = $(Handlebars.compile(
                '<div class="notification-container">' +
                    '<span class="notification-process"></span>' +
                    '<span class="notification-message"></span>' +
                '</div>')()).appendTo($('#flash'));
                
            this._container.find('.notification-message, .notification-process').hide();
        }
    }
})();
nsGmx.VirtualLayerManager = function() {
    this._classes = window.gmxVirtualClasses || {};
    this.loader = this.loader.bind(this);
}

nsGmx.VirtualLayerManager.prototype.loader = function(type) {
    var promise = new L.gmx.Deferred(),
        classInfo = this._classes[type];
    
    if (!classInfo) {
        promise.resolve();
        return promise;
    }
    
    gmxCore.loadModule(classInfo.module, classInfo.file).then(function(module) {
        promise.resolve(module.layerClass);
    }, promise.reject);
    
    return promise;
};
/*!
 * Lightweight URL manipulation with JavaScript
 * This library is independent of any other libraries and has pretty simple
 * interface and lightweight code-base.
 * Some ideas of query string parsing had been taken from Jan Wolter
 * @see http://unixpapa.com/js/querystring.html
 *
 * @license MIT
 * @author Mykhailo Stadnyk <mikhus@gmail.com>
 */
(function (ns) {
    'use strict';

    // configure given url options
    function urlConfig (url) {
        var config = {
            path: true,
            query: true,
            hash: true
        };

        if (!url) {
            return config;
        }

        if (/^[a-z]+:/.test(url)) {
            config.protocol = true;
            config.host = true;

            if (/[-a-z0-9]+(\.[-a-z0-9])*:\d+/i.test(url)) {
                config.port = true;
            }

            if (/\/\/(.*?)(?::(.*?))?@/.test(url)) {
                config.user = true;
                config.pass = true;
            }
        }

        return config;
    }

    var isNode = typeof window === 'undefined' &&
        typeof global !== 'undefined' &&
        typeof require === 'function';

    // Trick to bypass Webpack's require at compile time
    var nodeRequire = isNode ? ns['require'] : null;

    // mapping between what we want and <a> element properties
    var map = {
        protocol: 'protocol',
        host: 'hostname',
        port: 'port',
        path: 'pathname',
        query: 'search',
        hash: 'hash'
    };

    // jscs: disable
    /**
     * default ports as defined by http://url.spec.whatwg.org/#default-port
     * We need them to fix IE behavior, @see https://github.com/Mikhus/jsurl/issues/2
     */
    // jscs: enable
    var defaultPorts = {
        ftp: 21,
        gopher: 70,
        http: 80,
        https: 443,
        ws: 80,
        wss: 443
    };

    function parse (self, url, absolutize) {
        var link, i, auth;
        var currUrl = isNode ? ('file://' +
            (process.platform.match(/^win/i) ? '/' : '') +
            nodeRequire('fs').realpathSync('.')
        ) : document.location.href;

        if (!url) {
            url = currUrl;
        }

        if (isNode) {
            link = nodeRequire('url').parse(url);
        }

        else {
            link = document.createElement('a');
            link.href = url;
        }

        var config = urlConfig(url);

        auth = url.match(/\/\/(.*?)(?::(.*?))?@/) || [];

        for (i in map) {
            if (config[i]) {
                self[i] = link[map[i]] || '';
            }

            else {
                self[i] = '';
            }
        }

        // fix-up some parts
        self.protocol = self.protocol.replace(/:$/, '');
        self.query = self.query.replace(/^\?/, '');
        self.hash = decode(self.hash.replace(/^#/, ''));
        self.user = decode(auth[1] || '');
        self.pass = decode(auth[2] || '');
        /* jshint ignore:start */
        self.port = (
            // loosely compare because port can be a string
            defaultPorts[self.protocol] == self.port || self.port == 0
        ) ? '' : self.port; // IE fix, Android browser fix
        /* jshint ignore:end */

        if (!config.protocol && /[^/#?]/.test(url.charAt(0))) {
            self.path = url.split('?')[0].split('#')[0];
        }

        if (!config.protocol && absolutize) {
            // is IE and path is relative
            var base = new Url(currUrl.match(/(.*\/)/)[0]);
            var basePath = base.path.split('/');
            var selfPath = self.path.split('/');
            var props = ['protocol', 'user', 'pass', 'host', 'port'];
            var s = props.length;

            basePath.pop();

            for (i = 0; i < s; i++) {
                self[props[i]] = base[props[i]];
            }

            while (selfPath[0] === '..') { // skip all "../
                basePath.pop();
                selfPath.shift();
            }

            self.path =
                (url.charAt(0) !== '/' ? basePath.join('/') : '') +
                '/' + selfPath.join('/')
            ;
        }

        self.path = self.path.replace(/^\/{2,}/, '/');

        self.paths((self.path.charAt(0) === '/' ?
            self.path.slice(1) : self.path).split('/')
        );

        self.query = new QueryString(self.query);
    }

    function encode (s) {
        return encodeURIComponent(s).replace(/'/g, '%27');
    }

    function decode (s) {
        s = s.replace(/\+/g, ' ');

        s = s.replace(/%([ef][0-9a-f])%([89ab][0-9a-f])%([89ab][0-9a-f])/gi,
            function (code, hex1, hex2, hex3) {
                var n1 = parseInt(hex1, 16) - 0xE0;
                var n2 = parseInt(hex2, 16) - 0x80;

                if (n1 === 0 && n2 < 32) {
                    return code;
                }

                var n3 = parseInt(hex3, 16) - 0x80;
                var n = (n1 << 12) + (n2 << 6) + n3;

                if (n > 0xFFFF) {
                    return code;
                }

                return String.fromCharCode(n);
            }
        );

        s = s.replace(/%([cd][0-9a-f])%([89ab][0-9a-f])/gi,
            function (code, hex1, hex2) {
                var n1 = parseInt(hex1, 16) - 0xC0;

                if (n1 < 2) {
                    return code;
                }

                var n2 = parseInt(hex2, 16) - 0x80;

                return String.fromCharCode((n1 << 6) + n2);
            }
        );

        return s.replace(/%([0-7][0-9a-f])/gi,
            function (code, hex) {
                return String.fromCharCode(parseInt(hex, 16));
            }
        );
    }

    /**
     * Class QueryString
     *
     * @param {string} qs - string representation of QueryString
     * @constructor
     */
    function QueryString (qs) {
        var re = /([^=&]+)(=([^&]*))?/g;
        var match;

        while ((match = re.exec(qs))) {
            var key = decodeURIComponent(match[1].replace(/\+/g, ' '));
            var value = match[3] ? decode(match[3]) : '';

            if (!(this[key] === undefined || this[key] === null)) {
                if (!(this[key] instanceof Array)) {
                    this[key] = [this[key]];
                }

                this[key].push(value);
            }

            else {
                this[key] = value;
            }
        }
    }

    /**
     * Converts QueryString object back to string representation
     *
     * @returns {string}
     */
    QueryString.prototype.toString = function () {
        var s = '';
        var e = encode;
        var i, ii;

        for (i in this) {
            if (this[i] instanceof Function || this[i] === null) {
                continue;
            }

            if (this[i] instanceof Array) {
                var len = this[i].length;

                if (len) {
                    for (ii = 0; ii < len; ii++) {
                        s += s ? '&' : '';
                        s += e(i) + '=' + e(this[i][ii]);
                    }
                }

                else {
                    // parameter is an empty array, so treat as
                    // an empty argument
                    s += (s ? '&' : '') + e(i) + '=';
                }
            }

            else {
                s += s ? '&' : '';
                s += e(i) + '=' + e(this[i]);
            }
        }

        return s;
    };

    /**
     * Class Url
     *
     * @param {string} [url] - string URL representation
     * @param {boolean} [noTransform] - do not transform to absolute URL
     * @constructor
     */
    function Url (url, noTransform) {
        parse(this, url, !noTransform);
    }

    /**
     * Clears QueryString, making it contain no params at all
     *
     * @returns {Url}
     */
    Url.prototype.clearQuery = function () {
        for (var key in this.query) {
            if (!(this.query[key] instanceof Function)) {
                delete this.query[key];
            }
        }

        return this;
    };

    /**
     * Returns total number of parameters in QueryString
     *
     * @returns {number}
     */
    Url.prototype.queryLength = function () {
        var count = 0;
        var key;

        for (key in this) {
            if (!(this[key] instanceof Function)) {
                count++;
            }
        }

        return count;
    };

    /**
     * Returns true if QueryString contains no parameters, false otherwise
     *
     * @returns {boolean}
     */
    Url.prototype.isEmptyQuery = function () {
        return this.queryLength() === 0;
    };

    /**
     *
     * @param {Array} [paths] - an array pf path parts (if given will modify
     *                          Url.path property
     * @returns {Array} - an array representation of the Url.path property
     */
    Url.prototype.paths = function (paths) {
        var prefix = '';
        var i = 0;
        var s;

        if (paths && paths.length && paths + '' !== paths) {
            if (this.isAbsolute()) {
                prefix = '/';
            }

            for (s = paths.length; i < s; i++) {
                paths[i] = !i && paths[i].match(/^\w:$/) ? paths[i] :
                    encode(paths[i]);
            }

            this.path = prefix + paths.join('/');
        }

        paths = (this.path.charAt(0) === '/' ?
            this.path.slice(1) : this.path).split('/');

        for (i = 0, s = paths.length; i < s; i++) {
            paths[i] = decode(paths[i]);
        }

        return paths;
    };

    /**
     * Performs URL-specific encoding of the given string
     *
     * @method Url#encode
     * @param {string} s - string to encode
     * @returns {string}
     */
    Url.prototype.encode = encode;

    /**
     * Performs URL-specific decoding of the given encoded string
     *
     * @method Url#decode
     * @param {string} s - string to decode
     * @returns {string}
     */
    Url.prototype.decode = decode;

    /**
     * Checks if current URL is an absolute resource locator (globally absolute
     * or absolute path to current server)
     *
     * @returns {boolean}
     */
    Url.prototype.isAbsolute = function () {
        return this.protocol || this.path.charAt(0) === '/';
    };

    /**
     * Returns string representation of current Url object
     *
     * @returns {string}
     */
    Url.prototype.toString = function () {
        return (
            (this.protocol && (this.protocol + '://')) +
            (this.user && (
            encode(this.user) + (this.pass && (':' + encode(this.pass))
            ) + '@')) +
            (this.host && this.host) +
            (this.port && (':' + this.port)) +
            (this.path && this.path) +
            (this.query.toString() && ('?' + this.query)) +
            (this.hash && ('#' + encode(this.hash)))
        );
    };

    ns[ns.exports ? 'exports' : 'Url'] = Url;
}(typeof module !== 'undefined' && module.exports ? module : window));

var nsGmx = window.nsGmx = window.nsGmx || {};

nsGmx.GmxWidgetMixin = {
    getContainer: function() {
        return this.el || this._container;
    },
    appendTo: function(el) {
        el = el[0] || el;
        el.appendChild(this.getContainer());
    },
    show: function() {
        var el = this.getContainer();
        el.style.display = (this._previousStyleDisplayValue !== 'none' && this._previousStyleDisplayValue) || 'block';
        delete this._previousStyleDisplayValue;
    },
    hide: function() {
        var el = this.getContainer();
        this._previousStyleDisplayValue = el.style.display;
        el.style.display = 'none';
    },
    _terminateMouseEvents: function(el) {
        el = el || this.getContainer();
        L.DomEvent.disableClickPropagation(el);
        el.addEventListener('mousewheel', L.DomEvent.stopPropagation);
        el.addEventListener('mousemove', L.DomEvent.stopPropagation);
    }
}

nsGmx.GmxWidget = Backbone.View.extend(nsGmx.GmxWidgetMixin);

var nsGmx = window.nsGmx = window.nsGmx || {};nsGmx.Templates = nsGmx.Templates || {};nsGmx.Templates.DropdownMenuWidget = {};
nsGmx.Templates.DropdownMenuWidget["dropdownMenuWidget"] = "<div class=\"dropdownMenuWidget ui-widget\">\n" +
    "    {{#each items}}\n" +
    "    <div class=\"dropdownMenuWidget-item{{#if className}} {{className}}{{/if}}\">\n" +
    "        <a\n" +
    "            {{#if id}}id=\"{{id}}\"{{/if}}\n" +
    "            {{#if link}}href=\"{{link}}\"{{else}}href=\"javascript:void(0)\"{{/if}}\n" +
    "            {{#if newWindow}}{{#if link}}target=\"_blank\"{{/if}}{{/if}}\n" +
    "            class=\"dropdownMenuWidget-itemAnchor{{#if newWindow}} dropdownMenuWidget-itemAnchor_newWindow{{/if}}\"\n" +
    "        >\n" +
    "            {{#if icon}}\n" +
    "                <img src=\"{{icon}}\" />\n" +
    "            {{/if}}\n" +
    "            {{#if fonticon}}\n" +
    "                <i class=\"{{fonticon}}\"></i>\n" +
    "            {{/if}}\n" +
    "            {{#if title}}\n" +
    "                <span>{{title}}</span>\n" +
    "                {{#if dropdown}}<i class=\"icon-angle-down\"></i>{{/if}}\n" +
    "            {{/if}}\n" +
    "        </a>\n" +
    "        {{#if dropdown}}\n" +
    "            <div class=\"dropdownMenuWidget-itemDropdown\">\n" +
    "                <ul class=\"dropdownMenuWidget-dropdownMenu\">\n" +
    "                    {{#each dropdown}}\n" +
    "                        <li class=\"dropdownMenuWidget-dropdownMenuItem{{#if className}} {{className}}{{/if}}\">\n" +
    "                            {{#if newWindow}}<div class=\"ui-icon ui-icon-newwin dropdownMenuWidget-dropdownMenuIcon\"></div>{{/if}}\n" +
    "                            <a\n" +
    "                                {{#if id}}id=\"{{id}}\"{{/if}}\n" +
    "                                {{#if link}}href=\"{{link}}\"{{else}}href=\"javascript:void(0)\"{{/if}}\n" +
    "                                {{#if newWindow}}{{#if link}}target=\"_blank\"{{/if}}{{/if}}\n" +
    "                                class=\"dropdownMenuWidget-dropdownItemAnchor{{#if newWindow}} dropdownMenuWidget-dropdownItemAnchor_newWindow{{/if}}\"\n" +
    "                            >\n" +
    "                                {{#if icon}}\n" +
    "                                    <img src=\"{{icon}}\" />\n" +
    "                                {{/if}}\n" +
    "                                {{#if title}}\n" +
    "                                    <span>{{title}}</span>\n" +
    "                                {{/if}}\n" +
    "                            </a>\n" +
    "                        </li>\n" +
    "                    {{/each}}\n" +
    "                </ul>\n" +
    "            </div>\n" +
    "        {{/if}}\n" +
    "    </div>\n" +
    "    {{/each}}\n" +
    "</div>\n" +
    "";
nsGmx.Templates.DropdownMenuWidget["anchor"] = "<a \n" +
    "    {{#if id}}id=\"{{id}}\"{{/if}}\n" +
    "    {{#if link}}href=\"{{link}}\"{{else}}href=\"javascript:void(0)\"{{/if}}\n" +
    "    {{#if newWindow}}target=\"_blank\" class=\"dropdownMenuWidget-anchor_newWindow\"{{/if}}\n" +
    ">\n" +
    "    {{#if icon}}\n" +
    "        <img src=\"{{icon}}\" />\n" +
    "    {{/if}}\n" +
    "    {{#if title}}\n" +
    "        <span>{{title}}</span>\n" +
    "    {{/if}}\n" +
    "</a>";;
var nsGmx = window.nsGmx = window.nsGmx || {};

nsGmx.PlainTextWidget = nsGmx.GmxWidget.extend({
    initialize: function(txt) {
        this.setText(txt);
        this.$el.on('click', function () {
            this.trigger('click')
        }.bind(this));
    },
    getText: function () {
        return this.$el.html();
    },
    setText: function (txt) {
        this.$el.html(txt);
    }
});
;
var nsGmx = window.nsGmx = window.nsGmx || {};

// <String>options.title
// <String>options.className
// <String>options.trigger (hover|click|manual)
// <String>options.direction (down|up)
// <Boolean>options.adjustWidth
// <Boolean>options.showTopItem
nsGmx.DropdownWidget = nsGmx.GmxWidget.extend({
    className: 'dropdownWidget dropdownWidget-item',

    options: {
        title: '',
        trigger: 'hover',
        direction: 'down',
        adjustWidth: true,
        showTopItem: true,
        titleClassName: ''
    },

    initialize: function(options) {
        this.options = _.extend(this.options, options);
        this.$titleContainer = $('<div>')
            .addClass('dropdownWidget-dropdownTitle')
            .addClass(options.titleClassName)
            .html(this.options.title)
            .appendTo(this.$el);
        this.$dropdownContainer = $('<div>')
            .addClass('dropdownWidget-dropdown')
            .hide()
            .appendTo(this.$el);
        this.$dropdownTitle = $('<div>')
            .addClass('dropdownWidget-item dropdownWidget-dropdownTitle')
            .addClass(options.titleClassName)
            .html(this.options.title)
            .appendTo(this.$dropdownContainer);

        if (!this.options.showTopItem) {
            this.$dropdownTitle.hide();
        }

        if (this.options.trigger === 'hover') {
            this.$dropdownTitle.addClass('ui-state-disabled');
            this.$titleContainer.on('mouseover', function(je) {
                this.expand();
            }.bind(this));
            this.$dropdownContainer.on('mouseleave', function(je) {
                this.collapse();
            }.bind(this));
        } else if (this.options.trigger === 'click') {
            this.$titleContainer.on('click', function(je) {
                this.expand();
            }.bind(this));
            this.$dropdownTitle.on('click', function(je) {
                this.collapse();
            }.bind(this));
        }

        if (this.options.direction === 'up') {
            this.$el.addClass('dropdownWidget_direction-up');
        } else {
            this.$el.addClass('dropdownWidget_direction-down');
        }

        this._items = {};
    },

    addItem: function(id, inst, position) {
        this._items[id] = inst;
        var $container = $('<div>')
            .addClass('dropdownWidget-item dropdownWidget-dropdownItem')
            .attr('data-id', id)
            .attr('data-position', position)
            .on('click', function(je) {
                this.trigger('item', $(je.currentTarget).attr('data-id'));
                this.trigger('item:' + $(je.currentTarget).attr('data-id'));
                if (this.options.trigger === 'click') {
                    this.collapse();
                }
            }.bind(this));
        $container.append(inst.el);
        this.$dropdownContainer.append($container);
        this._sortItems()
    },

    setTitle: function(title) {
        this.$titleContainer.html(title);
        this.$dropdownTitle.html(title);
    },

    toggle: function() {
        this._expanded ? this.collapse() : this.expand();
        this._expanded = !this._expanded;
    },

    expand: function() {
        this.$dropdownContainer.css('min-width', this.$el.width());
        this.$dropdownContainer.show();
        this.trigger('expand');
    },

    collapse: function() {
        this.$dropdownContainer.hide();
        this.trigger('collapse');
    },

    reset: function() {
        this.collapse();
    },

    _sortItems: function() {
        var containerEl = this.$dropdownContainer[0];
        var items = Array.prototype.slice.call(containerEl.children);

        var titleEl = items.splice(
            items.indexOf($(containerEl).find('.dropdownWidget-dropdownTitle')[0]), 1
        );

        while (items.length) {
            var maxPositionIndex = items.indexOf(_.max(items, function(el) {
                return el.getAttribute('data-position') / 1;
            }));
            $(containerEl).prepend(items.splice(maxPositionIndex, 1)[0]);
        }

        if (this.options.direction === 'up') {
            $(containerEl).append(titleEl);
        } else {
            $(containerEl).prepend(titleEl);
        }
    }
});
;
var nsGmx = window.nsGmx = window.nsGmx || {};

nsGmx.DropdownMenuWidget = (function() {
    var DropdownMenuWidget = function(options) {
        var h = Handlebars.create();
        h.registerPartial('anchor', nsGmx.Templates.DropdownMenuWidget.anchor);
        this._view = $(h.compile(nsGmx.Templates.DropdownMenuWidget.dropdownMenuWidget)({
            items: options.items
        }));
        this._view.find('.dropdownMenuWidget-itemDropdown').hide();

        var mouseTimeout = options.mouseTimeout || 100;
        this._view.find('.dropdownMenuWidget-item').each(function(index) {
            var mouseIsOver = false;
            $(this).on('mouseenter', function(je) {
                mouseIsOver = true;
                setTimeout(function() {
                    if (mouseIsOver) {
                        $(je.currentTarget).find('.dropdownMenuWidget-itemDropdown').show();
                    }
                }, 100);
            });
            $(this).on('mouseleave', function(je) {
                mouseIsOver = false;
                $(je.currentTarget).find('.dropdownMenuWidget-itemDropdown').hide();
            });
        });
    };

    DropdownMenuWidget.prototype.appendTo = function(placeholder) {
        $(placeholder).append(this._view);
    };

    return DropdownMenuWidget;
})();;
var nsGmx = window.nsGmx = window.nsGmx || {};nsGmx.Templates = nsGmx.Templates || {};nsGmx.Templates.AuthWidget = {};
nsGmx.Templates.AuthWidget["authWidget"] = "{{#if userName}}\n" +
    "    <div class=\"authWidget_authorized\">\n" +
    "        <div class=\"authWidget-userPanel\">\n" +
    "            <div class=\"authWidget-userPanel-iconCell\">\n" +
    "                <div class=\"authWidget-userPanel-userIcon\"></div>\n" +
    "            </div>\n" +
    "            <div class=\"authWidget-userPanel-userMenuCell\"></div>\n" +
    "        </div>\n" +
    "    </div>\n" +
    "{{else}}\n" +
    "\n" +
    "    <div class=\"authWidget_unauthorized\">\n" +
    "        <div class=\"authWidget-userPanel\">\n" +
    "            <div class=\"authWidget-userPanel-iconCell\">\n" +
    "                <div class=\"authWidget-userPanel-userIcon\"></div>\n" +
    "            </div>\n" +
    "            <div class=\"authWidget-loginButton\">\n" +
    "                {{i 'auth.login'}}\n" +
    "            </div>\n" +
    "        </div>\n" +
    "    </div>\n" +
    "{{/if}}\n" +
    "";;
var nsGmx = window.nsGmx = window.nsGmx || {};

nsGmx.AuthWidget = (function() {

    // options.loginDialog
    var AuthWidget = function(options) {
        this._view = $('<div>');
        this._view.addClass('authWidget ui-widget');
        this._authManager = options.authManager;
        this._userInfo = null;

        this._options = $.extend({
            showAccountLink: true,
            accountLink: 'http://my.kosmosnimki.ru/Home/Settings/',
            showMapLink: true,
            changePassword: false
                /* mapLink */
        }, options);

        this._authManager.getUserInfo().then(function(response) {
            this._render({
                login: response.Result && response.Result.Login,
                userName: response.Result && (response.Result.FullName || response.Result.Nickname || response.Result.Login)
            });
            this._userInfo = response.Result;
            $(this).trigger('ready');
        }.bind(this)).fail(function(response) {
            this._render(response);
        }.bind(this));
    };

    AuthWidget.prototype._render = function(vm) {
        var self = this;

        this._view.html(Handlebars.compile(nsGmx.Templates.AuthWidget.authWidget)(vm));

        if (vm.userName) {
            var dropdownItems = [];

            if (this._options.showAccountLink) {
                dropdownItems.push({
                    title: nsGmx.Translations.getText('auth.myAccount'),
                    link: this._options.accountLink,
                    id: 'AuthWidgetAccountLink',
                    newWindow: true
                });
            }

            if (this._options.showMapLink) {
                var defaultMapLink = 'http://maps.kosmosnimki.ru/api/index.html?' + encodeURIComponent('@' + vm.login);
                dropdownItems.push({
                    title: nsGmx.Translations.getText('auth.myMap'),
                    link: this._options.mapLink || defaultMapLink,
                    id: 'AuthWidgetMapLink',
                    newWindow: true
                });
            }

            if (this._options.changePassword) {
                dropdownItems.push({
                    title: nsGmx.Translations.getText('auth.changePassword'),
                    className: 'authWidget-changePasswordButton'
                });
            }

            if (this._options.isAdmin) {
                dropdownItems.push({
                    title: nsGmx.Translations.getText('Системные настройки'),
                    link: window.serverBase + 'Administration/Actions.aspx',
                    id: 'AuthWidgetAdminLink',
                    newWindow: true
                });

                dropdownItems.push({
                    title: nsGmx.Translations.getText('Управление группами'),
                    link: 'javascript:void(0)',
                    className: 'authWidget-usergroupMenuItem'
                });
            }

            dropdownItems.push({
                title: nsGmx.Translations.getText('auth.logout'),
                className: 'authWidget-logoutButton'
            })

            var dropdownMenuWidget = new nsGmx.DropdownMenuWidget({
                items: [{
                    title: vm.userName,
                    dropdown: dropdownItems
                }]
            });

            dropdownMenuWidget.appendTo(this._view.find('.authWidget-userPanel-userMenuCell'));
        }

        this._view.find('.authWidget-usergroupMenuItem').click(function(e) {
            if (this._options.callbacks && 'authWidget-usergroupMenuItem' in this._options.callbacks) {
                this._options.callbacks['authWidget-usergroupMenuItem']();
            } else {
                return false;
            }
        }.bind(this));

        this._view.find('.authWidget-changePasswordButton').click(function(e) {
            var native = this._authManager.getNative();
            native.changePasswordDialog();
        }.bind(this));

        this._view.find('.authWidget-loginButton').click(function(e) {
            var $iframeContainer;
            if (this._options.loginDialog) {
                $iframeContainer = $('<div>').addClass('authWidget-iframeContainer');
                var dialog = $iframeContainer.dialog({
                    width: 500,
                    height: 450,
                    closeText: nsGmx.Translations.getText('auth.closeDialog'),
                    close: function(je, ui) {
                        $(this).dialog('destroy');
                    }
                });
                // HACK:
                $(dialog).parent().find('button.ui-button').addClass('ui-icon').css('outline', 'none')
            }

            this._authManager.login({
                iframeContainer: $iframeContainer && $iframeContainer[0]
            });
        }.bind(this));

        this._view.find('.authWidget-logoutButton').click(function(e) {
            this._authManager.logout().then(function(response) {
                this._render(response);
                this._userInfo = response.Result;
                $(this).trigger('logout');
            }.bind(this));
        }.bind(this));
    };

    /** Получить информацию о пользователе, которую вернул AuthManager
     * @return {Object}
     */
    AuthWidget.prototype.getUserInfo = function() {
        return this._userInfo;
    };

    AuthWidget.prototype.on = function(eventName, callback) {
        $(this).on(eventName, callback);
    };

    AuthWidget.prototype.appendTo = function(placeholder) {
        placeholder.append(this._view);
    };

    return AuthWidget;
})();
;
var nsGmx = window.nsGmx;

nsGmx.Translations.addText('rus', {
	auth: {
		'login': 'Войти',
		'logout': 'Выйти',
		'myAccount': 'Личный кабинет',
        'changePassword': 'Сменить пароль',
		'myMap': 'Личная карта',
		'closeDialog': 'Закрыть'
	}
});

nsGmx.Translations.addText('eng', {
	auth: {
		'login': 'Login',
		'logout': 'Logout',
		'myAccount': 'My account',
        'changePassword': 'Change password',
		'myMap': 'My map',
		'closeDialog': 'Close'
	}
});
;
var nsGmx = window.nsGmx = window.nsGmx || {};

nsGmx.LanguageWidget = (function() {
    'use strict';

    var LanguageWidget = function(options) {
        this._view = $(Handlebars.compile(nsGmx.Templates.LanguageWidget.layout)({
            eng: nsGmx.Translations.getLanguage() === 'eng',
            rus: nsGmx.Translations.getLanguage() === 'rus'
        }));

        if (nsGmx.Translations.getLanguage() !== 'eng') {
            this._view.find('.languageWidget-item_eng').click(function() {
                nsGmx.Translations.updateLanguageCookies('eng');
                // присвоение url не работает, если есть #
                window.location.reload(false);
            });
        }

        if (nsGmx.Translations.getLanguage() !== 'rus') {
            this._view.find('.languageWidget-item_rus').click(function() {
                nsGmx.Translations.updateLanguageCookies('rus');
                window.location.reload(false);
            });
        }
    };

    LanguageWidget.prototype.appendTo = function(placeholder) {
        $(placeholder).append(this._view);
    };

    return LanguageWidget;
})();
;
var nsGmx = window.nsGmx = window.nsGmx || {};nsGmx.Templates = nsGmx.Templates || {};nsGmx.Templates.LanguageWidget = {};
nsGmx.Templates.LanguageWidget["layout"] = "<div class=\"languageWidget ui-widget\">\n" +
    "    <div class=\"languageWidget-item languageWidget-item_rus\"><span class=\"{{^rus}}link languageWidget-link{{/rus}}{{#rus}}languageWidget-disabled{{/rus}}\">Ru</span></div>\n" +
    "    <div class=\"languageWidget-item languageWidget-item_eng\"><span class=\"{{^eng}}link languageWidget-link{{/eng}}{{#eng}}languageWidget-disabled{{/eng}}\">En</span></div>\n" +
    "</div>";;
var nsGmx = window.nsGmx = window.nsGmx || {};

nsGmx.HeaderWidget = (function() {
    'use strict';

    var SocialShareWidget = function(socials) {
        this._view = Handlebars.compile(nsGmx.Templates.HeaderWidget.socials)(socials);
    };

    SocialShareWidget.prototype.appendTo = function(placeholder) {
        $(placeholder).append(this._view);
    };

    var HeaderWidget = function(options) {
        var addDots = function(item) {
            if (!item.icon && !item.className) {
                item.className = item.className + ' headerWidget-menuDot';
            }
            return item;
        };

        var h = Handlebars.create();
        this._view = $(h.compile(nsGmx.Templates.HeaderWidget.layout)(options));
        if (nsGmx.DropdownMenuWidget) {
            (new nsGmx.DropdownMenuWidget({
                items: options.leftLinks && options.leftLinks.map(addDots)
            })).appendTo(this._view.find('.headerWidget-leftLinksContainer'));
            (new nsGmx.DropdownMenuWidget({
                items: options.rightLinks && options.rightLinks.map(addDots)
            })).appendTo(this._view.find('.headerWidget-rightLinksContainer'));
        } else {
            console.warn('DropdownMenuWidget not found');
        }
        (new SocialShareWidget(options.socials)).appendTo(this._view.find('.headerWidget-socialsContainer'));
        this._view.find(".headerWidget-authContainer").hide();
        this._view.find(".headerWidget-menuContainer").hide();
        this._view.find(".headerWidget-searchContainer").hide();
        this._view.find(".headerWidget-languageContainer").hide();
        if (!options.socials) {
            this._view.find(".headerWidget-socialsContainer").hide();
        }
    };

    HeaderWidget.prototype.appendTo = function(placeholder) {
        $(placeholder).append(this._view);
    };

    HeaderWidget.prototype.getAuthPlaceholder = function() {
        return this._view.find(".headerWidget-authContainer").show();
    };

    HeaderWidget.prototype.getMenuPlaceholder = function() {
        return this._view.find(".headerWidget-menuContainer").show();
    };

    HeaderWidget.prototype.getSearchPlaceholder = function() {
        return this._view.find(".headerWidget-searchContainer").show();
    };

    HeaderWidget.prototype.getLanguagePlaceholder = function() {
        return this._view.find(".headerWidget-languageContainer").show();
    };

    HeaderWidget.prototype.getSocialsPlaceholder = function(first_argument) {
        return this._view.find(".headerWidget-socialsContainer");
    };

    return HeaderWidget;
})();;
nsGmx.Translations.addText('rus', {
    header: {
        'langRu': 'Ru',
        'langEn': 'En'
    }
});

nsGmx.Translations.addText('eng', {
    header: {
        'langRu': 'Ru',
        'langEn': 'En'
    }
});;
var nsGmx = window.nsGmx = window.nsGmx || {};nsGmx.Templates = nsGmx.Templates || {};nsGmx.Templates.HeaderWidget = {};
nsGmx.Templates.HeaderWidget["layout"] = "<div class=\"headerWidget\">\n" +
    "    <div class=\"headerWidget-left\">\n" +
    "        <div class=\"headerWidget-logoContainer\">\n" +
    "            <img class=\"headerWidget-logo\" src=\"{{logo}}\" />\n" +
    "        </div>\n" +
    "    </div>\n" +
    "    <div class=\"headerWidget-right\">\n" +
    "        <div class=\"headerWidget-bar headerWidget-controlsBar\">\n" +
    "            <div class=\"headerWidget-barTable headerWidget-controlsBarTable\">\n" +
    "                <div class=\"headerWidget-barCell headerWidget-menuContainer\"></div>\n" +
    "                <div class=\"headerWidget-barCell headerWidget-authContainer\"></div>\n" +
    "                <div class=\"headerWidget-barCell headerWidget-languageContainer\"></div>\n" +
    "            </div>\n" +
    "        </div>\n" +
    "    </div>\n" +
    "</div>\n" +
    "";
nsGmx.Templates.HeaderWidget["socials"] = "<div class=\"headerWidget-socialIcons\">\n" +
    "    {{#if vk}}\n" +
    "        <div class=\"headerWidget-socialIconCell\"><a href=\"{{vk}}\" target=\"_blank\"><i class=\"icon-vk\"></i></a></div>\n" +
    "    {{/if}}\n" +
    "    {{#if facebook}}\n" +
    "        <div class=\"headerWidget-socialIconCell\"><a href=\"{{facebook}}\" target=\"_blank\"><i class=\"icon-facebook\"></i></a></div>\n" +
    "    {{/if}}\n" +
    "    {{#if twitter}}\n" +
    "        <div class=\"headerWidget-socialIconCell\"><a href=\"{{twitter}}\" target=\"_blank\"><i class=\"icon-twitter\"></i></a></div>\n" +
    "    {{/if}}\n" +
    "</div>";;
nsGmx.TransparencySliderWidget = function(container) {
    var _this = this;
    var ui = $(Handlebars.compile(
		'<div class="leaflet-gmx-iconSvg leaflet-gmx-iconSvg-transparency svgIcon leaflet-control gmx-transslider-toggle-icon" title="{{i "TransparencySliderWidget.title"}}"><svg role="img" class="svgIcon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#transparency"></use></svg></div>' +
        '<div class = "gmx-transslider-container"></div>' +
        '<div class = "leaflet-gmx-iconSvg leaflet-gmx-iconSvg-transparency-eye svgIcon leaflet-gmx-iconSvg-active leaflet-control gmx-transslider-onoff" title="{{i "TransparencySliderWidget.onOffTitle"}}"><svg role="img" class="svgIcon gmx-transslider-hide"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#transparency-eye"></use></svg><svg role="img" class="svgIcon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#transparency-eye-off"></use></svg></div>'
    )()).appendTo(container);

    var sliderContainer = container.find('.gmx-transslider-container');

    this._isCollapsed = true;

    container.find('.gmx-transslider-toggle-icon').click(function() {
        this._isCollapsed = !this._isCollapsed;
        sliderContainer.toggle(!this._isCollapsed);
        container.find('.gmx-transslider-onoff').toggle(!this._isCollapsed);
        container.find('.gmx-transslider-toggle-icon').toggleClass('leaflet-gmx-iconSvg-active', !this._isCollapsed);
    }.bind(this));

    var isOpaque = true;
    var updateOnOffIcon = function(value) {
        var isOpaqueNew = value === 1.0;
        if (isOpaqueNew !== isOpaque) {
            isOpaque = isOpaqueNew;
            var arr = container.find('.gmx-transslider-onoff')[0].childNodes;
			if (isOpaque) {
				L.DomUtil.removeClass(arr[1], 'gmx-transslider-hide');
				L.DomUtil.addClass(arr[0], 'gmx-transslider-hide');
			} else {
				L.DomUtil.removeClass(arr[0], 'gmx-transslider-hide');
				L.DomUtil.addClass(arr[1], 'gmx-transslider-hide');
			}
        }
    }

    sliderContainer.slider({
        range: 'min',
        min: 0.0,
        max: 1.0,
        step: 0.01,
        value: 1.0,
        change: function(event, ui) {
            $(_this).triggerHandler(event, ui);
            updateOnOffIcon(ui.value);
        },
        slide: function(event, ui) {
            $(_this).triggerHandler(event, ui);
            updateOnOffIcon(ui.value);
        }
    }).hide();

    // fix map moving in IE
    if (nsGmx.leafletMap) {
        var dragging = nsGmx.leafletMap.dragging;
        L.DomEvent
            .on(sliderContainer[0], 'mouseover', dragging.disable, dragging)
            .on(sliderContainer[0], 'mouseout', dragging.enable, dragging);
    }

    container.find('.gmx-transslider-onoff').click(function(){
        var curValue = sliderContainer.slider('value');
        sliderContainer.slider('value', curValue !== 1.0 ? 1.0 : 0.0);
    }).hide();

    container.on('mousedown click', function(event) {
        event.stopPropagation();
    });
}

nsGmx.TransparencySliderWidget.prototype.isCollapsed = function() {
    return this._isCollapsed;
}
;
nsGmx.Translations.addText('rus', { TransparencySliderWidget: {
    title: 'Прозрачность растровых слоёв',
    onOffTitle: 'Показать/скрыть растры'
}});
                         
nsGmx.Translations.addText("eng", { TransparencySliderWidget: {
    title: 'Raster layers transparency',
    onOffTitle: 'Show/hide rasters'
}});;
/* ========================================================================
 * Bootstrap: tooltip.js v3.3.1
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       =
    this.options    =
    this.enabled    =
    this.timeout    =
    this.hoverState =
    this.$element   = null

    this.init('tooltip', element, options)
  }

  Tooltip.VERSION  = '3.3.1'

  Tooltip.TRANSITION_DURATION = 150

  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled   = true
    this.type      = type
    this.$element  = $(element)
    this.options   = this.getOptions(options)
    this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport)

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }

    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()

    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (self && self.$tip && self.$tip.is(':visible')) {
      self.hoverState = 'in'
      return
    }

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var that = this;
    if (this.hasContent() && this.enabled) {
      this._toBeShown = true;
      this._preloadImages().then(function() {
        if (that._toBeShown) {
          that.doShow();
        }
      });
    }
  }

  Tooltip.prototype._preloadImages = function() {
    var that = this;
    
    var $images = $('<div>').html(that.getContent()).find('img');
    var srcs = Array.prototype.slice.apply($images).map(function(el) {
      return el.src;
    });

    var promises = srcs.map(function(src) {
      return $.Deferred(function(def) {
        var img = new Image();
        img.addEventListener('load', function() {
          def.resolve();
        });
        img.addEventListener('error', function() {
          def.reject();
        });
        img.src = src;
      }).promise();
    });

    return $.when.apply(null, promises);
  }

  Tooltip.prototype.doShow = function () {
      var e = $.Event('show.bs.' + this.type)

      this.$element.trigger(e)

      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this

      var $tip = this.tip()

      var tipId = this.getUID(this.type)

      this.setContent()

      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)
        .data('bs.' + this.type, this)

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var orgPlacement = placement
        var $container   = this.options.container ? $(this.options.container) : this.$element.parent()
        var containerDim = this.getPosition($container)

        placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top'    :
                    placement == 'top'    && pos.top    - actualHeight < containerDim.top    ? 'bottom' :
                    placement == 'right'  && pos.right  + actualWidth  > containerDim.width  ? 'left'   :
                    placement == 'left'   && pos.left   - actualWidth  < containerDim.left   ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)

      var complete = function () {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null

        if (prevHoverState == 'out') that.leave(that)
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
          .one('bsTransitionEnd', complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
  }

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  = offset.top  + marginTop
    offset.left = offset.left + marginLeft

    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)

    $tip.addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }

    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

    if (delta.left) offset.left += delta.left
    else offset.top += delta.top

    var isVertical          = /top|bottom/.test(placement)
    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }

  Tooltip.prototype.replaceArrow = function (delta, dimension, isHorizontal) {
    this.arrow()
      .css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isHorizontal ? 'top' : 'left', '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function (callback) {
    var that = this
    var $tip = this.tip()
    var e    = $.Event('hide.bs.' + this.type)

    this._toBeShown = false;

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      that.$element
        .removeAttr('aria-describedby')
        .trigger('hidden.bs.' + that.type)
      callback && callback()
    }

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition && this.$tip.hasClass('fade') ?
      $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()

    this.hoverState = null

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function ($element) {
    $element   = $element || this.$element

    var el     = $element[0]
    var isBody = el.tagName == 'BODY'

    var elRect    = el.getBoundingClientRect()
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
    }
    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()
    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width   }

  }

  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = { top: 0, left: 0 }
    if (!this.$viewport) return delta

    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)

    if (/right|left/.test(placement)) {
      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset < viewportDimensions.top) { // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset  = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }

    return delta
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }

  Tooltip.prototype.tip = function () {
    return (this.$tip = this.$tip || $(this.options.template))
  }

  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }

    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
  }

  Tooltip.prototype.destroy = function () {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
    })
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this    = $(this)
      var data     = $this.data('bs.tooltip')
      var options  = typeof option == 'object' && option
      var selector = options && options.selector

      if (!data && option == 'destroy') return
      if (selector) {
        if (!data) $this.data('bs.tooltip', (data = {}))
        if (!data[selector]) data[selector] = new Tooltip(this, options)
      } else {
        if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      }
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tooltip

  $.fn.tooltip             = Plugin
  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: popover.js v3.3.1
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.VERSION  = '3.3.1'

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }

  Popover.prototype.tip = function () {
    if (!this.$tip) this.$tip = $(this.options.template)
    return this.$tip
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this    = $(this)
      var data     = $this.data('bs.popover')
      var options  = typeof option == 'object' && option
      var selector = options && options.selector

      if (!data && option == 'destroy') return
      if (selector) {
        if (!data) $this.data('bs.popover', (data = {}))
        if (!data[selector]) data[selector] = new Popover(this, options)
      } else {
        if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      }
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover

  $.fn.popover             = Plugin
  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);

(function (factory) {
    if (typeof module === 'object' && module.exports) {
        module.exports = factory()
    } else {
        window.nsGmx = window.nsGmx || {}
        window.nsGmx.DateInterval = factory()
    }
})(function() {
    var DateInterval = window.Backbone.Model.extend({
        initialize: function() {
            if (!('dateBegin' in this.attributes) && !('dateEnd' in this.attributes)) {
                this.set(DateInterval.getUTCDayBoundary());
            }
        },

        saveState: function() {
            return {
                version: '1.1.0',
                dateBegin: +this.attributes.dateBegin,
                dateEnd: +this.attributes.dateEnd
            }
        },

        loadState: function(state) {
            if (!state.version || state.version === '1.1.0' || state.version === '1.0.0') {
                this.set({
                    dateBegin: new Date(state.dateBegin),
                    dateEnd: new Date(state.dateEnd)
                })
            } else {
                throw 'Unknown state version';
            }
        }
    }, {
        //number of milliseconds in one day
        MS_IN_DAY: 24*3600*1000,

        //set time to UTC midnight
        toMidnight: function(date) {
            return new Date(date - date % DateInterval.MS_IN_DAY);
        },

        getUTCDayBoundary: function(date) {
            date = date || new Date();

            var midnight = DateInterval.toMidnight(date);
            return {
                dateBegin: midnight,
                dateEnd: new Date(midnight.valueOf() + DateInterval.MS_IN_DAY)
            }
        },

        // 24+n interval
        defaultFireDateInterval: function() {
            var now = new Date(),
                lastMidnight = DateInterval.toMidnight(now),
                dateEnd = new Date((now - 1) - (now - 1) % (3600*1000) + 3600*1000), //round to the nearest hour greater then 'now'
                isTooSmall = dateEnd - lastMidnight < 12*3600*1000,
                dateBegin = new Date(isTooSmall ? (lastMidnight - nsGmx.DateInterval.MS_IN_DAY) : lastMidnight.valueOf());

            return {
                dateBegin: dateBegin,
                dateEnd: dateEnd
            }
        }
    })

    return DateInterval
})

var nsGmx = nsGmx || {};nsGmx.Templates = nsGmx.Templates || {};nsGmx.Templates.CalendarWidget = {};
nsGmx.Templates.CalendarWidget["CalendarWidget"] = "<table>\n" +
    "    <tr>\n" +
    "        <td><div class = \"CalendarWidget-iconScrollLeft ui-helper-noselect icon-left-open\"></div></td>\n" +
    "        <td class = \"CalendarWidget-inputCell\"><input class = \"gmx-input-text CalendarWidget-dateBegin\"></td>\n" +
    "        <td class = \"CalendarWidget-inputCell CalendarWidget-onlyMaxVersion\"><input class = \"gmx-input-text CalendarWidget-dateEnd\"></td>\n" +
    "        <td><div class = \"CalendarWidget-iconScrollRight ui-helper-noselect icon-right-open\" ></div></td>\n" +
    "        <td><div class = \"CalendarWidget-iconMore {{moreIconClass}}\" title = \"{{moreIconTitle}}\"></div></td>\n" +
    "        <td><div class = \"CalendarWidget-forecast\" hidden>{{forecast}}</div></td>\n" +
    "    </tr><tr>\n" +
    "        <td></td>\n" +
    "        <td class = \"CalendarWidget-dateBeginInfo\"></td>\n" +
    "        <td class = \"CalendarWidget-dateEndInfo\"></td>\n" +
    "        <td></td>\n" +
    "        <td></td>\n" +
    "    </tr>\n" +
    "</table>\n" +
    "<div class=\"CalendarWidget-footer\"></div>\n" +
    "";;
var nsGmx = nsGmx || {};

(function($){

'use strict';

var _gtxt = nsGmx.Translations.getText.bind(nsGmx.Translations),
    toMidnight = nsGmx.DateInterval.toMidnight;

/** Параметры календаря
 * @typedef nsGmx.CalendarWidget~Parameters
 * @property {nsGmx.DateInterval} dateInterval Временной интервал, который нужно менять
 * @property {Date} [dateMin] минимальная граничная дата для календарей, null - без ограничений
 * @property {Date} [dateMax] максимальная граничная дата для календарей, null - без ограничений
 * @property {String} [dateFormat='dd.mm.yy'] формат даты
 * @property {bool} [minimized=true] показывать ли минимизированный или развёрнутый виджет в начале
 * @property {bool} [showSwitcher=true] показывать ли иконку для разворачивания/сворачивания периода
 * @property {Date} [dateBegin=<текущая дата>] начальная дата интервала
 * @property {Date} [dateEnd=<текущая дата>] конечная дата интервала
 * @property {String|DOMNode} [container] куда добавлять календарик
 * @property {String} [buttonImage] URL иконки для активации календариков
 */

/** Контрол для задания диапазона дат. Даты календарика всегда в UTC, а не в текущем поясе.
 @description Виджет для выбора интервала дат. Пользователь при помощи datepicker'ов выбирает два дня (год, месяц, число),
              затем выбранные значения при помощи ф-ции `_updateModel()` переводятся в интервал дат ({@link nsGmx.DateInterval}).
              Так же виджет реагирует на изменения модели (с использованием ф-ции `_updateWidget()`)
 @alias nsGmx.CalendarWidget
 @extends nsGmx.GmxWidget
 @class
 @param {nsGmx.CalendarWidget~Parameters} options Параметры календаря
*/
var Calendar = nsGmx.GmxWidget.extend({
    tagName: 'div',
    className: 'CalendarWidget ui-widget',
    template: Handlebars.compile(nsGmx.Templates.CalendarWidget.CalendarWidget),

    events: {
        'click .CalendarWidget-iconMore': 'toggleMode',
        'click .CalendarWidget-iconScrollLeft': function() {
            this._shiftDates(-1);
        },
        'click .CalendarWidget-iconScrollRight': function() {
            this._shiftDates(1);
        }
    },

    initialize: function(options) {
        options = $.extend({
            minimized: true,
            showSwitcher: true,
            dateMax: null,
            dateMin: null,
            dateFormat: 'dd.mm.yy',
            name: null
        }, options);

        this._dateMin = options.dateMin;
        this._dateMax = options.dateMax;

        this._dateInterval = options.dateInterval;

        this.$el.html(this.template({
            moreIconClass: options.minimized ? 'icon-calendar' : 'icon-calendar-empty',
            moreIconTitle: options.minimized ? _gtxt('CalendarWidget.ExtendedViewTitle') : _gtxt('CalendarWidget.MinimalViewTitle'),
            forecast: _gtxt('CalendarWidget.forecast')
        }));

        this._moreIcon = this.$('.CalendarWidget-iconMore')
            .toggle(!!options.showSwitcher);

        this._dateBegin = this.$('.CalendarWidget-dateBegin');
        this._dateEnd = this.$('.CalendarWidget-dateEnd');
        this._dateInputs = this._dateBegin.add(this._dateEnd);

        this._dateInputs.datepicker({
            onSelect: function(dateText, inst){
                this._selectFunc(inst.input);
                this._updateModel();
            }.bind(this),
            showAnim: 'fadeIn',
            changeMonth: true,
            changeYear: true,
            minDate: this._dateMin ? Calendar.toUTC(this._dateMin) : null,
            maxDate: this._dateMax ? Calendar.toUTC(this._dateMax) : null,
            dateFormat: options.dateFormat,
            defaultDate: Calendar.toUTC(this._dateMax || new Date()),
            showOn: options.buttonImage ? 'both' : 'focus',
            buttonImageOnly: true
        });

        //устанавливаем опцию после того, как добавили календарик в canvas
        if (options.buttonImage) {
            this._dateInputs.datepicker('option', 'buttonImage', options.buttonImage);
        }

        this.$('.CalendarWidget-onlyMaxVersion').toggle(!options.minimized);

        options.dateBegin && this._dateBegin.datepicker('setDate', Calendar.toUTC(options.dateBegin));
        options.dateEnd && this._dateEnd.datepicker('setDate', Calendar.toUTC(options.dateEnd));

        if (options.container) {
            if (typeof options.container === 'string')
                $('#' + options.container).append(this.$el);
            else
                $(options.container).append(this.$el);
        }

        this.setMode(options.minimized ? Calendar.SIMPLE_MODE : Calendar.ADVANCED_MODE);

        this._updateWidget();

        this._dateInterval.on('change', this._updateWidget, this);

        //for backward compatibility
        this.canvas = this.$el;
    },

    _shiftDates: function(delta) {
        var dateBegin = this.getDateBegin(),
            dateEnd = this.getDateEnd();

        if (!dateBegin || !dateEnd) {
            return;
        }

        var shift = (dateEnd - dateBegin + nsGmx.DateInterval.MS_IN_DAY) * delta,
            newDateBegin = new Date(dateBegin.valueOf() + shift),
            newDateEnd = new Date(dateEnd.valueOf() + shift);

        if ((!this._dateMin || toMidnight(this._dateMin) <= toMidnight(newDateBegin)) &&
            (!this._dateMax || toMidnight(this._dateMax) >= toMidnight(newDateEnd)))
        {
            this._dateBegin.datepicker('setDate', Calendar.toUTC(newDateBegin));
            this._dateEnd.datepicker('setDate', Calendar.toUTC(newDateEnd));

            this._updateModel();
        }
    },

    _selectFunc: function(activeInput) {
        var begin = this._dateBegin.datepicker('getDate');
        var end   = this._dateEnd.datepicker('getDate');

        if (end && begin && begin > end) {
            var dateToFix = activeInput[0] == this._dateEnd[0] ? this._dateBegin : this._dateEnd;
            dateToFix.datepicker('setDate', $(activeInput[0]).datepicker('getDate'));
        } else if (this._curMode === Calendar.SIMPLE_MODE) {
            //либо установлена только одна дата, либо две, но отличающиеся
            if (!begin != !end || begin && begin.valueOf() !== end.valueOf()) {
                this._dateEnd.datepicker('setDate', this._dateBegin.datepicker('getDate'));
            }
        }
    },

    _updateModel: function() {
        var dateBegin = this.getDateBegin(),
            dateEnd = this.getDateEnd();

        this._dateInterval.set({
            dateBegin: dateBegin ? toMidnight(dateBegin) : null,
            dateEnd: dateEnd ? toMidnight(dateEnd.valueOf() + nsGmx.DateInterval.MS_IN_DAY) : null
        });
    },

    _updateWidget: function() {
        var dateBegin = this._dateInterval.get('dateBegin'),
            dateEnd = this._dateInterval.get('dateEnd'),
            dayms = nsGmx.DateInterval.MS_IN_DAY;

        if (!dateBegin || !dateEnd) {
            return;
        };

        var isValid = !(dateBegin % dayms) && !(dateEnd % dayms);

        var newDateBegin = Calendar.toUTC(dateBegin),
            newDateEnd;
        if (isValid) {
            newDateEnd = Calendar.toUTC(new Date(dateEnd - dayms));
            if (dateEnd - dateBegin > dayms) {
                this.setMode(Calendar.ADVANCED_MODE);
            }
        } else {
            newDateEnd = Calendar.toUTC(dateEnd);
            this.setMode(Calendar.ADVANCED_MODE);
        }

        //если мы сюда пришли после выбора интервала в самом виджете, вызов setDate сохраняет фокус на input-поле
        //возможно, это какая-то проблема jQueryUI.datepicker'ов.
        //чтобы этого избежать, явно проверяем, нужно ли изменять дату
        var prevDateBegin = this._dateBegin.datepicker('getDate'),
            prevDateEnd = this._dateEnd.datepicker('getDate');

        if (!prevDateBegin || prevDateBegin.valueOf() !== newDateBegin.valueOf()) {
            this._dateBegin.datepicker('setDate', newDateBegin);
        }

        if (!prevDateEnd || prevDateEnd.valueOf() !== newDateEnd.valueOf()) {
            this._dateEnd.datepicker('setDate', newDateEnd);
        }
    },

    //public interface

    /** Закрыть все открытые datepicker'ы.
     * @return {nsGmx.CalendarWidget} this
     */
    reset: function() {
        this._dateInputs.datepicker('hide');
        return this;
    },

    /** Сериализация состояния виджета
     * @return {Object} Сериализованное состояние
     */
    saveState: function() {
        return {
            version: '1.1.0',
            vismode: this.getMode()
        }
    },

    /** Восстановить состояние виджета по сериализованным данным
     * @param {Object} data Сериализованное состояние календарика
     */
    loadState: function( data ) {
        this.setMode(data.vismode);
    },

    /** Получить начальную дату
     * @return {Date} начальная дата
     */
    getDateBegin: function() {
        return Calendar.fromUTC(this._dateBegin.datepicker('getDate'));
    },

    /** Получить конечную дату
     * @return {Date} конечная дата
     */
    getDateEnd: function() {
        return Calendar.fromUTC(this._dateEnd.datepicker('getDate'));
    },

    /** Получить верхнюю границу возможных дат периода
     * @return {Date} верхняя граница возможных периодов
     */
    getDateMax: function() {
        return this._dateMax;
    },

    /** Получить нижнуюю границу возможных дат периода
     * @return {Date} нижняя граница возможных периодов
     */
    getDateMin: function() {
        return this._dateMin;
    },

    /** Установить нижнуюю границу возможных дат периода
     * @param {Date} dateMin нижняя граница возможных периодов
     */
    setDateMin: function(dateMin) {
        this._dateMin = dateMin;
        this._dateInputs.datepicker('option', 'minDate', dateMin ? Calendar.toUTC(dateMin) : null);
    },

    /** Установить верхнюю границу возможных дат периода
     * @param {Date} dateMax верхняя граница возможных периодов
     */
    setDateMax: function(dateMax) {
        var titleContainer = this.$('.CalendarWidget-forecast');

        this._dateMax = dateMax;
        if (dateMax) {
            var utcDate = Calendar.toUTC(dateMax);
            this._dateInputs.datepicker('option', 'maxDate', utcDate);

            if (dateMax > new Date()) {
                $(titleContainer).attr('title', _gtxt('CalendarWidget.tooltip') + ' ' +
                ('0' + dateMax.getDate()).slice(-2) + '.' +
                ('0' + (dateMax.getMonth() + 1)).slice(-2) + '.' +
                dateMax.getFullYear());
                $(titleContainer).show();
            } else {
                $(titleContainer).hide();
            }

        } else {
            this._dateInputs.datepicker('option', 'maxDate', null);
        }
    },

    setSwitcherVisibility: function(isVisible) {
        this._moreIcon && this._moreIcon.toggle(isVisible);
    },

    getDateInterval: function() {
        return this._dateInterval;
    },

    getMode: function() {
        return this._curMode;
    },

    setMode: function(mode) {
        if (this._curMode === mode) {
            return this;
        }

        this.reset();

        this._curMode = mode;
        var isSimple = mode === Calendar.SIMPLE_MODE;

        this.$('.CalendarWidget-onlyMaxVersion').toggle(!isSimple);

        this._moreIcon
            .toggleClass('icon-calendar', isSimple)
            .toggleClass('icon-calendar-empty', !isSimple)
            .attr('title', isSimple ? _gtxt('CalendarWidget.ExtendedViewTitle') : _gtxt('CalendarWidget.MinimalViewTitle'));


        var dateBegin = this._dateBegin.datepicker('getDate'),
            dateEnd = this._dateEnd.datepicker('getDate');

        if (isSimple && dateBegin && dateEnd && dateBegin.valueOf() !== dateEnd.valueOf()) {
            this._selectFunc(this._dateEnd);
            this._updateModel();
        }

        this.trigger('modechange');

        return this;
    },

    toggleMode: function() {
        this.setMode(this._curMode === Calendar.SIMPLE_MODE ? Calendar.ADVANCED_MODE : Calendar.SIMPLE_MODE );
    }
}, {
    /* static methods */
    fromUTC: function(date) {
        if (!date) return null;
        var timeOffset = date.getTimezoneOffset()*60*1000;
        return new Date(date.valueOf() - timeOffset);
    },
    toUTC: function(date) {
        if (!date) return null;
        var timeOffset = date.getTimezoneOffset()*60*1000;
        return new Date(date.valueOf() + timeOffset);
    },
    SIMPLE_MODE: 1,
    ADVANCED_MODE: 2
});

nsGmx.CalendarWidget = Calendar;

})(jQuery);
;
nsGmx.Translations.addText("rus", { CalendarWidget: {
    ExtendedViewTitle: "Выбор периода",
    MinimalViewTitle:  "Свернуть",
    UTC:               "Всемирное координированное время",
    forecast:           "прогноз",
    tooltip:            "доступны прогнозные данные до"
}});

nsGmx.Translations.addText("eng", { CalendarWidget: {
    ExtendedViewTitle: "Period selection",
    MinimalViewTitle:  "Minimize",
    UTC:               "Coordinated Universal Time",
    forecast:           "forecast",
    tooltip:            "forecast data is available up to"
}});
;
/** Контрол для задания диапазона дат с логикой работы, взятой с сайта fires.ru.
 @description Основное отличае в логине формировании интервала на основе выбранных в календариках дат.
              Работает так же, как и обычный виджет ({@link nsGmx.CalendarWidget}) за исключением ситуации, когда dateEnd попадает в текущие UTC сутки.
              В этом случае, dateEnd устанавливается равном началу следующего часа. Далее, если длина выбранного интервала меньше 12 часов, начало интервала смещается на сутки назад.
              Кроме формирования интервала, этот виджет показывает пользователю дополнительную информацию о выбранном интервале.
 @alias nsGmx.FireCalendarWidget
 @class
 @param {nsGmx.CalendarWidget~Parameters} params Параметры календаря
*/

var nsGmx = nsGmx || {};

(function($){

'use strict';

var toMidnight = nsGmx.DateInterval.toMidnight;

nsGmx.Translations.addText("rus", { FireCalendarWidget: {
    timeTitlePrefix : 'За ',
    timeTitleLastPrefix : 'За последние ',
    timeTitlePostfix : 'ч (UTC)'
}});

nsGmx.Translations.addText("eng", { FireCalendarWidget: {
    timeTitlePrefix : 'For ',
    timeTitleLastPrefix : 'For last ',
    timeTitlePostfix : 'h (UTC)'
}});


function f(n) {
    return n < 10 ? '0' + n : n;
}

function getStr (hours, minutes) {
    return f(hours) + ":" + f(minutes); /*+ ":" + f(time.seconds)*/
};

var FireCalendarWidget = nsGmx.CalendarWidget.extend({
    initialize: function(options) {
        options = $.extend({
            dateMax: new Date()
        }, options);

        nsGmx.CalendarWidget.prototype.initialize.call(this, options);

        this._dateInterval.on('change', this._updateInfo, this);
        this.on('modechange', this._updateInfo, this);
        this.on('modechange', this._updateModel, this);
        this._updateInfo();
    },

    _updateModel: function() {
        var dateBegin = this.getDateBegin(),
            origDateEnd = this.getDateEnd(),
            now = new Date(),
            lastMidnight = toMidnight(now),
            dateEnd;

        if (lastMidnight <= origDateEnd) {
            //last day
            dateEnd = new Date((now - 1) - (now - 1) % (3600*1000) + 3600*1000); //round to the nearest hour greater then 'now'

            if (dateEnd - toMidnight(dateBegin) < 12*3600*1000 && this.getMode() === nsGmx.CalendarWidget.SIMPLE_MODE) {
                dateBegin = new Date(dateBegin - nsGmx.DateInterval.MS_IN_DAY);
            }
        } else {
            //previous days
            dateEnd = new Date(origDateEnd.valueOf() + nsGmx.DateInterval.MS_IN_DAY);
        }

        this._dateInterval.set({
            dateBegin: toMidnight(dateBegin),
            dateEnd: dateEnd
        });
    },

    _updateWidget: function() {
        var dateBegin = +this._dateInterval.get('dateBegin'),
            dateEnd = +this._dateInterval.get('dateEnd');

        if (!dateBegin || !dateEnd) {
            return;
        };

        var currentDayMode = toMidnight(new Date()) < dateEnd;

        if (currentDayMode && this.getMode() === nsGmx.CalendarWidget.SIMPLE_MODE && dateEnd - dateBegin < 2 * nsGmx.DateInterval.MS_IN_DAY) {
            this._dateBegin.datepicker("setDate", nsGmx.CalendarWidget.toUTC(new Date()));
            this._dateEnd.datepicker("setDate", nsGmx.CalendarWidget.toUTC(new Date()));
        } else {
            nsGmx.CalendarWidget.prototype._updateWidget.call(this);
        }
    },

    _updateInfo: function() {
        var isSimpleMode = this.getMode() === nsGmx.CalendarWidget.SIMPLE_MODE;

        this.$('.CalendarWidget-footer').toggle(isSimpleMode);
        this.$('.CalendarWidget-dateBeginInfo, .CalendarWidget-dateEndInfo').toggle(!isSimpleMode);

        var dateBegin = this._dateInterval.get('dateBegin'),
            dateEnd = this._dateInterval.get('dateEnd');

        if (!dateBegin || !dateEnd) {
            return;
        }

        var hours = Math.ceil((dateEnd - dateBegin)/3600000);

        if (isSimpleMode) {
            var hoursStr = hours > 24 ? "24+" + (hours-24) : hours;
            var prefix = hours === 24 ? _gtxt("FireCalendarWidget.timeTitlePrefix") : _gtxt("FireCalendarWidget.timeTitleLastPrefix");

            this.$('.CalendarWidget-footer').html(prefix + hoursStr + _gtxt("FireCalendarWidget.timeTitlePostfix"));
        } else {
            var dateEndToShow = (hours % 24) === 0 ? new Date(+dateEnd - 1) : dateEnd; //hack to show 23:59 instead of 00:00
            this.$('.CalendarWidget-dateBeginInfo').text(getStr(dateBegin.getUTCHours(), dateBegin.getUTCMinutes()) + " (UTC)").attr('title', _gtxt('CalendarWidget.UTC'));
            this.$('.CalendarWidget-dateEndInfo'  ).text(getStr(dateEndToShow.getUTCHours(), dateEndToShow.getUTCMinutes()) + " (UTC)").attr('title', _gtxt('CalendarWidget.UTC'));

        }
    }
}, {
    defaultFireDateInterval: function() {
        var now = new Date(),
            lastMidnight = toMidnight(now),
            dateEnd = new Date((now - 1) - (now - 1) % (3600*1000) + 3600*1000), //round to the nearest hour greater then 'now'
            isTooSmall = dateEnd - lastMidnight < 12*3600*1000,
            dateBegin = new Date(isTooSmall ? (lastMidnight - nsGmx.DateInterval.MS_IN_DAY) : lastMidnight.valueOf());

        return {
            dateBegin: dateBegin,
            dateEnd: dateEnd
        }
    }
});

nsGmx.FireCalendarWidget = FireCalendarWidget;

})(jQuery);
;
(function($){

'use strict';

var _gtxt = nsGmx.Translations.getText.bind(nsGmx.Translations),
    toMidnight = nsGmx.DateInterval.toMidnight;


    nsGmx.Translations.addText("rus", { CalendarWidget: {
        ShowIconTitle:     "Выбрать дату",
        createDateInterval: "Задать интервал",
        resetDateInterval:  "Сбросить интервал",
        selectDateInterval: "Применить",
        hour:               "ч.",
        from: "с",
        to: "до"
    }});

    nsGmx.Translations.addText("eng", { CalendarWidget: {
        ShowIconTitle:     "Select date",
        createDateInterval: "Create date interval",
        resetDateInterval:  "Reset date interval",
        selectDateInterval: "Select date interval",
        hour:               "h.",
        from: "from",
        to: "to"
    }});

    var template = '' +
        '<div>' +
            '<div class = "CalendarWidget-row CalendarWidget-dates">' +
                // dates block
                '<span class = "CalendarWidget-iconScrollLeft icon-left-open"></span>' +
                '<span class = "CalendarWidget-dates-outside">' +
                    '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputBegin">' +
                    '<input class = "CalendarWidget-dateBegin">' +
                    '</span>' +
                    '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputMiddle">-</span>' +
                    '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputEnd">' +
                    '<input class = "CalendarWidget-dateEnd">' +
                    '</span>' +
                '</span>' +
                '<span class = "CalendarWidget-iconScrollRight ui-helper-noselect icon-right-open"></span>' +
                // space between dates and time
                '<span class = "CalendarWidget-space"></span>' +
                // times block
                '<span class = "CalendarWidget-timeicon"><img src="img/time-icon-01.svg"></img></span>' +
                '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputTimeBegin"><input class = "CalendarWidget-timeInput CalendarWidget-timeBegin" value={{hourBegin}} ></span>' +
                '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputMiddle CalendarWidget-inputCell-inputTimeMiddle">-</span>' +
                '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputTimeEnd"><input class = "CalendarWidget-timeInput CalendarWidget-timeEnd" value={{hourEnd}}></span>' +
            '</div>' +
        '</div>';

/** Параметры календаря
 * @typedef nsGmx.CalendarWidget~Parameters
 * @property {nsGmx.DateInterval} dateInterval Временной интервал, который нужно менять
 * @property {Date} [dateMin] минимальная граничная дата для календарей, null - без ограничений
 * @property {Date} [dateMax] максимальная граничная дата для календарей, null - без ограничений
 * @property {String} [dateFormat='dd.mm.yy'] формат даты
 * @property {bool} [minimized=true] показывать ли минимизированный или развёрнутый виджет в начале
 * @property {bool} [showSwitcher=true] показывать ли иконку для разворачивания/сворачивания периода
 * @property {Date} [dateBegin=<текущая дата>] начальная дата интервала
 * @property {Date} [dateEnd=<текущая дата>] конечная дата интервала
 * @property {String|DOMNode} [container] куда добавлять календарик
 * @property {String} [buttonImage] URL иконки для активации календариков
 */

/** Контрол для задания диапазона дат. Даты календарика всегда в UTC, а не в текущем поясе.
 @description Виджет для выбора интервала дат. Пользователь при помощи datepicker'ов выбирает два дня (год, месяц, число),
              затем выбранные значения при помощи ф-ции `_updateModel()` переводятся в интервал дат ({@link nsGmx.DateInterval}).
              Так же виджет реагирует на изменения модели (с использованием ф-ции `_updateWidget()`)
 @alias nsGmx.CalendarWidget
 @extends nsGmx.GmxWidget
 @class
 @param {nsGmx.CalendarWidget~Parameters} options Параметры календаря
*/

var CalendarModel = window.Backbone.Model.extend({
    defaults: {
        dailyFilter: true
    }
});
var Calendar1 = window.Backbone.View.extend({
    tagName: 'div',
    model: new CalendarModel(),
    className: 'CalendarWidget ui-widget',
    template: Handlebars.compile(template),
    events: {
        'click .CalendarWidget-dates-outside .CalendarWidget-inputCell': function (e) {
            e.stopPropagation();
            this.showCalendar(e);
            $(e.target).focus();
        },
        'keydown .CalendarWidget-dateBegin': function (e) {
            this.manuallyChangeDateInterval(e, 'begin');
        },
        'keydown .CalendarWidget-dateEnd': function (e) {
            this.manuallyChangeDateInterval(e, 'end');
        },
        'click .CalendarWidget-iconScrollLeft': function () {
            this._shiftDates(-1);
        },
        'click .CalendarWidget-iconScrollRight': function () {
            this._shiftDates(1);
        },
        'keydown .CalendarWidget-inputCell-inputTimeBegin': function (e) {
            this.jumpByArrow(e, 'left');
        },
        'keydown .CalendarWidget-inputCell-inputTimeEnd': function (e) {
            this.jumpByArrow(e, 'right');
        }
    },

    initialize: function(options) {
        var _this = this;
        options = $.extend({
            minimized: true,
            showSwitcher: true,
            dateMax: null,
            dateMin: null,
            dateFormat: 'dd.mm.yy',
            name: null
        }, options);

        this._dateMin = options.dateMin;
        this._dateMax = options.dateMax;
        this._dateInterval = options.dateInterval;
        this._opened = false;

        $.datepicker.setDefaults({

            onSelect: function(dateText, inst){
                this._selectFunc(inst.input);
            }.bind(this),
            minDate: this._dateMin ? Calendar1.toUTC(this._dateMin) : null,
            maxDate: this._dateMax ? Calendar1.toUTC(this._dateMax) : null,
            changeMonth: true,
            changeYear: true,
            dateFormat: 'dd.mm.yy',
            defaultDate: Calendar1.toUTC(this._dateMax || new Date()),
            buttonImageOnly: true,
            constrainInput: true
        });

        this.calendarTemplates = {
            beginTemplate: Handlebars.compile('' +
                '<div class="outside-calendar-container">' +
                    '<div class="begin-outside-calendar">' +
                    '</div>' +
                    '<div class="time-container begin-time-container">' +
                    '</div>' +
                    '<div class="time-placeholder begin-time-placeholder" hidden>' +
                    '</div>' +
                        '<span class="calendar-button createdateinterval-button">' +
                        '{{i "CalendarWidget.createDateInterval"}}'+
                        '</span>' +
                        '<span class="calendar-button resetdateinterval-button" hidden>' +
                            '{{i "CalendarWidget.resetDateInterval"}}'+
                        '</span>' +
                '</div>'
            ),
            endTemplate: Handlebars.compile('' +
                '<div class="outside-calendar-container">' +
                    '<div class="end-outside-calendar">' +
                    '</div>' +
                    '<div class="time-container end-time-container">' +
                    '</div>' +
                    '<div class="time-placeholder end-time-placeholder" hidden>' +
                    '</div>' +
                    '<span class="calendar-button selectdateinterval-button disabled">' +
                        '{{i "CalendarWidget.selectDateInterval"}}'+
                    '</span>' +
                '</div>'
            )
        };

        var dateBegin = this._dateInterval.get('dateBegin'),
            dateEnd = this._dateInterval.get('dateEnd'),
            hourBegin = Calendar1.getTime(dateBegin, 'begin'),
            hourEnd = Calendar1.getTime(dateEnd, 'end');

        this.$el.html(this.template({
            showCalendarIconClass:'icon-calendar-empty',
            showCalendarIconTitle: _gtxt('CalendarWidget.ShowIconTitle'),
            hourBegin: hourBegin,
            hourEnd: hourEnd
        }));

        // если есть контейнер, куда прикреплять виджет календаря
        if (options.container) {
            if (typeof options.container === 'string')
                $('#' + options.container).append(this.$el);
            else
                $(options.container).append(this.$el);
        }

        this._updateWidget();

        this._dateInterval.on('change', this._updateWidget, this);
        this.listenTo(this.model, 'change:dailyFilter', this.enableDailyFilter);

        $('#leftMenu').on('click', function (e) {
            if (e.target.className !== 'CalendarWidget-show-calendar-icon icon-calendar-empty' &&
                e.target.className !== 'layers-before' &&
                e.target.className.indexOf('CalendarWidget-timeInput') === -1 &&
                e.target.className !== 'calendar-container'
            ) {
                $(".calendar-outside .ui-dialog-titlebar-close").trigger('click');
                _this._opened = false;
            }
        })

        this.$('.CalendarWidget-timeInput').on('blur', this._selectTime.bind(this));

        //for backward compatibility
        this.canvas = this.$el;
    },

    manuallyChangeDateInterval: function (e, type) {
        if (e.keyCode !== 13) return;
        e.preventDefault();
        e.stopPropagation();
        var value = $(e.target).val(),
            beginInput = this.$('.CalendarWidget-dateBegin')[0],
            endInput = this.$('.CalendarWidget-dateEnd')[0],
            dayms = nsGmx.DateInterval.MS_IN_DAY,
            dateBegin = this._dateInterval.get('dateBegin'),
            dateEnd = this._dateInterval.get('dateEnd'),
            endMidnight = (dateEnd.valueOf() === toMidnight(dateEnd).valueOf()),
            oneDayPeriod, parsed;

        try {
            parsed = $.datepicker.parseDate('dd.mm.yy', value);
        } catch (e) {
            return;
        }

        // handle errors and too large values
        if (!parsed || parsed < this._dateMin || parsed > this._dateMax) { return; }

        parsed = nsGmx.CalendarWidget1.fromUTC(parsed);

        oneDayPeriod = (parsed.valueOf() === dateBegin.valueOf());
        oneDayPeriod ? this.setMode(Calendar1.SIMPLE_MODE) : this.setMode(Calendar1.ADVANCED_MODE);

        if (type === 'begin') {
            this._dateBegin.datepicker('setDate', parsed);
            if (parsed > new Date(dateEnd.valueOf() - dayms)) {
                this._dateEnd.datepicker('setDate', parsed);
                $(endInput).val(e.target.value);
                this._selectFunc(endInput);
            }
            this._dateInterval.set({
                dateBegin: new Date(parsed.valueOf()),
                dateEnd: new Date(parsed.valueOf() + dayms)
            });
        } else {
            this._dateEnd.datepicker('setDate', parsed);
            if (parsed < dateBegin) {
                this._dateBegin.datepicker('setDate', parsed);
                $(beginInput).val(e.target.value);
                this._selectFunc(beginInput);
                this._dateInterval.set({
                    dateBegin: new Date(parsed.valueOf()),
                    dateEnd: new Date(parsed.valueOf() + dayms)
                });
            } else if (parsed > dateBegin) {
                this._dateInterval.set({
                    dateEnd: new Date(parsed.valueOf() + dayms)
                });
            }
        }

        this._selectFunc(e.target);
        this.showCalendar(e);
    },

    enableDailyFilter: function () {
        var dailyFilter = this.model.get('dailyFilter'),
            timeBeginValue = this.$('.CalendarWidget-timeBegin').val(),
            timeEndValue = this.$('.CalendarWidget-timeEnd').val();

        if (dailyFilter) {
            if (Number(timeBeginValue) >= Number(timeEndValue)) {
                this.$('.CalendarWidget-timeBegin').addClass('error');
                this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
                this.$('.CalendarWidget-timeEnd').addClass('error');
            } else {
                this.$('.CalendarWidget-timeBegin').removeClass('error');
                this.$('.CalendarWidget-inputCell-inputTimeMiddle').removeClass('error');
                this.$('.CalendarWidget-timeEnd').removeClass('error');
            }
        } else {
            this.$('.CalendarWidget-timeBegin').removeClass('error');
            this.$('.CalendarWidget-inputCell-inputTimeMiddle').removeClass('error');
            this.$('.CalendarWidget-timeEnd').removeClass('error');
        }
        this.$('.CalendarWidget-timeBegin').trigger('blur');
        this.$('.CalendarWidget-timeEnd').trigger('blur');
    },

    _selectTime: function (e) {
        var match = this._checkValue(e.target.value);

        if (!match) {
            this.$('.CalendarWidget-timeBegin').addClass('error');
            this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
            this.$('.CalendarWidget-timeEnd').addClass('error');
            return;
        }

        // $(e.target).removeClass('error');

        var isBegin = $(e.target).hasClass('CalendarWidget-timeBegin'),
            dayms = nsGmx.DateInterval.MS_IN_DAY,
            dailyFilter = this.model.get('dailyFilter'),
            timeBeginValue = this.$('.CalendarWidget-timeBegin').val(),
            timeEndValue = this.$('.CalendarWidget-timeEnd').val(),
            msBeginInputValue = Calendar1.convertTimeValueToMs(timeBeginValue),
            msEndInputValue = Calendar1.convertTimeValueToMs(timeEndValue),
            dateBegin = this._dateInterval.get('dateBegin'),
            dateEnd = this._dateInterval.get('dateEnd'),
            hourBegin = Calendar1.getTime(dateBegin, 'begin'),
            hourEnd = Calendar1.getTime(dateEnd, 'end'),
            msBegin = Calendar1.convertTimeValueToMs(hourBegin),
            msEnd = Calendar1.convertTimeValueToMs(hourEnd),
            newDateBegin = new Date(dateBegin.valueOf() + (msBeginInputValue - msBegin)),
            newDateEnd = new Date(dateEnd.valueOf() + (msEndInputValue - msEnd));

            if (dailyFilter && Number(timeBeginValue) >= Number(timeEndValue)) {
                this.$('.CalendarWidget-timeBegin').addClass('error');
                this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
                this.$('.CalendarWidget-timeEnd').addClass('error');
                return;
            }

            if (newDateBegin.valueOf() >= newDateEnd.valueOf()) {
                this.$('.CalendarWidget-timeBegin').addClass('error');
                this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
                this.$('.CalendarWidget-timeEnd').addClass('error');
                return;
            } else {
                this.$('.CalendarWidget-timeBegin').removeClass('error');
                this.$('.CalendarWidget-inputCell-inputTimeMiddle').removeClass('error');
                this.$('.CalendarWidget-timeEnd').removeClass('error');
            }

        this._dateInterval.set({
            dateBegin: newDateBegin,
            dateEnd: newDateEnd
        });
    },

    _checkValue: function (value) {
        var hours = [
                '00', '01', '02', '03', '04', '05', '06', '07', '08', '09',
                '10', '11', '12', '13', '14', '15', '16', '17', '18', '19',
                '20', '21', '22', '23', '24'
             ],
             match = false;

        for (var i = 0; i < hours.length; i++) {
            if (value === hours[i]) {
                match = true;
            }
        }

        return match;
    },

    showCalendar: function (e) {
        var _this = this,
            beginInput = this.$('.CalendarWidget-dateBegin')[0],
            endInput = this.$('.CalendarWidget-dateEnd')[0],
            dateBegin = this._dateInterval.get('dateBegin'),
            dateEnd = this._dateInterval.get('dateEnd'),
            dayms = nsGmx.DateInterval.MS_IN_DAY,
            oneDayPeriod = (dateEnd.valueOf() - dateBegin.valueOf() === dayms),
            endMidnight = (dateEnd.valueOf() === toMidnight(dateEnd).valueOf());

        this.beginCalendar = $(this.calendarTemplates.beginTemplate({oneDayPeriod: oneDayPeriod}));
        this.endCalendar = $(this.calendarTemplates.endTemplate({}));

        var createIntervalButton = $('.createdateinterval-button', this.beginCalendar),
            resetIntervalButton = $('.resetdateinterval-button', this.beginCalendar),
            selectIntervalButton = $('.selectdateinterval-button', this.endCalendar),
            beginDialogOptions = {
                dialogClass: "calendar-outside begin-calendar",
                draggable: false,
                resizable: false,
                width: 224.8,
                height: 280,
                position: [372, 105],
                resizeFunc: function () {
                    return false;
                },
                closeFunc: function () {
                    _this._dateBegin.datepicker("destroy");
                },
            },
            endDialogOptions = {
                dialogClass: "calendar-outside end-calendar",
                draggable: false,
                resizable: false,
                width: 224.8,
                height: 280,
                position: [610, 105],
                resizeFunc: function () {
                    return false;
                },
                closeFunc: function () {
                    _this._dateEnd.datepicker("destroy");
                }
            };

        if (this._opened) {
            $(".calendar-outside .ui-dialog-titlebar-close").trigger('click');
            this._opened = false;
        }

        oneDayPeriod ? this.setMode(Calendar1.SIMPLE_MODE) : this.setMode(Calendar1.ADVANCED_MODE);

        this._dateBegin = $('.begin-outside-calendar', this.beginCalendar);
        this._dateEnd = $('.end-outside-calendar', this.endCalendar);

        this._dateInputs = this._dateBegin.add(this._dateEnd);

        this._dateInputs.datepicker();

        this._dateInputs.datepicker('option', 'minDate', Calendar1.toUTC(this._dateMin));
        this._dateInputs.datepicker('option', 'maxDate', Calendar1.toUTC(this._dateMax));

        this._dateBegin.datepicker('setDate', Calendar1.toUTC(dateBegin));
        this._dateEnd.datepicker('setDate', oneDayPeriod || endMidnight ? Calendar1.toUTC(new Date(dateEnd.valueOf() - dayms)) : Calendar1.toUTC(dateEnd));

        $(this.beginCalendar).dialog(beginDialogOptions);
        this._opened = true;

        if (this.getMode() === Calendar1.ADVANCED_MODE) {
            $(createIntervalButton).toggle(false);
            $(resetIntervalButton).toggle(true);
            $(this.endCalendar).dialog(endDialogOptions);
            this._opened = true;
        }

        // кнопки в первом календаре
        $(createIntervalButton).on('click', function () {
            var begin = _this._dateInterval.get('dateBegin'),
                end = _this._dateInterval.get('dateEnd');

            _this.setMode(Calendar1.ADVANCED_MODE);
            $(_this.endCalendar).dialog(endDialogOptions);
            _this._opened = true;

            $(this).toggle(false);
            $(resetIntervalButton).toggle(true);
        })

        $(resetIntervalButton).on('click', function () {
            var dateBegin = toMidnight(_this._dateInterval.get('dateBegin'));
            _this.setMode(Calendar1.SIMPLE_MODE);
            _this._dateBegin.datepicker('setDate', Calendar1.toUTC(dateBegin));
            _this._dateEnd.datepicker('setDate', Calendar1.toUTC(dateBegin));
            $(".calendar-outside.end-calendar .ui-dialog-titlebar-close").trigger('click');
            _this._opened = false;

            $(this).toggle(false);
            $(createIntervalButton).toggle(true);
            _this._dateInterval.set({
                dateBegin: dateBegin,
                dateEnd: new Date(dateBegin.valueOf() + dayms)
            })
        })

        // кнопка во втором календаре
        $(selectIntervalButton).on('click', function () {
            _this._updateModel();
            _this.setActive(true);
            _this._enableCreateIntervalButton();
            $(".calendar-outside .ui-dialog-titlebar-close").trigger('click');
            _this._opened = false;
        })
    },

    _enableCreateIntervalButton: function (e) {
        var dayms = nsGmx.DateInterval.MS_IN_DAY,
            selectIntervalButton = $('.selectdateinterval-button'),
            dateBegin = this._dateInterval.get('dateBegin'),
            dateEnd = this._dateInterval.get('dateEnd'),
            beginTimeValue = Calendar1.convertTimeValueToMs(e && e.target === $('CalendarWidget-timeBegin', this)[0] ? $(e.target).val() : $('.CalendarWidget-timeBegin').val()),
            endTimeValue = Calendar1.convertTimeValueToMs(e && e.target === $('CalendarWidget-timeEnd', this)[0] ? $(e.target).val() : $('.CalendarWidget-timeEnd').val()),
            calendarDateBegin = this.getDateBegin(),
            calendarDateEnd = this.getDateEnd(),
            newDateBegin = new Date(calendarDateBegin.valueOf() + beginTimeValue),
            newDateEnd = new Date(calendarDateEnd.valueOf() + endTimeValue);

        // если даты в итоге не поменялись или вторая дата больше первой
        if ((newDateBegin.valueOf() === dateBegin.valueOf() && newDateEnd.valueOf() === dateEnd.valueOf()) ||
            newDateBegin.valueOf() >= newDateEnd.valueOf()) {
                $(selectIntervalButton).addClass('disabled');
        } else {
            $(selectIntervalButton).removeClass('disabled');
        }
    },

    _shiftDates: function(delta) {
        var dateBegin = this._dateInterval.get('dateBegin'),
            dateEnd = this._dateInterval.get('dateEnd'),
            dayms = nsGmx.DateInterval.MS_IN_DAY,
            dailyFilter = this.model.get('dailyFilter'),
            shift;

        if (!dateBegin || !dateEnd) {
            return;
        }

        if (dailyFilter) {
            var diff = (toMidnight(dateEnd) - toMidnight(dateBegin));
            shift = diff ? diff * delta : dayms * delta;
        } else {
            shift = (dateEnd - dateBegin) * delta;
        }

        var newDateBegin = new Date(dateBegin.valueOf() + shift),
            newDateEnd = new Date(dateEnd.valueOf() + shift);

        if ((!this._dateMin || toMidnight(this._dateMin) <= toMidnight(newDateBegin)) &&
            (!this._dateMax || toMidnight(this._dateMax) >= toMidnight(newDateEnd)))
        {
            this._dateInterval.set({
                dateBegin: newDateBegin ? newDateBegin : null,
                dateEnd: newDateEnd ? newDateEnd : null
            });
        }
    },

    _selectFunc: function(activeInput) {
        var begin = this.getDateBegin(),
            end = this.getDateEnd(),
            dayms = nsGmx.DateInterval.MS_IN_DAY,
            selectIntervalButton = $('.selectdateinterval-button');

        if (end && begin && begin > end) {
            var dateToFix = activeInput[0] == this._dateEnd[0] ? this._dateBegin : this._dateEnd;

            dateToFix.datepicker('setDate', $(activeInput[0]).datepicker('getDate'));
        }
        if (this._curMode === Calendar1.SIMPLE_MODE) {
            if (!begin != !end || begin && begin.valueOf() !== end.valueOf()) {
                this._dateEnd.datepicker('setDate', this._dateBegin.datepicker('getDate'));
            }
            this._dateInterval.set({
                dateBegin: begin ? begin : null,
                dateEnd: end ? new Date(begin.valueOf() + nsGmx.DateInterval.MS_IN_DAY) : null
            });
        } else if (this._curMode === Calendar1.ADVANCED_MODE) {
            this._enableCreateIntervalButton();
        }
    },

    _updateModel: function() {
        // получаем значения с дейтпикеров и переводим их в локальное время
        var dateBegin = this.getDateBegin(),
            dateEnd = this.getDateEnd(),
            // значение часов
            beginTimeValue = Calendar1.convertTimeValueToMs($('.CalendarWidget-timeBegin').val()),
            endTimeValue = Calendar1.convertTimeValueToMs($('.CalendarWidget-timeEnd').val()),
            dayms = nsGmx.DateInterval.MS_IN_DAY,
            // если второй день захвачен полностью
            fullDay = endTimeValue === dayms;

        // добавим время к часам (в локальном времени)
        dateBegin = new Date(dateBegin.valueOf() + beginTimeValue);
        dateEnd = new Date(dateEnd.valueOf() + endTimeValue);

        this._dateInterval.set({
            dateBegin: dateBegin ? dateBegin : null,
            dateEnd: dateEnd ? dateEnd : null
        });
    },

    _updateWidget: function() {
        var dateBegin = this._dateInterval.get('dateBegin'),
            dateEnd = this._dateInterval.get('dateEnd'),
            hourBegin = Calendar1.getTime(dateBegin, 'begin'),
            hourEnd = Calendar1.getTime(dateEnd, 'end'),
            beginInput = this.$('.CalendarWidget-dateBegin')[0],
            endInput = this.$('.CalendarWidget-dateEnd')[0],
            timeBegin = this.$('.CalendarWidget-timeBegin')[0],
            timeEnd = this.$('.CalendarWidget-timeEnd')[0],
            dayms = nsGmx.DateInterval.MS_IN_DAY,
            newDateEnd;

        if (!dateBegin || !dateEnd) {
            return;
        };

        var newDateBegin = Calendar1.toUTC(dateBegin),
            newDateEnd = Calendar1.toUTC(new Date(dateEnd));

        // если календарь показывает ровно один день,
        // прибавляем 24 часа к первой дате, чтобы получить сутки
        if (dateEnd.valueOf() === toMidnight(dateEnd).valueOf()) {
            newDateEnd = Calendar1.toUTC(new Date(dateEnd - dayms));
        }

        $(beginInput).val(Calendar1.formatDate(newDateBegin));
        $(endInput).val(Calendar1.formatDate(newDateEnd));

        $(timeBegin).val(Calendar1.prefixTimeValue(hourBegin));
        $(timeEnd).val(Calendar1.prefixTimeValue(hourEnd));

        this.enableDailyFilter();
    },

    setActive: function (value) {
        var active = this.active;
        if (value !== active) {
            this.active = value;
        }

        if (this.active) {
            this.$el.removeClass('gmx-disabled')
        } else {
            this.$el.addClass('gmx-disabled')
        }
    },

    jumpByArrow: function (e, type) {
        var target = type === 'left' ? this.$('.CalendarWidget-inputCell-inputTimeBegin').find('input') : this.$('.CalendarWidget-inputCell-inputTimeEnd').find('input'),
            source = type === 'left' ? this.$('.CalendarWidget-inputCell-inputTimeEnd').find('input') : this.$('.CalendarWidget-inputCell-inputTimeBegin').find('input'),
            sourceElem = $(source).get(0),
            strEnd;

        switch (type) {
            case 'left':
                if (e.key === 'ArrowRight' && e.target.value.length === e.target.selectionEnd) {
                    $(target).blur();
                    $(source).focus();

                    strEnd = sourceElem.value.length || 0;

                    setTimeout(function () {
                        sourceElem.setSelectionRange(strEnd, strEnd);
                    }, 0);
                }
                break;
            case 'right':
                if (e.key === 'ArrowLeft' && e.target.selectionStart === 0) {
                    $(target).blur();
                    $(source).focus();

                    strEnd = sourceElem.value.length || 0;

                    setTimeout(function () {
                        sourceElem.setSelectionRange(strEnd, strEnd);
                    }, 0);
                }
                break;
            default: return;
        }
    },

    //public interface

    /** Закрыть все открытые datepicker'ы.
     * @return {nsGmx.CalendarWidget} this
     */
    reset: function() {
        this._dateInputs.datepicker('hide');
        return this;
    },

    /** Сериализация состояния виджета
     * @return {Object} Сериализованное состояние
     */
    saveState: function() {
        return {
            version: '1.1.0',
            vismode: this.getMode()
        }
    },

    /** Восстановить состояние виджета по сериализованным данным
     * @param {Object} data Сериализованное состояние календарика
     */
    loadState: function( data ) {
        this.setMode(data.vismode);
    },

    /** Получить начальную дату
     * @return {Date} начальная дата
     */
    getDateBegin: function() {
        return this._dateBegin ? Calendar1.fromUTC(this._dateBegin.datepicker('getDate')) : this.getDateInterval().get('dateBegin');
    },

    /** Получить конечную дату
     * @return {Date} конечная дата
     */
    getDateEnd: function() {
        return this._dateEnd ? Calendar1.fromUTC(this._dateEnd.datepicker('getDate')) : this.getDateInterval().get('dateEnd');
    },

    /** Получить верхнюю границу возможных дат периода
     * @return {Date} верхняя граница возможных периодов
     */
    getDateMax: function() {
        return this._dateMax;
    },

    /** Получить нижнуюю границу возможных дат периода
     * @return {Date} нижняя граница возможных периодов
     */
    getDateMin: function() {
        return this._dateMin;
    },

    /** Установить нижнуюю границу возможных дат периода
     * @param {Date} dateMin нижняя граница возможных периодов
     */
    setDateMin: function(dateMin) {
        this._dateMin = dateMin;
        this._dateInputs.datepicker('option', 'minDate', dateMin ? Calendar1.toUTC(dateMin) : null);
    },

    /** Установить верхнюю границу возможных дат периода
     * @param {Date} dateMax верхняя граница возможных периодов
     */
    setDateMax: function(dateMax) {
        // var titleContainer = this.$('.CalendarWidget-forecast');

        this._dateMax = dateMax;
        if (dateMax) {
            var utcDate = Calendar1.toUTC(dateMax);
            if (this._dateInputs) {
                this._dateInputs.datepicker('option', 'maxDate', utcDate);
            }

            if (dateMax > new Date()) {
            //     $(titleContainer).attr('title', _gtxt('CalendarWidget.tooltip') + ' ' +
            //     ('0' + dateMax.getDate()).slice(-2) + '-' +
            //     ('0' + (dateMax.getMonth() + 1)).slice(-2) + '-' +
            //     dateMax.getFullYear());
            //     $(titleContainer).show();
            // } else {
            //     $(titleContainer).hide();
            }

        } else {
            if (this._dateInputs) {
                this._dateInputs.datepicker('option', 'maxDate', null);
            }
        }
    },

    setSwitcherVisibility: function(isVisible) {
        this._showCalendarIcon && this._showCalendarIcon.toggle(isVisible);
    },

    getDateInterval: function() {
        return this._dateInterval;
    },

    getMode: function() {
        return this._curMode;
    },

    setMode: function(mode) {
        if (this._curMode === mode) {
            return this;
        }

        this._curMode = mode;
    }

}, {
    /* static methods */

    // date показывает в utc
    // нужно вычесть отрицательную разницу
    // utc 13:00
    // 13:00 - (-3 часа) = 16:00
    // locale 16:00
    // return locale date
    fromUTC: function(date) {
        if (!date) return null;
        var timeOffset = date.getTimezoneOffset()*60*1000;
        return new Date(date.valueOf() - timeOffset);
    },
    toUTC: function(date) {
        if (!date) return null;
        var timeOffset = date.getTimezoneOffset()*60*1000;
        return new Date(date.valueOf() + timeOffset);
    },
    formatDate: function(date) {
        var d = new Date(date),
        month = '' + (d.getMonth() + 1),
        day = '' + d.getDate(),
        year = d.getFullYear();

        if (month.length < 2) month = '0' + month;
        if (day.length < 2) day = '0' + day;

        return [day, month, year].join('.');
    },
    convertTimeValueToMs: function (value) {
        var ms = Number(value)*1000*3600;
        return ms;
    },
    getTime: function (date, position) {
        var dayms = nsGmx.DateInterval.MS_IN_DAY,
            offset, hours;

        if (position === 'begin') {
            offset = date.valueOf() - toMidnight(date).valueOf();
        } else {
            if (date.valueOf() === toMidnight(date).valueOf()) {
                offset = dayms;
            } else {
                offset = date.valueOf() - toMidnight(date).valueOf();
            }
        };

        hours = offset/(3600*1000);

        return hours;
    },

    prefixTimeValue: function (value) {
        value = Number(value);
        return value < 10 ? '0' + value : String(value);
    },
    SIMPLE_MODE: 1,
    ADVANCED_MODE: 2
});

nsGmx.CalendarWidget1 = Calendar1;

})(jQuery);

var nsGmx = window.nsGmx = window.nsGmx || {};
//<div class="alertWidget-message ui-state-{{type}}">{{message}}</div>
nsGmx.AlertWidget = nsGmx.GmxWidget.extend({
    className: 'alertWidget ui-widget',
    constructor: function() {
        this.collection = new Backbone.Collection();
        nsGmx.GmxWidget.apply(this, arguments);
    },
    initialize: function() {
        this.collection.on('add remove update', this.render, this);
        var msg = this._getMessageObject(arguments);
        if (msg) {
            this.collection.add(msg);
        }
    },
    // Вывести сообщение об ошибке
    // type может быть 'error' или 'warning'
    // push({ message: 'something wrong', type: 'warning', timeout: 200 }) или
    // push('something wrong', 'warning', 200)
    push: function() {
        var msg = this._getMessageObject(arguments);
        if (msg) {
            this.collection.add(msg);
        }
    },
    // удалить все сообщения
    clear: function() {
        this.collection.reset();
    },
    render: function() {
        this.$el.empty();
        for (var i = 0; i < this.collection.length; i++) {
            var m = this.collection.at(i);
            $('<div>')
                .addClass('alertWidget-message')
                .addClass('ui-state-' + m.get('type'))
                .html(m.get('message'))
                .appendTo(this.$el);
        }
        return this;
    },
    _getMessageObject: function(args) {
        if (args.length === 0 || !args[0]) {
            return null;
        } else if (args.length === 1) {
            return {
                message: args[0].message,
                type: args[0].type === 'warning' ? 'highlight' : 'error',
                timeout: args[0].timeout
            };
        } else {
            return {
                message: args[0],
                type: (args[1] && args[1] === 'warning') ? 'highlight' : 'error',
                timeout: args[2]
            };
        }
    }
});
var nsGmx = nsGmx || {};nsGmx.Templates = nsGmx.Templates || {};nsGmx.Templates.ShareIconControl = {};
nsGmx.Templates.ShareIconControl["shareDialog"] = "<div class=\"shareDialog-row shareDialog-title\">\n" +
    "    <span><%= nsGmx.Translations.getText('shareDialog.permalinkBelow') %></span>\n" +
    "    <a class=\"gmx-link gmx-link_icon shareDialog-socialShareLink shareDialog-socialShareLink_twitter\" target=\"_blank\"><i class=\"icon-twitter\"></i></a>\n" +
    "    <a class=\"gmx-link gmx-link_icon shareDialog-socialShareLink shareDialog-socialShareLink_facebook\" target=\"_blank\"><i class=\"icon-facebook\"></i></a>\n" +
    "    <a class=\"gmx-link gmx-link_icon shareDialog-socialShareLink shareDialog-socialShareLink_vk\" target=\"_blank\"><i class=\"icon-vk\"></i></a>\n" +
    "</div>\n" +
    "<div class=\"shareDialog-row\">\n" +
    "    <div class=\"gmx-table\">\n" +
    "        <div class=\"gmx-table-cell shareDialog-permalinkUrlCell\">\n" +
    "            <input class=\"gmx-input-text gmx-input-text_maxwidth gmx-input-text_readonly shareDialog-inputPermalinkUrl\" type=\"text\" readonly=\"readonly\" />\n" +
    "        </div>\n" +
    "        <div class=\"gmx-table-cell shareDialog-permalinkUrlPreviewButtonCell\">\n" +
    "            <a class=\"gmx-link gmx-link_icon shareDialog-permalinkUrlPreviewButton\" target=\"_blank\"><i class=\"icon-link-ext\" title=\"<%= nsGmx.Translations.getText('shareDialog.newWin') %>\"></i></a>\n" +
    "        </div>\n" +
    "    </div>\n" +
    "</div>\n" +
    "<div class=\"shareDialog-row shareDialog-title\"><%= nsGmx.Translations.getText('shareDialog.embeddedBelow') %></div>\n" +
    "<div class=\"shareDialog-row\">\n" +
    "    <table><tr><td class=\"shareDialog-resolutionTable-cell\">\n" +
    "    <div class=\"gmx-table shareDialog-resolutionTable\">\n" +
    "        <div class=\"gmx-table-cell shareDialog-previewResolutionCell\">\n" +
    "            <input class=\"gmx-input-text shareDialog-inputIframeWidth\" type=\"text\" value=\"<%= iframeWidth %>\"/>\n" +
    "            <span class=\"shareDialog-resolutionCross\">x</span>\n" +
    "            <input class=\"gmx-input-text shareDialog-inputIframeHeight\" type=\"text\" value=\"<%= iframeHeight %>\" />\n" +
    "        </div>\n" +
    "    </div>\n" +
    "    </td><td>\n" +
    "    <div class=\"gmx-table-cell shareDialog-winnieLinkCell shareDialog-validationOk\">\n" +
    "        <a class=\"shareDialog-winnieLink gmx-link\" href=\"#\" target=\"_blank\"><%= nsGmx.Translations.getText('shareDialog.winnieLink') %></a><i class=\"gmx-icon icon-link-ext\"></i>\n" +
    "    </div>\n" +
    "    </td></tr></table>\n" +
    "</div>\n" +
    "<div class=\"shareDialog-row\">\n" +
    "    <textarea class=\"shareDialog-inputEmbedCode gmx-input-text gmx-input-text_maxwidth gmx-input-text_readonly shareDialog-validationOk\" readonly=\"readonly\">\n" +
    "        <%= embedCode %>\n" +
    "    </textarea>\n" +
    "    <div class=\"shareDialog-validationError shareDialog-validationErrorView\"></div>\n" +
    "</div>\n" +
    "\n" +
    "<div class=\"gmx-table-cell shareDialog-previewLinkCell ui-state-disabled shareDialog-validationError\">\n" +
    "    <span><%= nsGmx.Translations.getText('shareDialog.preview') %></span><i class=\"icon-link-ext\"></i>\n" +
    "</div>\n" +
    "<div class=\"gmx-table-cell shareDialog-previewLinkCell shareDialog-validationOk\">\n" +
    "    <a class=\"shareDialog-previewLink gmx-link\" href=\"#\" target=\"_blank\"><%= nsGmx.Translations.getText('shareDialog.preview') %></a><i class=\"gmx-icon icon-link-ext\"></i>\n" +
    "</div>";;
var nsGmx = nsGmx || {};

nsGmx.ShareIconControl = L.Control.gmxIcon.extend({
    options: {
        className: 'shareIcon',
        id: 'share',
        text: 'Share',
        style: {
            width: 'auto'
        }
    },
    onAdd: function(map) {
        if (map.options.svgSprite) {
            delete this.options.text;
            var proto = Object.getPrototypeOf(this.options);
            if (proto.text) {
                delete proto.text;
            }
        }
        this._container = L.Control.gmxIcon.prototype.onAdd.apply(this, arguments);
        this._shareDialogContainer = L.DomUtil.create('div', 'shareDialogContainer');

        L.DomEvent.addListener(this._shareDialogContainer, 'click', function (e) {
            L.DomEvent.stopPropagation(e);
        });

        $(this._container).popover({
            content: this._shareDialogContainer,
            container: this._container,
            placement: 'bottom',
            html: true
        });

        $(this._container).on('shown.bs.popover', function() {
            var shareDialog = new nsGmx.ShareIconControl.ShareDialog(_.pick(this.options, [
                'permalinkUrlTemplate',
                'embeddedUrlTemplate',
                'winnieUrlTemplate',
                'previewUrlTemplate',
                'embedCodeTemplate',
                'permalinkManager'
            ]));
            shareDialog.appendTo(this._shareDialogContainer);
        }.bind(this));

        $(this._container).on('hide.bs.popover', function() {
            $(this._shareDialogContainer).empty();
        }.bind(this));

        return this._container;
    }
});
;
nsGmx.ShareIconControl.ShareDialogModel = Backbone.Model.extend({
    validate: function(attrs, options) {
        // NaN check
        if (attrs.iframeWidth / 1 !== attrs.iframeWidth / 1) {
            return 'shareDialog.invalidWidth';
        }
        if (attrs.iframeHeight / 1 !== attrs.iframeHeight / 1) {
            return 'shareDialog.invalidHeight';
        }
    }
});

nsGmx.ShareIconControl.ShareDialog = nsGmx.GmxWidget.extend({
    className: 'shareDialog',
    options: {
        permalinkUrlTemplate: '{{origin}}?permalink={{permalinkId}}',
        embeddedUrlTemplate: '{{origin}}embedded.html{{#if winnieId}}?permalink={{winnieId}}{{/if}}',
        winnieUrlTemplate: '{{origin}}{{#if winnieId}}?config={{winnieId}}{{/if}}',
        previewUrlTemplate: '{{origin}}iframePreview.html?width={{width}}&height={{height}}&permalinkUrl={{{embeddedUrl}}}',
        embedCodeTemplate: '<iframe src="{{{embeddedUrl}}}" width="{{width}}" height="{{height}}"></iframe>'
    },
    events: function() {
        return {
            'click .shareDialog-inputPermalinkUrl': function(e) {
                e.target.select();
            },
            'click .shareDialog-inputEmbedCode': function(e) {
                e.target.select();
            },
            'input .shareDialog-inputIframeWidth': this._setModelPropertyFn('iframeWidth'),
            'input .shareDialog-inputIframeHeight': this._setModelPropertyFn('iframeHeight'),
            'change .shareDialog-inputIframeWidth': this._setModelPropertyFn('iframeWidth'),
            'change .shareDialog-inputIframeHeight': this._setModelPropertyFn('iframeHeight')
        }
    },
    constructor: function(options) {
        nsGmx.GmxWidget.call(this, _.extend({
            model: new nsGmx.ShareIconControl.ShareDialogModel({
                permalinkId: '',
                winnieId: '',
                includePermalink: true,
                iframeWidth: 800,
                iframeHeight: 600,
                embedCode: '',
                error: ''
            })
        }, options));
    },
    initialize: function(options) {
        this.options = _.extend(this.options, options);
        this._terminateMouseEvents();
        this._permalinkManager = options.permalinkManager;
        this.createPermalink().then(null, function(err) {
            console.error(err);
        });
    },
    render: function() {
        if (this.model.get('error')) {
            return this._renderError();
        }
        if (!this.model.get('permalinkId')) {
            return this._renderLoader();
        }
        var changed = arguments[0] && arguments[0].changed;
        if (changed && (changed.iframeWidth || changed.iframeHeight)) {
            this._updateFields();
            return this;
        }
        this._renderDialog();
        return this;
    },
    createPermalink: function() {
        return $.Deferred(function(def) {
            this.model.set('permalinkId', '');
            this.model.set('error', '');
            this._permalinkManager.save()
                .then(function(permalinkId, winnieId) {
                    this.model.set({
                        permalinkId: permalinkId,
                        winnieId: winnieId
                    });
                    def.resolve();
                }.bind(this), function() {
                    this.model.set('error', 'shareDialog.permalinkError');
                    def.reject();
                }.bind(this))
                .fail(function(err) {
                    console.error(err);
                });
        }.bind(this)).promise();
    },
    appendTo: function() {
        nsGmx.GmxWidget.prototype.appendTo.apply(this, arguments);
        this.model.on('change', this.render, this);
        this.render();
    },
    _setModelPropertyFn: function(property) {
        return function(e) {
            this.model.set(property, $(e.currentTarget).val());
        }
    },
    _renderLoader: function() {
        this.undelegateEvents();
        this.$el.html(nsGmx.Translations.getText('shareDialog.creatingPermalink'));
        return this;
    },
    _renderError: function() {
        this.undelegateEvents();
        this.$el.html(nsGmx.Translations.getText(this.model.get('error')));
        return this;
    },
    _renderDialog: function() {
        this.undelegateEvents();
        this.$el.html(_.template(nsGmx.Templates.ShareIconControl.shareDialog)(this.model.attributes));
        this.errorsView = new nsGmx.AlertWidget();
        this.errorsView.appendTo(this.$('.shareDialog-validationErrorView'));
        this._updateFields();
        this.delegateEvents();
        this.$el.contextmenu(function (e) {
            e.stopPropagation();
            return true;
        });
        return this;
    },
    _updateFields: function() {
        var urls = this._generateUrls();
        this.errorsView.clear();
        if (this.model.isValid()) {
            this.$el.find('.shareDialog-validationOk').show();
            this.$el.find('.shareDialog-validationError').hide();
        } else {
            this.errorsView.push(nsGmx.Translations.getText(this.model.validationError), 'error');
            this.$el.find('.shareDialog-validationOk').hide();
            this.$el.find('.shareDialog-validationError').show();
        }
        this.$el.find('.shareDialog-inputPermalinkUrl').val(urls.permalinkUrl);
        this.$el.find('.shareDialog-permalinkUrlPreviewButton').attr('href', urls.permalinkUrl);
        this.$el.find('.shareDialog-previewLink').attr('href', urls.previewUrl);
        this.$el.find('.shareDialog-winnieLink').attr('href', urls.winnieUrl);
        this.$el.find('.shareDialog-inputEmbedCode').html(urls.embedCode);

        this.$el.find('.shareDialog-socialShareLink_vk').attr('href', urls.vkShareUrl);
        this.$el.find('.shareDialog-socialShareLink_twitter').attr('href', urls.twitterShareUrl);
        this.$el.find('.shareDialog-socialShareLink_facebook').attr('href', urls.facebookShareUrl);
    },
    _generateUrls: function() {
        var escapeHtml = function(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        var tpl = Handlebars.compile;
        var urls = {};

        var origin = window.location.protocol + '//' + window.location.host + '/';
        var href = window.location.search ? window.location.href.split(window.location.search)[0] : window.location.href;

        var permalinkUrl = urls.permalinkUrl = tpl(this.options.permalinkUrlTemplate)({
            origin: origin,
            href: href,
            permalinkId: this.model.get('permalinkId')
        });

        var embeddedUrl = urls.embeddedUrl = tpl(this.options.embeddedUrlTemplate)({
            origin: origin,
            href: href,
            winnieId: this.model.get('includePermalink') ? this.model.get('winnieId') : false            
        });

        var previewUrl = urls.previewUrl = tpl(this.options.previewUrlTemplate)({
            origin: origin,
            href: href,
            embeddedUrl: encodeURIComponent(embeddedUrl),
            width: this.model.get('iframeWidth'),
            height: this.model.get('iframeHeight')
        });
        
        var winnieUrl = urls.winnieUrl = tpl(this.options.winnieUrlTemplate)({
            origin: origin,
            href: href,
            winnieId: this.model.get('winnieId')
        });

        var embedCode = urls.embedCode = escapeHtml(tpl(this.options.embedCodeTemplate)({
            embeddedUrl: embeddedUrl,
            href: href,
            width: this.model.get('iframeWidth'),
            height: this.model.get('iframeHeight')
        }));

        var vkShareUrl = urls.vkShareUrl = tpl('http://vkontakte.ru/share.php?url={{urltoshare}}')({
            urltoshare: escape(permalinkUrl)
        });

        var twitterShareUrl = urls.twitterShareUrl = tpl('http://www.twitter.com/share?url={{urltoshare}}')({
            urltoshare: escape(permalinkUrl)
        });

        var facebookShareUrl = urls.facebookShareUrl = tpl('https://www.facebook.com/sharer/sharer.php?u={{urltoshare}}')({
            urltoshare: escape(permalinkUrl)
        });

        return urls;
    }
});
nsGmx.Translations.addText('rus', {
    shareDialog: {
        permalinkBelow: 'Ссылка на карту:',
        embeddedBelow: 'Код для вставки:',
        creatingPermalink: 'формирование ссылки..',
        invalidWidth: 'Некорректная ширина фрейма',
        invalidHeight: 'Некорректная высота фрейма',
        newWin: 'открыть в новом окне',
        includePermalink: 'добавить пермалинк',
        preview: 'предпросмотр',
        winnieLink: 'конструктор приложений'
    }
});

nsGmx.Translations.addText('eng', {
    shareDialog: {
        permalinkBelow: 'Share link:',
        embeddedBelow: 'Embed map:',
        creatingPermalink: 'creating permalink..',
        invalidWidth: 'Invalid frame width',
        invalidHeight: 'Invalid frame height',
        newWin: 'open in new window',
        includePermalink: 'include permalink',
        preview: 'preview',
        winnieLink: 'application constructor'
    }
});
;
/*eslint-env commonjs, browser */
(function(factory) {
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory(require('leaflet'));
    } else {
        window.L.control.iconLayers = factory(window.L);
        window.L.Control.IconLayers = window.L.control.iconLayers.Constructor;
    }
})(function(L) {
    function each(o, cb) {
        for (var p in o) {
            if (o.hasOwnProperty(p)) {
                cb(o[p], p, o);
            }
        }
    }

    function find(ar, cb) {
        if (ar.length) {
            for (var i = 0; i < ar.length; i++) {
                if (cb(ar[i])) {
                    return ar[i];
                }
            }
        } else {
            for (var p in ar) {
                if (ar.hasOwnProperty(p) && cb(ar[p])) {
                    return ar[p];
                }
            }
        }
    }

    function first(o) {
        for (var p in o) {
            if (o.hasOwnProperty(p)) {
                return o[p];
            }
        }
    }

    function length(o) {
        var length = 0;
        for (var p in o) {
            if (o.hasOwnProperty(p)) {
                length++;
            }
        }
        return length;
    }

    function prepend(parent, el) {
        if (parent.children.length) {
            parent.insertBefore(el, parent.children[0]);
        } else {
            parent.appendChild(el);
        }
    }

    var IconLayers = L.Control.extend({
		includes: L.Evented ? L.Evented.prototype : L.Mixin.Events,
        _getActiveLayer: function() {
            if (this._activeLayerId) {
                return this._layers[this._activeLayerId];
            } else if (length(this._layers)) {
                return first(this._layers);
            } else {
                return null;
            }
        },
        _getPreviousLayer: function() {
            var activeLayer = this._getActiveLayer();
            if (!activeLayer) {
                return null;
            } else if (this._previousLayerId) {
                return this._layers[this._previousLayerId];
            } else {
                return find(this._layers, function(l) {
                    return l.id !== activeLayer.id;
                }.bind(this)) || null;
            }
        },
        _getInactiveLayers: function() {
            var ar = [];
            var activeLayerId = this._getActiveLayer() ? this._getActiveLayer().id : null;
            var previousLayerId = this._getPreviousLayer() ? this._getPreviousLayer().id : null;
            each(this._layers, function(l) {
                if ((l.id !== activeLayerId) && (l.id !== previousLayerId)) {
                    ar.push(l);
                }
            });
            return ar;
        },
        _arrangeLayers: function() {
            var behaviors = {};
            behaviors.previous = function() {
                var layers = this._getInactiveLayers();
                if (this._getActiveLayer()) {
                    layers.unshift(this._getActiveLayer());
                }
                if (this._getPreviousLayer()) {
                    layers.unshift(this._getPreviousLayer());
                }
                return layers;
            };
            return behaviors[this.options.behavior].apply(this, arguments);
        },
        _getLayerCellByLayerId: function(id) {
            var els = this._container.getElementsByClassName('leaflet-iconLayers-layerCell');
            for (var i = 0; i < els.length; i++) {
                if (els[i].getAttribute('data-layerid') == id) {
                    return els[i];
                }
            }
        },
        _createLayerElement: function(layerObj) {
            var el = L.DomUtil.create('div', 'leaflet-iconLayers-layer');
            if (layerObj.title) {
                var titleContainerEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerTitleContainer');
                var titleEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerTitle');
                var checkIconEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerCheckIcon');
                titleEl.innerHTML = layerObj.title;
                titleContainerEl.appendChild(titleEl);
                el.appendChild(titleContainerEl);
                el.appendChild(checkIconEl);
            }
            if (layerObj.icon) {
                el.setAttribute('style', 'background-image: url(\'' + layerObj.icon + '\')');
            }
            return el;
        },
        _createLayerElements: function() {
            var currentRow, layerCell;
            var layers = this._arrangeLayers();
            var activeLayerId = this._getActiveLayer() && this._getActiveLayer().id;

            for (var i = 0; i < layers.length; i++) {
                if (i % this.options.maxLayersInRow === 0) {
                    currentRow = L.DomUtil.create('div', 'leaflet-iconLayers-layersRow');
                    if (this.options.position.indexOf('bottom') === -1) {
                        this._container.appendChild(currentRow);
                    } else {
                        prepend(this._container, currentRow);
                    }
                }
                layerCell = L.DomUtil.create('div', 'leaflet-iconLayers-layerCell');
                layerCell.setAttribute('data-layerid', layers[i].id);
                if (i !== 0) {
                    L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_hidden');
                }
                if (layers[i].id === activeLayerId) {
                    L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_active');
                }
                if (this._expandDirection === 'left') {
                    L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_expandLeft');
                } else {
                    L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_expandRight');
                }
                layerCell.appendChild(this._createLayerElement(layers[i]));

                if (this.options.position.indexOf('right') === -1) {
                    currentRow.appendChild(layerCell);
                } else {
                    prepend(currentRow, layerCell);
                }
            }
        },
        _onLayerClick: function(e) {
            e.stopPropagation();
            var layerId = e.currentTarget.getAttribute('data-layerid');
            var layer = this._layers[layerId];
            this.setActiveLayer(layer.layer);
            this.expand();
        },
        _attachEvents: function() {
            each(this._layers, function(l) {
                var e = this._getLayerCellByLayerId(l.id);
                if (e) {
                    e.addEventListener('click', this._onLayerClick.bind(this));
                }
            }.bind(this));
            var layersRowCollection = this._container.getElementsByClassName('leaflet-iconLayers-layersRow');

            var onMouseEnter = function(e) {
                e.stopPropagation();
                this.expand();
            }.bind(this);

            var onMouseLeave = function(e) {
                e.stopPropagation();
                this.collapse();
            }.bind(this);

            var stopPropagation = function(e) {
                e.stopPropagation();
            };

            //TODO Don't make functions within a loop.
            for (var i = 0; i < layersRowCollection.length; i++) {
                var el = layersRowCollection[i];
                el.addEventListener('mouseenter', onMouseEnter);
                el.addEventListener('mouseleave', onMouseLeave);
                el.addEventListener('mousemove', stopPropagation);
            }
        },
        _render: function() {
            this._container.innerHTML = '';
            this._createLayerElements();
            this._attachEvents();
        },
        _switchMapLayers: function() {
            if (!this._map) {
                return;
            }
            var activeLayer = this._getActiveLayer();
            var previousLayer = this._getPreviousLayer();
            if (previousLayer) {
                this._map.removeLayer(previousLayer.layer);
            } else {
                each(this._layers, function(layerObject) {
                    var layer = layerObject.layer;
                    this._map.removeLayer(layer);
                }.bind(this));
            }
            if (activeLayer) {
                this._map.addLayer(activeLayer.layer);
            }
        },
        options: {
            position: 'bottomleft', // one of expanding directions depends on this
            behavior: 'previous', // may be 'previous', 'expanded' or 'first'
            expand: 'horizontal', // or 'vertical'
            autoZIndex: true, // from L.Control.Layers
            maxLayersInRow: 5,
            manageLayers: true
        },
        initialize: function(layers, options) {
            if (!L.Util.isArray(arguments[0])) {
                // first argument is options
                options = layers;
                layers = [];
            }
            L.setOptions(this, options);
            this._expandDirection = (this.options.position.indexOf('left') != -1) ? 'right' : 'left';
            if (this.options.manageLayers) {
                this.on('activelayerchange', this._switchMapLayers, this);
            }
            this.setLayers(layers);
        },
        onAdd: function(map) {
            this._container = L.DomUtil.create('div', 'leaflet-iconLayers');
            L.DomUtil.addClass(this._container, 'leaflet-iconLayers_' + this.options.position);
            this._render();
            map.on('click', this.collapse, this);
            if (this.options.manageLayers) {
                this._switchMapLayers();
            }
            return this._container;
        },
        onRemove: function(map) {
            map.off('click', this.collapse, this);
        },
        setLayers: function(layers) {
            this._layers = {};
            layers.map(function(layer) {
                var id = L.stamp(layer.layer);
                this._layers[id] = L.extend(layer, {
                    id: id
                });
            }.bind(this));
            if (this._container) {
                this._render();
            }
        },
        setActiveLayer: function(layer) {
            var l = layer && this._layers[L.stamp(layer)];
            if (!l || l.id === this._activeLayerId) {
                return;
            }
            this._previousLayerId = this._activeLayerId;
            this._activeLayerId = l.id;
            if (this._container) {
                this._render();
            }
            this.fire('activelayerchange', {
                layer: layer
            });
        },
        expand: function() {
            this._arrangeLayers().slice(1).map(function(l) {
                var el = this._getLayerCellByLayerId(l.id);
                L.DomUtil.removeClass(el, 'leaflet-iconLayers-layerCell_hidden');
            }.bind(this));
        },
        collapse: function() {
            this._arrangeLayers().slice(1).map(function(l) {
                var el = this._getLayerCellByLayerId(l.id);
                L.DomUtil.addClass(el, 'leaflet-iconLayers-layerCell_hidden');
            }.bind(this));
        }
    });

    var iconLayers = function(layers, options) {
        return new IconLayers(layers, options);
    };

    iconLayers.Constructor = IconLayers;

    return iconLayers;
});
window.nsGmx.Translations.addText('rus', {
    gmxIconLayers: {
        zoominpls: 'Приблизьте карту, чтобы активировать слой',
        zoomoutpls: 'Отдалите карту, чтобы активировать слой'
    }
});

window.nsGmx.Translations.addText('eng', {
    gmxIconLayers: {
        zoominpls: 'Zoom in to enable layer',
        zoomoutpls: 'Zoom out to enable layer'
    }
});

window.L.Control.GmxIconLayers = window.L.Control.IconLayers.extend({
    _updateLayers: function() {
        var lang = nsGmx && nsGmx.Translations && nsGmx.Translations.getLanguage() || 'rus';
        var blm = this._baseLayersManager;
        var layers = blm.getActiveIDs().map(function(id) {
            var layer = blm.get(id);
            if (!layer) {
                return null;
            } else {
                return {
                    layer: layer,
                    icon: layer.options.icon,
                    title: layer.options[lang]
                }
            }
        }).filter(function(e) {
            return e;
        });

        this.setLayers(layers);
        this.setActiveLayer(
            blm.get(
                blm.getCurrentID()
            )
        );

        this._updateDisabledLayers();
    },
    _updateDisabledLayers: function() {
        this._disabledLayerIds = this._map ? this._baseLayersManager.getActiveIDs().map(function(id) {
            return this._baseLayersManager.get(id);
        }.bind(this)).filter(function(l) {
            return !!l && (this._map.getZoom() < l.options.minZoom || this._map.getZoom() > l.options.maxZoom);
        }.bind(this)).map(function(l) {
            return L.stamp(l) + '';
        }) : [];
        this._updateDisabledLayersStyle();
    },
    _updateDisabledLayersStyle: function() {
        var els = this._container ? this._container.getElementsByClassName('leaflet-iconLayers-layerCell') : [];

        Array.prototype.slice.call(els).map(function(el) {
            var elId = el.getAttribute('data-layerid');
            if (this._disabledLayerIds.indexOf(elId) + 1) {
                L.DomUtil.addClass(el, 'leaflet-iconLayers-layerCell_disabled');
            } else {
                L.DomUtil.removeClass(el, 'leaflet-iconLayers-layerCell_disabled');
            }
        }.bind(this));
    },
    _updatePopoversContent: function() {
        var els = this._container ? this._container.getElementsByClassName('leaflet-iconLayers-layerCell') : [];

        var defaultTemplate = (new $.fn.popover.Constructor()).getDefaults().template;

        function createPopover(el, text) {
            $(el).popover({
                viewport: {
                    selector: this._map && this._map.getContainer(),
                    padding: 10
                },
                container: this._map && this._map.getContainer(),
                content: text,
                trigger: 'manual',
                placement: this.options.position.indexOf('bottom') != -1 ? 'top' : 'bottom',
                html: true,
                template: $(defaultTemplate).css('pointer-events', 'none')[0].outerHTML
            });
            if (el.mouseIsOver) {
                $(el).popover('show');
            }
        }

        Array.prototype.slice.call(els).map(function(el) {
            var elId = el.getAttribute('data-layerid');
            var layerEl = el.getElementsByClassName('leaflet-iconLayers-layer')[0];
            var layer = this._layers[elId].layer;
            if (layer.options.maxZoom && this._map && this._map.getZoom() > layer.options.maxZoom) {
                $(layerEl).popover('destroy');
                createPopover.call(this, layerEl, nsGmx.Translations.getText('gmxIconLayers.zoomoutpls'));
            } else if (layer.options.minZoom && this._map && this._map.getZoom() < layer.options.minZoom) {
                $(layerEl).popover('destroy');
                createPopover.call(this, layerEl, nsGmx.Translations.getText('gmxIconLayers.zoominpls'));
            } else if (layer.options.description) {
                $(layerEl).popover('destroy');
                createPopover.call(this, layerEl, layer.options.description);
            } else {
                $(layerEl).popover('destroy');
            }
        }.bind(this));
    },
    _createLayerElement: function(layerObj) {
        var layer = layerObj.layer;
        var el = L.Control.IconLayers.prototype._createLayerElement.call(this, layerObj);
        var shutterEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerShutter');
        $(el).prepend(shutterEl);
        el.addEventListener('mouseover', function(e) {
            e.currentTarget.mouseIsOver = true;
            $(e.currentTarget).popover('show');
        });
        el.addEventListener('mouseout', function(e) {
            e.currentTarget.mouseIsOver = false;
            $(e.currentTarget).popover('hide');
        });
        return el;
    },
    _render: function() {
        L.Control.IconLayers.prototype._render.apply(this, arguments);
        this._updateDisabledLayers();
        this._updatePopoversContent();
    },
    _onLayerClick: function(e) {
        e.stopPropagation();
        $(e.currentTarget).find('.leaflet-iconLayers-layer').popover('hide')
        var layerId = e.currentTarget.getAttribute('data-layerid');
        if (this._disabledLayerIds.indexOf(layerId) === -1) {
            var layer = this._layers[layerId];
            this.setActiveLayer(layer.layer);
        }
        this.expand();
    },
    initialize: function(gmxBaseLayersManager, options) {
        L.Control.IconLayers.prototype.initialize.call(this, [], L.extend(options || {}, {
            manageLayers: false
        }));

        this._baseLayersManager = gmxBaseLayersManager;
        this._updateLayers();

        this.on('activelayerchange', function(le) {
            this._baseLayersManager.setCurrentID(le.layer.id);
        }.bind(this));

        this._baseLayersManager.on('baselayeradd', this._updateLayers.bind(this));
        this._baseLayersManager.on('baselayerremove', this._updateLayers.bind(this));
        this._baseLayersManager.on('baselayeractiveids', this._updateLayers.bind(this));
        this._baseLayersManager.on('baselayerchange', this._updateLayers.bind(this));
        this._baseLayersManager.on('baselayerlayerschange', this._updateLayers.bind(this));
    },
    onAdd: function() {
        var container = L.Control.IconLayers.prototype.onAdd.apply(this, arguments);
        this._map.on('zoomend', function() {
            this._updateDisabledLayers();
            this._updatePopoversContent();
        }.bind(this));
        return container;
    }
});

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 5);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SearchWidget = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(7);

var _ResultView = __webpack_require__(6);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function chain(tasks, state) {
    return tasks.reduce(function (prev, next) {
        return prev.then(next);
    }, new Promise(function (resolve, reject) {
        return resolve(state);
    }));
}

var SearchWidget = function () {
    function SearchWidget(container, _ref) {
        var placeHolder = _ref.placeHolder,
            providers = _ref.providers,
            _ref$suggestionTimeou = _ref.suggestionTimeout,
            suggestionTimeout = _ref$suggestionTimeou === undefined ? 1000 : _ref$suggestionTimeou,
            _ref$limit = _ref.limit,
            limit = _ref$limit === undefined ? 10 : _ref$limit,
            _ref$fuzzySearchLimit = _ref.fuzzySearchLimit,
            fuzzySearchLimit = _ref$fuzzySearchLimit === undefined ? 1000 : _ref$fuzzySearchLimit,
            _ref$retrieveManyOnEn = _ref.retrieveManyOnEnter,
            retrieveManyOnEnter = _ref$retrieveManyOnEn === undefined ? false : _ref$retrieveManyOnEn;

        _classCallCheck(this, SearchWidget);

        this._container = container;
        this._allowSuggestion = true;
        this._providers = providers;
        this._suggestionTimeout = suggestionTimeout;
        this._limit = limit;
        this._fuzzySearchLimit = fuzzySearchLimit;
        this._retrieveManyOnEnter = retrieveManyOnEnter;

        this._container.classList.add('leaflet-ext-search');
        this._container.innerHTML = '<input type="text" value="" placeholder="' + placeHolder + '" /><span class="leaflet-ext-search-button"></span>';
        this._input = this._container.querySelector('input');
        this._input.addEventListener('input', this._handleChange.bind(this));
        this._input.addEventListener('mousemove', this._handleMouseMove.bind(this));
        this._input.addEventListener('dragstart', this._handleMouseMove.bind(this));
        this._input.addEventListener('drag', this._handleMouseMove.bind(this));

        this._button = this._container.querySelector('.leaflet-ext-search-button');
        this._button.addEventListener('click', this._handleSearch.bind(this));

        this.results = new _ResultView.ResultView({
            input: this._input,
            onSelect: this._selectItem.bind(this),
            onEnter: this._search.bind(this)
        });

        // map.on ('click', this.results.hide.bind(this.results));
        // map.on ('dragstart', this.results.hide.bind(this.results));
    }

    _createClass(SearchWidget, [{
        key: '_suggest',
        value: function _suggest(text) {
            var _this = this;

            this.results.allowNavigation = false;
            var tasks = this._providers.filter(function (provider) {
                return provider.showSuggestion;
            }).map(function (provider) {
                return function (state) {
                    return new Promise(function (resolve) {
                        if (state.completed) {
                            resolve(state);
                        } else {
                            provider.find(text, _this._limit, false, false).then(function (response) {
                                state.completed = response.length > 0;
                                state.response = state.response.concat(response);
                                resolve(state);
                            }).catch(function (e) {
                                return console.log(e);
                            });
                        }
                    });
                };
            });
            chain(tasks, { completed: false, response: [] }).then(function (state) {
                _this.results.show(state.response, text.trim());
                _this.results.allowNavigation = true;
            });
        }
    }, {
        key: '_handleChange',
        value: function _handleChange(e) {
            var _this2 = this;

            if (this._input.value.length) {
                if (this._allowSuggestion) {
                    this._allowSuggestion = false;
                    this._timer = setTimeout(function () {
                        clearTimeout(_this2._timer);
                        _this2._allowSuggestion = true;
                        var text = _this2._input.value;
                        _this2._suggest(text);
                    }, this._suggestionTimeout);
                }
            } else {
                this.results.hide();
            }
        }
    }, {
        key: '_handleMouseMove',
        value: function _handleMouseMove(e) {
            e.stopPropagation();
        }
    }, {
        key: '_search',
        value: function _search(text) {
            var _this3 = this;

            var tasks = this._providers.filter(function (provider) {
                return provider.showOnEnter;
            }).map(function (provider) {
                return function (state) {
                    return new Promise(function (resolve) {
                        if (state.completed) {
                            resolve(state);
                        } else {
                            provider.find(text, _this3._retrieveManyOnEnter ? _this3._fuzzySearchLimit : 1, true, true).then(function (response) {
                                state.completed = response.length > 0;
                                state.response = state.response.concat(response);
                                resolve(state);
                            });
                        }
                    });
                };
            });

            chain(tasks, { completed: false, response: [] }).then(function (state) {
                // if(state.response.length > 0 && !this._retrieveManyOnEnter){
                //     let item = state.response[0];
                //     item.provider
                //     .fetch(item.properties)
                //     .then(response => {});                    
                // }
            });

            this.results && this.results.hide();
        }
    }, {
        key: '_selectItem',
        value: function _selectItem(item) {
            return item.provider.fetch(item.properties);
        }
    }, {
        key: '_handleSearch',
        value: function _handleSearch(e) {
            e.stopPropagation();
            this._search(this._input.value);
        }
    }, {
        key: 'setText',
        value: function setText(text) {
            this._input.value = text;
        }
    }, {
        key: 'setPlaceHolder',
        value: function setPlaceHolder(value) {
            this._input.placeholder = value;
        }
    }]);

    return SearchWidget;
}();

exports.SearchWidget = SearchWidget;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CadastreDataProvider = function () {
    function CadastreDataProvider(_ref) {
        var serverBase = _ref.serverBase,
            tolerance = _ref.tolerance,
            onFetch = _ref.onFetch;

        _classCallCheck(this, CadastreDataProvider);

        this._serverBase = serverBase;
        this._tolerance = tolerance;
        this._onFetch = onFetch;
        this.showSuggestion = true;
        this.showOnSelect = false;
        this.showOnEnter = true;
        this._cadastreLayers = [{ id: 1, title: 'Участок', reg: /^\d\d:\d+:\d+:\d+$/ }, { id: 2, title: 'Квартал', reg: /^\d\d:\d+:\d+$/ }, { id: 3, title: 'Район', reg: /^\d\d:\d+$/ }, { id: 4, title: 'Округ', reg: /^\d\d$/ }, { id: 5, title: 'ОКС', reg: /^\d\d:\d+:\d+:\d+:\d+$/ }, { id: 10, title: 'ЗОУИТ', reg: /^\d+\.\d+\.\d+/
            // ,
            // {id: 7, title: 'Границы', 	reg: /^\w+$/},
            // {id: 6, title: 'Тер.зоны', 	reg: /^\w+$/},
            // {id: 12, title: 'Лес', 		reg: /^\w+$/},
            // {id: 13, title: 'Красные линии', 		reg: /^\w+$/},
            // {id: 15, title: 'СРЗУ', 	reg: /^\w+$/},
            // {id: 16, title: 'ОЭЗ', 		reg: /^\w+$/},
            // {id: 9, title: 'ГОК', 		reg: /^\w+$/},
            // {id: 10, title: 'ЗОУИТ', 	reg: /^\w+$/}
            // /[^\d\:]/g,
            // /\d\d:\d+$/,
            // /\d\d:\d+:\d+$/,
            // /\d\d:\d+:\d+:\d+$/
        }];
    }

    _createClass(CadastreDataProvider, [{
        key: 'getCadastreLayer',
        value: function getCadastreLayer(str, type) {
            str = str.trim();
            for (var i = 0, len = this._cadastreLayers.length; i < len; i++) {
                var it = this._cadastreLayers[i];
                if (it.id === type) {
                    return it;
                }
                if (it.reg.exec(str)) {
                    return it;
                }
            }
            return this._cadastreLayers[0];
        }
    }, {
        key: 'find',
        value: function find(value, limit, strong, retrieveGeometry) {
            var _this = this;

            var cadastreLayer = this.getCadastreLayer(value);
            return new Promise(function (resolve) {
                // let req = new Request(`${this._serverBase}/typeahead?limit=${limit}&skip=0&text=${value}&type=${cadastreLayer.id}`);
                var req = new Request(_this._serverBase + '/features/' + cadastreLayer.id + '?text=' + value + '&tolerance=' + _this._tolerance + '&limit=' + limit);
                var headers = new Headers();
                headers.append('Content-Type', 'application/json');
                var init = {
                    method: 'GET',
                    mode: 'cors',
                    cache: 'default'
                };
                fetch(req, init).then(function (response) {
                    return response.json();
                }).then(function (json) {
                    // if(json.status === 200){
                    var rs = json.features.map(function (x) {
                        return {
                            name: x.attrs.name || x.attrs.cn || x.attrs.id,
                            properties: x,
                            provider: _this,
                            query: value
                        };
                    });
                    resolve(rs);
                    // }
                    // else {
                    // resolve(json);
                    // }                                       
                });
            });
        }
    }, {
        key: 'fetch',
        value: function (_fetch) {
            function fetch(_x) {
                return _fetch.apply(this, arguments);
            }

            fetch.toString = function () {
                return _fetch.toString();
            };

            return fetch;
        }(function (obj) {
            var _this2 = this;

            var text = obj.attrs.name || obj.attrs.cn || obj.attrs.id;
            var cadastreLayer = this.getCadastreLayer(text, obj.type);
            return new Promise(function (resolve) {
                if (cadastreLayer) {
                    // let req = new Request(`${this._serverBase}/features/${cadastreLayer.id}?tolerance=${this._tolerance}&limit=1&text=${obj.value}`);
                    var req = new Request(_this2._serverBase + '/features/' + cadastreLayer.id + '?tolerance=' + _this2._tolerance + '&limit=1&text=' + text);
                    var headers = new Headers();
                    headers.append('Content-Type', 'application/json');
                    var init = {
                        method: 'GET',
                        mode: 'cors',
                        cache: 'default'
                    };
                    fetch(req, init).then(function (response) {
                        return response.json();
                    }).then(function (json) {
                        if (json.status === 200) {
                            if (typeof _this2._onFetch === 'function') {
                                _this2._onFetch(json);
                            }
                            var rs = json.features.map(function (x) {
                                return {
                                    name: x.attrs.name || x.attrs.cn || x.attrs.id,
                                    properties: x,
                                    provider: _this2,
                                    query: obj
                                };
                            });
                            resolve(rs);
                        } else {
                            resolve(json);
                        }
                    });
                } else {
                    resolve([]);
                }
            });
        })
    }]);

    return CadastreDataProvider;
}();

window.nsGmx = window.nsGmx || {};
window.nsGmx.CadastreDataProvider = CadastreDataProvider;

exports.CadastreDataProvider = CadastreDataProvider;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CoordinatesDataProvider = function () {
    function CoordinatesDataProvider(_ref) {
        var onFetch = _ref.onFetch;

        _classCallCheck(this, CoordinatesDataProvider);

        this._onFetch = onFetch;
        this.showSuggestion = false;
        this.showOnSelect = false;
        this.showOnEnter = true;
        this.fetch = this.fetch.bind(this);
        this.find = this.find.bind(this);

        this.rxF = new RegExp('^\\s*\\-?(\\d+(\\.\\d+)?)(\\s+[N|S])?(,\\s*|\\s+)\\-?(\\d+(\\.\\d+)?)(\\s+[E|W])?');
        this.rxD = new RegExp('^\\s*(\\d{1,2})[\\s|\\u00b0](\\d{1,2})[\\s|\\u0027](\\d{1,2}\\.\\d+)\\u0022?(\\s+[N|S])?,?\\s+(\\d{1,2})[\\s|\\u00b0](\\d{1,2})[\\s|\\u0027](\\d{1,2}\\.\\d+)\\u0022?(\\s+[E|W])?');
    }

    _createClass(CoordinatesDataProvider, [{
        key: '_parseCoordinates',
        value: function _parseCoordinates(value) {
            var m = this.rxD.exec(value);
            if (Array.isArray(m) && m.length === 9) {
                return this._parseDegrees([m[1], m[2], m[3], m[5], m[6], m[7]].map(function (x) {
                    return parseFloat(x);
                }));
            }
            m = this.rxF.exec(value);
            if (Array.isArray(m) && m.length === 8) {
                return { type: 'Point', coordinates: [parseFloat(m[5]), parseFloat(m[1])] };
            }

            return null;
        }
    }, {
        key: '_parseDegrees',
        value: function _parseDegrees(_ref2) {
            var _ref3 = _slicedToArray(_ref2, 6),
                latDeg = _ref3[0],
                latMin = _ref3[1],
                latSec = _ref3[2],
                lngDeg = _ref3[3],
                lngMin = _ref3[4],
                lngSec = _ref3[5];

            return { type: 'Point', coordinates: [lngDeg + lngMin / 60 + lngSec / 3600, latDeg + latMin / 60 + latSec / 3600] };
        }
    }, {
        key: 'fetch',
        value: function fetch(value) {
            return new Promise(function (resolve) {
                return resolve([]);
            });
        }
    }, {
        key: 'find',
        value: function find(value, limit, strong, retrieveGeometry) {
            var _this = this;

            var g = this._parseCoordinates(value);
            return new Promise(function (resolve) {
                var result = { feature: { type: 'Feature', geometry: g, properties: {} }, provider: _this, query: value };
                if (g && typeof _this._onFetch === 'function') {
                    _this._onFetch(result);
                }
                resolve(g ? [result] : []);
            });
        }
    }]);

    return CoordinatesDataProvider;
}();

window.nsGmx = window.nsGmx || {};
window.nsGmx.CoordinatesDataProvider = CoordinatesDataProvider;

exports.CoordinatesDataProvider = CoordinatesDataProvider;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var OsmDataProvider = function () {
    function OsmDataProvider(_ref) {
        var serverBase = _ref.serverBase,
            onFetch = _ref.onFetch;

        _classCallCheck(this, OsmDataProvider);

        this._serverBase = serverBase;
        this._onFetch = onFetch;
        this.showSuggestion = true;
        this.showOnSelect = true;
        this.showOnEnter = true;
        this.find = this.find.bind(this);
        this.fetch = this.fetch.bind(this);
        this._convertGeometry = this._convertGeometry.bind(this);

        this._key = window.KOSMOSNIMKI_SESSION_KEY == null || window.KOSMOSNIMKI_SESSION_KEY == 'INVALID' ? '' : '&key=' + window.KOSMOSNIMKI_SESSION_KEY;
    }

    _createClass(OsmDataProvider, [{
        key: '_convertGeometry',
        value: function _convertGeometry(geometry) {
            switch (geometry.type.toUpperCase()) {
                case 'POINT':
                    geometry.type = 'Point';
                    break;
                case 'POLYGON':
                    geometry.type = 'Polygon';
                    break;
                case 'MULTIPOLYGON':
                    geometry.type = 'MultiPolygon';
                    break;
                case 'LINESTRING':
                case 'POLYLINE':
                    geometry.type = 'LineString';
                    break;
                case 'MULTILINESTRING':
                    geometry.type = 'MultiLineString';
                    break;
                default:
                    throw 'Unknown WKT type';
            }
            return geometry;
        }
    }, {
        key: 'fetch',
        value: function (_fetch) {
            function fetch(_x) {
                return _fetch.apply(this, arguments);
            }

            fetch.toString = function () {
                return _fetch.toString();
            };

            return fetch;
        }(function (obj) {
            var _this = this;

            var query = 'WrapStyle=None&RequestType=ID&ID=' + obj.ObjCode + '&TypeCode=' + obj.TypeCode + '&UseOSM=1';
            var req = new Request(this._serverBase + '/SearchObject/SearchAddress.ashx?' + query + this._key);
            var headers = new Headers();
            headers.append('Content-Type', 'application/json');
            var init = {
                method: 'GET',
                mode: 'cors',
                credentials: 'include',
                cache: 'default'
            };
            return new Promise(function (resolve, reject) {
                fetch(req, init).then(function (response) {
                    return response.json();
                }).then(function (json) {
                    if (json.Status === 'ok') {
                        var rs = json.Result.reduce(function (a, x) {
                            return a.concat(x.SearchResult);
                        }, []).map(function (x) {
                            var g = _this._convertGeometry(x.Geometry);
                            var props = Object.keys(x).filter(function (k) {
                                return k !== 'Geometry';
                            }).reduce(function (a, k) {
                                a[k] = x[k];
                                return a;
                            }, {});
                            return {
                                feature: {
                                    type: 'Feature',
                                    geometry: g,
                                    properties: props
                                },
                                provider: _this,
                                query: obj
                            };
                        });
                        if (typeof _this._onFetch === 'function') {
                            _this._onFetch(rs);
                        }
                        resolve(rs);
                    } else {
                        reject(json);
                    }
                }).catch(function (response) {
                    return reject(response);
                });
            });
        })
    }, {
        key: 'find',
        value: function find(value, limit, strong, retrieveGeometry) {
            var _this2 = this;

            var _strong = Boolean(strong) ? 1 : 0;
            var _withoutGeometry = Boolean(retrieveGeometry) ? 0 : 1;
            var query = 'WrapStyle=None&RequestType=SearchObject&IsStrongSearch=' + _strong + '&WithoutGeometry=' + _withoutGeometry + '&UseOSM=1&Limit=' + limit + '&SearchString=' + encodeURIComponent(value);
            var req = new Request(this._serverBase + '/SearchObject/SearchAddress.ashx?' + query + this._key);
            var headers = new Headers();
            headers.append('Content-Type', 'application/json');
            var init = {
                method: 'GET',
                mode: 'cors',
                credentials: 'include',
                cache: 'default'
            };
            return new Promise(function (resolve, reject) {
                fetch(req, init).then(function (response) {
                    return response.json();
                }).then(function (json) {
                    if (json.Status === 'ok') {
                        var rs = json.Result.reduce(function (a, x) {
                            return a.concat(x.SearchResult);
                        }, []).map(function (x) {
                            if (retrieveGeometry && x.Geometry) {
                                var g = _this2._convertGeometry(x.Geometry);
                                var props = Object.keys(x).filter(function (k) {
                                    return k !== 'Geometry';
                                }).reduce(function (a, k) {
                                    a[k] = x[k];
                                    return a;
                                }, {});
                                return {
                                    name: x.ObjNameShort,
                                    feature: {
                                        type: 'Feature',
                                        geometry: g,
                                        properties: props
                                    },
                                    properties: props,
                                    provider: _this2,
                                    query: value
                                };
                            } else {
                                return {
                                    name: x.ObjNameShort,
                                    properties: x,
                                    provider: _this2,
                                    query: value
                                };
                            }
                        });
                        if (typeof _this2._onFetch === 'function' && strong && retrieveGeometry) {
                            _this2._onFetch(rs);
                        }
                        resolve(rs);
                    } else {
                        reject(json);
                    }
                }).catch(function (response) {
                    return reject(response);
                });
            });
        }
    }]);

    return OsmDataProvider;
}();

window.nsGmx = window.nsGmx || {};
window.nsGmx.OsmDataProvider = OsmDataProvider;

exports.OsmDataProvider = OsmDataProvider;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SearchControl = undefined;

var _SearchWidget = __webpack_require__(0);

var SearchControl = L.Control.extend({
    includes: L.Evented ? L.Evented.prototype : L.Mixin.Events,
    initialize: function initialize(options) {
        L.setOptions(this, options);
        this._allowSuggestion = true;
        this.options.suggestionTimeout = this.options.suggestionTimeout || 1000;
        this.options.limit = this.options.limit || 10;
    },
    onAdd: function onAdd(map) {
        this._container = L.DomUtil.create('div', 'leaflet-ext-search');
        this._widget = new _SearchWidget.SearchWidget(this._container, this.options);
        map.on('click', this._widget.results.hide.bind(this._widget.results));
        map.on('dragstart', this._widget.results.hide.bind(this._widget.results));
        return this._container;
    },
    addTo: function addTo(map) {
        L.Control.prototype.addTo.call(this, map);
        if (this.options.addBefore) {
            this.addBefore(this.options.addBefore);
        }
        return this;
    },

    addBefore: function addBefore(id) {
        var parentNode = this._parent && this._parent._container;
        if (!parentNode) {
            parentNode = this._map && this._map._controlCorners[this.getPosition()];
        }
        if (!parentNode) {
            this.options.addBefore = id;
        } else {
            for (var i = 0, len = parentNode.childNodes.length; i < len; i++) {
                var it = parentNode.childNodes[i];
                if (id === it._id) {
                    parentNode.insertBefore(this._container, it);
                    break;
                }
            }
        }
        return this;
    },

    setText: function setText(text) {
        this._widget.setText(text);
    },
    setPlaceHolder: function setPlaceHolder(value) {
        this._widget.setPlaceHolder(value);
    }
});

exports.SearchControl = SearchControl;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _SearchWidget = __webpack_require__(0);

var _SearchControl = __webpack_require__(4);

var _OsmDataProvider = __webpack_require__(3);

var _CoordinatesDataProvider = __webpack_require__(2);

var _CadastreDataProvider = __webpack_require__(1);

window.nsGmx = window.nsGmx || {};
window.nsGmx.SearchWidget = _SearchWidget.SearchWidget;
window.nsGmx.SearchControl = _SearchControl.SearchControl;
window.nsGmx.OsmDataProvider = _OsmDataProvider.OsmDataProvider;
window.nsGmx.CoordinatesDataProvider = _CoordinatesDataProvider.CoordinatesDataProvider;
window.nsGmx.CadastreDataProvider = _CadastreDataProvider.CadastreDataProvider;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ResultView = function () {
    function ResultView(_ref) {
        var input = _ref.input,
            onSelect = _ref.onSelect,
            onEnter = _ref.onEnter,
            _ref$replaceInput = _ref.replaceInput,
            replaceInput = _ref$replaceInput === undefined ? false : _ref$replaceInput;

        _classCallCheck(this, ResultView);

        this._input = input;
        this._onSelect = onSelect;
        this._onEnter = onEnter;
        this.index = -1;
        this.count = 0;
        this._item = null;
        this._inputText = '';
        this._replaceInput = replaceInput;
        this._list = L.DomUtil.create('div');
        this._list.setAttribute('class', 'leaflet-ext-search-list noselect');

        this.allowNavigation = true;

        this._list.style.top = this._input.offsetTop + this._input.offsetHeight + 2 + 'px';
        this._list.style.left = this._input.offsetLeft + 'px';
        this._input.addEventListener('keydown', this._handleKey.bind(this));
        this._input.addEventListener('click', this._handleInputClick.bind(this));
        this._input.addEventListener('focus', this._handleFocus.bind(this));
        this._list.addEventListener('keydown', this._handleKey.bind(this));
        this._list.addEventListener('wheel', this._handleWheel.bind(this));
        L.DomEvent.disableClickPropagation(this._list).disableScrollPropagation(this._list);
        // this._list.addEventListener('mousewheel', this._handleWheel.bind(this));
        // this._list.addEventListener('MozMousePixelScroll', this._handleWheel.bind(this));       
        this._input.parentElement.appendChild(this._list);
        this._input.addEventListener('input', this._handleChange.bind(this));
    }

    _createClass(ResultView, [{
        key: '_handleInputClick',
        value: function _handleInputClick(e) {
            e.stopPropagation();
        }
    }, {
        key: '_handleFocus',
        value: function _handleFocus(e) {
            if (this.index >= 0) {
                var el = this._list.querySelector('[tabindex="' + this.index + '"]');
                L.DomUtil.removeClass(el, 'leaflet-ext-search-list-selected');
            }
            this.index = -1;
            this._item = null;
        }
    }, {
        key: '_handleChange',
        value: function _handleChange(e) {
            this._inputText = this._input.value;
        }
    }, {
        key: '_handleWheel',
        value: function _handleWheel(e) {
            e.stopPropagation();
        }
    }, {
        key: '_handleKey',
        value: function _handleKey(e) {
            if (this.listVisible()) {
                switch (e.keyCode) {
                    // ArroLeft / ArrowRight
                    case 37:
                    case 39:
                        e.stopPropagation();
                        break;
                    // ArrowDown
                    case 40:
                        e.preventDefault();
                        e.stopPropagation();
                        if (this.allowNavigation) {
                            if (this.index < 0) {
                                this.index = 0;
                            } else if (0 <= this.index && this.index < this.count - 1) {
                                var _el = this._list.querySelector('[tabindex="' + this.index + '"]');
                                L.DomUtil.removeClass(_el, 'leaflet-ext-search-list-selected');
                                ++this.index;
                            } else {
                                var _el2 = this._list.querySelector('[tabindex="' + this.index + '"]');
                                L.DomUtil.removeClass(_el2, 'leaflet-ext-search-list-selected');
                                this.index = this.count - 1;
                            }
                            var el = this._list.querySelector('[tabindex="' + this.index + '"]');
                            L.DomUtil.addClass(el, 'leaflet-ext-search-list-selected');
                            this.selectItem(this.index);
                            el.focus();
                        }
                        break;
                    // ArrowUp
                    case 38:
                        e.preventDefault();
                        e.stopPropagation();
                        if (this.allowNavigation) {
                            if (this.index > 0) {
                                var _el3 = this._list.querySelector('[tabindex="' + this.index + '"]');
                                L.DomUtil.removeClass(_el3, 'leaflet-ext-search-list-selected');
                                --this.index;
                                _el3 = this._list.querySelector('[tabindex="' + this.index + '"]');
                                L.DomUtil.addClass(_el3, 'leaflet-ext-search-list-selected');
                                this.selectItem(this.index);
                                _el3.focus();
                            } else if (this.index === 0) {
                                this._input.focus();
                                this._input.value = this._inputText;
                            }
                        }
                        break;
                    // Enter
                    case 13:
                        if (this.index < 0 && this._input.value && typeof this._onEnter === 'function') {
                            var text = this._input.value;
                            this._input.focus();
                            this._input.setSelectionRange(text.length, text.length);
                            this.hide();
                            this._onEnter(text);
                        } else {
                            this.complete(this.index);
                        }
                        break;
                    // Escape
                    case 27:
                        if (this.index < 0) {
                            this.hide();
                        }
                        this._input.focus();
                        this._input.value = this._inputText;
                        break;
                    default:
                        break;
                }
            } else {
                if (e.keyCode === 13 && this._input.value && typeof this._onEnter == 'function') {
                    var _text = this._input.value;
                    this._input.setSelectionRange(_text.length, _text.length);
                    this._onEnter(_text);
                } else if (e.keyCode === 27) {
                    this._input.value = '';
                    this.index = -1;
                    this._input.focus();
                }
            }
        }
    }, {
        key: 'listVisible',
        value: function listVisible() {
            return this.count > 0 && this._list.style.display !== 'none';
        }
    }, {
        key: 'selectItem',
        value: function selectItem(i) {
            this._item = this._items[i];
            var text = this._item.name;
            if (this._replaceInput) {
                this._input.value = text;
                this._input.setSelectionRange(text.length, text.length);
            }
        }
    }, {
        key: '_handleClick',
        value: function _handleClick(i, e) {
            e.preventDefault();
            this.complete(i);
        }
    }, {
        key: 'complete',
        value: function complete(i) {
            var item = i >= 0 ? this._items[i] : this._item ? this._item : null;
            if (item) {
                this._item = item;
                this.index = -1;
                var text = item.name;
                if (this._replaceInput) {
                    this._input.value = text;
                    this._input.setSelectionRange(text.length, text.length);
                }
                this._input.focus();
                this.hide();
                if (typeof this._onSelect === 'function') {
                    this._onSelect(item);
                }
            }
        }
    }, {
        key: 'show',
        value: function show(items, highlight) {
            if (items.length) {
                this._item = null;
                this.index = -1;
                this._items = items;
                var html = '<ul>' + this._items.filter(function (x) {
                    return x.name && x.name.length;
                }).map(function (x, i) {
                    var name = '<span class="leaflet-ext-search-list-item-normal">' + x.name + '</span>';
                    if (highlight && highlight.length) {
                        var start = x.name.toLowerCase().indexOf(highlight.toLowerCase());
                        if (start != -1) {
                            var head = x.name.substr(0, start);
                            if (head.length) {
                                head = '<span class="leaflet-ext-search-list-item-normal">' + head + '</span>';
                            }
                            var tail = x.name.substr(start + highlight.length);
                            if (tail.length) {
                                tail = '<span class="leaflet-ext-search-list-item-normal">' + tail + '</span>';
                            }
                            name = head + '<span class="leaflet-ext-search-list-item-highlight">' + highlight + '</span>' + tail;
                        }
                    }
                    return '<li tabindex=' + i + '>' + name + '</li>';
                }, []).join('') + '</ul>';

                this._list.innerHTML = html;
                var elements = this._list.querySelectorAll('li');
                for (var i = 0; i < elements.length; ++i) {
                    elements[i].addEventListener('click', this._handleClick.bind(this, i));
                }

                this.count = elements.length;
                this._list.style.display = 'block';
            }
        }
    }, {
        key: 'hide',
        value: function hide() {
            this._list.style.display = 'none';
        }
    }]);

    return ResultView;
}();

exports.ResultView = ResultView;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ })
/******/ ]);
//# sourceMappingURL=bundle.js.map
// COMMON CalendarWidget

var nsGmx = nsGmx || {};

(function($){

    nsGmx.Translations.addText("rus", { CommonCalendarWidget: {
        Timeline:    "Таймлайн",
        select: "Выберите мультивременной слой",
        sync: "Единый интервал для слоев",
        daily: "посуточно",
        on: "Включить синхронизацию слоев",
        off: "Выключить синхронизацию слоев",
        all: "Интервал для всех слоев"
    }});

    nsGmx.Translations.addText("eng", { CommonCalendarWidget: {
        Timeline:     "Timeline",
        select: "Select temporal layer",
        sync: "Single date interval",
        daily: "daily",
        on: "Layers sync on",
        off: "Layers sync off",
        all: "Интервал для всех слоев"
    }});

    var toMidnight = nsGmx.DateInterval.toMidnight,
        dayms = nsGmx.DateInterval.MS_IN_DAY;

    var calendarWidgetTemplate = '' +
        '<div class="commoncalendar-container">' +
            '<div class="calendar-layers-container">' +
                '<div class="calendar-container">' +
                    '<div class="calendar-widget-container"></div>' +
                '</div>' +
            '</div>' +
            '<div class="sync-switch-container switch-container">' +
                '<label class="sync-switch switch">' +
                    '<input type="checkbox"' +
                    '{{#if synchronyzed}}checked{{/if}}' +
                    '>' +
                    '<div class="sync-switch-slider switch-slider round"></div>' +
                '</label>' +
                '<span class="sync-switch-slider-description">{{i "CommonCalendarWidget.sync"}}</span>' +
                '<label class="daily-switch">' +
                    '<input type="checkbox"' +
                    '{{#if dailyFilter}}checked{{/if}}' +
                    '>' +
                    '{{i "CommonCalendarWidget.daily"}}' +
                '</label>' +
            '</div>' +
            '<div class="unsync-layers-container" style="display: none">' +
                '<select class="layersList">' +
                    '{{#each this.layers}}' +
                    '<option value="{{this.layer}}"' +
                        '{{#if this.current}} selected="selected"{{/if}}>' +
                        '{{this.layer}}' +
                    '</option>' +
                    '{{/each}}' +
                '</select>' +
            '</div>' +
        '</div>' ;
    'use strict';

    var _gtxt = nsGmx.Translations.getText.bind(nsGmx.Translations);

    var CommonCalendarModel = window.Backbone.Model.extend({
        defaults: {
            active: true,
            currentLayer: null,
            calendar: null,
            isAppended: false,
            unbindedTemporalLayers: {},
            dailyFiltersHash: {},
            dailyFilter: true,
            synchronyzed: true
        }
    });

    var CommonCalendar = window.Backbone.View.extend({
        tagName: 'div',
        model: new CommonCalendarModel(),
        className: 'CommonCalendarWidget ui-widget',
        template: Handlebars.compile(calendarWidgetTemplate),
        events: {
            'change .sync-switch': 'toggleSync',
            'change .daily-switch': 'toggleDailyFilter',
            'change .layersList': 'changeCurrentLayer'
        },
        initialize: function (options) {
            var _this = this;

            this.$el.html(this.template({
                synchronyzed: _this.model.get('synchronyzed'),
                layers: _this.model.get('visibleTemporalLayers'),
                dailyFilter: _this.model.get('dailyFilter')
            }));

            //for backward compatibility
            this.canvas = this.$el;
            this.dateInterval = new nsGmx.DateInterval();

            this.listenTo(this.model, 'change:synchronyzed', this.updateSync);
            this.listenTo(this.model, 'change:dailyFilter', (function () {
                this.handleFiltersHash();
                this.applyDailyFilter();
            }).bind(this));

            this.dateInterval.on('change', function () {
                _this.updateVisibleTemporalLayers(nsGmx.gmxMap.layers);
                if (_this.model.get('dailyFilter')) {
                    _this.applyDailyFilter();
                }
            });

            this._fillFiltersHash();
        },

        _fillFiltersHash: function(layers) {
            layers = layers || nsGmx.gmxMap.layers;

            var dailyFiltersHash = {};

            for (var i = 0; i < layers.length; i++) {
                var layer = layers[i],
                    props = layer.getGmxProperties(),
                    layerID = props.LayerID,
                    isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                if (isTemporalLayer) {
                    dailyFiltersHash[layerID] = true;
                }

                this.model.set('dailyFiltersHash', dailyFiltersHash);
            }
        },

        _clearFiltersHash: function (layers) {
            layers = layers || nsGmx.gmxMap.layers;

            var dailyFiltersHash = {};

            for (var i = 0; i < layers.length; i++) {
                var layer = layers[i],
                    props = layer.getGmxProperties(),
                    layerID = props.LayerID,
                    isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                if (isTemporalLayer) {
                    dailyFiltersHash[layerID] = false;
                }

                this.model.set('dailyFiltersHash', dailyFiltersHash);
            }
        },

        setDateInterval: function (dateBegin, dateEnd, layer) {
            if (layer) {
                this.setCurrentLayer(layer);
            }

            var oldBegin = this.dateInterval.get('dateBegin').valueOf(),
                oldEnd = this.dateInterval.get('dateEnd').valueOf();

            if (oldBegin === dateBegin.valueOf() && oldEnd === dateEnd.valueOf()) {
                this.updateTemporalLayers();

                this.updateVisibleTemporalLayers(nsGmx.gmxMap.layers);
                if (this.model.get('dailyFilter')) {
                    this.applyDailyFilter();
                }
                this.trigger('change:dateInterval');
            } else {
                this.dateInterval.set({
                    dateBegin: dateBegin,
                    dateEnd: dateEnd
                });
            }

            if (this.dateInterval.get('dailyFilter')) {
                this.applyDailyFilter();
            }
        },

        setCurrentLayer: function (layer) {
            var props = layer.getGmxProperties();

            this.model.set('currentLayer', props.LayerID);
        },

        changeCurrentLayer: function (e) {
            var _this = this,
                layerID = e.target.value;

            _this.model.set('currentLayer', layerID);
        },

        log: function () {
            var f = function(list) {
                var layers = nsGmx.gmxMap.layers;

                for (var i = 0; i < layers.length; i++) {
	               var layer = layers[i],
                        props = layer.getGmxProperties(),
                        t = props.title,
                        isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);
                        int = layer.getDateInterval();

                    if (isTemporalLayer && int) {
                        var b = int.beginDate.toString(),
                            e = int.endDate.toString();
                        list.push({
                            title: t,
                            beginDate: b,
                            endDate: e
                        });
                    }
	            }
	               console.table(list);
            };
            f([]);
        },

        getDateInterval: function () {
            return this.dateInterval;
        },

        get: function() {
            var attrs = this.model.toJSON(),
                _this = this,
                calendar;

            if (!attrs.calendar) {
                calendar = new nsGmx.CalendarWidget1({
                    minimized: false,
                    dateMin: new Date(2000, 1, 1),
                    dateMax: new Date(Date.now() + dayms) > _this.dateInterval.get('dateEnd') ? new Date(Date.now() + dayms) : _this.dateInterval.get('dateEnd'),
                    dateInterval: _this.dateInterval
                });

                this.dateInterval.on('change', this.updateTemporalLayers.bind(this, null));

                this.model.set('calendar', calendar);
            this.updateTemporalLayers();
            }

            return this.model.get('calendar');
        },

        replaceCalendarWidget: function(newCalendar) {
            this._calendar = newCalendar;

            //заменим виджет перед деревом слоёв
            if (this._isAppended) {
                var doChange = function() {
                    var calendarDiv = $('<div class="commoncalendar-container"></div>').append(newCalendar.canvas);
                    // special for steppe project
                    if (nsGmx.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
                        _queryMapLayers.getContainerAfter().find('.commoncalendar-container').replaceWith(calendarDiv);
                    } else {
                        _queryMapLayers.getContainerBefore().findcommoncalendar-container('.commoncalendar-container').replaceWith(calendarDiv);
                    }
                }
                //явная проверка, так как хочется быть максимально синхронными в этом методе
                if (_queryMapLayers.loadDeferred.state() === 'resolved') {
                    doChange();
                } else {
                    _queryMapLayers.loadDeferred.then(doChange);
                }
            }
        },

        show: function() {
            var calendarDiv = this.$('.calendar-widget-container'),
                calendarCanvas = this.get().canvas;

            $(_queryMapLayers.getContainerBefore()).append(calendarCanvas[0]);

            var doAdd = function() {
                calendarDiv.append(calendarCanvas);

                var commonCanvas = this.canvas;

                // special for steppe Project
                if (nsGmx.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
                    _queryMapLayers.getContainerAfter().append(commonCanvas);
                } else {
                    _queryMapLayers.getContainerBefore().append(commonCanvas);
                }
                this.model.set('isAppended', true);
            }.bind(this);

            if (!this.model.get('isAppended')) {
                //явная проверка, так как хочется быть максимально синхронными в этом методе
                if (_queryMapLayers.loadDeferred.state() === 'resolved') {
                    doAdd();
                } else {
                    _queryMapLayers.loadDeferred.then(doAdd);
                }
            }

            return this;
        },

        hide: function() {
            var attrs = this.model.toJSON();
            attrs._isAppended && $(this.get().canvas).hide();
            this.model.set('isAppended', true);

            return this;
        },

        bindLayer: function (layerName) {
            var attrs = this.model.toJSON(),
                unbindedTemporalLayers = attrs.unbindedTemporalLayers,
                clone = {};

            // clone object
            for (var variable in unbindedTemporalLayers) {
                if (unbindedTemporalLayers.hasOwnProperty(variable)) {
                    clone[variable] = unbindedTemporalLayers[variable];
                }
            };

            delete clone[layerName];

            this.model.set('unbindedTemporalLayers', clone);
            this.updateTemporalLayers();
        },

        unbindLayer: function (layerName) {
            var attrs = this.model.toJSON(),
                layer = nsGmx.gmxMap.layersByID[layerName];
            if (!layer) {
                return;
            }
            var props = layer.getGmxProperties(),
                unbindedTemporalLayers = attrs.unbindedTemporalLayers,
                clone = {};

            layer.removeLayerFilter({ id: 'dailyFilter' });
            // clone object
            for (var variable in unbindedTemporalLayers) {
                if (unbindedTemporalLayers.hasOwnProperty(variable)) {
                    clone[variable] = unbindedTemporalLayers[variable];
                }
            };

            clone[layerName] = true;
            this.model.set('unbindedTemporalLayers', clone);
            this.updateTemporalLayers([layer]);
        },

        _updateOneLayer: function(layer, dateBegin, dateEnd) {
            var props = layer.getGmxProperties();
            if (props.maxShownPeriod) {
                var msecPeriod = props.maxShownPeriod*24*3600*1000;
                var newDateBegin = new Date( Math.max(dateBegin.valueOf(), dateEnd.valueOf() - msecPeriod));
                layer.setDateInterval(newDateBegin, dateEnd);
            } else {
                layer.setDateInterval(dateBegin, dateEnd);
            }
        },

        updateTemporalLayers: function(layers) {
            layers = layers || nsGmx.gmxMap.layers;
            
            var attrs = this.model.toJSON(),
                synchronyzed = attrs.synchronyzed,
                dateBegin = this.dateInterval.get('dateBegin'),
                dateEnd = this.dateInterval.get('dateEnd'),
                currentLayer = attrs.currentLayer,
                layersMaxDates = [],
                maxDate = null,
                localeDate;

            if (!attrs.calendar) {return;}

            if (synchronyzed) {
                for (var i = 0, len = layers.length; i < len; i++) {
                    var layer = layers[i],
                    props = layer.getGmxProperties(),
                    isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                    if (isTemporalLayer && !(props.name in attrs.unbindedTemporalLayers)) {
                        if (props.DateEnd) {
                            if (typeof props.DateEnd === "string") {
                                localeDate = $.datepicker.parseDate('dd.mm.yy', props.DateEnd);
                            } else if (typeof props.DateEnd === "number") {
                                localeDate = new Date(props.DateEnd);
                            }

                            layersMaxDates.push(localeDate);
                        }

                        this._updateOneLayer(layer, dateBegin, dateEnd);
                    }
                }
            } else {
                if (currentLayer && !(currentLayer in attrs.unbindedTemporalLayers)) {
                    currentLayer = nsGmx.gmxMap.layersByID[currentLayer];
                    this._updateOneLayer(currentLayer, dateBegin, dateEnd);
                } else {
                    return;
                }
            }

            if (layersMaxDates.length > 0) {
                layersMaxDates.sort(function(a, b) {
                    return b - a;
                });

                maxDate = new Date(layersMaxDates[0]);

                if (maxDate > attrs.calendar.getDateMax()) {
                    attrs.calendar.setDateMax(nsGmx.CalendarWidget.fromUTC(new Date(maxDate.valueOf() + dayms)));
                }

                this.model.set('calendar', attrs.calendar);
            }
        },

        onDateIntervalChanged: function (e) {
            var attrs = this.model.toJSON(),
                currentLayer = attrs.currentLayer,
                layer = e.target,
                props,
                layerName,
                dateInterval, dateBegin, dateEnd;

            if (!currentLayer) {
                return;
            }

            props = layer.getGmxProperties(),
            layerID = props.LayerID;

            if (layerID in attrs.unbindedTemporalLayers) {
                return;
            }

            if (layerID === currentLayer) {
                if (props.maxShownPeriod) { return; }
                dateInterval = layer.getDateInterval(),
                dateBegin = dateInterval.beginDate,
                dateEnd = dateInterval.endDate;

                this.setDateInterval(dateBegin, dateEnd, layer);
            }
        },

        updateVisibleTemporalLayers: function (layers) {
            var _this = this,
                attrs = this.model.toJSON(),
                currentLayer = attrs.currentLayer,
                layersList = this.$('.layersList'),
                temporalLayers = [],
                layersArr = [],
                str = '';

            $.widget( "ui.temporallayersmenu", $.ui.selectmenu, {
                _renderItem: function(ul, item) {
                    var li = $( "<li>" );

                    if ( item.value ) {
                        var l = nsGmx.gmxMap.layersByID[item.value],
                            props = l.getGmxProperties(),
                            di = l.getDateInterval && l.getDateInterval(),
                            dateBegin, dateEnd,
                            hourBegin, hourEnd,
                            newDateBegin, newDateEnd,
                            str = '';

                        if (di) {
                            var now = new Date(),
                                dateBeginToMidnight = new Date(now - now % dayms);

                            // dateBegin = di.beginDate;
                            // dateEnd = di.endDate);
                            dateBegin = di.beginDate || dateBeginToMidnight;
                            dateEnd = di.endDate || new Date(dateBeginToMidnight.valueOf() + dayms);
                            hourBegin = nsGmx.CalendarWidget1.prefixTimeValue(nsGmx.CalendarWidget1.getTime(dateBegin, 'begin'));
                            hourEnd = nsGmx.CalendarWidget1.prefixTimeValue(nsGmx.CalendarWidget1.getTime(dateEnd, 'end'));
                            newDateBegin = nsGmx.CalendarWidget1.toUTC(dateBegin);
                            newDateEnd = nsGmx.CalendarWidget1.toUTC(dateEnd);

                            // если календарь показывает ровно один день,
                            // прибавляем 24 часа к первой дате, чтобы получить сутки
                            if (dateEnd.valueOf() === toMidnight(dateEnd).valueOf()) {
                                newDateEnd = nsGmx.CalendarWidget1.toUTC(new Date(dateEnd - dayms));
                            }

                            str = '<span class=\'layerslist-title\'>' +  props.title + '</span>' + ' ' +
                                  '<span class=\'layerslist-dates-times\'>' + nsGmx.CalendarWidget1.formatDate(newDateBegin) + ' - ' + nsGmx.CalendarWidget1.formatDate(newDateEnd) +
                                  ' | ' + hourBegin + '-' + hourEnd + '</span>';

                        }

                        $(li).html(str);
                        $(li).prop('layerID', item.value);

                        return li.appendTo( ul );
                    }
                },
                _renderMenu: function( ul, items ) {
                    var that = this;
                    $.each( items, function( index, item ) {
                        that._renderItemData( ul, item );
                    });
                }
            });

            if ($(layersList).temporallayersmenu("instance")) {
                $(layersList).temporallayersmenu("destroy");
            }

            for (var i = 0; i < layers.length; i++) {
                var layer = layers[i];
                    if (layer.getGmxProperties) {
                        var props = layer.getGmxProperties(),
                            isVisible = props.visible,
                            isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                        if (isTemporalLayer && isVisible) {
                            temporalLayers.push(layer);
                        }
                    }
                }

            for (var i = 0; i < temporalLayers.length; i++) {
                var layer = temporalLayers[i],
                    props = layer.getGmxProperties(),
                    layerID = props.LayerID;

                str += '<option value=' + layerID + '>' + props.title + '</option>';
            };

            $(layersList).html(str);

            if (currentLayer) {
                var l = nsGmx.gmxMap.layersByID[currentLayer];

                this.$('.layersList option').each(function () {
                    if ($(this).val() === currentLayer) {
                        $(this).prop("selected", true);
                    }
                })

            // установим текщим первый слой из списка
            } else if (!currentLayer && temporalLayers.length) {
                var props = temporalLayers[0].getGmxProperties(),
                    layerID = props.LayerID;

                this.$('.layersList option[value="' + layerID + '"]').prop("selected", true);
            }

            $(layersList).temporallayersmenu({
                change: function (e) {
                    var layerID = $(e.currentTarget).prop('layerID'),
                        layer = nsGmx.gmxMap.layersByID[layerID],
                        filters = layer._gmx.dataManager._filtersView,
                        layerFilters = filters[layerID],
                        dateBegin, dateEnd;

                    dateInterval = layer.getDateInterval();

                    if (dateInterval.beginDate && dateInterval.endDate) {
                        dateBegin = dateInterval.beginDate;
                        dateEnd = dateInterval.endDate;
                    } else {
                        dateInterval = new nsGmx.DateInterval();
                        dateBegin = dateInterval.get('dateBegin');
                        dateEnd = dateInterval.get('dateEnd');
                    }

                    if (layerFilters) {
                        if ('screen_dailyFilter' in layerFilters) {
                            _this.$('.daily-switch input').prop("checked", true);
                        } else {
                            _this.$('.daily-switch input').prop("checked", false);
                        }
                    }

                    _this.$('.layersList option[value="' + layerID + '"]').prop("selected", true);
                    _this.setDateInterval(dateBegin, dateEnd, layer);

                }
            });
        },

        toggleSync: function () {
            this.model.set('synchronyzed', !this.model.get('synchronyzed'));
        },

        setSyncMode: function (value) {
            this.model.set('synchronyzed', Boolean(value));
        },

        updateSync: function () {
            var _this = this,
                layers = nsGmx.gmxMap.layers,
                attrs = this.model.toJSON(),
                synchronyzed = attrs.synchronyzed,
                currentLayer = attrs.currentLayer,
                listContainer = this.$('.unsync-layers-container'),
                layersList = this.$('.layersList'),
                dateBegin, dateEnd;

            if (synchronyzed) {
                dateBegin = _this.dateInterval.get('dateBegin'),
                dateEnd = _this.dateInterval.get('dateEnd'),
                _this.setDateInterval(dateBegin, dateEnd);
                this.model.set('currentLayer', null);
                this.model.set('currentLayer', null);
                this.$('.sync-switch input').prop("checked", true);
                $(listContainer).hide();
            } else {
                if (currentLayer) {
                    return;
                } else {
                    var temporalLayers = [];

                    this.$('.sync-switch input').prop("checked", false);
                    $(listContainer).show();
                    this.updateVisibleTemporalLayers(layers);

                    for (var i = 0; i < layers.length; i++) {
                        var layer = layers[i];
                        if (layer.getGmxProperties) {
                            var props = layer.getGmxProperties(),
                            isVisible = props.visible,
                            isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                            if (isTemporalLayer && isVisible) {
                                temporalLayers.push(layer);
                            }
                        }
                    }
                    if (!temporalLayers.length) {
                        this.model.set('currentLayer', null);
                    } else {
                        var props = temporalLayers[0].getGmxProperties(),
                        layerID = props.LayerID;
                        this.model.set('currentLayer', layerID);
                    }
                }
            }
        },

        toggleDailyFilter: function () {
            var attrs = this.model.toJSON(),
                calendar = attrs.calendar;

            calendar.model.set('dailyFilter', !this.model.get('dailyFilter'));
            this.model.set('dailyFilter', !this.model.get('dailyFilter'));
        },

        setDailyFilter: function (active) {
            var attrs = this.model.toJSON(),
                calendar = attrs.calendar;

            calendar.model.set('dailyFilter', active);
            this.model.set('dailyFilter', active);
        },

        handleFiltersHash: function () {
            var attrs = this.model.toJSON(),
                synchronyzed = attrs.synchronyzed,
                currentLayer = attrs.currentLayer,
                dateInterval = this.dateInterval,
                calendar = attrs.calendar,
                dailyFilter = attrs.dailyFilter,
                dailyFiltersHash = attrs.dailyFiltersHash;

            if (dailyFilter) {
                if (currentLayer) {
                    dailyFiltersHash[currentLayer] = true;
                } else {
                    this._fillFiltersHash();
                }
            } else {
                if (currentLayer) {
                    dailyFiltersHash[currentLayer] = false;
                } else {
                    this._clearFiltersHash();
                }
            }
        },

        applyDailyFilter: function (layers) {
            var temporalLayers = layers || nsGmx.gmxMap.layers,
                _this = this,
                attrs = this.model.toJSON(),
                dailyFilter = attrs.dailyFilter,
                dailyFiltersHash = attrs.dailyFiltersHash,
                synchronyzed = attrs.synchronyzed,
                currentLayer = attrs.currentLayer,
                dateInterval = this.dateInterval,
                calendar = attrs.calendar,
                dateBegin = this.dateInterval.get('dateBegin'),
                dateEnd = this.dateInterval.get('dateEnd'),
                hourBegin = Number(nsGmx.CalendarWidget1.getTime(dateBegin, 'begin')) * 1000 * 3600,
                hourEnd = Number(nsGmx.CalendarWidget1.getTime(dateEnd, 'end')) * 1000 * 3600;
                temporalLayers;

            if (synchronyzed) {
                temporalLayers = nsGmx.gmxMap.layers;
            }

            if (!synchronyzed && !currentLayer) {
                return;
            }

            for (var i = 0; i < temporalLayers.length; i++) {
                var l = temporalLayers[i],
                    p = l.getGmxProperties && l.getGmxProperties(),
                    layerName;

                if (!p) {
                    continue;
                }

                layerName = p.name;

                if (layerName in attrs.unbindedTemporalLayers) {
                    continue;
                }

                (function (x) {
                var layer = temporalLayers[x];

                if (layer.getGmxProperties) {
                        var props = layer.getGmxProperties(),
                            isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                        if (isTemporalLayer && layer.getDataManager) {

                            if (!synchronyzed && layer.getDateInterval()) {
                                dateInterval = layer.getDateInterval();
                                if (dateInterval.beginDate && dateInterval.endDate) {
                                    dateBegin = dateInterval.beginDate;
                                    dateEnd = dateInterval.endDate;
                                    hourBegin = Number(nsGmx.CalendarWidget1.getTime(dateBegin, 'begin')) * 1000 * 3600,
                                    hourEnd = Number(nsGmx.CalendarWidget1.getTime(dateEnd, 'end')) * 1000 * 3600;
                                }
                            }

                            var dm = layer.getDataManager(),
                                dmOpt = dm.options,
                                fullDays,
                                intervals = [];

                            if (dmOpt.Temporal) {
                                var tmpKeyNum = dm.tileAttributeIndexes[dmOpt.TemporalColumnName];
                            }

                            if (hourEnd < dayms) {
                                fullDays = toMidnight(dateEnd).valueOf() - toMidnight(dateBegin).valueOf() + dayms;
                            } else if (hourEnd === dayms) {
                                fullDays = toMidnight(dateEnd).valueOf() - toMidnight(dateBegin).valueOf();
                            }

                            for (var i = 0; i < fullDays; i+= dayms) {
                                intervals.push({
                                    begin: toMidnight(dateBegin).valueOf() + hourBegin + i,
                                    end: toMidnight(dateBegin).valueOf() + hourEnd + i
                                });
                            }

                            if (dailyFilter && dailyFiltersHash[props.LayerID]) {
                                layer.addLayerFilter(function (item) {
                                    var itemDate = item.properties[tmpKeyNum] * 1000,
                                        inside = false;
                                    for (var j = 0; j < intervals.length; j++) {
                                        if (intervals[j].begin <= itemDate && itemDate <= intervals[j].end) {
                                            inside = true;
                                            break;
                                        }
                                    }
                                    //
                                    // if (inside) {
                                    //     console.log(layer.getGmxProperties().title + ' / ' + 'loaded');
                                    // } else {
                                    //     console.log(layer.getGmxProperties().title + ' / ' + 'filtered');
                                    // }
                                    return inside;
                                }, {id: 'dailyFilter'});

                                _this.$('.daily-switch input').prop("checked", true);

                            } else {
                                layer.removeLayerFilter({id: 'dailyFilter'});
                                _this.$('.daily-switch input').prop("checked", false);
                            }
                        }
                    }
                }(i));
            }
        }
    });

    nsGmx.CommonCalendarWidget = CommonCalendar;

})(jQuery);

var nsGmx = nsGmx || {};

nsGmx.searchProviders = {};

nsGmx.searchProviders.Osm2DataProvider = function(options){
    nsGmx.OsmDataProvider.call(this, options);
};

nsGmx.searchProviders.Osm2DataProvider.prototype = Object.create(nsGmx.OsmDataProvider.prototype);
nsGmx.searchProviders.Osm2DataProvider.prototype.constructor = nsGmx.Osm2DataProvider;

nsGmx.searchProviders.Osm2DataProvider.prototype.fetch = function (obj) {
    var _this = this;

    var query = 'WrapStyle=None&RequestType=ID&ID=' + obj.ObjCode + '&TypeCode=' + obj.TypeCode + '&UseOSM=1';
    var req = new Request(this._serverBase + '/SearchObject/SearchAddress.ashx?' + query + this._key);
    var headers = new Headers();
    headers.append('Content-Type', 'application/json');
    var init = {
        method: 'GET',
        mode: 'cors',
        credentials: 'include',
        cache: 'default'
    };

    return new Promise(function (resolve, reject) {
        fetch(req, init).then(function (response) {
            return response.json();
        }).then(function (json) {
            if (json.Status === 'ok') {
                if (typeof _this._onFetch === 'function') {
                    _this._onFetch(json.Result);
                }
                resolve(json.Result);
            } else {
                reject(json.Result);
            }
        }).catch(function (response) {
            return reject(response);
        });
    });
};

nsGmx.searchProviders.Osm2DataProvider.prototype.find = function (value, limit, strong, retrieveGeometry) {
    var result;
    var _this2 = this;
    _this2.searchString = value;
    var _strong = Boolean(strong) ? 1 : 0;
    var _withoutGeometry = Boolean(retrieveGeometry) ? 0 : 1;
    var query = 'WrapStyle=None&RequestType=SearchObject&IsStrongSearch=' + _strong + '&WithoutGeometry=' + _withoutGeometry + '&UseOSM=1&Limit=' + limit + '&SearchString=' + encodeURIComponent(value);
    var req = new Request(this._serverBase + '/SearchObject/SearchAddress.ashx?' + query + this._key);
    var headers = new Headers();
    headers.append('Content-Type', 'application/json');
    var init = {
        method: 'GET',
        mode: 'cors',
        credentials: 'include',
        cache: 'default'
    };
    return new Promise(function (resolve, reject) {
        fetch(req, init).then(function (response) {
            return response.json();
        }).then(function (json) {
            if (json.Status === 'ok') {
                json.Result.searchString = _this2.searchString;
                result = json;
                return json;
            } else {
                reject(json.Result);
            }
        }).then(function (json1) {
            return window.searchLogic && window.searchLogic.layersSearch(json1);
        }).then(function (json2) {
            var arr = [];

            for (var i = 0; i < result.Result.length; i++) {
                arr.push(result.Result[i]);
            }

            for (var i = 0; i < json2.length; i++) {
                if (json2[i] && json2[i].length) {
                    for (var j = 0; j < json2[i].length; j++) {
                        arr.push(json2[i][j]);
                    }
                }
            }

            arr.searchString = result.Result.searchString;

            return {
                Status: result.Status,
                Result: arr
            }
        }).then(function (json3) {
            if (json3.Status === 'ok') {
                var rs = json3.Result.reduce(function (a, x) {
                    return a.concat(x.SearchResult);
                }, []).map(function (x) {
                    if (retrieveGeometry && x.Geometry) {
                        var g = _this2._convertGeometry(x.Geometry);
                        var props = Object.keys(x).filter(function (k) {
                            return k !== 'Geometry';
                        }).reduce(function (a, k) {
                            a[k] = x[k];
                            return a;
                        }, {});
                        return {
                            name: x.ObjNameShort,
                            feature: {
                                type: 'Feature',
                                geometry: g,
                                properties: props
                            },
                            properties: props,
                            provider: _this2,
                            query: value
                        };
                    } else {
                        return {
                            name: x.ObjNameShort,
                            properties: x,
                            provider: _this2,
                            query: value
                        };
                    }
                });
                if (typeof _this2._onFetch === 'function' && strong && retrieveGeometry) {
                    _this2._onFetch(json3.Result);
                }
                resolve(rs);
            } else {
                reject(json3);
            }
        });
    });
}

var nsGmx = nsGmx || {};

$('#flash').droppable({
    drop: function(event, ui) {
        var obj = ui.draggable[0].gmxDrawingObject;

        if (obj) {
            var text = Functions.GetFullName(obj.TypeName, obj.ObjName);
            nsGmx.leafletMap.gmxDrawing.addGeoJSON({
                type: 'Feature',
                geometry: L.gmxUtil.geometryToGeoJSON(obj.Geometry)
            }, {text: text});
        }
    }
})

window._translationsHash.addtext("rus", {
    "Текущее местоположение отображается только для России и Украины": "Текущее местоположение отображается только для России и Украины",
    "Следующие [value0] страниц": "Следующие [value0] страниц",
    "Следующие [value0] страницы": "Следующие [value0] страницы",
    "Следующая страница": "Следующая страница",
    "Следующая [value0] страница": "Следующая [value0] страница",
    "Предыдущие [value0] страниц" : "Предыдущие [value0] страниц",
    "Первая страница" : "Первая страница",
    "Последняя страница" : "Последняя страница"
});
window._translationsHash.addtext("eng", {
    "Текущее местоположение отображается только для России и Украины": "Current location is shown only for Russia and Ukraine",
    "Следующие [value0] страниц": "Next [value0] pages",
    "Следующие [value0] страницы": "Next [value0] pages",
    "Следующая страница": "Next page",
    "Следующая [value0] страница": "Next [value0] pages",
    "Предыдущие [value0] страниц" : "Previous [value0] pages",
    "Первая страница" : "First page",
    "Последняя страница" : "Last page"
});

var imagesHost = "img";

/** Вспомогательные функции
 @namespace Functions
 @memberOf Search
*/
var Functions = {

	/** Возвращает полное наименование объекта, состоящее из типа и наименования
	 @static
	 @param sType Наименование типа объекта
	 @param sName Наименование объекта
    */
	GetFullName: function(/** string */sType, /** string */sName){
		var sFullName = "";

		if (sType==null || sType == "государство" || sType == "г." || /[a-zA-Z]/.test(sName))
			sFullName = sName;
		else if ((sType.indexOf("район") != -1) || (sType.indexOf("область") != -1) || (sType.indexOf("край") != -1))
			sFullName = sName + " " + sType;
		else
			sFullName = sType + " " + sName;

		return sFullName;
	},

	/** Возвращает полный путь к объекту
    * @memberOf Search.Functions
    *
	* @param oFoundObject найденный объект
	* @param sObjectsSeparator разделитель между дочерним элементом и родителем в строке пути
	* @param bParentAfter признак того, что родительский элемент идет после дочернего
	* @param sObjNameField название свойства, из которого брать наименование
    */
	GetPath: function(/*object*/ oFoundObject,/* string */ sObjectsSeparator, /* bool */ bParentAfter, /* string */ sObjNameField){
		if (sObjNameField == null) sObjNameField = "ObjName";
		if (oFoundObject == null) return "";
		var oParentObj = oFoundObject.Parent;
		if (oParentObj != null && (oParentObj.ObjName == "Российская Федерация" || oParentObj.TypeName == "административный округ")) {
			oParentObj = oParentObj.Parent;
		}
		var sObjectName = (oFoundObject.CountryCode != 28000 && oFoundObject.CountryCode != 310000183) ? oFoundObject[sObjNameField] : this.GetFullName(oFoundObject.TypeName, oFoundObject[sObjNameField]);
		if (oParentObj != null && oParentObj[sObjNameField] != null && oParentObj[sObjNameField]){
			if (bParentAfter){
				return sObjectName + sObjectsSeparator + this.GetPath(oParentObj, sObjectsSeparator,  bParentAfter, sObjNameField);
			}
			else{
				return this.GetPath(oParentObj, sObjectsSeparator,  bParentAfter, sObjNameField) + sObjectsSeparator + sObjectName;
			}
		}
		else{
			return sObjectName;
		}
	},

	/** Возвращает строку, соединяющую переданные свойства
	 @static
	 @param oProps - Свойства
	 @param sObjectsSeparator Разделитель 2х свойств в строке*/
	GetPropertiesString: function(/**object[]*/oProps,/**string*/ sPropSeparator, /**object[]*/arrDisplayFields){
		var sResultString = "";
		if (oProps != null){
			for (var sPropName in oProps){
				if (sResultString != "") sResultString += sPropSeparator;
				sResultString += sPropName + ": " + oProps[sPropName];
			}
		}
		return sResultString;
	}
}


/** Конструктор
 @class Предоставляет функции, отображающие найденные объекты на карте
 @memberof Search
 @param {L.Map} map карта, на которой будут рисоваться объекты
 @param {string} sInitImagesHost - строка пути к картинкам
 @param {bool} bInitAutoCenter - если true, карта будет центрироваться по 1ому найденному объекту*/
var ResultRenderer = function(map, sInitImagesHost, bInitAutoCenter){
	if (map == null)  throw "ResultRenderer.Map is null";

	var sImagesHost = sInitImagesHost || "http://maps.kosmosnimki.ru/api/img";
	var bAutoCenter = (bInitAutoCenter == null) || bInitAutoCenter;

    this.arrContainer = [];
	var counts = [];

	/** возвращает стили найденных объектов, используется только для точки*/
	var getSearchIcon = function(iPosition) {
        iPosition = Math.min(iPosition, 9);
        return L.icon({
            iconUrl: sImagesHost + "/search/search_" + (iPosition + 1).toString() + ".png",
            iconAnchor: [15, 38],
            popupAnchor: [0, -28]
        });

		// return [
						// { marker: { image: sImagesHost + "/search/search_" + (iPosition + 1).toString() + ".png", dx: -14, dy: -38} },
						// { marker: { image: sImagesHost + "/search/search_" + (iPosition + 1).toString() + "a.png", dx: -14, dy: -38} }
				// ];
	}

    var bindHoverPopup = function(layer, content) {
        layer.bindPopup(content);
    }

	/**Помещает объект на карту
	@param {MapObject} oContainer контейнер, содержащий в себе объекты текущей группы результатов поиска
	@param {MapObject} oFoundObject добавляемый объект
	@param {int} iPosition порядковый номер добавляемого объекта в группе
	@param {int} iCount общее количество объектов в группе
    @return {Object} Нарисованные на карте объекты: хеш с полями center и boundary */
	var DrawObject = function(oContainer, oFoundObject, iPosition, iCount){
        var color = Math.round(0x22 + 0x99*iPosition/iCount);
		var sDescr = "<b>" + Functions.GetFullName(oFoundObject.TypeName, oFoundObject.ObjName) + "</b><br/>" + Functions.GetPath(oFoundObject.Parent, "<br/>", true);
		if (oFoundObject.properties != null) sDescr += "<br/>" + Functions.GetPropertiesString(oFoundObject.properties, "<br/>");

        sDescr = sDescr.replace(/;/g, "<br/>");

		var fnBaloon = function(o) {
			return o.properties.Descr.replace(/;/g, "<br/>");
		};
		var centerMapElem,
            boundaryMapElem;
		//Рисуем центр объекта
		if (oFoundObject.Geometry != null && (oFoundObject.Geometry.type).toUpperCase() == 'POINT') {
            centerMapElem = L.marker([oFoundObject.Geometry.coordinates[1], oFoundObject.Geometry.coordinates[0]], {
                icon: getSearchIcon(iPosition)
            });
            bindHoverPopup(centerMapElem, sDescr);
            oContainer.addLayer(centerMapElem);
		}
		else if (oFoundObject.CntrLon != null && oFoundObject.CntrLat != null){
            centerMapElem = L.marker([oFoundObject.CntrLat, oFoundObject.CntrLon], {
                icon: getSearchIcon(iPosition)
            });

            bindHoverPopup(centerMapElem, sDescr);
            oContainer.addLayer(centerMapElem);
		}


		//Рисуем контур объекта
		if (oFoundObject.Geometry != null && (oFoundObject.Geometry.type).toUpperCase() != 'POINT') {
            boundaryMapElem = L.geoJson(L.gmxUtil.geometryToGeoJSON(oFoundObject.Geometry), {
                style: function(feature) {
                    return
                },
                onEachFeature: function(feature, layer) {
                    layer.setStyle({
                        color: '#' + (0x1000000 + (color << 16) + (color << 8) + color).toString(16).substr(-6),
                        weight: 3,
                        opacity: 0.6,
                        fill: false
                    });

                    bindHoverPopup(layer, sDescr)
                }
            });

            oContainer.addLayer(boundaryMapElem);
		}

        return {center: centerMapElem, boundary: boundaryMapElem};
	};

	/**Центрует карту по переданному объекту*/
	var CenterObject = function(oFoundObject){
		if (!oFoundObject) return;
		var iZoom = oFoundObject.TypeName == "г." ? 9 : 15;
        if (oFoundObject.Geometry == null) {
		    if (oFoundObject.MinLon != null && oFoundObject.MaxLon != null && oFoundObject.MinLat != null && oFoundObject.MaxLat != null
                && oFoundObject.MaxLon - oFoundObject.MinLon < 1e-9 && oFoundObject.MaxLat - oFoundObject.MinLat < 1e-9)
			    map.setView([oFoundObject.CntrLat, oFoundObject.CntrLon], iZoom);
		    else
			    map.fitBounds([[oFoundObject.MinLat, oFoundObject.MinLon], [oFoundObject.MaxLat, oFoundObject.MaxLon]]);
        }
		else
		{
           if ((oFoundObject.Geometry.type).toUpperCase() == 'POINT') {
		        if (oFoundObject.MinLon != oFoundObject.MaxLon && oFoundObject.MinLat != oFoundObject.MaxLat) {
			        map.fitBounds([[oFoundObject.MinLat, oFoundObject.MinLon], [oFoundObject.MaxLat, oFoundObject.MaxLon]]);
                } else {
                    var c = oFoundObject.Geometry.coordinates;
			        map.setView([c[1], c[0]], iZoom);
                }
		    }
		    else {
                var bounds = L.gmxUtil.getGeometryBounds(oFoundObject.Geometry);
			    //var oExtent = getBounds(oFoundObject.Geometry.coordinates);
			    map.fitBounds([[bounds.min.y, bounds.min.x], [bounds.max.y, bounds.max.x]]);
            }
		}
	};

	/**Центрует карту по переданному объекту
	@param {MapObject} oFoundObject объект, который нужно поместить в центр
	@returns {void}*/
	this.CenterObject = function(oFoundObject){
		CenterObject(oFoundObject);
	}

	/** Рисует объекты на карте.
	@param {int} iDataSourceN № источника данных (группы результатов поиска)
	@param {Array} arrFoundObjects Массив объектов для отрисовки. Каждый объект имеет свойства
	@param {bool} [options.append=false] Добавить к существующим объектам для источника данных, а не удалять их
	@return {Array} Нарисованные на карте объекты: массив хешей с полями center и boundary
    */
	this.DrawObjects = function(iDataSourceN, arrFoundObjects, options){
        options = $.extend({append: false}, options);

        if (!options.append && this.arrContainer[iDataSourceN]) {
            map.removeLayer(this.arrContainer[iDataSourceN]);
            delete this.arrContainer[iDataSourceN];
        }

        if (!this.arrContainer[iDataSourceN]) {
            this.arrContainer[iDataSourceN] = L.layerGroup();
            counts[iDataSourceN] = 0;
        }

		iCount = arrFoundObjects.length;

        var mapObjects = [];

        counts[iDataSourceN] += arrFoundObjects.length;

		//Отрисовываем задом наперед, чтобы номер 1 был сверху от 10ого
		for (var i = arrFoundObjects.length - 1; i >= 0; i--){
			mapObjects.unshift(DrawObject(this.arrContainer[iDataSourceN], arrFoundObjects[i], counts[iDataSourceN] + i - arrFoundObjects.length, counts[iDataSourceN]));
		}

		this.arrContainer[iDataSourceN].addTo(map);
		if (bAutoCenter && iDataSourceN == 0) CenterObject(arrFoundObjects[0]);

        return mapObjects;
	}
};

/** Конструктор
 @class Предоставляет функции, отображающие найденные объекты на карте
 @memberof Search
 @param {object} oInitMap карта, на которой будут рисоваться объекты
 @param {function} fnSearchLocation = function({Geometry, callback})- функция поиска объектов по переданной геометрии*/
var LocationTitleRenderer = function(oInitMap, fnSearchLocation){
	var _this = this;
	var oMap = oInitMap;
	var dtLastSearch;

	/**Добавляет объект в список найденных результатов*/
	var drawObject = function(oFoundObject, elemDiv)
	{
		if (oFoundObject.Parent != null) drawObject(oFoundObject.Parent, elemDiv, true);
		var	realPath = oFoundObject.IsForeign ? oFoundObject.ObjName : Functions.GetFullName(oFoundObject.TypeName, oFoundObject.ObjName);

		var searchElemHeader = _span([_t(realPath)], [['dir', 'className', 'searchLocationPath']]);

		/** Вызывается при клике на найденный объект в списке результатов поиска
		@name Search.ResultList.onObjectClick
		@event
		@param {object} oFoundObject Найденный объект*/
		searchElemHeader.onclick = function(){$(_this).triggerHandler('onObjectClick', [oFoundObject]);};

		if (oFoundObject.Parent != null) _(elemDiv, [_t("->")]);
		_(elemDiv, [searchElemHeader]);
	}

	var setLocationTitleDiv = function(div, attr) {
		if (dtLastSearch && Number(new Date()) - dtLastSearch < 300) return;
		dtLastSearch = new Date();

		var locationTitleDiv = div;

		fnSearchLocation({Geometry: attr['screenGeometry'], callback: function(arrResultDataSources){
			$(locationTitleDiv).empty();
			if(arrResultDataSources.length>0 && arrResultDataSources[0].SearchResult.length>0){
				drawObject(arrResultDataSources[0].SearchResult[0], locationTitleDiv);
			}
			else{
				_(locationTitleDiv, [_t(_gtxt("Текущее местоположение отображается только для России и Украины"))]);
			}
		}});
	};

	if (oMap.coordinates) oMap.coordinates.addCoordinatesFormat(setLocationTitleDiv);
}

var ResultList = function(oInitContainer, oRenderer, ImagesHost){
	/**Объект, в котором находится контрол (div)*/
    // создается в начале searchLogic.showResult
	var Container = oInitContainer;
	var _this = this;

	var sImagesHost = ImagesHost || "http://maps.kosmosnimki.ru/api/img";

	var arrDisplayedObjects = []; //Объекты, которые отображаются на текущей странице
	var iLimit = 10; //Максимальное количество результатов на странице
	var iPagesCount = 7; //Количество прокручиваемых страниц при нажатии на двойные стрелки
	if (Container == null) throw "ResultList.Container is null";

	var oResultCanvas;
	var arrTotalResultSet = [];

	if(oResultCanvas == null)
	{
		oResultCanvas = nsGmx.Utils._div(null, [['dir', 'className', 'searchResultCanvas']]);
        Container.appendChild(oResultCanvas);
	}
	var oLoading = nsGmx.Utils._div([_img(null, [['attr', 'src', sImagesHost + '/progress.gif'], ['dir', 'className', 'searchResultListLoadingImg']]), _t(_gtxt("загрузка..."))], [['dir', 'className', 'searchResultListLoading']]);
	var fnNotFound = function(){nsGmx.Utils._(oResultCanvas, [nsGmx.Utils._div([_t(_gtxt("Поиск не дал результатов"))], [['dir', 'className', 'SearchResultListNotFound']])]);};

	/**Удаляет все найденные объекты из результатов поиска*/
	var unload = function(){
		for(i=0; i<arrDisplayedObjects.length; i++){
			SetDisplayedObjects(i, []);
		}
		$(oResultCanvas).empty();
	}
    /** Переход на следующие страницы*/
    var next = function(iDataSourceN, divChilds, divPages) {
        var button = makeImageButton(sImagesHost + '/next.png', sImagesHost + '/next_a.png');

        button.style.marginBottom = '-7px';

        button.onclick = function() {
			var oDataSource = arrTotalResultSet[iDataSourceN];
            oDataSource.start += iPagesCount;
            oDataSource.reportStart = oDataSource.start * iLimit;

            drawPagesRow(iDataSourceN, divChilds, divPages);
        }

        _title(button, _gtxt('Следующие [value0] страниц', iPagesCount));

        return button;
    }

    /** Переход на предыдущие страницы*/
    var previous = function(iDataSourceN, divChilds, divPages) {
        var button = makeImageButton(sImagesHost + '/prev.png', sImagesHost + '/prev_a.png');

        button.style.marginBottom = '-7px';

        button.onclick = function() {
			var oDataSource = arrTotalResultSet[iDataSourceN];
            oDataSource.start -= iPagesCount;
            oDataSource.reportStart = oDataSource.start * iLimit;

            drawPagesRow(iDataSourceN, divChilds, divPages);
        }

        _title(button, _gtxt('Предыдущие [value0] страниц', iPagesCount));

        return button;
    }

    /** Переход на первую страницу*/
    var first = function(iDataSourceN, divChilds, divPages) {
        var _this = this,
			button = makeImageButton(sImagesHost + '/first.png', sImagesHost + '/first_a.png');

        button.style.marginBottom = '-7px';

        button.onclick = function() {
			var oDataSource = arrTotalResultSet[iDataSourceN];
            oDataSource.start = 0;
            oDataSource.reportStart = oDataSource.start * iLimit;

            drawPagesRow(iDataSourceN, divChilds, divPages);
        }

        _title(button, _gtxt('Первая страница'));

        return button;
    }

    /** Переход на последнюю страницу*/
    var last = function(iDataSourceN, divChilds, divPages) {
        var _this = this,
			button = makeImageButton(sImagesHost + '/last.png', sImagesHost + '/last_a.png');

        button.style.marginBottom = '-7px';

        button.onclick = function() {
			var oDataSource = arrTotalResultSet[iDataSourceN];
            oDataSource.start = Math.floor((oDataSource.SearchResult.length - 1)/ (iPagesCount * iLimit)) * iPagesCount;
            oDataSource.reportStart = Math.floor((oDataSource.SearchResult.length - 1)/ (iLimit)) * iLimit;

            drawPagesRow(iDataSourceN, divChilds, divPages);
        }

        _title(button, _gtxt('Последняя страница'));

        return button;
    }

	/**Добавляет объект в список найденных результатов*/
	var drawObject = function(oFoundObject, elemDiv, bIsParent)
	{
		var	realPath = (oFoundObject.CountryCode != 28000 && oFoundObject.CountryCode != 310000183)  ? oFoundObject.ObjName : Functions.GetFullName(oFoundObject.TypeName, oFoundObject.ObjName);
		if (oFoundObject.Parent != null) realPath += ",";

		var searchElemHeader = _span([_t(realPath)], [['dir', 'className', bIsParent?'searchElemParent':'searchElem']]);

		/** Вызывается при клике на найденный объект в списке результатов поиска
		@name Search.ResultList.onObjectClick
		@event
		@param {object} oFoundObject Найденный объект*/
		searchElemHeader.onclick = function(){$(_this).triggerHandler('onObjectClick', [oFoundObject]);};

		nsGmx.Utils._(elemDiv, [searchElemHeader]);
		if (oFoundObject.Parent != null) drawObject(oFoundObject.Parent, elemDiv, true);
		if (oFoundObject.properties != null) nsGmx.Utils._(elemDiv, [document.createTextNode(" " + Functions.GetPropertiesString(oFoundObject.properties, "; "))]);
	}

	/** Рисует строки списка*/
	var drawRows = function(iDataSourceN, divChilds) {
		var arrObjects = arrDisplayedObjects[iDataSourceN];
		$(divChilds).empty();
		var tbody = _tbody();
		for (var i = 0; i < arrObjects.length; i++) {
			var elemTR = _tr(null, [['dir', 'className', 'SearchResultRow']]);
			var elemTD = _td(null, [['dir', 'className', 'SearchResultText']]);
			nsGmx.Utils._(elemTR, [_td([_t((i+1).toString() + ".")], [['dir', 'className','searchElemPosition']]), elemTD]);
			drawObject(arrObjects[i], elemTD);

			// загрузка SHP Файла
			if (window.gmxGeoCodeShpDownload && arrObjects[i].Geometry != null) {
			    var shpFileLink = _span([_t(".shp")], [['dir', 'className', 'searchElem'], ['attr', 'title', 'скачать SHP-файл'], ['attr', 'number', i]]);

			    shpFileLink.onclick = function () {
			        var obj = arrObjects[$(this).attr('number')];
			        var objsToDownload = [obj];
			        $(_this).triggerHandler('onDownloadSHP', [obj.ObjCode, objsToDownload]);
			    };
			   nsGmx.Utils._(elemTD, [_t(" ")]);
			   nsGmx.Utils._(elemTD, [shpFileLink]);
			}

            elemTD.gmxDrawingObject = arrObjects[i];

            $(elemTD).draggable({
                scroll: false,
                appendTo: document.body,
                helper: 'clone',
                distance: 10
            });

			nsGmx.Utils._(tbody, [elemTR]);
		}
		nsGmx.Utils._(divChilds, [_table([tbody])]);

	}

	/**рисует номера страниц списка
	@param end - последний номер
	@param iDataSourceN - номер источника данных
	@param divChilds - раздел для элементов списка
	@param divPages - раздел для номеров страниц списка*/
	var drawPages = function(end, iDataSourceN, divChilds, divPages) {
		var oDataSource = arrTotalResultSet[iDataSourceN];
		for (var i = oDataSource.start + 1; i <= end; i++) {
			// текущий элемент
			if (i - 1 == oDataSource.reportStart / iLimit) {
				var el = _span([_t(i.toString())]);
				nsGmx.Utils._(divPages, [el]);
				$(el).addClass('page');
			}
			else {
				var link = makeLinkButton(i.toString());

				link.setAttribute('page', i - 1);
				link.style.margin = '0px 2px';

				nsGmx.Utils._(divPages, [link]);

				link.onclick = function() {
					arrTotalResultSet[iDataSourceN].reportStart = this.getAttribute('page') * iLimit;

					drawPagesRow(iDataSourceN, divChilds, divPages);
				};
			}

		}
	}

	/**Рисует одну из страниц списка
	@param iDataSourceN - номер источника данных
	@param divChilds - раздел для элементов списка
	@param divPages - раздел для номеров страниц списка*/
	var drawPagesRow = function(iDataSourceN, divChilds, divPages) {
		var oDataSource = arrTotalResultSet[iDataSourceN];

		// перерисовывем номера страниц
		$(divPages).empty();

		var end = (oDataSource.start + iPagesCount <= oDataSource.allPages) ? oDataSource.start + iPagesCount : oDataSource.allPages;

		if (oDataSource.start - iPagesCount >= 0)
			nsGmx.Utils._(divPages, [first(iDataSourceN, divChilds, divPages), previous(iDataSourceN, divChilds, divPages)]);

		// drawPages(end, iDataSourceN, divChilds, divPages);

		// if (end + 1 <= oDataSource.allPages)
		// 	nsGmx.Utils._(divPages, [next(iDataSourceN, divChilds, divPages), last(iDataSourceN, divChilds, divPages)]);
        var startFrom = oDataSource.reportStart * iLimit;

		SetDisplayedObjects(iDataSourceN, oDataSource.SearchResult.slice(startFrom, (startFrom + iLimit)));
		drawRows(iDataSourceN, divChilds);
	}

	/**Рисует таблицу для результатов источника данных
	@param iDataSourceN - номер источника данных
	@param divChilds - раздел для элементов списка
	@param divPages - раздел для номеров страниц списка*/
	var drawTable = function(iDataSourceN, divChilds, divPages) {
		var oDataSource = arrTotalResultSet[iDataSourceN];


		if (oDataSource.SearchResult.length <= iLimit/* && iDataSourceN < oDataSource.SearchResult.length - 1*/) {
			$(divPages).empty();
			SetDisplayedObjects(iDataSourceN, oDataSource.SearchResult);
			drawRows(iDataSourceN, divChilds);
		}
		else {
			oDataSource.allPages = Math.ceil(oDataSource.SearchResult.length / iLimit);
			drawPagesRow(iDataSourceN, divChilds, divPages);
		}
	}

	/**Обрабатывает событие нажатия на кнопку "Скачать SHP-файл"
	@param iDataSourceN - номер источника данных*/
	var downloadMarkers = function(iDataSourceN) {
		var oDataSource = arrTotalResultSet[iDataSourceN];
		var canvas = nsGmx.Utils._div(),
			filename = _input(null, [['dir', 'className', 'filename'], ['attr', 'value', oDataSource.name]]);

		var downloadButton = makeButton(_gtxt("Скачать"));
		downloadButton.onclick = function() {
			if (filename.value == '') {
				inputError(filename, 2000);

				return;
			}

			/** Вызывается при необходимости осуществить загрузку SHP-файла с результатами поиска
			@name Search.ResultList.onDownloadSHP
			@event
			@param {string} filename Имя файла, которой необходимо будет сформировать
			@param {object[]} SearchResult Результаты поиска, которые необходимо сохранить в файл*/
			$(_this).triggerHandler('onDownloadSHP', [filename.value, oDataSource.SearchResult]);

			$(canvas.parentNode).dialog("destroy").remove();
		}

		nsGmx.Utils._(canvas, [nsGmx.Utils._div([_t(_gtxt("Введите имя файла для скачивания")), filename], [['dir', 'className', 'DownloadSHPButtonText']]), nsGmx.Utils._div([downloadButton], [['dir', 'className', 'DownloadSHPButton']])]);

		var area = getOffsetRect(Container);
		showDialog(_gtxt("Скачать shp-файл"), canvas, 291, 120, 30, area.top + 10);
	}

	/**Отображает результаты поиска с источника данных
	@param iDataSourceN - номер источника данных*/
	var drawSearchResult = function(iDataSourceN, options) {
		var oDataSource = arrTotalResultSet[iDataSourceN];

		var arrDataSourceList = oDataSource.SearchResult;
		var header = oDataSource.name;

		var divChilds = nsGmx.Utils._div(null, [['dir', 'className', 'SearchResultListChildsCanvas']]),
			divPages = nsGmx.Utils._div(),
			liInner = _li([divChilds, divPages]),
			li;
		if (arrTotalResultSet.length == 1){
			li = nsGmx.Utils._ul([liInner]);
		}
		else{
			li = _li([nsGmx.Utils._div([_t(header), _span([_t("(" + arrDataSourceList.length + ")")])], [['dir', 'className', 'searchLayerHeader']]), nsGmx.Utils._ul([liInner])]);
		}

		oDataSource.start = 0;
		oDataSource.reportStart = options.page || 0;
		oDataSource.allPages = 0;

		drawTable(iDataSourceN, divChilds, divPages);

		if (oDataSource.CanDownloadVectors) {
			var downloadVector = makeLinkButton(_gtxt("Скачать shp-файл"));

			downloadVector.onclick = function() {
				downloadMarkers(iDataSourceN);
			}

			liInner.insertBefore(nsGmx.Utils._div([downloadVector], [['dir', 'className', 'SearchDownloadShpLink']]), liInner.firstChild);
		}

		return li;
	}

    var fnDisplayedObjectsChanged = function(event, iDataSourceN, arrFoundObjects){
        oRenderer.DrawObjects(iDataSourceN, arrFoundObjects);
        /** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
        @name Search.ResultListMap.onDisplayedObjectsChanged
        @event
        @param {int} iDataSourceN № источника данных(группы результатов поиска)
        @param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/
        // $(_this).triggerHandler('onDisplayedObjectsChanged', [iDataSourceN, arrFoundObjects]);
    }

    var fnObjectClick = function(event, oFoundObject){
        oRenderer.CenterObject(oFoundObject);

        /** Вызывается при клике на найденный объект в списке результатов поиска
        @name Search.ResultListMap.onObjectClick
        @event
        @param {object} oFoundObject Найденный объект*/
        // $(oSearchResultDiv).triggerHandler('onObjectClick', [oFoundObject]);
    }

    var fnDownloadSHP = function(event, filename, arrObjectsToDownload){
        /** Вызывается при необходимости осуществить загрузку SHP-файла с результатами поиска
        @name Search.ResultListMap.onDownloadSHP
        @event
        @param {string} filename Имя файла, которой необходимо будет сформировать
        @param {object[]} SearchResult Результаты поиска, которые необходимо сохранить в файл*/
        // $(oSearchResultDiv).triggerHandler('onDownloadSHP', [filename, arrObjectsToDownload]);
    }


    $(_this).bind('onDisplayedObjectsChanged', fnDisplayedObjectsChanged);
    $(_this).bind('onObjectClick', fnObjectClick);
    $(_this).bind('onDownloadSHP', fnDownloadSHP);

	/**Отображает результаты поиска в списке
	@param sTotalListName - заголовок итогового результата
	@param {Array.<Object>} arrTotalList. Массив объектов со следующими свойствами{name:DataSourceName, CanDownloadVectors:CanDownloadVectors, SearchResult:arrDataSourceList[oObjFound,...]}
	@returns {void}
	*/
	this.ShowResult = function(sTotalListName, arrTotalList, options){
		arrTotalResultSet = arrTotalList;
	    $(oResultCanvas).empty();
		arrDisplayedObjects = [];
		if (!objLength(arrTotalResultSet)) {
			fnNotFound();
			return;
		}
		else {
			var foundSomething = false;

			for (var i = 0; i < arrTotalResultSet.length; i++) {
				if (arrTotalResultSet[i].SearchResult.length > 0) {
					foundSomething = true;
					break;
				}
			}
			if (!foundSomething) {
				fnNotFound();
				return;
			}
		}

		var ulSearch = nsGmx.Utils._ul();

		for (var iDataSourceN  = 0; iDataSourceN < arrTotalResultSet.length; iDataSourceN++)
			nsGmx.Utils._(ulSearch, [drawSearchResult(iDataSourceN, options)]);

		if (arrTotalResultSet.length == 1){
			nsGmx.Utils._(oResultCanvas, [ulSearch]);
		}
		else{
			nsGmx.Utils._(oResultCanvas, [_li([nsGmx.Utils._div([_t(sTotalListName)], [['dir', 'className', 'SearchTotalHeader']]), ulSearch])]);
		}

        if (typeof($.fn.treeview) === 'function') {
            $(oResultCanvas).treeview();
        }

		$(oResultCanvas).find(".SearchResultListChildsCanvas").each(function() {
			this.parentNode.style.padding = '0px';
			this.parentNode.style.background = 'none';
		})
	}


    /**Создается переключатель страниц
    @param results - набор результатов
    @param onclick - обработчик нажатия переключателя страниц
    @returns {void}*/
    this.CreatePager = function (results, onclick) {

        function makeNavigButton(pager, img, imga, id, title) {
            var b = makeImageButton(sImagesHost + img, sImagesHost + imga);
            b.style.marginBottom = '-7px';
            $(b).attr('id', id)
            nsGmx.Utils._title(b, title);
            nsGmx.Utils._(pager, [b]);
            return b;
        }

        containerList = Container;
        $('#respager').remove();
        //var pager = nsGmx.Utils._div([_t('всего: ' + results[0].ResultsCount)], [["attr", "id", "respager"]]);
        var pager = nsGmx.Utils._div([_t('')], [["attr", "id", "respager"]]);
        nsGmx.Utils._(containerList, [pager]);

        var pcount = results[0].SearchResult[0] ? Math.ceil(results[0].SearchResult[0].OneOf / iLimit) : 0;
        if (pcount > 1) {
            var first = makeNavigButton(pager, '/first.png', '/first_a.png', 'firstpage', _gtxt('Первая страница'));
            $(first).bind('click', function () {
                fnShowPage(0);
            });
            var prev = makeNavigButton(pager, '/prev.png', '/prev_a.png', 'prevpages', _gtxt('Предыдущие [value0] страниц', iPagesCount));
            $(prev).bind('click', function () {
                fnShowPage(parseInt($('#page1').text()) - iPagesCount - 1);
            });
            $(first).hide();
            $(prev).hide();

            for (var i = 0; i < iPagesCount && i < pcount; ++i) {
                var pagelink = makeLinkButton(i + 1);
                $(pagelink).attr('id', 'page' + (i + 1));
                if (i == 0){
                    $(pagelink).attr('class', 'page')
                    attachEffects(pagelink, '');
                }
                $(pagelink).bind('click', onclick);
                nsGmx.Utils._(pager, [pagelink, _t(' ')]);
            }

            var remains = pcount % iPagesCount;
            var nextPages = pcount/iPagesCount<2 ? remains : iPagesCount
            var nextButTitle = 'Следующие [value0] страниц';
            if (nextPages == 1)
                nextButTitle = 'Следующая страница';
            if (nextPages % 10 == 1 && nextPages != 1 && nextPages != 11)
                nextButTitle = 'Следующая [value0] страница';
            if (1 < nextPages % 10 && nextPages % 10 < 5 && (nextPages<10 || nextPages > 20))
                nextButTitle = 'Следующие [value0] страницы';
            var next = makeNavigButton(pager, '/next.png', '/next_a.png', 'nextpages', _gtxt(nextButTitle, nextPages));
            $(next).bind('click', function () {
                fnShowPage(parseInt($('#page' + iPagesCount).text()));
            });
            var last = makeNavigButton(pager, '/last.png', '/last_a.png', 'lastpage', _gtxt('Последняя страница'));
            $(last).bind('click', function () {
                var lastindex = (remains == 0 ? iPagesCount : remains)
                fnShowPage(pcount - lastindex, $('#page' + lastindex));
            });

            if (iPagesCount >= pcount) {
                $(next).hide();
                $(last).hide();
            }
        }

        var fnShowPage = function (n, active) {
            //alert(n + "\n" + pcount);
            for (var i = 0; i < iPagesCount; ++i) {//pcount
                if (i + n < pcount) {
                    $('#page' + (i + 1)).text(i + n + 1);
                    $('#page' + (i + 1)).show();
                }
                else
                    $('#page' + (i + 1)).hide();
            }

            if (n < iPagesCount) {
                $('#prevpages').hide(); $('#firstpage').hide();
            }
            else {
                $('#prevpages').show(); $('#firstpage').show();
            }

            if (n + iPagesCount < pcount) {
                $('#nextpages').show(); $('#lastpage').show();
                var rest = pcount - n - iPagesCount;
                var nextPages = rest < iPagesCount ? rest : iPagesCount
                var nextButTitle = 'Следующие [value0] страниц';
                if (nextPages == 1)
                    nextButTitle = 'Следующая страница';
                if (nextPages % 10 == 1 && nextPages != 1 && nextPages != 11)
                    nextButTitle = 'Следующая [value0] страница';
                if (1 < nextPages % 10 && nextPages % 10 < 5 && (nextPages < 10 || nextPages > 20))
                    nextButTitle = 'Следующие [value0] страницы';
                $('#nextpages').attr('title', _gtxt(nextButTitle, nextPages));
            }
            else {
                $('#nextpages').hide(); $('#lastpage').hide();
            }

            if (active == null) active = $('#prevpages~span')[0];
            $(active).trigger('click');
        }
    }
    /*----------------------------------------------------------*/

	/**Возвращает список объектов, которые отображаются на текущей странице во всех разделах*/
	this.GetDisplayedObjects = function(){return arrDisplayedObjects; };
	var SetDisplayedObjects = function(iDataSourceN, value) {
		arrDisplayedObjects[iDataSourceN] = value;

		/** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
		@name Search.ResultList.onDisplayedObjectsChanged
		@event
		@param {int} iDataSourceN № источника данных(группы результатов поиска)
		@param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/
		$(_this).triggerHandler('onDisplayedObjectsChanged',[iDataSourceN, arrDisplayedObjects[iDataSourceN]]);
	};

	/** Показывает режим загрузки
	@returns {void}*/
	this.ShowLoading = function(){
	    $('#respager').remove();
        $(oResultCanvas).empty();
        // Container.appendChild(oResultCanvas);
		nsGmx.Utils._(oResultCanvas, [oLoading]);
	}

	/**Показывает сообщение об ошибке
	@returns {void}*/
	this.ShowError = function(){
		$(oResultCanvas).empty();
		nsGmx.Utils._(oResultCanvas, [_t("Произошла ошибка")]);
	}

	/**Очищает результаты поиска
	@returns {void}*/
	this.Unload = function(){unload();};
	/** Возвращает контрол, в котором находится данный контрол*/
	this.getContainer = function(){return Container;};
};

nsGmx.SearchLogic = function () {};

nsGmx.SearchLogic.prototype = {
    init: function (params) {
        this.oMenu = params.oMenu || new leftMenu();
        this.oRenderer = new ResultRenderer(nsGmx.leafletMap, imagesHost, true);
        this.oSearchResultDiv = document.createElement('div');
        this.searchByStringHooks = [];
        var workCanvas;
        this.oSearchResultDiv.className = 'ddfdfdf';
        this.oSearchResultDiv.title = window._gtxt('Изменить параметры поиска');

        var fnBeforeSearch = function(event){
            /** Вызывается перед началом поиска
            @name Search.SearchGeomixer.onBeforeSearch
            @event */
            $(this.oSearchResultDiv).triggerHandler('onBeforeSearch');
            fnLoad();
        }
        var fnAfterSearch = function(event){
            /** Вызывается после окончания поиска
            @name Search.SearchGeomixer.onAfterSearch
            @event */
            $(this.oSearchResultDiv).triggerHandler('onAfterSearch');
        }
        var onDisplayedObjectsChanged = function(event, iDataSourceN, arrFoundObjects){
            /** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
            @name Search.SearchGeomixer.onDisplayedObjectsChanged
            @event
            @param {int} iDataSourceN № источника данных(группы результатов поиска)
            @param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/
            $(this.oSearchResultDiv).triggerHandler('onDisplayedObjectsChanged', [iDataSourceN, arrFoundObjects]);
        }
        var onObjectClick = function(event, oFoundObject){
            /** Вызывается при клике на найденный объект в списке результатов поиска
            @name Search.SearchGeomixer.onObjectClick
            @event
            @param {object} oFoundObject Найденный объект*/
            $(this.oSearchResultDiv).triggerHandler('onObjectClick', [oFoundObject]);
        };
        $(this.oSearchResultDiv).bind('onBeforeSearch', fnBeforeSearch);
        $(this.oSearchResultDiv).bind('onAfterSearch', fnAfterSearch);
        $(this.oSearchResultDiv).bind('onDisplayedObjectsChanged', onDisplayedObjectsChanged);
        $(this.oSearchResultDiv).bind('onObjectClick', onObjectClick);

        // coordinates search hook
        this.addSearchByStringHook(function(searchString) {
            var pos = L.gmxUtil.parseCoordinates(searchString);
            if (pos) {
                nsGmx.leafletMap.panTo(pos);

                // Добавим иконку по умолчанию
                // L.Icon.Default.imagePath = 'leaflet/images';
                nsGmx.leafletMap.gmxDrawing.add(L.marker(pos, { draggable: true, title: searchString }));

                // Либо задать свою иконку
                // map.gmxDrawing.add(L.marker(pos, {
                    // draggable: true, title: searchString,
                    // icon: L.icon({ iconUrl: 'img/flag_blau1.png', iconAnchor: [6, 36] })
                // }));

                //map.moveTo(pos[0], pos[1], map.getZ());
                //map.drawing.addObject({ type: "POINT", coordinates: pos }, { text: searchString });
                return true;
            }
        })
    },

    fnLoad: function(){
        if (this.oMenu != null){
            var alreadyLoaded = this.oMenu.createWorkCanvas("search", this.fnUnload.bind(this));
            if(!alreadyLoaded) {
                this.oMenu.workCanvas.appendChild(this.oSearchResultDiv);
            }
            $(this.oSearchResultDiv).empty();
        }
    },

    fnUnload: function () {
        if (this.lstResult) {
            this.lstResult.Unload();
        }
    },

    showResult: function (response) {
        var _this = this;
        var searchString = response.searchString || '';
        if (searchString) {
            for (var h = 0; h < this.searchByStringHooks.length; h++) {
                if (this.searchByStringHooks[h].hook(searchString)) {
                    return;
                }
            }
        }
        this.fnLoad();
        this.lstResult = new ResultList(this.oSearchResultDiv, this.oRenderer, imagesHost);
        this.lstResult.ShowLoading();
        this.lstResult.ShowResult(searchString, response, {page: 0});
        this.lstResult.CreatePager(response, function (e) {
            var evt = e || window.event,
                active = evt.srcElement || evt.target,
                activePage = parseInt($(this).text()) - 1;

            $('#prevpages~span:visible').attr('class', 'buttonLink');
            for (var i=0; i<$('#prevpages~span:visible').length; ++i) attachEffects($('#prevpages~span:visible')[i], 'buttonLinkHover');
            $(active).attr('class', 'page');
            attachEffects(active, '');

            _this.lstResult.ShowResult(searchString, response, {page: activePage});
        });
    },

    addSearchByStringHook: function (hook, priority) {
        var _this = this;
        this.searchByStringHooks.push({
            hook: hook,
            priority: priority || 0,
            index: _this.searchByStringHooks.length
        });

        this.searchByStringHooks.sort(function(a, b) {
            return b.priority - a.priority || a.index - b.index;
        })
    },

    removeSearchByStringHook: function(hook) {
        for (var h = 0; h < this.searchByStringHooks.length; h++) {
            if (this.searchByStringHooks[h].hook === hook) {
                this.searchByStringHooks.splice(h, 1);
                return;
            }
        }
    },

    layersSearch: function (res) {
        var globalRes = res;
        if (!nsGmx.gmxMap){
            reject(res);
        }

        var promisesArr = [];

        var layersToSearch = [];
        for (var i=0; i< nsGmx.gmxMap.layers.length; i++) {
            //свойства мы берём из дерева слоёв, а не из API. Cвойство AllowSearch относится к карте и не поддерживаются API
            var searchRes = window._layersTree.treeModel.findElem('name', nsGmx.gmxMap.layers[i].getGmxProperties().name);

            if (searchRes) {
                var props = searchRes.elem.content.properties;

                if (props.type == "Vector" && props.AllowSearch) {
                    layersToSearch.push(props);
                }
            }
        }
        var iRespCount = 0;

        if (layersToSearch.length > 0) {
            layersToSearch.forEach(function(props) {
                var mapName = nsGmx.gmxMap.layersByID[props.name].options.mapID;
                var url = window.serverBase + "SearchObject/SearchVector.ashx" +
                    "?LayerNames=" + props.name +
                    "&MapName=" + mapName +
                    "&SearchString=" + encodeURIComponent(res.Result.searchString);

                var promise = new Promise(function(resolve, reject) {
                    var req = new XMLHttpRequest();
                    req.withCredentials = true;
                    req.open('GET', url);

                    req.onload = function() {
                if (req.status == 200) {
                    var res = handleResponse(req.response, props);

                    res.then(function (res2) {
                        resolve(res2);
                    });
                } else {
                      reject(Error(req.statusText));
                    }
                  };
                  req.onerror = function() {
                    reject(Error("Network Error"));
                  };

                  req.send();
                });

                promisesArr.push(promise);
            });

            return Promise.all(promisesArr);
        } else {
            return new Promise(function(resolve, reject) {
                    resolve(res);
            })
        }

        function handleResponse(searchReq, layerProps) {
            searchReq = typeof searchReq === 'string' ? JSON.parse(searchReq.substring(1, searchReq.length - 1)) : searchReq;
            iRespCount++;
            var arrLayerResult = [];
            var arrResult = [];
            var arrDisplayFields = null;
            if (searchReq.Status == 'ok') {
                for (var iServer = 0; iServer < searchReq.Result.length; iServer++)
                {
                    var limitSearchResults = typeof(LayerSearchLimit)=="number" ? LayerSearchLimit : 100;
                    var req = searchReq.Result[iServer];
                    for (var j = 0; j<limitSearchResults && j < req.SearchResult.length; j++)
                    {
                        var arrDisplayProperties = {};
                        if (!arrDisplayFields) {
                            arrDisplayProperties = req.SearchResult[j].properties;
                        }
                        else {
                            for (var iProperty=0; iProperty<arrDisplayFields.length; iProperty++){
                                var sPropName = arrDisplayFields[iProperty];
                                if(sPropName in req.SearchResult[j].properties) {
                                    arrDisplayProperties[sPropName] = req.SearchResult[j].properties[sPropName];
                                }
                            }
                        }

                        for (var p in arrDisplayProperties) {
                            var type = layerProps.attrTypes[layerProps.attributes.indexOf(p)];
                            arrDisplayProperties[p] = nsGmx.Utils.convertFromServer(type, arrDisplayProperties[p]);
                        }

                        arrLayerResult.push({
                            ObjName: req.SearchResult[j].properties.NAME || req.SearchResult[j].properties.Name || req.SearchResult[j].properties.name || req.SearchResult[j].properties.text || req.SearchResult[j].properties["Название"] || "[объект]",
                            properties: arrDisplayProperties,
                            Geometry: L.gmxUtil.convertGeometry(req.SearchResult[j].geometry, true)
                        });
                    }
                }
                if(arrLayerResult.length > 0) arrResult.push({name: layerProps.title, SearchResult: arrLayerResult, CanDownloadVectors: true});

                if (iRespCount == layersToSearch.length){
                    // return arrResult;
                }
                return Promise.resolve(arrResult);
            } else {
                return Promise.reject(searchReq);
            }
        }
    }
}

L.Control.GmxLayers2 = L.Control.Layers.extend({
    options: {
        collapsed: true,
        autoZIndex: false,
        id: 'layers'
    },

    initialize: function (baseLayers, overlays, options) {
        L.Control.Layers.prototype.initialize.call(this, baseLayers, overlays, options);
    },
    onAdd: function (map) {
        L.Control.Layers.prototype.onAdd.call(this, map);
        this.init = false;
        this._initLayout();
        this._update();

        map
            .on('layeradd', this._onLayerChange, this)
            .on('layerremove', this._onLayerChange, this);

            this._iconClick = function () {
                if (this._iconContainer) {
                    this.setActive(!this.options.isActive);
                    this._update();
                    if (this.options.stateChange) { this.options.stateChange(this); }
                }
            };
            var stop = L.DomEvent.stopPropagation;
            L.DomEvent
                .on(this._iconContainer, 'mousemove', stop)
                .on(this._iconContainer, 'touchstart', stop)
                .on(this._iconContainer, 'mousedown', stop)
                .on(this._iconContainer, 'dblclick', stop)
                .on(this._iconContainer, 'click', stop)
                .on(this._iconContainer, 'click', this._iconClick, this);

        return this._container;
    },

    _initLayout: function () {
        var controlClassName = 'leaflet-control-layers2',
            prefix = 'leaflet-gmx-iconSvg',
            iconClassName =  prefix + ' ' + prefix + '-overlays svgIcon',
            listClassName = 'leaflet-control-layers',
            container = this._container = L.DomUtil.create('div', controlClassName),
            iconContainer = this._iconContainer = L.DomUtil.create('div', iconClassName),
            listContainer = this._listContainer = L.DomUtil.create('div', listClassName);

        var openingDirection = this.options.direction || 'bottom';

        L.DomUtil.addClass(listContainer, listClassName + '-' + openingDirection);
        if (this.options.title) { this._iconContainer.title = this.options.title; }

		this._prefix = prefix;

        //Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released
        container.setAttribute('aria-haspopup', true);

        if (!L.Browser.touch) {
            L.DomEvent
                .disableClickPropagation(container)
                .disableScrollPropagation(container);
        } else {
            L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);
        }

        var placeHolder = this._placeHolder = L.DomUtil.create('div', 'layers-placeholder');
        placeHolder.innerHTML = this.options.placeHolder;

        var form = this._form = L.DomUtil.create('form', listClassName + '-list');

        if (this.options.collapsed) {

          var useHref = '#' + 'overlays';
          iconContainer.innerHTML = '<svg role="img" class="svgIcon">\
              <use xlink:href="' + useHref + '"></use>\
            </svg>';

            var link = this._layersLink = L.DomUtil.create('a', '', listContainer);
            link.href = '#';
            link.title = 'Layers';

            if (L.Browser.touch) {
                L.DomEvent
                    .on(iconContainer, 'click', L.DomEvent.stop)
                    .on(iconContainer, 'click', this._expand, this);
            }
            //Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033
            L.DomEvent.on(form, 'click', function () {
                setTimeout(L.bind(this._onInputClick, this), 0);
            }, this);

            this._map.on('click', this._collapse, this);
        } else {
            this._expand();
        }

        this._baseLayersList = L.DomUtil.create('div', listClassName + '-base', form);
        this._separator = L.DomUtil.create('div', listClassName + '-separator', form);
        this._overlaysList = L.DomUtil.create('div', listClassName + '-overlays', form);

        listContainer.appendChild(form);
        listContainer.appendChild(placeHolder);
        container.appendChild(iconContainer);
        container.appendChild(listContainer);
        if (!this.init) { container.style.display = 'none'; }
    },

    _addLayer: function (layer, name, overlay) {
        if (Object.keys(this._layers).length === 0) {
            this.init = true;
        }

        L.Control.Layers.prototype._addLayer.call(this, layer, name, overlay);
    },

    _addItemObject: function (obj) {
        var label = this._addItem(obj);
        if (obj.layer && obj.layer._gmx && obj.layer._gmx.layerID) {
            label.className = '_' + obj.layer._gmx.layerID;
        }
    },

    _update: function () {
        if (!this._listContainer) {
            return;
        }
        var options = this.options;

        if (this.init) {
            this._container.style.display = '';
            this.setActive(false);
            this.init = false;
        }

        this._baseLayersList.innerHTML = '';
        this._overlaysList.innerHTML = '';

        var baseLayersPresent = false,
            overlaysPresent = false,
            i, len, obj;

        for (i in this._layers) {
            obj = this._layers[i];
            if (obj.overlay) {
                this._addItemObject(obj);
                overlaysPresent = true;
            } else {
                baseLayersPresent = true;
            }
        }

        this._container.style.display = overlaysPresent ? '' : 'none';

        this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
        this._form.style.display = overlaysPresent || baseLayersPresent ? '' : 'none';
        this._placeHolder.style.display = overlaysPresent || baseLayersPresent ? 'none' : '';


        if (!options.isActive) {
            this._form.style.display = 'none';
            this._placeHolder.style.display = 'none';
        }
    },

    setActive: function (active, skipEvent) {
        var options = this.options,
            togglable = options.togglable || options.toggle;
        if (togglable) {
            var prev = options.isActive,
                prefix = this._prefix,
                className = prefix + '-' + options.id,
                container = this._iconContainer;

            options.isActive = active;
            if (active) {
                L.DomUtil.addClass(container, prefix + '-active');
                L.DomUtil.addClass(container, className + '-active');
                if (container.children.length) {
                    L.DomUtil.addClass(container, prefix + '-externalImage-active');
                }
                if (options.styleActive) { this.setStyle(options.styleActive); }

        		L.DomUtil.addClass(this._listContainer, 'leaflet-control-layers-expanded');
            } else {
                L.DomUtil.removeClass(container, prefix + '-active');
                L.DomUtil.removeClass(container, className + '-active');
                if (container.children.length) {
                    L.DomUtil.removeClass(container, prefix + '-externalImage-active');
                }
                if (options.style) { this.setStyle(options.style); }
                L.DomUtil.removeClass(this._listContainer, 'leaflet-control-layers-expanded');
            }
            // ugly bug in IE
            // IE appends 'extended' class to the parent!
            if (L.DomUtil.hasClass(this._container, 'leaflet-control-layers-expanded')) {
                L.DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded')
            };
        }
    },

    addTo: function (map) {
        // L.Control.prototype.addTo.call(this, map);
        L.Control.GmxIcon.prototype.addTo.call(this, map);
        if (this.options.addBefore) {
            this.addBefore(this.options.addBefore);
        }
        return this;
    },

    addBefore: function (id) {
        var parentNode = this._parent && this._parent._container;
        if (!parentNode) {
            parentNode = this._map && this._map._controlCorners[this.getPosition()];
        }
        if (!parentNode) {
            this.options.addBefore = id;
        } else {
            for (var i = 0, len = parentNode.childNodes.length; i < len; i++) {
                var it = parentNode.childNodes[i];
                if (id === it._id) {
                    parentNode.insertBefore(this._container, it);
                    break;
                }
            }
        }
        return this;
    }
});

L.Control.gmxLayers2 = L.Control.GmxLayers2;
L.control.gmxLayers2 = function (baseLayers, overlays, options) {
  return new L.Control.GmxLayers2(baseLayers, overlays, options);
};

L.Control.Dialog = L.Control.extend({
  options: {
    size: [ 300, 300 ],
    minSize: [ 100, 100 ],
    maxSize: [ 350, 350 ],
    anchor: [ 250, 250 ],
    position: 'topleft',
    initOpen: true
  },

  initialize: function (options){
    L.setOptions(this, options);

    this._attributions = {};
  },

  onAdd: function (map){

    this._initLayout();
    this._map = map;

    this.update();

    if(!this.options.initOpen){
      this.close();
    }

    return this._container;
  },

  open: function(){
    if(!this._map){
      return;
    }
    this._container.style.visibility = '';

    this._map.fire('dialog:opened', this);

    return this;
  },

  close: function(){
    this._container.style.visibility = 'hidden';

    this._map.fire('dialog:closed', this);
    return this;
  },

  destroy: function(){
    if(!this._map){ return this; }

    this.removeFrom(this._map);

    if (this.onRemove) {
			this.onRemove(this._map);
		}

    this._map.fire('dialog:destroyed', this);
    return this;
  },

  setLocation: function(location){
    location = location || [ 250, 250 ];

    this.options.anchor[0] = 0;
    this.options.anchor[1] = 0;
    this._oldMousePos.x = 0;
    this._oldMousePos.y = 0;

    this._move(location[1], location[0]);

    return this;
  },

  setSize: function(size){
    size = size || [ 300, 300 ];

    this.options.size[0] = 0;
    this.options.size[1] = 0;
    this._oldMousePos.x = 0;
    this._oldMousePos.y = 0;

    this._resize(size[0], size[1]);

    return this;
  },

  lock: function(){
    this._resizerNode.style.visibility = 'hidden';
    this._grabberNode.style.visibility = 'hidden';
    this._closeNode.style.visibility = 'hidden';

    this._map.fire('dialog:locked', this);
    return this;
  },

  unlock: function(){
    this._resizerNode.style.visibility = '';
    this._grabberNode.style.visibility = '';
    this._closeNode.style.visibility = '';

    this._map.fire('dialog:unlocked', this);
    return this;
  },

  freeze: function(){
    this._resizerNode.style.visibility = 'hidden';
    this._grabberNode.style.visibility = 'hidden';

    this._map.fire('dialog:frozen', this);
    return this;
  },

  unfreeze : function(){
    this._resizerNode.style.visibility = '';
    this._grabberNode.style.visibility = '';

    this._map.fire('dialog:unfrozen', this);
    return this;
  },

  setContent: function(content){
    this._content = content;
    this.update();
    return this;
  },

  getContent: function(){
    return this._content;
  },

  getElement: function(){
    return this._container;
  },

  update: function(){
    if (!this._map) { return; }

    this._container.style.visibility = 'hidden';

    this._updateContent();
    this._updateLayout();

    this._container.style.visibility = '';
    this._map.fire('dialog:updated', this);

  },

  _initLayout: function(){
    var className = 'leaflet-control-dialog',
      container = this._container = L.DomUtil.create('div', className);

    container.style.width = this.options.size[0] + 'px';
    container.style.height = this.options.size[1] + 'px';

    container.style.top = this.options.anchor[0] + 'px';
    container.style.left = this.options.anchor[1] + 'px';

    var stop = L.DomEvent.stopPropagation;
    L.DomEvent
        .on(container, 'click', stop)
        .on(container, 'mousedown', stop)
        .on(container, 'touchstart', stop)
        .on(container, 'dblclick', stop)
        .on(container, 'mousewheel', stop)
        .on(container, 'contextmenu', stop)
        .on(container, 'MozMousePixelScroll', stop);

    var innerContainer = this._innerContainer = L.DomUtil.create('div', className + '-inner');

    var grabberNode = this._grabberNode = L.DomUtil.create('div', className + '-grabber');
    var grabberIcon = L.DomUtil.create('i', 'fa fa-arrows');
    grabberNode.appendChild(grabberIcon);

    L.DomEvent.on(grabberNode, 'mousedown', this._handleMoveStart, this);

    var closeNode = this._closeNode = L.DomUtil.create('div', className + '-close');
    var closeIcon = L.DomUtil.create('i', 'fa fa-times');
    closeNode.appendChild(closeIcon);
    L.DomEvent.on(closeNode, 'click', this._handleClose, this);

    var resizerNode = this._resizerNode = L.DomUtil.create('div', className + '-resizer');
    var resizeIcon = L.DomUtil.create('i', 'fa fa-arrows-h fa-rotate-45');
    resizerNode.appendChild(resizeIcon);

    L.DomEvent.on(resizerNode, 'mousedown', this._handleResizeStart, this);

    var contentNode = this._contentNode = L.DomUtil.create('div', className + "-contents");

    container.appendChild(innerContainer);

    innerContainer.appendChild(contentNode);
    innerContainer.appendChild(grabberNode);
    innerContainer.appendChild(closeNode);
    innerContainer.appendChild(resizerNode);

    this._oldMousePos = { x: 0, y: 0 };

  },

  _handleClose: function(){
    this.close();
  },

  _handleResizeStart: function(e){
    this._oldMousePos.x = e.clientX;
    this._oldMousePos.y = e.clientY;

    L.DomEvent.on(this._map, 'mousemove', this._handleMouseMove, this);
    L.DomEvent.on(this._map, 'mouseup', this._handleMouseUp, this);

    this._map.fire('dialog:resizestart', this);
    this._resizing = true;
  },

  _handleMoveStart: function(e){
    this._oldMousePos.x = e.clientX;
    this._oldMousePos.y = e.clientY;

    L.DomEvent.on(this._map, 'mousemove', this._handleMouseMove, this);
    L.DomEvent.on(this._map, 'mouseup', this._handleMouseUp, this);

    this._map.fire('dialog:movestart', this);
    this._moving = true;
  },

  _handleMouseMove: function(e){
    var diffX = e.originalEvent.clientX - this._oldMousePos.x,
      diffY = e.originalEvent.clientY - this._oldMousePos.y;

      // this helps prevent accidental highlighting on drag:
    if(e.originalEvent.stopPropagation){ e.originalEvent.stopPropagation(); }
    if(e.originalEvent.preventDefault){ e.originalEvent.preventDefault(); }

    if(this._resizing){
      this._resize(diffX, diffY);
    }

    if(this._moving){
      this._move(diffX, diffY);
    }
  },

  _handleMouseUp: function(){
    L.DomEvent.off(this._map, 'mousemove', this._handleMouseMove, this);
    L.DomEvent.off(this._map, 'mouseup', this._handleMouseUp, this);

    if(this._resizing){
      this._resizing = false;
      this._map.fire('dialog:resizeend', this);
    }

    if(this._moving){
      this._moving = false;
      this._map.fire('dialog:moveend', this);
    }
  },

  _move: function(diffX, diffY){
    var newY = this.options.anchor[0] + diffY;
    var newX = this.options.anchor[1] + diffX;

    this.options.anchor[0] = newY;
    this.options.anchor[1] = newX;

    this._container.style.top = this.options.anchor[0] + 'px';
    this._container.style.left = this.options.anchor[1] + 'px';

    this._map.fire('dialog:moving', this);

    this._oldMousePos.y += diffY;
    this._oldMousePos.x += diffX;
  },

  _resize: function(diffX, diffY){
    var newX = this.options.size[0] + diffX;
    var newY = this.options.size[1] + diffY;

    if( newX <= this.options.maxSize[0] && newX >= this.options.minSize[0]){
      this.options.size[0] = newX;
      this._container.style.width = this.options.size[0] + 'px';
      this._oldMousePos.x += diffX;
    }

    if(newY <= this.options.maxSize[1] && newY >= this.options.minSize[1] ){
      this.options.size[1] = newY;
      this._container.style.height = this.options.size[1] + 'px';
      this._oldMousePos.y += diffY;
    }

    this._map.fire('dialog:resizing', this);
  },

  _updateContent: function(){

    if(!this._content){ return; }

    var node = this._contentNode;
    var content = (typeof this._content === 'function') ? this._content(this) : this._content;

    if(typeof content === 'string'){
      node.innerHTML = content;
    }
    else{
      while(node.hasChildNodes()){
        node.removeChild(node.firstChild);
      }
      node.appendChild(content);
    }

  },

  _updateLayout: function(){

    this._container.style.width = this.options.size[0] + 'px';
    this._container.style.height = this.options.size[1] + 'px';

    this._container.style.top = this.options.anchor[0] + 'px';
    this._container.style.left = this.options.anchor[1] + 'px';

  }

});

L.control.dialog = function (options) {
  return new L.Control.Dialog(options);
};

//Тут кратко описываются разные внешние классы для системы генерации документации

/** ГеоМиксер активно использует {@link http://jquery.com/|jQuery}
 * @namespace jQuery
 */

/** Официальная документация: {@link http://api.jquery.com/category/deferred-object/|jQuery Deferred}
 * @name Deferred
 * @memberOf jQuery
 */


/** Библиотека для формализации понятия модели и представления: {@link http://backbonejs.org/|Backbone}
 * @namespace Backbone
 */

/** Официальная документация: {@link http://backbonejs.org/#Model| Backbone Model}
 * @name Model
 * @memberOf Backbone
 */


/**
    Основное пространство имён ГеоМиксера
    @namespace
*/
var nsGmx = nsGmx || {};
nsGmx.widgets = nsGmx.widgets || {};

(function() {

    'use strict';

    var gmxJSHost = window.gmxJSHost || '';

    if (!window.mapHostName && window.gmxJSHost) {
        window.mapHostName = /https?:\/\/(.*)\/api\//.exec(window.gmxJSHost)[1];
    }

    var _mapHostName; //откуда грузить API
    var protocol = window.location.protocol;

    if (window.mapHostName) {
        _mapHostName = protocol + '//' + window.mapHostName + '/api/';
    } else {
        var curUri = L.gmxUtil.parseUri(window.location.href);
        _mapHostName = protocol + '//' + curUri.host + curUri.directory;
    }

    var _serverBase = window.serverBase || /(.*)\/[^\/]*\//.exec(_mapHostName)[1] + '/';

    //подставляет к локальному имени файла хост (window.gmxJSHost) и, опционально, рандомное поле для сброса кэша (window.gmxDropBrowserCache)
    var _getFileName = function(localName) {
        return gmxJSHost + localName + (window.gmxDropBrowserCache ? '?' + Math.random() : '');
    }

    nsGmx.initGeoMixer = function() {

        var oSearchLeftMenu = new leftMenu();
        window.searchLogic = new nsGmx.SearchLogic();

        //для синхронизации меню и тулбара при включении/выключении сетки координат
        nsGmx.gridManager = {
            state: false,
            gridControl: null,
            options: null,
            menu: null,

            setState: function(state) {
                var isActive = state.isActive,
                    options = state.options;

                if (this.state == isActive) {
                    return;
                }

                //lazy instantantion
                this.gridControl = this.gridControl || new L.GmxGrid();
                nsGmx.leafletMap[isActive ? 'addLayer' : 'removeLayer'](this.gridControl);
                if (options) {
                    this.restoreOptions(options);
                }
                this.state = isActive;
                nsGmx.leafletMap.gmxControlIconManager.get('gridTool').setActive(isActive);
                _menuUp.checkItem('mapGrid', isActive);
                _mapHelper.gridView = isActive; //можно удалить?

                if (this.state) {
                    this.configureGrid();
                } else {
                    if (this.menu) {
                        this.menu.Unload();
                    }
                }
            },

            saveOptions: function() {
                this.options = this.gridControl.options;
            },

            restoreOptions: function(options) {
                this.gridControl.setUnits(options.units);
                if (options.customStep) {
                    this.gridControl.setStep(options.customStep.x, options.customStep.y);
                }
                this.gridControl.setColor(options.color);
                this.gridControl.setTitleFormat(options.titleFormat);
            },

            configureGrid: function() {
                var _this = this;
                gmxCore.loadModule('GridPlugin', 'src/GridPlugin.js').then(function(def) {
                    _this.menu = new def.ConfigureGridMenu(nsGmx.gridManager);
                    _this.menu.Load();
                });
            }
        }

        var createMenuNew = function() {
            //формирует описание элемента меню для включения/выключения плагина
            var getPluginToMenuBinding = function(pluginName, menuItemName, menuTitle) {
                var plugin = nsGmx.pluginsManager.getPluginByName(pluginName);

                if (!plugin) {
                    return null;
                }

                var sel = function() {
                    nsGmx.pluginsManager.setUsePlugin(pluginName, true);
                    nsGmx.pluginsManager.done(function() {
                        var paramsClone = $.extend(true, {}, plugin.params);
                        plugin.body.afterViewer && plugin.body.afterViewer(paramsClone, nsGmx.leafletMap);
                        _mapHelper.mapPlugins.addPlugin(pluginName, plugin.params);
                    })
                }

                var unsel = function() {
                    nsGmx.pluginsManager.setUsePlugin(pluginName, false);
                    nsGmx.pluginsManager.done(function() {
                        _mapHelper.mapPlugins.remove(pluginName);
                        plugin.body.unload && plugin.body.unload();
                    })
                }

                return {
                    id: menuItemName,
                    title: menuTitle,
                    onsel: sel,
                    onunsel: unsel,
                    checked: plugin.isUsed()
                }
            }

            var isMapEditor = _queryMapLayers.currentMapRights() === 'edit',
                isLogined = nsGmx.AuthManager.isLogin();

            _menuUp.submenus = [];

            _menuUp.addItem({
                id: 'mapsMenu',
                title: _gtxt('Карта'),
                childs: [].concat(
                    isLogined ? [{ id: 'mapList', title: _gtxt('Открыть'), func: function() { _queryMapLayers.getMaps() } }] : [], [{
                            id: 'mapCreate',
                            title: _gtxt('Создать'),
                            func: function() {
                                _queryMapLayers.createMapDialog(_gtxt('Создать карту'), _gtxt('Создать'), _queryMapLayers.createMap)
                            }
                        },
                        { id: 'mapSave', title: _gtxt('Сохранить'), func: _queryMapLayers.saveMap },
                        {
                            id: 'mapSaveAs',
                            title: _gtxt('Сохранить как'),
                            func: function() {
                                _queryMapLayers.createMapDialog(_gtxt('Сохранить карту как'), _gtxt('Сохранить'), _queryMapLayers.saveMapAs)
                            },
                            delimiter: true
                        },
                        {
                            id: 'export',
                            title: _gtxt('Экспорт'),
                            func: function() {
                                mapExportMenu();
                            },
                            disabled: !isLogined
                        },
                        { id: 'shareMenu', title: _gtxt('Поделиться'), func: function() { _mapHelper.showPermalink() } },
                        // {id: 'codeMap',      title: _gtxt('Код для вставки'),   func: function(){_mapHelper.createAPIMapDialog()}, disabled: true},
                        {
                            id: 'mapTabsNew',
                            title: _gtxt('Добавить закладку'),
                            func: function() {
                                mapHelp.tabs.load('mapTabs');
                                _queryTabs.add();
                            }
                        },
                        { id: 'printMap', title: _gtxt('Печать'), func: function() { _mapHelper.print() }, delimiter: true },
                        {
                            id: 'mapProperties',
                            title: _gtxt('Свойства'),
                            func: function() {
                                var div = $(_layersTree._treeCanvas).find('div[MapID]')[0];
                                nsGmx.createMapEditor(div);
                            },
                            disabled: !isMapEditor
                        },
                        {
                            id: 'createGroup',
                            title: _gtxt('Добавить подгруппу'),
                            func: function() {
                                var div = $(_layersTree._treeCanvas).find('div[MapID]')[0];
                                nsGmx.addSubGroup(div, _layersTree);
                            },
                            disabled: !isMapEditor
                        },
                        {
                            id: 'mapSecurity',
                            title: _gtxt('Права доступа'),
                            func: function() {
                                var securityDialog = new nsGmx.mapSecurity(),
                                    props = _layersTree.treeModel.getMapProperties();
                                securityDialog.getRights(props.MapID, props.title);
                            },
                            disabled: !isMapEditor
                        }
                    ]
                )
            });

            _menuUp.addItem({
                id: 'dataMenu',
                title: _gtxt('Данные'),
                childs: [
                    { id: 'layerList', title: _gtxt('Открыть слой'), func: function() { _queryMapLayers.getLayers() }, disabled: !isMapEditor },
                    {
                        id: 'createLayer',
                        title: _gtxt('Создать слой'),
                        childs: [
                            { id: 'createRasterLayer', title: _gtxt('Растровый'), func: _mapHelper.createNewLayer.bind(_mapHelper, 'Raster'), disabled: !isMapEditor },
                            { id: 'createVectorLayer', title: _gtxt('Векторный'), func: _mapHelper.createNewLayer.bind(_mapHelper, 'Vector'), disabled: !isMapEditor },
                            { id: 'createMultiLayer', title: _gtxt('Мультислой'), func: _mapHelper.createNewLayer.bind(_mapHelper, 'Multi'), disabled: !isMapEditor }
                        ],
                        disabled: !isMapEditor
                    },
                    {
                        id: 'baseLayers',
                        title: _gtxt('Базовые слои'),
                        func: function() {
                            var div = $(_layersTree._treeCanvas).find('div[MapID]')[0];
                            nsGmx.createMapEditor(div, 1);
                        },
                        delimiter: true,
                        disabled: !isMapEditor
                    },
                    { id: 'loadFile', title: _gtxt('Загрузить объекты'), func: drawingObjects.loadShp.load, delimiter: true },
                    { id: 'loadPhotos', title: _gtxt('Загрузить фотографии'), func: function() { PhotoLayerDialog() }, delimiter: true, disabled: !isMapEditor },
                    { id: 'wms', title: _gtxt('Подключить WMS'), func: loadServerData.WMS.load },
                    { id: 'wfs', title: _gtxt('Подключить WFS'), func: loadServerData.WFS.load }
                ]
            });

            _menuUp.addItem({
                id: 'viewMenu',
                title: _gtxt('Вид'),
                childs: [
                    { id: 'externalMaps', title: _gtxt('Дополнительные карты'), func: mapHelp.externalMaps.load },
                    { id: 'mapTabs', title: _gtxt('Закладки'), func: mapHelp.tabs.load },
                    { id: 'DrawingObjects', title: _gtxt('Объекты'), func: oDrawingObjectGeomixer.Load }
                    // {id:'searchView',     title: _gtxt('Результаты поиска'),    func: oSearchControl.Load}
                ]
            });

            _menuUp.addItem({
                id: 'instrumentsMenu',
                title: _gtxt('Инструменты'),
                childs: [{
                        id: 'mapGrid',
                        title: _gtxt('Координатная сетка'),
                        onsel: nsGmx.gridManager.setState.bind(nsGmx.gridManager, { isActive: true }),
                        onunsel: nsGmx.gridManager.setState.bind(nsGmx.gridManager, { isActive: false }),
                        checked: _mapHelper.gridView
                    },
                    {
                        id: 'mapIndexGrid',
                        title: _gtxt('Индексная сетка'),
                        func: function() {
                            indexGridMenu();
                        }
                    },
                    { id: 'shift', title: _gtxt('Ручная привязка растров'), func: function() {}, disabled: true },
                    { id: 'crowdsourcing', title: _gtxt('Краудсорсинг данных'), func: function() {}, disabled: true },
                    { id: 'geocoding', title: _gtxt('Пакетный геокодинг'), func: function() {}, disabled: true },
                    { id: 'directions', title: _gtxt('Маршруты'), func: function() {}, disabled: true }
                ]
            });


            function fillPluginsMenu() {
                var plugins = window.menuPlugins || [];

                // для локальной версии Геомиксера покажем плагины кадастра и Викимапии
                if (!window.menuPlugins) {
                    if (nsGmx.pluginsManager.getPluginByName('Cadastre')) {
                        plugins.push({ pluginName: 'Cadastre', menuItemName: 'cadastre', menuTitle: 'Кадастр Росреестра' });
                    }
                }

                if (plugins.length) {
                    var childs = [];
                    for (var p = 0; p < plugins.length; p++) {
                        childs.push(
                            getPluginToMenuBinding(
                                plugins[p].pluginName,
                                plugins[p].menuItemName,
                                window._gtxt(plugins[p].menuTitle)
                            )
                        )
                    }

                    _menuUp.addItem({ id: 'pluginsMenu', title: _gtxt('Сервисы'), childs: childs });
                }
            }
            fillPluginsMenu();

            _menuUp.addItem({
                id: 'helpMenu',
                title: _gtxt('Справка'),
                childs: nsGmx.gmxMap.properties.MapID !== '31RJS' ? [
                    { id: 'about', title: _gtxt('О проекте'), func: _mapHelper.version },
                ].concat(window.mapsSite ? [{
                        id: 'usage',
                        title: _gtxt('Руководство пользователя'),
                        func: function() {
                            window.open('http://geomixer.ru/index.php/ru/docs/', '_blank');
                        }
                    },
                    {
                        id: 'api',
                        title: _gtxt('GeoMixer API'),
                        func: function() {
                            window.open('http://geomixer.ru/index.php/ru/docs/dev-manual/getting-started', '_blank');
                        }
                    },
                    {
                        id: 'pluginsUsage',
                        title: _gtxt('Использование плагинов'),
                        func: function() {
                            window.open('http://geomixer.ru/index.php/ru/docs/manual/plugins', '_blank');
                        }
                    }
                ] : []) : [{
                        id: 'usage',
                        title: _gtxt('Руководство'),
                        func: function() {
                            window.open('http://kosmosnimki.ru/downloads/%D1%86%D1%81%D0%BC%D1%81.pdf', '_blank');
                        }
                    }]
            });
        }

        var createToolbar = function() {
            var lmap = nsGmx.leafletMap;

            var SliderControl = L.Control.extend({
                options: {
                    position: 'topleft'
                },
                onAdd: function(map) {
                    var sliderContainer = $('<div class="gmx-slider-control"></div>');
                    this._widget = new nsGmx.TransparencySliderWidget(sliderContainer);

                    $(this._widget).on('slide slidechange', function(event, ui) {
                        _queryMapLayers.applyOpacityToRasterLayers(ui.value * 100, _queryMapLayers.buildedTree);
                    })

                    return sliderContainer[0];
                },
                onRemove: function() {},
                isCollapsed: function() { return this._widget.isCollapsed(); }
            });
            var sliderControl = new SliderControl();
            lmap.addControl(sliderControl);

            //пополняем тулбар
            var uploadFileIcon = L.control.gmxIcon({
                id: 'uploadFile',
                title: _gtxt('Загрузить объекты')
            }).on('click', drawingObjects.loadShp.load.bind(drawingObjects.loadShp));

            lmap.gmxControlIconManager.get('drawing').addIcon(uploadFileIcon);

            // выпадающие группы иконок наезжают на слайдер прозрачности.
            // Эта ф-ция разруливает этот конфликт, скрывая слайдер в нужный момент
            var resolveToolConflict = function(iconGroup) {
                iconGroup
                    .on('collapse', function() {
                        $('.gmx-slider-control').removeClass('invisible');
                    }).on('expand', function() {
                        sliderControl.isCollapsed() || $('.gmx-slider-control').addClass('invisible');
                    });
            }

            if (_queryMapLayers.currentMapRights() === 'edit') {

                var saveMapIcon = L.control.gmxIcon({
                        id: 'saveMap',
                        title: _gtxt('Сохранить карту'),
                        addBefore: 'drawing'
                    })
                    .addTo(lmap)
                    .on('click', _queryMapLayers.saveMap.bind(_queryMapLayers));

                //группа создания слоёв
                var createVectorLayerIcon = L.control.gmxIcon({
                    id: 'createVectorLayer',
                    title: _gtxt('Создать векторный слой'),
                    addBefore: 'drawing'
                }).on('click', function() {
                    _mapHelper.createNewLayer('Vector');
                    createVectorLayerIcon.setActive(true);
                    createRasterLayerIcon.setActive(false);
                });

                var createRasterLayerIcon = L.control.gmxIcon({
                    id: 'createRasterLayer',
                    title: _gtxt('Создать растровый слой'),
                    addBefore: 'drawing'
                }).on('click', function() {
                    _mapHelper.createNewLayer('Raster');
                    createRasterLayerIcon.setActive(true);
                    createVectorLayerIcon.setActive(false);
                });

                var createLayerIconGroup = L.control.gmxIconGroup({
                    id: 'createLayer',
                    isSortable: true,
                    //isCollapsible: false,
                    items: [createVectorLayerIcon, createRasterLayerIcon],
                    addBefore: 'drawing'
                }).addTo(lmap);

                var bookmarkIcon = L.control.gmxIcon({
                    id: 'bookmark',
                    title: _gtxt('Добавить закладку'),
                    addBefore: 'drawing'
                }).on('click', function() {
                    mapHelp.tabs.load('mapTabs');
                    _queryTabs.add();
                }).addTo(lmap);

                resolveToolConflict(createLayerIconGroup);
            } else {
                resolveToolConflict(lmap.gmxControlIconManager.get('drawing'));
            }

            var printIcon = L.control.gmxIcon({
                    id: 'gmxprint',
                    title: _gtxt('Печать'),
                    addBefore: 'drawing'
                })
                .addTo(lmap)
                .on('click', _mapHelper.print.bind(_mapHelper));

            var permalinkIcon = L.control.gmxIcon({
                    id: 'permalink',
                    title: _gtxt('Ссылка на карту'),
                    addBefore: 'drawing'
                })
                .addTo(lmap)
                .on('click', _mapHelper.showPermalink.bind(_mapHelper));

            if (window.mapsSite) {
                var shareIconControl = new nsGmx.ShareIconControl({
                    className: 'shareIcon',
                    id: 'share',
                    text: 'Share',
                    style: {
                        width: 'auto'
                    },
                    permalinkManager: {
                        save: function() {
                            return $.when(
                                _mapHelper.createPermalink(),
                                nsMapCommon.generateWinniePermalink()
                            )
                        }
                    },
                    permalinkUrlTemplate: '{{href}}?permalink={{permalinkId}}',
                    embeddedUrlTemplate: 'http://winnie.kosmosnimki.ru/viewer.html?config={{winnieId}}',
                    winnieUrlTemplate: 'http://winnie.kosmosnimki.ru/?config={{winnieId}}',
                    previewUrlTemplate: 'iframePreview.html?width={{width}}&height={{height}}&permalinkUrl={{{embeddedUrl}}}'
                });
                lmap.addControl(shareIconControl);
            }

            var gridIcon = L.control.gmxIcon({
                    id: 'gridTool',
                    title: _gtxt('Координатная сетка'),
                    togglable: true,
                    addBefore: 'drawing'
                })
                .addTo(lmap)
                .on('click', function() {
                    var state = { isActive: gridIcon.options.isActive };
                    nsGmx.gridManager.setState(state);
                });

            _mapHelper.customParamsManager.addProvider({
                name: 'GridManager',
                loadState: function(state) {
                    nsGmx.gridManager.setState(state);
                },
                saveState: function() {
                    return {
                        version: '1.0.0',
                        isActive: gridIcon.options.isActive,
                        options: nsGmx.gridManager.options
                    }
                }
            });

            lmap.addControl(L.control.gmxIcon({
                id: 'boxzoom-dashed-rounded',
                toggle: true,
                addBefore: 'drawing',
                title: 'Увеличение',
                onAdd: function(control) {
                    var map = control._map,
                        _onMouseDown = map.boxZoom._onMouseDown;
                    map.boxZoom._onMouseDown = function(e) {
                        _onMouseDown.call(map.boxZoom, {
                            clientX: e.clientX,
                            clientY: e.clientY,
                            which: 1,
                            shiftKey: true
                        });
                    };
                    map.on('boxzoomend', function() {
                        map.dragging.enable();
                        map.boxZoom.removeHooks();
                        control.setActive(false);
                    });
                },
                stateChange: function(control) {
                    var map = control._map;
                    if (control.options.isActive) {
                        map.dragging.disable();
                        map.boxZoom.addHooks();
                    } else {
                        map.dragging.enable();
                        map.boxZoom.removeHooks();
                    }
                }
            }));

            /**
             * seachParams
             */

            window.searchControl = new nsGmx.SearchControl({
                id: 'searchcontrol',
                placeHolder: 'Поиск по векторным слоям и адресной базе',
                position: 'topright',
                limit: 10,
                retrieveManyOnEnter: true,
                providers: [
                    new nsGmx.searchProviders.Osm2DataProvider({
                        showOnMap: true,
                        serverBase: 'http://maps.kosmosnimki.ru',
                        limit: 10,
                        onFetch: function(response) {
                            window.searchLogic.showResult(response);
                        }.bind(this)
                    })
                ],
                style: {
                    editable: false,
                    map: true,
                    pointStyle: {
                        size: 8,
                        weight: 1,
                        opacity: 1,
                        color: '#00008B'
                    },
                    lineStyle: {
                        fill: false,
                        weight: 3,
                        opacity: 1,
                        color: '#008B8B'
                    }
                }
            });

            window.searchLogic.searchControl = window.searchControl;

            lmap.addControl(window.searchControl);
            lmap.gmxControlsManager.add(window.searchControl);
            // shitty trick
            // 'cause Aryunov doesn't use controls id
            window.searchControl._container._id = 'searchcontrol';

            var searchContainer = window.searchControl._widget._container;
            var stop = L.DomEvent.stopPropagation;

            L.DomEvent
                .on(searchContainer, 'mousemove', stop)
                .on(searchContainer, 'touchstart', stop)
                .on(searchContainer, 'mousedown', stop)
                .on(searchContainer, 'dblclick', stop)
                .on(searchContainer, 'contextmenu', stop)
                .on(searchContainer, 'click', stop);

            var gmxLayers = new L.control.gmxLayers2(null, null, {
                title: window._gtxt('Панель оверлеев'),
                collapsed: true,
                togglable: true,
                addBefore: 'searchcontrol',
                direction: '',
                placeHolder: window._gtxt("оверлеи отсутствуют")

            });

            lmap.addControl(gmxLayers);
            lmap.gmxControlsManager.add(gmxLayers);
        }

        var createDefaultMenu = function() {
            _menuUp.submenus = [];

            _menuUp.addItem({
                id: 'mapsMenu',
                title: _gtxt('Карта'),
                childs: [
                    { id: 'mapCreate', title: _gtxt('Создать'), func: function() { _queryMapLayers.createMapDialog(_gtxt('Создать карту'), _gtxt('Создать'), _queryMapLayers.createMap) } },
                    { id: 'mapList', title: _gtxt('Открыть'), func: function() { _queryMapLayers.getMaps() } }
                ]
            });

            _menuUp.addItem({
                id: 'helpMenu',
                title: _gtxt('Справка'),
                childs: [
                    { id: 'usage', title: _gtxt('Использование'), onsel: mapHelp.mapHelp.load, onunsel: mapHelp.mapHelp.unload },
                    { id: 'serviceHelp', title: _gtxt('Сервисы'), onsel: mapHelp.serviceHelp.load, onunsel: mapHelp.serviceHelp.unload },
                    { id: 'about', title: _gtxt('О проекте'), func: _mapHelper.version }
                ]
            });
        }

        var parseURLParams = function() {
            var q = window.location.search,
                kvp = (q.length > 1) ? q.substring(1).split('&') : [];

            for (var i = 0; i < kvp.length; i++) {
                kvp[i] = kvp[i].split('=');
            }

            var params = {},
                givenMapName = false;

            for (var j = 0; j < kvp.length; j++) {
                if (kvp[j].length == 1) {
                    if (!givenMapName)
                        givenMapName = decodeURIComponent(kvp[j][0]);
                } else {
                    params[kvp[j][0]] = kvp[j][1];
                }
            }

            return { params: params, givenMapName: givenMapName };
        }

        $(function() {

            var virtualLayerManager = new nsGmx.VirtualLayerManager();
            L.gmx.addLayerClassLoader(virtualLayerManager.loader);

            $('body').on('keyup', function(event) {
                if ((event.target === document.body || $(event.target).hasClass('leaflet-container')) && event.keyCode === 79) {
                    _queryMapLayers.getMaps();
                    return false;
                }
            })

            var languageFromSettings = translationsHash.getLanguageFromCookies() || window.defaultLang;
            window.language = languageFromSettings || 'rus';

            window.shownTitle = window.pageTitle || _gtxt('ScanEx Web Geomixer - просмотр карты');
            document.title = window.shownTitle;

            window.serverBase = _serverBase;

            addParseResponseHook('*', function(response, customErrorDescriptions) {
                if (response.Warning) {
                    //мы дожидаемся загрузки дерева слоёв, чтобы не добавлять notification widget слишком рано (до инициализации карты в контейнере)
                    _queryMapLayers.loadDeferred.then(function() {
                        nsGmx.widgets.notifications.stopAction(null, 'warning', response.Warning, 0);
                    });
                }
            })

            var customErrorTemplate = Handlebars.compile('<div class="CustomErrorText">{{description}}</div>'),
                commonErrorTemplate = Handlebars.compile(
                    '<div class="CommonErrorText"><table class="CommonErrorTable">' +
                    '<tr><td>{{message}}</td></tr>' +
                    '<tr class="StacktraceContainer"><td class="StacktraceContainer">{{#if stacktrace}}<textarea class="inputStyle error StacktraceErrorText">{{stacktrace}}</textarea>{{/if}}</td></tr>' +
                    '</table></div>'
                );

            //при каждой ошибке от сервера будем показывать диалог с ошибкой и стектрейсом.
            addParseResponseHook('error', function(response, customErrorDescriptions) {
                var errInfo = response.ErrorInfo;

                if (errInfo.ErrorMessage && !errInfo.ErrorMessage in _mapHelper.customErrorsHash) {
                    if (customErrorDescriptions && errInfo.ExceptionType in customErrorDescriptions) {
                        var canvas = $(customErrorTemplate({
                            description: customErrorDescriptions[errInfo.ExceptionType]
                        }));
                        showDialog(_gtxt('Ошибка!'), canvas[0], 220, 100);
                    } else {
                        var stackTrace = response.ErrorInfo.ExceptionType && response.ErrorInfo.StackTrace;
                        var canvas = $(commonErrorTemplate({
                            message: errInfo.ErrorMessage,
                            stacktrace: stackTrace
                        }));
                        showDialog(_gtxt('Ошибка сервера'), canvas[0], 220, 170, false, false);
                        return false;
                    }
                }
            })

            _translationsHash.addErrorHandler(function(text) {
                showErrorMessage('Не найдено тектовое описание для "' + text + '"');
            })

            nsGmx.pluginsManager = new(gmxCore.getModule('PluginsManager').PluginsManager)();

            //будем сохранять в пермалинке все активные плагины
            _mapHelper.customParamsManager.addProvider({
                name: 'PluginManager',
                loadState: function(state) {
                    for (var p in state.usage) {
                        var plugin = nsGmx.pluginsManager.getPluginByName(p);

                        plugin && plugin.setUsage(state.usage[p] ? 'used' : 'notused');
                    }
                },
                saveState: function() {
                    var usage = {};
                    nsGmx.pluginsManager.forEachPlugin(function(plugin) {
                        if (plugin.pluginName) {
                            usage[plugin.pluginName] = plugin.isUsed();
                        }
                    })

                    return {
                        version: '1.0.0',
                        usage: usage
                    }
                }
            });

            //сейчас подгружаются все глобальные плагины + все плагины карт, у которых нет имени в конфиге
            nsGmx.pluginsManager.done(function() {
                nsGmx.AuthManager.checkUserInfo(function() {
                    nsGmx.pluginsManager.beforeMap();

                    var parsedURL = parseURLParams();

                    parseReferences(parsedURL.params, parsedURL.givenMapName);

                }, function() {
                    //TODO: обработка ошибок
                })
            })
        });

        function parseReferences(params, givenMapName) {
            window.documentHref = window.location.href.split('?')[0];

            if (params['permalink']) {
                eraseCookie('TinyReference');
                createCookie('TinyReference', params['permalink']);

                window.location.replace(documentHref + (givenMapName ? ('?' + givenMapName) : ''));
                return;
            }

            var defaultState = { isFullScreen: params['fullscreen'] == 'true' || params['fullscreen'] == 'false' ? params['fullscreen'] : 'false' };

            if ('x' in params && 'y' in params && 'z' in params &&
                !isNaN(Number(params.x)) && !isNaN(Number(params.y)) && !isNaN(Number(params.z)))
                defaultState.position = { x: Number(params.x), y: Number(params.y), z: Number(params.z) }

            if ('mx' in params && 'my' in params &&
                !isNaN(Number(params.mx)) && !isNaN(Number(params.my)))
                defaultState.marker = { mx: Number(params.mx), my: Number(params.my), mt: 'mt' in params ? params.mt : false }

            if ('mode' in params)
                defaultState.mode = params.mode;

            if ('dt' in params) {
                defaultState.dt = params.dt;
            }

            window.defaultMapID = typeof window.defaultMapID !== 'undefined' ? window.defaultMapID : 'DefaultMap';

            var mapName = window.defaultMapID && !givenMapName ? window.defaultMapID : givenMapName;

            window.globalMapName = mapName;

            if (!window.globalMapName) {
                // нужно прописать дефолтную карту в конфиге
                alert(_gtxt('$$phrase$$_1'))

                return;
            } else {
                checkUserInfo(defaultState);
            }
        }

        function checkUserInfo(defaultState) {
            var tinyRef = readCookie('TinyReference');

            if (tinyRef) {
                eraseCookie('TinyReference');
                _mapHelper.restoreTinyReference(tinyRef, function(obj) {
                    if (obj.mapName) {
                        window.globalMapName = obj.mapName;
                    }
                    loadMap(obj);
                }, function() {
                    loadMap(defaultState); //если пермалинк какой-то не такой, просто открываем дефолтное состояние
                });

                var tempPermalink = readCookie('TempPermalink');

                if (tempPermalink && tempPermalink == tinyRef) {
                    nsGmx.Utils.TinyReference.remove(tempPermalink);
                    eraseCookie('TempPermalink');
                }
            } else {
                loadMap(defaultState);
            }
        }


        window.layersShown = true;

        window.resizeAll = function() {
            if (window.printMode) {
                return;
            }

            var top = 0,
                bottom = 0,
                right = 0,
                left = window.exportMode ? 0 : (layersShown ? 360 : 12),
                headerHeight = $('#header').outerHeight(),
                mainDiv = $('#flash')[0];

            mainDiv.style.left = left + 'px';
            mainDiv.style.top = top + 'px';
            mainDiv.style.width = getWindowWidth() - left - right + 'px';
            mainDiv.style.height = getWindowHeight() - top - headerHeight - bottom + 'px';

            nsGmx.leafletMap && nsGmx.leafletMap.invalidateSize();

            if (layersShown) {
                $('#leftMenu').show();

                var mapNameHeight = $('.mainmap-title').outerHeight();

                var baseHeight = getWindowHeight() - top - bottom - headerHeight;

                $('#leftMenu')[0].style.height = baseHeight + 'px'

                $('#leftContent')[0].style.top = ($('#leftPanelHeader')[0].offsetHeight + mapNameHeight) + 'px';
                $('#leftContent')[0].style.height = baseHeight -
                    $('#leftPanelHeader')[0].offsetHeight -
                    $('#leftPanelFooter')[0].offsetHeight -
                    mapNameHeight + 'px';
            } else {
                $('#leftMenu').hide();
            }
        }

        var editUIInited = false;
        var initEditUI = function() {
            if (editUIInited) {
                return;
            }

            var isEditableLayer = function(layer) {
                var props = layer.getGmxProperties(),
                    layerRights = _queryMapLayers.layerRights(props.name);

                return props.type === 'Vector' &&
                    (layerRights === 'edit' || layerRights === 'editrows');
            }

            var hasEditableLayer = false;
            for (var iL = 0; iL < nsGmx.gmxMap.layers.length; iL++)
                if (isEditableLayer(nsGmx.gmxMap.layers[iL])) {
                    hasEditableLayer = true;
                    break;
                }

            if (!hasEditableLayer) return;

            //добавляем пункт меню к нарисованным объектам
            nsGmx.ContextMenuController.addContextMenuElem({
                title: _gtxt('EditObject.drawingMenuTitle'),
                isVisible: function(context) {
                    var active = $(_queryMapLayers.treeCanvas).find('.active');

                    //должен быть векторный слой
                    if (!active[0] || !active[0].parentNode.getAttribute('LayerID') ||
                        !active[0].parentNode.gmxProperties.content.properties.type === 'Vector') {
                        return false;
                    }

                    //TODO: проверить тип геометрии

                    var layer = nsGmx.gmxMap.layersByID[active[0].parentNode.gmxProperties.content.properties.name];

                    //слой поддерживает редактирование и у нас есть права на это
                    return isEditableLayer(layer);
                },
                clickCallback: function(context) {
                    var active = $(_queryMapLayers.treeCanvas).find('.active');
                    var layerName = active[0].parentNode.gmxProperties.content.properties.name;
                    new nsGmx.EditObjectControl(layerName, null, { drawingObject: context.obj });
                }
            }, 'DrawingObject');

            //добавляем пункт меню ко всем слоям
            nsGmx.ContextMenuController.addContextMenuElem({
                title: _gtxt('EditObject.menuTitle'),
                isVisible: function(context) {
                    var layer = nsGmx.gmxMap.layersByID[context.elem.name];
                    return !context.layerManagerFlag && isEditableLayer(layer);
                },
                clickCallback: function(context) {
                    new nsGmx.EditObjectControl(context.elem.name);
                }
            }, 'Layer');

            //добавляем тул в тублар карты
            var listeners = {};
            var pluginPath = gmxCore.getModulePath('EditObjectPlugin');

            var editIcon = L.control.gmxIcon({
                id: 'editTool',
                title: _gtxt('Редактировать'),
                togglable: true,
                addBefore: 'gmxprint'
            }).addTo(nsGmx.leafletMap);

            editIcon.on('statechange', function() {
                if (editIcon.options.isActive) {

                    var clickHandler = function(event) {
                        var layer = event.target,
                            props = layer.getGmxProperties(),
                            id = event.gmx.properties[props.identityField];

                        layer.bringToTopItem(id);
                        new nsGmx.EditObjectControl(props.name, id, { event: event });
                        return true; // TODO: как oтключить дальнейшую обработку события
                    }

                    for (var iL = 0; iL < nsGmx.gmxMap.layers.length; iL++) {
                        var layer = nsGmx.gmxMap.layers[iL],
                            props = layer.getGmxProperties();

                        if (layer.disableFlip && layer.disablePopup) {
                            layer.disableFlip();
                            layer.disablePopup();
                        }

                        listeners[props.name] = clickHandler.bind(null); //bind чтобы были разные ф-ции
                        layer.on('click', listeners[props.name]);
                    }
                } else {
                    for (var layerName in listeners) {
                        var pt = listeners[layerName];
                        var layer = nsGmx.gmxMap.layersByID[layerName];
                        if (layer) {
                            layer.off('click', listeners[layerName]);
                            if (layer.getGmxProperties().type !== 'Virtual') {
                                layer.enableFlip();
                                layer.enablePopup();
                            }
                        }
                    }
                    listeners = {};
                }
            });

            editUIInited = true;
        }

        function initAuthWidget() {
            var registrationCallback = function() {
                gmxCore.loadModule('ProfilePlugin').then(function(AccountModule) {
                    AccountModule.showRegistrationForm(function() {
                        window.location.reload();
                    });
                })
            };

            var nativeAuthWidget = new nsGmx.GeoMixerAuthWidget($('<div/>')[0], nsGmx.AuthManager, function() {
                _mapHelper.reloadMap();
            }, { registrationCallback: registrationCallback });

            // прокси между nsGmx.AuthManager редактора и AuthManager'а из общей библиотеки
            var authManagerProxy = {
                getUserInfo: function() {
                    var def = $.Deferred();
                    nsGmx.AuthManager.checkUserInfo(function() {
                        var auth = nsGmx.AuthManager;
                        def.resolve({
                            Status: 'ok',
                            Result: {
                                Login: auth.getLogin(),
                                Nickname: auth.getNickname(),
                                FullName: auth.getFullname()
                            }
                        });
                    })
                    return def;
                },

                login: function() {
                    nativeAuthWidget.showLoginDialog();
                },

                logout: function() {
                    var def = $.Deferred();
                    nsGmx.AuthManager.logout(function() {
                        def.resolve({ Status: 'ok', Result: {} });
                        _mapHelper.reloadMap();
                    });
                    return def;
                },
                getNative: function() {
                    return nativeAuthWidget;
                }
            };

            nsGmx.widgets.authWidget = new nsGmx.AuthWidget({
                authManager: authManagerProxy,
                showAccountLink: !!window.mapsSite,
                accountLink: null,
                showMapLink: !!window.mapsSite,
                changePassword: !window.mapsSite,
                isAdmin: nsGmx.AuthManager.isRole(nsGmx.ROLE_ADMIN),
                callbacks: {
                    'authWidget-usergroupMenuItem': showUserList
                }
            });

            var authPlaceholder = nsGmx.widgets.header.getAuthPlaceholder();
            nsGmx.widgets.authWidget.appendTo(authPlaceholder);

            authPlaceholder.on('click', '#AuthWidgetAccountLink', function() {
                gmxCore.loadModule('ProfilePlugin').then(function(AccountModule) {
                    AccountModule.showProfile();
                })
            });

            //ugly hack
            nsGmx.widgets.authWidget.showLoginDialog = nativeAuthWidget.showLoginDialog.bind(nativeAuthWidget);
        }


        function loadMap(state) {
            //при переходе на новое API мы изменили место хранения мапплетов карты
            //раньше мапплеты хранились в свойстве onLoad карты
            //теперь - внутри клиентских данных (UserData)

            nsGmx.mappletLoader = {
                _script: '',

                //UserObjectsManager interface
                collect: function() {
                    return this._script;
                },
                load: function(data) {
                    this._script = data;
                },

                //self public interface
                execute: function() {
                    if (this._script) {
                        var evalStr = '(' + this._script + ')';
                        try {
                            eval(evalStr)();
                        } catch (e) {
                            console.error(e);
                        }
                    }
                },
                get: function() {
                    return this._script;
                },
                set: function(data) {
                    this._script = data;
                }
            }
            nsGmx.userObjectsManager.addDataCollector('mapplet_v2', nsGmx.mappletLoader);

            layersShown = (state.isFullScreen == 'false');

            if (state.language) {
                window.language = state.language;
                translationsHash.updateLanguageCookies(window.language);
            }

            window.onresize = resizeAll;
            resizeAll();

            L.Icon.Default.imagePath = (window.gmxJSHost || '') + 'img';
            var iconUrl = L.Icon.Default.imagePath + '/flag_blau1.png';

            if (L.version !== '0.7.7') {
                L.Icon.Default = L.Icon.Default.extend({
                    _getIconUrl: function (name) {
                        return L.Icon.prototype._getIconUrl.call(this, name);
                    }
                });
            }

            L.Marker = L.Marker.extend({
                options: {
                    icon: new L.Icon.Default({
                        iconUrl: iconUrl,
                        iconSize: [36, 41],
                        iconAnchor: [7, 37],
                        popupAnchor: [3, -25],
                        shadowUrl: iconUrl,
                        shadowSize: [0, 0],
                        shadowAnchor: [0, 0]
                    })
                }
            });

            var hostName = L.gmxUtil.normalizeHostname(window.serverBase),
                apiKey = window.mapsSite ? window.apiKey : null; //передаём apiKey только если не локальная версия ГеоМиксера

            //мы явно получаем описание карты, но пока что не начинаем создание слоёв
            //это нужно, чтобы получить список плагинов и загрузить их до того, как начнутся создаваться слои
            var skipTiles = (window.mapOptions ? window.mapOptions.skipTiles : '') || window.gmxSkipTiles || '';
            var srs = window.mapOptions ? window.mapOptions.srs : '';

            if (!srs) { var arr = location.href.match(/[?&][cs]rs=(\d+)/); if (arr) { srs = arr[1]; } }

            var isGeneralized = window.mapOptions && 'isGeneralized' in window.mapOptions ? window.mapOptions.isGeneralized : true;

            L.gmx.gmxMapManager.loadMapProperties({
                srs: srs,
                serverHost: hostName,
                apiKey: apiKey,
                mapName: globalMapName,
                skipTiles: skipTiles,
                isGeneralized: isGeneralized
            }).then(function(mapInfo) {
                var userObjects = state.userObjects || (mapInfo && mapInfo.properties.UserData);
                userObjects && nsGmx.userObjectsManager.setData(JSON.parse(userObjects));

                //в самом начале загружаем только данные о плагинах карты.
                //Остальные данные будем загружать чуть позже после частичной инициализации вьюера
                //О да, формат хранения данных о плагинах часто менялся!
                //Поддерживаются все предыдущие форматы из-за старых версий клиента и сложности обновления базы данных
                nsGmx.userObjectsManager.load('mapPlugins');
                nsGmx.userObjectsManager.load('mapPlugins_v2');
                nsGmx.userObjectsManager.load('mapPlugins_v3');

                //вызываем сразу после загрузки списка плагинов ГеоМиксера,
                //так как в state может содержаться информация о включённых плагинах
                if (state.customParamsCollection) {
                    _mapHelper.customParamsManager.loadParams(state.customParamsCollection);
                }

                //после загрузки списка плагинов карты начали загружаться не глобальные плагины,
                //у которых имя плагина было прописано в конфиге. Ждём их загрузки.
                nsGmx.pluginsManager.done(function() {
                    nsGmx.pluginsManager.preloadMap();
                    L.gmx.loadMap(globalMapName, {
                        srs: srs,
                        skipTiles: skipTiles,
                        hostName: window.serverBase,
                        apiKey: apiKey,
                        setZIndex: true,
                        isGeneralized: isGeneralized
                    }).then(processGmxMap.bind(null, state));
                })
            }, function(resp) {
                initHeader();
                initAuthWidget();

                _menuUp.defaultHash = 'usage';

                _menuUp.createMenu = function() {
                    createDefaultMenu();
                    nsGmx.pluginsManager.addMenuItems(_menuUp);
                };

                _menuUp.go(nsGmx.widgets.header.getMenuPlaceholder()[0]);

                $('#left_usage').hide();

                _menuUp.checkView();

                var str = resp && resp.ErrorInfo && resp.ErrorInfo.ErrorMessage ? resp.ErrorInfo.ErrorMessage : 'У вас нет прав на просмотр данной карты';
                nsGmx.widgets.notifications.stopAction(null, 'failure', _gtxt(str) || str, 0);

                window.onresize = resizeAll;
                resizeAll();

                state.originalReference && createCookie('TinyReference', state.originalReference);

                nsGmx.widgets.authWidget.showLoginDialog();
            });
        }

        //создаём подложки в BaseLayerManager по описанию из config.js
        function initDefaultBaseLayers() {

            var lang = L.gmxLocale.getLanguage(),
                iconPrefix = 'img/baseLayers/',
                blm = nsGmx.leafletMap.gmxBaseLayersManager,
                zIndexOffset = 2000000,
                defaultMapID = window.baseMap.defaultMapID,
                promises = [],
                defaultHostName;

            if (window.baseMap.defaultHostName) {
                defaultHostName = window.baseMap.defaultHostName === '/' ? _serverBase : window.baseMap.defaultHostName;
            } else {
                defaultHostName = 'maps.kosmosnimki.ru';
            }

            if (window.baseMap.baseLayers) {
                var baseLayers = window.baseMap.baseLayers,
                    bl;

                // проставляем дефолтным слоям свойства, зависящие от путей, языка, zIndex
                for (var i = 0; i < baseLayers.length; i++) {
                    bl = baseLayers[i];
                    // у Спутника в конфиге нет иконки и копирайта
                    if (bl.id === 'sputnik') {
                        bl.icon = iconPrefix + 'basemap_sputnik_ru.png';
                        bl.layers[0].attribution = '<a href="http://maps.sputnik.ru">Спутник</a> © ' + (lang === 'rus' ? 'Ростелеком' : 'Rostelecom') + ' | © <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>';
                    }
                    // у ОСМ в конфиге нет иконки и урл
                    if (bl.id === 'OSM') {
                        bl.icon = iconPrefix + 'basemap_osm_' + (lang === 'rus' ? 'ru' : 'eng') + '.png',
                            bl.layers[0].urlTemplate = 'http://{s}.tile.osm.kosmosnimki.ru/kosmo' + (lang === 'rus' ? '' : '-en') + '/{z}/{x}/{y}.png';
                    }
                    // у гибрида в конфиге нет урл
                    if (bl.id === 'OSMHybrid') {
                        bl.layers[0].urlTemplate = 'http://{s}.tile.osm.kosmosnimki.ru/kosmohyb' + (lang === 'rus' ? '' : '-en') + '/{z}/{x}/{y}.png';
                        // bl.layers[0].setZIndex(zIndexOffset);
                    }
                    // у спутника нет иконки
                    if (bl.id === 'satellite') {
                        bl.icon = iconPrefix + 'basemap_satellite.png';
                    }
                }

                for (var i = 0; i < baseLayers.length; i++) {
                    var bl = baseLayers[i];
                    if (bl.layers && bl.layers.length) {
                        var l = bl.layers;
                        for (var j = 0; j < l.length; j++) {
                            if (l[j].urlTemplate) {
                                // заменяем в подложках с айди описания слоев на L.tileLayers
                                l[j] = L.tileLayer(l[j].urlTemplate, l[j]);
                            } else {
                                var currentTl = bl,
                                    layerID = l[j].layerID,
                                    hostName = l[j].hostName || defaultHostName,
                                    mapID = l[j].mapID || defaultMapID,
                                    skipTiles = (window.mapOptions ? window.mapOptions.skipTiles : '') || window.gmxSkipTiles || '',
                                    srs = window.mapOptions ? window.mapOptions.srs : '',
                                    isGeneralized = window.mapOptions && 'isGeneralized' in window.mapOptions ? window.mapOptions.isGeneralized : true;

                                if (!srs) { var arr = location.href.match(/[?&][cs]rs=(\d+)/); if (arr) { srs = arr[1]; } }
                                // resolve promise -> заменяем в подложках с айди описания слоев на gmxLayers
                                var promise = L.gmx.loadLayer(mapID, layerID, {
                                    hostName: hostName,
                                    srs: srs,
                                    isGeneralized: isGeneralized,
                                    skipTiles: skipTiles
                                }).then(function(layer) {
                                    var id = layer.getGmxProperties().name;
                                    for (var k = 0; k < baseLayers.length; k++) {
                                        var bl = baseLayers[k];

                                        if (bl.layers && bl.layers.length) {
                                            var l = bl.layers;

                                            for (var m = 0; m < l.length; m++) {
                                                if (l[m].layerID && l[m].layerID === id) {
                                                    l[m] = layer;
                                                }
                                            }
                                        }
                                    }
                                });

                                promises.push(promise);
                            }
                        }
                    }
                }
            }
            return L.gmx.Deferred.all.apply(null, promises).then(function() {
                if (window.baseMap.baseLayers) {
                    var layers = window.baseMap.baseLayers,
                        layersToLoad = {};

                    layers.forEach(function(bl) {
                        layersToLoad[bl.id] = bl;
                    });

                    // добавим в гибрид снимок
                    if (layersToLoad.satellite && layersToLoad.OSMHybrid) {
                        layersToLoad.OSMHybrid.layers[0].setZIndex(zIndexOffset);
                        layersToLoad.OSMHybrid.layers.push(layersToLoad.satellite.layers[0]);
                    }

                    _.each(layersToLoad, function(l, name) {
                        blm.add(name, l);
                    });
                }
            });
        }

        function showUserList() {
            gmxCore.loadModule('UserGroupWidget').then(function(module) {
                var canvas = $('<div/>');
                new module.UserGroupListWidget(canvas);
                canvas.dialog({
                    width: 400,
                    height: 400,
                    title: _gtxt('Управление группами пользователей')
                });
            });
        }

        // Инициализации шапки. Будем оттягивать с инициализацией до последнего момента, так как при инициализации
        // требуется знать текущий язык, а он становится известен только после загрузки карты
        function initHeader() {
            var rightLinks = [];

            nsGmx.widgets.header = new nsGmx.HeaderWidget({
                logo: (window.gmxViewerUI && window.gmxViewerUI.logoImage) || 'logotypes/geomixer_transpar_small.png'
            });

            nsGmx.widgets.header.appendTo($('.header'));
        }

        function processGmxMap(state, gmxMap) {
            var DEFAULT_VECTOR_LAYER_ZINDEXOFFSET = 2000000;
            var defCenter = [55.7574, 37.5952],
                mapProps = gmxMap.properties,
                defZoom = mapProps.DefaultZoom || 5,
                data = gmxMap.rawTree;

            if (mapProps.DefaultLat && mapProps.DefaultLong) {
                defCenter = [mapProps.DefaultLat, mapProps.DefaultLong];
            } else {
                //подсчитаем общий extend всех видимых слоёв
                var visBounds = L.latLngBounds([]);



                for (var l = 0; l < gmxMap.layers.length; l++) {
                    var layer = gmxMap.layers[l];

                    if (layer.getGmxProperties().visible && layer.getBounds) {
                        visBounds.extend(layer.getBounds());
                    }
                }

                if (visBounds.isValid()) {
                    //вычислям центр и максимальный zoom по bounds (map.fitBounds() использовать не можем, так как ещё нет карты)
                    var proj = L.Projection.Mercator;
                    var mercBounds = L.bounds([proj.project(visBounds.getNorthWest()), proj.project(visBounds.getSouthEast())]);
                    var ws = 2 * proj.project(L.latLng(0, 180)).x,
                        screenSize = [$('#flash').width(), $('#flash').height()];

                    var zoomX = Math.log(ws * screenSize[0] / (mercBounds.max.x - mercBounds.min.x)) / Math.log(2) - 8;
                    var zoomY = Math.log(ws * screenSize[1] / (mercBounds.max.y - mercBounds.min.y)) / Math.log(2) - 8;

                    defZoom = Math.floor(Math.min(zoomX, zoomY, 17));
                    defCenter = proj.unproject(mercBounds.getCenter());
                }
            }

            //если информации о языке нет ни в куках ни в config.js, то используем данные о языке из карты
            if (!translationsHash.getLanguageFromCookies() && !window.defaultLang && data) {
                window.language = data.properties.DefaultLanguage;
            }

            initHeader();

            if (!window.gmxViewerUI || !window.gmxViewerUI.hideLanguage) {
                var langContainer = nsGmx.widgets.header.getLanguagePlaceholder();
                nsGmx.widgets.languageWidget = new nsGmx.LanguageWidget();
                nsGmx.widgets.languageWidget.appendTo(langContainer);
            }
            var mapOptions = L.extend(window.mapOptions ? window.mapOptions : {}, {
                contextmenu: true,
                // если есть пермалинк, центрируем и зумируем карту сразу по его параметрам
                center: state.position ? [state.position.y, state.position.x] : defCenter,
                zoom: state.position ? state.position.z : defZoom,
                // boxZoom: false,
                zoomControl: false,
                attributionControl: false,
                trackResize: true,
                fadeAnimation: !window.gmxPhantom, // отключение fadeAnimation при запуске тестов
                zoomAnimation: !window.gmxPhantom, // отключение zoomAnimation при запуске тестов
                distanceUnit: mapProps.DistanceUnit,
                squareUnit: mapProps.SquareUnit,
                minZoom: mapProps.MinZoom || undefined,
                maxZoom: mapProps.MaxZoom || undefined,
                maxPopupCount: mapProps.maxPopupContent
            });

            var lmap = new L.Map($('#flash')[0], mapOptions);


            // update layers zIndexes
            var currentZoom = lmap.getZoom(),
                layerOrder = gmxMap.rawTree.properties.LayerOrder;

            updateZIndexes();

            lmap.on('zoomend', function(e) {
                currentZoom = lmap.getZoom();
                updateZIndexes();
            })

            //clip polygons
            if (mapProps.MinViewX && mapProps.MinViewY && mapProps.MaxViewX && mapProps.MaxViewY) {
                lmap.on('layeradd', function(e) {
                    if (e.layer.addClipPolygon) {
                        _mapHelper.clipLayer(e.layer, mapProps);
                    }
                })
            }

            // bind clusters to photoLayers
            for (var l = 0; l < gmxMap.layers.length; l++) {
                var layer = gmxMap.layers[l],
                props = layer.getGmxProperties();

                if (props.IsPhotoLayer) {
                    layer.bindClusters({
                        iconCreateFunction: function(cluster) {
                            var photoClusterIcon = L.divIcon({
                                html: '<img src="img/camera18.png" class="photo-icon"/><div class="marker-cluster-photo">' + cluster.getChildCount() + '</div>',
                                className: 'photo-div-icon',
                                iconSize: [14, 12],
                                iconAnchor: [0, 0]
                            });
                            return photoClusterIcon;
                        },
                        maxClusterRadius: 40,
                        spiderfyOnMaxZoom: true,
                        spiderfyDistanceMultiplier: 1.2,
                        disableClusteringAtZoom: 19,
                        maxZoom: 19
                    });
                }
            }
            lmap.contextmenu.insertItem({
                text: _gtxt('Поставить маркер'),
                callback: function(event) {
                    lmap.gmxDrawing.addGeoJSON({ type: 'Point', coordinates: [event.latlng.lng, event.latlng.lat] });
                }
            })

            lmap.contextmenu.insertItem({
                text: _gtxt('Центрировать'),
                callback: function(event) {
                    lmap.setView(event.latlng);
                }
            });

            function updateZIndexes() {
                for (var l = 0; l < gmxMap.layers.length; l++) {
                    var layer = gmxMap.layers[l],
                        props = layer.getGmxProperties();

                    switch (layerOrder) {
                        case 'VectorOnTop':
                            if (props.type === 'Vector' && layer.setZIndexOffset) {
                                var minZoom,
                                    rcMinZoom,
                                    quickLookMinZoom,
                                    defaultMinZoom = 6;

                                if (props.IsRasterCatalog || (props.Quicklook && props.Quicklook !== 'null')) {
                                    rcMinZoom = props.IsRasterCatalog ? props.RCMinZoomForRasters : null;
                                    quickLookMinZoom = (props.Quicklook && nsGmx.Utils.isJSON(props.Quicklook)) ? JSON.parse(props.Quicklook).minZoom : null;

                                    if (props.IsRasterCatalog && !props.Quicklook) {
                                        minZoom = nsGmx.Utils.checkForNumber(rcMinZoom) ? rcMinZoom : defaultMinZoom;
                                    } else if (!props.IsRasterCatalog && props.Quicklook) {
                                        minZoom = nsGmx.Utils.checkForNumber(quickLookMinZoom) ? quickLookMinZoom : defaultMinZoom;
                                    } else if (props.IsRasterCatalog && props.Quicklook) {
                                        rcMinZoom = nsGmx.Utils.checkForNumber(rcMinZoom) ? rcMinZoom : defaultMinZoom;
                                        quickLookMinZoom = nsGmx.Utils.checkForNumber(quickLookMinZoom) ? quickLookMinZoom : defaultMinZoom;

                                        minZoom = Math.min(rcMinZoom, quickLookMinZoom);
                                    }
                                    layer.setZIndexOffset(currentZoom < rcMinZoom ? DEFAULT_VECTOR_LAYER_ZINDEXOFFSET : 0);
                                } else {
                                    layer.setZIndexOffset(DEFAULT_VECTOR_LAYER_ZINDEXOFFSET);
                                }
                            }
                            break;
                    }
                }
            }

            // Begin: запоминание текущей позиции карты
            function saveMapPosition(key) {
                window.localStorage.setItem('lastMapPosiotion_' + key, JSON.stringify({ zoom: lmap.getZoom(), center: lmap.getCenter() }));
            }

            function getMapPosition(key) {
                return JSON.parse(localStorage.getItem('lastMapPosiotion_' + key));
            }
            lmap.on('boxzoomstart', function(ev) { saveMapPosition('z'); });
            L.DomEvent.on(document, 'keydown', function(ev) {
                var key = ev.key;
                if (lmap.gmxMouseDown === 1) {
                    var pos = getMapPosition(key);
                    if (pos && (key === 'z' || Number(key) >= 0)) {
                        lmap.setView(pos.center, pos.zoom);
                    }
                } else if (lmap.gmxMouseDown > 1) {
                    if (Number(key) >= 0) {
                        saveMapPosition(key);
                    }
                }

            }, lmap);
            // End: запоминание текущей позиции карты

            lmap.gmxControlsManager.init(window.controlsOptions);
            // lmap.addControl(new L.Control.gmxLayers(lmap.gmxBaseLayersManager, {
            //     // position: 'topleft',
            //     collapsed: true,
            //     hideBaseLayers: true
            // }));

            nsGmx.leafletMap = lmap;

            var loc = nsGmx.leafletMap.gmxControlsManager.get('location');

            loc.setCoordinatesFormat(gmxMap.properties.coordinatesFormat);

            loc.on('coordinatesformatchange', function(ev) {
                nsGmx.leafletMap.options.coordinatesFormat = ev.coordinatesFormat;
            });

            var baseLayerDef = 'baseMap' in window ? initDefaultBaseLayers() : lmap.gmxBaseLayersManager.initDefaults({ hostName: window.mapHostName, apiKey: window.apiKey, srs: lmap.options.srs, skipTiles: lmap.options.skipTiles, isGeneralized: lmap.options.isGeneralized });

            baseLayerDef.then(function() {

                nsGmx.gmxMap = gmxMap;
                gmxAPI.layersByID = gmxMap.layersByID; // слои по layerID

                var mapProp = gmxMap.rawTree.properties || {}
                var baseLayers = mapProp.BaseLayers ? JSON.parse(mapProp.BaseLayers) : [window.language === 'eng' ? 'mapbox' : 'sputnik', 'OSMHybrid', 'satellite'];

                lmap.gmxBaseLayersManager.setActiveIDs(baseLayers);

                var baseLayersControl = new L.Control.GmxIconLayers(lmap.gmxBaseLayersManager, { id: 'iconLayers' });
                lmap.gmxControlsManager.add(baseLayersControl);

                lmap.addControl(baseLayersControl);

                /**
                 *
                 * OPERATIVE NEW COMMONCALENDAR TEST
                 * START
                 *
                 */
                // if (mapProp.MapID === 'ATTBP') {
                nsGmx.widgets.commonCalendar = new nsGmx.CommonCalendarWidget();

                // добавление временных слоев в commonCalendar
                // добавление происходит безопасно, в клон объекта со списком слоев
                var initTemporalLayers = function(layers) {
                    layers = layers || nsGmx.gmxMap.layers;

                    var attrs = nsGmx.widgets.commonCalendar.model.toJSON(),
                        showCalendar = undefined,
                        dateInterval,
                        dateBegin,
                        dateEnd;

                    for (var i = 0; i < layers.length; i++) {
                        var layer = layers[i],
                            props = layer.getGmxProperties(),
                            isVisible = props.visible,
                            isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                        if (isTemporalLayer) {
                            // показываем виджет календаря, если в карте есть хоть один мультивременной слой
                            showCalendar = true;

                            dateInterval = layer.getDateInterval ? layer.getDateInterval() : new nsGmx.DateInterval();

                            if (dateInterval.beginDate && dateInterval.endDate) {
                                dateBegin = dateInterval.beginDate;
                                dateEnd = dateInterval.endDate;
                            } else {
                                dateInterval = new nsGmx.DateInterval();
                                dateBegin = dateInterval.get('dateBegin');
                                dateEnd = dateInterval.get('dateEnd');
                            }

                            if (!(props.name in attrs.unbindedTemporalLayers)) {
                                nsGmx.widgets.commonCalendar.bindLayer(props.name);

                                layer.setDateInterval(dateBegin, dateEnd);

                                if (props.LayerID in attrs.dailyFiltersHash) {
                                    nsGmx.widgets.commonCalendar.applyDailyFilter([layer]);
                                }

                            }
                            //подписка на изменение dateInterval
                            if (layer.getDateInterval) {
                                layer.on('dateIntervalChanged', nsGmx.widgets.commonCalendar.onDateIntervalChanged, nsGmx.widgets.commonCalendar);
                            }
                        }
                    }

                    nsGmx.widgets.commonCalendar.updateVisibleTemporalLayers(nsGmx.gmxMap.layers);

                    if (showCalendar && !attrs.isAppended) {
                        nsGmx.widgets.commonCalendar.show();
                    }
                }

                // привяжем изменение активной ноды к календарю
                $(_layersTree).on('activeNodeChange', function(e, p) {
                    var layerID = $(p).attr('layerid'),
                        calendar = nsGmx.widgets.commonCalendar.model.get('calendar'),
                        synchronyzed = nsGmx.widgets.commonCalendar.model.get('synchronyzed');

                    lmap.fireEvent('layersTree.activeNodeChange', { layerID: layerID });
                });

                $(_layersTree).on('layerVisibilityChange', function(event, elem) {
                    var props = elem.content.properties,
                        attrs = nsGmx.widgets.commonCalendar.model.toJSON(),
                        visible = props.visible,
                        layerID = props.LayerID,
                        calendar = attrs.calendar,
                        currentLayer = attrs.currentLayer,
                        synchronyzed = attrs.synchronyzed;

                    if (synchronyzed) {
                        return;
                    } else {
                        if (layerID) {
                            var layer = nsGmx.gmxMap.layersByID[layerID],
                                props = layer.getGmxProperties(),
                                isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval),
                                visibleTemporalLayers, index;

                            if (isTemporalLayer) {
                                if (visible) {
                                    if (currentLayer) {
                                        return;
                                    } else {
                                        var dateInterval = layer.getDateInterval();

                                        if (dateInterval.beginDate && dateInterval.endDate) {
                                            nsGmx.widgets.commonCalendar.setDateInterval(dateInterval.beginDate, dateInterval.endDate, layer);
                                        }
                                    }
                                } else {
                                    if (currentLayer) {
                                        if (layerID !== currentLayer) {
                                            return;
                                        } else {
                                            visibleTemporalLayers = getLayersListWithTarget(nsGmx.gmxMap.layers, layer),
                                                index = visibleTemporalLayers.indexOf(layer);

                                            if (visibleTemporalLayers.length === 1) {
                                                nsGmx.widgets.commonCalendar.model.set('currentLayer', null);
                                            } else {
                                                if (index === 0) {
                                                    var targetLayer = visibleTemporalLayers[index + 1],
                                                        targetLayerID = targetLayer.getGmxProperties().LayerID,
                                                        dateInterval = targetLayer.getDateInterval();

                                                    nsGmx.widgets.commonCalendar.setDateInterval(dateInterval.beginDate, dateInterval.endDate, targetLayer);
                                                    // nsGmx.widgets.commonCalendar.model.set('currentLayer', targetLayerID)
                                                } else {
                                                    var targetLayer = visibleTemporalLayers[index - 1],
                                                        targetLayerID = targetLayer.getGmxProperties().LayerID,
                                                        dateInterval = targetLayer.getDateInterval();

                                                    nsGmx.widgets.commonCalendar.setDateInterval(dateInterval.beginDate, dateInterval.endDate, targetLayer);
                                                    // nsGmx.widgets.commonCalendar.model.set('currentLayer', targetLayerID)
                                                }
                                            }

                                        }
                                    } else {
                                        return;
                                    }
                                }
                            }
                        }
                    }
                    nsGmx.widgets.commonCalendar.updateVisibleTemporalLayers(nsGmx.gmxMap.layers);

                    function getLayersListWithTarget(layers, targetLayer) {
                        var visibleTemporalLayers = [];
                        for (var i = 0; i < layers.length; i++) {
                            var layer = layers[i],
                                props = layer.getGmxProperties && layer.getGmxProperties(),
                                isTemporalLayer,
                                isVisible;

                            if (props) {
                                isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);
                                isVisible = props.visible;

                                if (isTemporalLayer && isVisible || layer === targetLayer) {
                                    visibleTemporalLayers.push(layer);
                                }
                            }
                        }
                        return visibleTemporalLayers;
                    }
                });

                _mapHelper.customParamsManager.addProvider({
                    name: 'commonCalendar',
                    loadState: function(state) {
                        if (!('version' in state)) {
                            var tmpDateInterval = new nsGmx.DateInterval({
                                dateBegin: new Date(state.dateBegin),
                                dateEnd: new Date(state.dateEnd)
                            });
                            nsGmx.widgets.commonCalendar.getDateInterval().loadState(tmpDateInterval.saveState());
                        } else if (state.version === '1.0.0') {
                            nsGmx.widgets.commonCalendar.model.set('synchronyzed', typeof(state.synchronyzed) !== 'undefined' ? state.synchronyzed : true);
                            nsGmx.widgets.commonCalendar.model.set('currentLayer', typeof(state.currentLayer) !== 'undefined' ? state.currentLayer : null);
                            nsGmx.widgets.commonCalendar.getDateInterval().loadState(state.dateInterval);
                            nsGmx.widgets.commonCalendar.model.set('dailyFilter', typeof(state.dailyFilter) !== 'undefined' ? state.dailyFilter : true);
                        } else {
                            throw 'Unknown params version';
                        }
                    },
                    saveState: function() {
                        return {
                            version: '1.0.0',
                            dateInterval: nsGmx.widgets.commonCalendar.getDateInterval().saveState(),
                            currentLayer: nsGmx.widgets.commonCalendar.model.get('currentLayer'),
                            synchronyzed: nsGmx.widgets.commonCalendar.model.get('synchronyzed'),
                            dailyFilter: nsGmx.widgets.commonCalendar.model.get('dailyFilter')
                        };
                    }
                });

                /**
                 *
                 * OPERATIVE
                 * END
                 *
                 */
                // } else {
                // var now = new Date();
                // nsGmx.widgets.commonCalendar = {
                //     _calendar: null,
                //     _dateInterval: new nsGmx.DateInterval(),
                //     _isAppended: false,
                //     _unbindedTemporalLayers: {},
                //     active: true,
                //     setActive: function (active) {
                //         this.active = active;
                //     },
                //     getDateInterval: function() {
                //         return this._dateInterval;
                //     },
                //     get: function() {
                //         var _this = this;
                //         if (!this._calendar) {
                //             this._calendar = new nsGmx.CalendarWidget({
                //                 minimized: true,
                //                 dateMin: new Date(2000, 1, 1),
                //                 dateMax: this._dateInterval.get('dateEnd'),
                //                 dateInterval: this._dateInterval
                //             });
                //
                //             this._dateInterval.on('change', this.updateTemporalLayers.bind(this, null));
                //             this.updateTemporalLayers();
                //         }
                //
                //         return this._calendar;
                //     },
                //     replaceCalendarWidget: function(newCalendar) {
                //         this._calendar = newCalendar;
                //
                //         //заменим виджет перед деревом слоёв
                //         if (this._isAppended) {
                //             var doChange = function() {
                //                 var calendarDiv = $('<div class="common-calendar-container"></div>').append(newCalendar.canvas);
                //                 // special for steppe project
                //                 if (nsGmx.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
                //                     _queryMapLayers.getContainerAfter().find('.common-calendar-container').replaceWith(calendarDiv);
                //                 } else {
                //                     _queryMapLayers.getContainerBefore().find('.common-calendar-container').replaceWith(calendarDiv);
                //                 }
                //             }
                //             //явная проверка, так как хочется быть максимально синхронными в этом методе
                //             if (_queryMapLayers.loadDeferred.state() === 'resolved') {
                //                 doChange();
                //             } else {
                //                 _queryMapLayers.loadDeferred.then(doChange);
                //             }
                //         }
                //     },
                //     show: function() {
                //         var doAdd = function() {
                //             var calendarDiv = $('<div class="common-calendar-container"></div>').append(this.get().canvas);
                //             // special for steppe Project
                //             if (nsGmx.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
                //                 _queryMapLayers.getContainerAfter().append(calendarDiv);
                //             } else {
                //                 _queryMapLayers.getContainerBefore().append(calendarDiv);
                //             }
                //             this._isAppended = true;
                //         }.bind(this);
                //
                //         if (!this._isAppended) {
                //             //явная проверка, так как хочется быть максимально синхронными в этом методе
                //             if (_queryMapLayers.loadDeferred.state() === 'resolved') {
                //                 doAdd();
                //             } else {
                //                 _queryMapLayers.loadDeferred.then(doAdd);
                //             }
                //         }
                //     },
                //     hide: function() {
                //         this._isAppended && $(this.get().canvas).hide();
                //         this._isAppended = false;
                //     },
                //
                //     bindLayer: function(layerName) {
                //         delete this._unbindedTemporalLayers[layerName];
                //         this.updateTemporalLayers();
                //     },
                //     unbindLayer: function(layerName) {
                //         this._unbindedTemporalLayers[layerName] = true;
                //     },
                //     _updateOneLayer: function(layer, dateBegin, dateEnd) {
                //         var props = layer.getGmxProperties();
                //         if (props.maxShownPeriod) {
                //             var msecPeriod = props.maxShownPeriod*24*3600*1000;
                //             var newDateBegin = new Date( Math.max(dateBegin.valueOf(), dateEnd.valueOf() - msecPeriod));
                //             layer.setDateInterval(newDateBegin, dateEnd);
                //         } else {
                //             layer.setDateInterval(dateBegin, dateEnd);
                //         }
                //     },
                //     updateTemporalLayers: function(layers) {
                //         if (!this._calendar || !this.active) {return;}
                //         var layers = layers || nsGmx.gmxMap.layers,
                //             dateBegin = this._dateInterval.get('dateBegin'),
                //             dateEnd = this._dateInterval.get('dateEnd'),
                //             layersMaxDates = [],
                //             maxDate = null;
                //
                //         for (var i = 0, len = layers.length; i < len; i++) {
                //             var layer = layers[i],
                //                 props = layer.getGmxProperties(),
                //                 isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);
                //
                //             if (isTemporalLayer && !(props.name in this._unbindedTemporalLayers)) {
                //                 if (props.DateEnd) {
                //                     var localeDate = $.datepicker.parseDate('dd.mm.yy', props.DateEnd);
                //                     layersMaxDates.push(localeDate);
                //                 }
                //
                //                 this._updateOneLayer(layer, dateBegin, dateEnd);
                //             }
                //         }
                //
                //         if (layersMaxDates.length > 0) {
                //             layersMaxDates.sort(function(a, b) {
                //                 return b - a;
                //             });
                //
                //             maxDate = new Date(layersMaxDates[0]);
                //
                //             if (maxDate > new Date()) {
                //                 this._calendar.setDateMax(nsGmx.CalendarWidget.fromUTC(maxDate));
                //             } else {
                //                 this._calendar.setDateMax(new Date());
                //             }
                //         }
                //     }
                // }
                //
                // //устарело, используйте commonCalendar
                // nsGmx.widgets.getCommonCalendar = function() {
                //     nsGmx.widgets.commonCalendar.show();
                //     return nsGmx.widgets.commonCalendar.get();
                // }
                //
                // var initTemporalLayers = function(layers) {
                //     layers = layers || nsGmx.gmxMap.layers;
                //     for (var i = 0; i < layers.length; i++) {
                //         var props = layers[i].getGmxProperties();
                //         if (props.Temporal && nsGmx.widgets.commonCalendar._unbindedTemporalLayers && !(props.name in nsGmx.widgets.commonCalendar._unbindedTemporalLayers)) {
                //             nsGmx.widgets.commonCalendar.show();
                //             break;
                //         }
                //     }
                //
                //     nsGmx.widgets.commonCalendar.updateTemporalLayers(layers);
                // }
                //
                // _mapHelper.customParamsManager.addProvider({
                //     name: 'commonCalendar',
                //     loadState: function(state) {
                //         if (!('version' in state)) {
                //             var tmpDateInterval = new nsGmx.DateInterval({
                //                 dateBegin: new Date(state.dateBegin),
                //                 dateEnd: new Date(state.dateEnd)
                //             });
                //             nsGmx.widgets.commonCalendar.getDateInterval().loadState(tmpDateInterval.saveState());
                //         } else if (state.version === '1.0.0') {
                //             nsGmx.widgets.commonCalendar.getDateInterval().loadState(state.dateInterval);
                //         } else {
                //             throw 'Unknown params version';
                //         }
                //     },
                //     saveState: function() {
                //         return {
                //             version: '1.0.0',
                //             dateInterval: nsGmx.widgets.commonCalendar.getDateInterval().saveState()
                //         };
                //     }
                // });

                // }

                $('#flash').bind('dragover', function() {
                    return false;
                });

                $('#flash').bind('drop', function(e) {
                    if (!e.originalEvent.dataTransfer) {
                        return;
                    }

                    _queryLoadShp.loadAndShowFiles(e.originalEvent.dataTransfer.files);

                    return false;
                })

                if (state.dt) {
                    try {
                        var dateLocal = $.datepicker.parseDate('dd.mm.yy', state.dt);
                        var dateBegin = nsGmx.CalendarWidget.fromUTC(dateLocal);
                        var dateEnd = new Date(dateBegin.valueOf() + 24 * 3600 * 1000);
                        var dateInterval = nsGmx.widgets.commonCalendar.getDateInterval();
                        dateInterval.set({
                            dateBegin: dateBegin,
                            dateEnd: dateEnd
                        });
                    } catch (e) {}
                }

                nsGmx.pluginsManager.beforeViewer();

                //для каждого ответа сервера об отсутствии авторизации (Status == 'auth') сообщаем об этом пользователю или предлагаем залогиниться
                addParseResponseHook('auth', function() {
                    if (nsGmx.AuthManager.isLogin()) {
                        showErrorMessage(_gtxt('Недостаточно прав для совершения операции'), true);
                    } else {
                        nsGmx.widgets.authWidget.showLoginDialog();
                    }

                    return false;
                });

                initAuthWidget();

                //инициализация контролов пользовательских объектов
                //соответствующий модуль уже загружен
                var oDrawingObjectsModule = gmxCore.getModule('DrawingObjects');
                window.oDrawingObjectGeomixer = new oDrawingObjectsModule.DrawingObjectGeomixer();
                window.oDrawingObjectGeomixer.Init(nsGmx.leafletMap, nsGmx.gmxMap);

                //для всех слоёв должно выполняться следующее условие: если хотя бы одна групп-предков невидима, то слой тоже невидим.
                (function fixVisibilityConstrains(o) {
                    o.content.properties.visible = o.content.properties.visible;

                    if (o.type === 'group') {
                        var a = o.content.children;

                        var isAnyVisibleChild = false;

                        for (var k = a.length - 1; k >= 0; k--) {
                            var childrenVisibility = fixVisibilityConstrains(a[k]);
                            isAnyVisibleChild = isAnyVisibleChild || childrenVisibility;
                        }

                        // если внутри группы есть включенные слои, группа тоже включается
                        // если же ни одного включенного слоя нет, то группа выключается
                        o.content.properties.visible = isAnyVisibleChild ? true : false;
                    }
                    return o.content.properties.visible;
                })({ type: 'group', content: { children: data.children, properties: { visible: true } } });

                window.oldTree = JSON.parse(JSON.stringify(data));

                window.defaultLayersVisibility = {};

                for (var k = 0; k < gmxMap.layers.length; k++) {
                    var props = gmxMap.layers[k].getGmxProperties();
                    window.defaultLayersVisibility[props.name] = props.visible;
                }

                //основная карта всегда загружена с того-же сайта, что и серверные скрипты
                data.properties.hostName = window.serverBase.slice(7).slice(0, -1);

                //DEPRICATED. Do not use it!
                _mapHelper.mapProperties = data.properties;

                //DEPRICATED. Do not use it!
                _mapHelper.mapTree = data;

                if (window.copyright && typeof window.copyright === 'string') {
                    lmap.gmxControlsManager.get('copyright').setMapCopyright(window.copyright);
                }

                var condition = false,
                    mapStyles = false,
                    LayersTreePermalinkParams = false;

                if (state.condition) {
                    condition = state.condition;
                }

                if (state.mapStyles) {
                    mapStyles = state.mapStyles;
                }
                if (state.LayersTreePermalinkParams) {
                    LayersTreePermalinkParams = state.LayersTreePermalinkParams;
                }

                _queryMapLayers.addLayers(data, condition, mapStyles, LayersTreePermalinkParams);

                var headerDiv = $('<div class="mainmap-title">' + data.properties.title + '</div>').prependTo($('#leftMenu'));

                // special for steppe Project
                if (data.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
                    $(headerDiv).toggle();
                }

                nsGmx.ContextMenuController.bindMenuToElem(headerDiv[0], 'Map', function() {
                        return _queryMapLayers.currentMapRights() == 'edit';
                    },
                    function() {
                        return {
                            div: $(_layersTree._treeCanvas).find('div[MapID]')[0],
                            tree: _layersTree
                        }
                    }
                );

                // _menuUp.defaultHash = 'layers';
                mapLayers.mapLayers.load();

                //создаём тулбар
                var iconContainer = _div(null, [
                    ['css', 'borderLeft', '1px solid #216b9c']
                ]);

                // var searchContainer = nsGmx.widgets.header.getSearchPlaceholder()[0];

                window.searchLogic.init({
                    oMenu: oSearchLeftMenu
                });

                //инициализация контролов поиска (модуль уже загружен)
                var oSearchModule = gmxCore.getModule('search');
                // window.oSearchControl = new oSearchModule.SearchGeomixer();

                // if (document.getElementById('searchCanvas')) {
                // window.oSearchControl.Init({
                //     Menu: oSearchLeftMenu,
                //     ContainerInput: searchContainer,
                //     ServerBase: window.serverBase,
                //     layersSearchFlag: true,
                //     Map: lmap,
                //     gmxMap: gmxMap
                // });

                _menuUp.createMenu = function() {
                    createMenuNew();
                };

                _menuUp.go(nsGmx.widgets.header.getMenuPlaceholder()[0]);

                var headerLinks = nsGmx.addHeaderLinks();

                if (headerLinks.length) {
                    _menuUp.addItem({ id: 'linksMenu', title: _gtxt('Ссылки'), childs: headerLinks });
                }

                // Загружаем все пользовательские данные
                nsGmx.userObjectsManager.load();

                // выставляет правильные z-indexes слоям-вьюхам
                _layersTree.updateZIndexes();

                //выполняем мапплет карты нового формата
                nsGmx.mappletLoader.execute();

                //динамически добавляем пункты в меню. DEPRICATED.
                nsGmx.pluginsManager.addMenuItems(_menuUp);

                _mapHelper.gridView = false;

                var updateLeftPanelVis = function() {
                    $('.leftCollapser-icon')
                        .toggleClass('leftCollapser-right', !layersShown)
                        .toggleClass('leftCollapser-left', !!layersShown);
                    resizeAll();
                }

                $('#leftCollapser').click(function() {
                    layersShown = !layersShown;
                    updateLeftPanelVis();
                });
                updateLeftPanelVis();

                createToolbar();

                if (state.mode) {
                    lmap.gmxBaseLayersManager.setCurrentID(lmap.gmxBaseLayersManager.getIDByAlias(state.mode) || state.mode);
                } else if (baseLayers.length && !lmap.gmxBaseLayersManager.getCurrentID()) {
                    lmap.gmxBaseLayersManager.setCurrentID(baseLayers[0]);
                }

                if (state.drawings) {
                    lmap.gmxDrawing.loadState(state.drawings);
                } else if (state.drawnObjects) {
                    state.drawnObjects.forEach(function(objInfo) {
                        //старый формат - число, новый - строка
                        var lineStyle = {};

                        if (objInfo.color) {
                            lineStyle.color = typeof objInfo.color === 'number' ? '#' + L.gmxUtil.dec2hex(objInfo.color) : objInfo.color;
                        }

                        if (objInfo.thickness) { lineStyle.weight = objInfo.thickness };
                        if (objInfo.opacity) { lineStyle.opacity = objInfo.opacity / 100 };

                        var featureOptions = $.extend(true, {}, objInfo.properties, {
                            lineStyle: lineStyle
                        });

                        var drawingFeature = lmap.gmxDrawing.addGeoJSON(L.gmxUtil.geometryToGeoJSON(objInfo.geometry), featureOptions)[0];

                        if (objInfo.isBalloonVisible) {
                            drawingFeature.openPopup();
                        }
                    });
                } else if (state.marker) {
                    nsGmx.leafletMap.gmxDrawing.addGeoJSON({
                        type: 'Feature',
                        geometry: { type: 'Point', coordinates: [state.marker.mx, state.marker.my] },
                        properties: { title: state.marker.mt }
                    });
                }

                if (state.openPopups) {
                    for (var l in state.openPopups) {
                        var layer = nsGmx.gmxMap.layersByID[l];
                        if (layer && layer.addPopup) {
                            state.openPopups[l].forEach(layer.addPopup.bind(layer));
                        }
                    }
                }

                _menuUp.checkView();

                if (nsGmx.AuthManager.isLogin()) {
                    _queryMapLayers.addUserActions();
                }

                if (state.dateIntervals) {
                    for (var lid in gmxMap.layersByID) {
                        if (lid in state.dateIntervals) {
                            var l = gmxMap.layersByID[lid],
                                beginDate = new Date(state.dateIntervals[lid].beginDate),
                                endDate = new Date(state.dateIntervals[lid].endDate);

                            l.setDateInterval(beginDate, endDate);
                        }
                    }
                }

                initEditUI();
                initTemporalLayers();

                gmxMap.addLayersToMap(lmap);

                nsGmx.leafletMap.on('layeradd', function(event) {
                    var layer = event.layer;

                    if (layer.getGmxProperties) {
                        var layerProps = layer.getGmxProperties();

                        initEditUI();
                        initTemporalLayers([layer]);

                    }
                });
                // if (mapProp.MapID !== 'ATTBP') {
                nsGmx.gmxMap.on('onRemoveLayer', function(event) {
                    var layer = event.layer;
                    if (!layer.getGmxProperties()) {
                        return;
                    }
                    var props = layer.getGmxProperties(),
                        isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                    if (isTemporalLayer && !(props.name in nsGmx.widgets.commonCalendar._unbindedTemporalLayers)) {
                        nsGmx.widgets.commonCalendar.unbindLayer(props.name);
                        nsGmx.widgets.commonCalendar.updateTemporalLayers();
                        delete nsGmx.widgets.commonCalendar._unbindedTemporalLayers[props.name];
                    }
                });

                // special for steppe project
                if (nsGmx.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
                    nsGmx.widgets.commonCalendar.show();
                }
                nsGmx.pluginsManager.afterViewer();

                if (nsGmx.timeLineControl) {
                    nsGmx.timeLineControl.on('layerRemove', function(e) {
                        $(window._layersTree).triggerHandler('layerTimelineRemove', e);
                    });
                    nsGmx.timeLineControl.on('layerAdd', function(e) {
                        $(window._layersTree).triggerHandler('layerTimelineAdd', e);
                    });
                }

                $('#leftContent').mCustomScrollbar();

                // экспорт карты

                if (state.exportMode) {
                    _mapHelper.exportMap(state);
                }
            });
        }

        function mapExportMenu() {
            gmxCore.loadModule('MapExport', 'src/MapExport/MapExport.js').then(function(def) {
                var menu = new def.MapExportMenu();
                menu.Load();
            });
        }

        function indexGridMenu() {
            gmxCore.loadModule('IndexGrid', 'src/IndexGrid/IndexGrid.js').then(function(def) {
                var menu = new def.IndexGridMenu();
                menu.Load();
            });
        }

        function PhotoLayerDialog() {
            gmxCore.loadModule('PhotoLayer', 'src/PhotoLayer/PhotoLayer.js').then(function(def) {
                var dialog = new def.PhotoLayer();
                dialog.Load();
            });
        }

        function promptFunction(title, value) {
            var ui = $(Handlebars.compile(
                '<div class="gmx-prompt-canvas">' +
                '<input class="inputStyle gmx-prompt-input" value="{{value}}">' +
                '</div>')({ value: value }));

            ui.find('input').on('keydown', function(e) {
                var evt = e || window.event;
                if (e.which === 13) {
                    var coord = L.gmxUtil.parseCoordinates(this.value);
                    nsGmx.leafletMap.panTo(coord);
                    return false;
                }
            })

            showDialog(title, ui[0], 300, 80, false, false);
        }

        window.prompt = promptFunction;

    };
})();

window.nsGmx = window.nsGmx || {};
window.nsGmx.GeomixerFrameworkVersion = '3.3.1';
