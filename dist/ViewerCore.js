/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   4.0.5
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  return typeof x === 'function' || typeof x === 'object' && x !== null;
}

function isFunction(x) {
  return typeof x === 'function';
}

var _isArray = undefined;
if (!Array.isArray) {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
} else {
  _isArray = Array.isArray;
}

var isArray = _isArray;

var len = 0;
var vertxNext = undefined;
var customSchedulerFn = undefined;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var r = require;
    var vertx = r('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = undefined;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var _arguments = arguments;

  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;

  if (_state) {
    (function () {
      var callback = _arguments[_state - 1];
      asap(function () {
        return invokeCallback(_state, child, callback, parent._result);
      });
    })();
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  _resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(16);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

var GET_THEN_ERROR = new ErrorObject();

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    GET_THEN_ERROR.error = error;
    return GET_THEN_ERROR;
  }
}

function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
  try {
    then.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        _resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      _reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      _reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    _reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return _resolve(promise, value);
    }, function (reason) {
      return _reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$) {
  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$ === GET_THEN_ERROR) {
      _reject(promise, GET_THEN_ERROR.error);
    } else if (then$$ === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$)) {
      handleForeignThenable(promise, maybeThenable, then$$);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function _resolve(promise, value) {
  if (promise === value) {
    _reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function _reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;

  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = undefined,
      callback = undefined,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function ErrorObject() {
  this.error = null;
}

var TRY_CATCH_ERROR = new ErrorObject();

function tryCatch(callback, detail) {
  try {
    return callback(detail);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = undefined,
      error = undefined,
      succeeded = undefined,
      failed = undefined;

  if (hasCallback) {
    value = tryCatch(callback, detail);

    if (value === TRY_CATCH_ERROR) {
      failed = true;
      error = value.error;
      value = null;
    } else {
      succeeded = true;
    }

    if (promise === value) {
      _reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
      _resolve(promise, value);
    } else if (failed) {
      _reject(promise, error);
    } else if (settled === FULFILLED) {
      fulfill(promise, value);
    } else if (settled === REJECTED) {
      _reject(promise, value);
    }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      _resolve(promise, value);
    }, function rejectPromise(reason) {
      _reject(promise, reason);
    });
  } catch (e) {
    _reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function Enumerator(Constructor, input) {
  this._instanceConstructor = Constructor;
  this.promise = new Constructor(noop);

  if (!this.promise[PROMISE_ID]) {
    makePromise(this.promise);
  }

  if (isArray(input)) {
    this._input = input;
    this.length = input.length;
    this._remaining = input.length;

    this._result = new Array(this.length);

    if (this.length === 0) {
      fulfill(this.promise, this._result);
    } else {
      this.length = this.length || 0;
      this._enumerate();
      if (this._remaining === 0) {
        fulfill(this.promise, this._result);
      }
    }
  } else {
    _reject(this.promise, validationError());
  }
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
};

Enumerator.prototype._enumerate = function () {
  var length = this.length;
  var _input = this._input;

  for (var i = 0; this._state === PENDING && i < length; i++) {
    this._eachEntry(_input[i], i);
  }
};

Enumerator.prototype._eachEntry = function (entry, i) {
  var c = this._instanceConstructor;
  var resolve$$ = c.resolve;

  if (resolve$$ === resolve) {
    var _then = getThen(entry);

    if (_then === then && entry._state !== PENDING) {
      this._settledAt(entry._state, i, entry._result);
    } else if (typeof _then !== 'function') {
      this._remaining--;
      this._result[i] = entry;
    } else if (c === Promise) {
      var promise = new c(noop);
      handleMaybeThenable(promise, entry, _then);
      this._willSettleAt(promise, i);
    } else {
      this._willSettleAt(new c(function (resolve$$) {
        return resolve$$(entry);
      }), i);
    }
  } else {
    this._willSettleAt(resolve$$(entry), i);
  }
};

Enumerator.prototype._settledAt = function (state, i, value) {
  var promise = this.promise;

  if (promise._state === PENDING) {
    this._remaining--;

    if (state === REJECTED) {
      _reject(promise, value);
    } else {
      this._result[i] = value;
    }
  }

  if (this._remaining === 0) {
    fulfill(promise, this._result);
  }
};

Enumerator.prototype._willSettleAt = function (promise, i) {
  var enumerator = this;

  subscribe(promise, undefined, function (value) {
    return enumerator._settledAt(FULFILLED, i, value);
  }, function (reason) {
    return enumerator._settledAt(REJECTED, i, reason);
  });
};

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  _reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {function} resolver
  Useful for tooling.
  @constructor
*/
function Promise(resolver) {
  this[PROMISE_ID] = nextId();
  this._result = this._state = undefined;
  this._subscribers = [];

  if (noop !== resolver) {
    typeof resolver !== 'function' && needsResolver();
    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
  }
}

Promise.all = all;
Promise.race = race;
Promise.resolve = resolve;
Promise.reject = reject;
Promise._setScheduler = setScheduler;
Promise._setAsap = setAsap;
Promise._asap = asap;

Promise.prototype = {
  constructor: Promise,

  /**
    The primary way of interacting with a promise is through its `then` method,
    which registers callbacks to receive either a promise's eventual value or the
    reason why the promise cannot be fulfilled.
  
    ```js
    findUser().then(function(user){
      // user is available
    }, function(reason){
      // user is unavailable, and you are given the reason why
    });
    ```
  
    Chaining
    --------
  
    The return value of `then` is itself a promise.  This second, 'downstream'
    promise is resolved with the return value of the first promise's fulfillment
    or rejection handler, or rejected if the handler throws an exception.
  
    ```js
    findUser().then(function (user) {
      return user.name;
    }, function (reason) {
      return 'default name';
    }).then(function (userName) {
      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
      // will be `'default name'`
    });
  
    findUser().then(function (user) {
      throw new Error('Found user, but still unhappy');
    }, function (reason) {
      throw new Error('`findUser` rejected and we're unhappy');
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
    });
    ```
    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
  
    ```js
    findUser().then(function (user) {
      throw new PedagogicalException('Upstream error');
    }).then(function (value) {
      // never reached
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // The `PedgagocialException` is propagated all the way down to here
    });
    ```
  
    Assimilation
    ------------
  
    Sometimes the value you want to propagate to a downstream promise can only be
    retrieved asynchronously. This can be achieved by returning a promise in the
    fulfillment or rejection handler. The downstream promise will then be pending
    until the returned promise is settled. This is called *assimilation*.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // The user's comments are now available
    });
    ```
  
    If the assimliated promise rejects, then the downstream promise will also reject.
  
    ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // If `findCommentsByAuthor` fulfills, we'll have the value here
    }, function (reason) {
      // If `findCommentsByAuthor` rejects, we'll have the reason here
    });
    ```
  
    Simple Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let result;
  
    try {
      result = findResult();
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
    findResult(function(result, err){
      if (err) {
        // failure
      } else {
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findResult().then(function(result){
      // success
    }, function(reason){
      // failure
    });
    ```
  
    Advanced Example
    --------------
  
    Synchronous Example
  
    ```javascript
    let author, books;
  
    try {
      author = findAuthor();
      books  = findBooksByAuthor(author);
      // success
    } catch(reason) {
      // failure
    }
    ```
  
    Errback Example
  
    ```js
  
    function foundBooks(books) {
  
    }
  
    function failure(reason) {
  
    }
  
    findAuthor(function(author, err){
      if (err) {
        failure(err);
        // failure
      } else {
        try {
          findBoooksByAuthor(author, function(books, err) {
            if (err) {
              failure(err);
            } else {
              try {
                foundBooks(books);
              } catch(reason) {
                failure(reason);
              }
            }
          });
        } catch(error) {
          failure(err);
        }
        // success
      }
    });
    ```
  
    Promise Example;
  
    ```javascript
    findAuthor().
      then(findBooksByAuthor).
      then(function(books){
        // found books
    }).catch(function(reason){
      // something went wrong
    });
    ```
  
    @method then
    @param {Function} onFulfilled
    @param {Function} onRejected
    Useful for tooling.
    @return {Promise}
  */
  then: then,

  /**
    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
    as the catch block of a try/catch statement.
  
    ```js
    function findAuthor(){
      throw new Error('couldn't find that author');
    }
  
    // synchronous
    try {
      findAuthor();
    } catch(reason) {
      // something went wrong
    }
  
    // async with promises
    findAuthor().catch(function(reason){
      // something went wrong
    });
    ```
  
    @method catch
    @param {Function} onRejection
    Useful for tooling.
    @return {Promise}
  */
  'catch': function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};

function polyfill() {
    var local = undefined;

    if (typeof global !== 'undefined') {
        local = global;
    } else if (typeof self !== 'undefined') {
        local = self;
    } else {
        try {
            local = Function('return this')();
        } catch (e) {
            throw new Error('polyfill failed because global object is unavailable in this environment');
        }
    }

    var P = local.Promise;

    if (P) {
        var promiseToString = null;
        try {
            promiseToString = Object.prototype.toString.call(P.resolve());
        } catch (e) {
            // silently ignored
        }

        if (promiseToString === '[object Promise]' && !P.cast) {
            return;
        }
    }

    local.Promise = Promise;
}

// Strange compat..
Promise.polyfill = polyfill;
Promise.Promise = Promise;

return Promise;

})));

ES6Promise.polyfill();
//# sourceMappingURL=es6-promise.auto.map
(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift()
        return {done: value === undefined, value: value}
      }
    }

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      }
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)

    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var list = this.map[name]
    if (!list) {
      list = []
      this.map[name] = list
    }
    list.push(value)
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    var values = this.map[normalizeName(name)]
    return values ? values[0] : null
  }

  Headers.prototype.getAll = function(name) {
    return this.map[normalizeName(name)] || []
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)]
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function(name) {
      this.map[name].forEach(function(value) {
        callback.call(thisArg, value, name, this)
      }, this)
    }, this)
  }

  Headers.prototype.keys = function() {
    var items = []
    this.forEach(function(value, name) { items.push(name) })
    return iteratorFor(items)
  }

  Headers.prototype.values = function() {
    var items = []
    this.forEach(function(value) { items.push(value) })
    return iteratorFor(items)
  }

  Headers.prototype.entries = function() {
    var items = []
    this.forEach(function(value, name) { items.push([name, value]) })
    return iteratorFor(items)
  }

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    reader.readAsArrayBuffer(blob)
    return fileReaderReady(reader)
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    reader.readAsText(blob)
    return fileReaderReady(reader)
  }

  function Body() {
    this.bodyUsed = false

    this._initBody = function(body) {
      this._bodyInit = body
      if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString()
      } else if (!body) {
        this._bodyText = ''
      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
        // Only support ArrayBuffers for POST method.
        // Receiving ArrayBuffers happens via Blobs, instead.
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        return this.blob().then(readBlobAsArrayBuffer)
      }

      this.text = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text')
        } else {
          return Promise.resolve(this._bodyText)
        }
      }
    } else {
      this.text = function() {
        var rejected = consumed(this)
        return rejected ? rejected : Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body
    if (Request.prototype.isPrototypeOf(input)) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = input
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this)
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function headers(xhr) {
    var head = new Headers()
    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\n')
    pairs.forEach(function(header) {
      var split = header.trim().split(':')
      var key = split.shift().trim()
      var value = split.join(':').trim()
      head.append(key, value)
    })
    return head
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = options.status
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = options.statusText
    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request
      if (Request.prototype.isPrototypeOf(input) && !init) {
        request = input
      } else {
        request = new Request(input, init)
      }

      var xhr = new XMLHttpRequest()

      function responseURL() {
        if ('responseURL' in xhr) {
          return xhr.responseURL
        }

        // Avoid security warnings on getResponseHeader when not allowed by CORS
        if (/^X-Request-URL:/mi.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL')
        }

        return
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: headers(xhr),
          url: responseURL()
        }
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);

/*
 Leaflet-GeoMixer, Leaflet plugin for visualization data from GeoMixer server
 (c) 2013-2016, RDC ScanEx
*/
(function () {
"use strict";
var L;
if (typeof module !== 'undefined' && module.exports) {
    L = require('leaflet');
    L.gmx = {};
    module.exports = L.gmx;
} else {
    L = window.L;
}


/*
   Single-pass recursive descent PEG parser library:
      http://en.wikipedia.org/wiki/Parsing_expression_grammar
   Inspired by Chris Double's parser combinator library in JavaScript:
      http://www.bluishcoder.co.nz/2007/10/javascript-packrat-parser.html
	+ Добавлены функции: Math.floor
*/
(function() {
    var regexExpression = /\[(.+?)\]/g,
        regexMath = /(floor\()/g;
	var Parsers = {						// Парсеры
        functionFromExpression: function(s) {
/*eslint-disable no-new-func*/
            return new Function(
/*eslint-enable */
                'props',
                'indexes',
                'return ' +
                    s
                     .replace(regexExpression, 'props[indexes["$1"]]')
                     .replace(regexMath, 'Math.$1')
                    + ';'
            );
        }
    };

	var makePair = function(t1, t2) {
		return {head: t1, tail: t2};
	};

// C-style linked list via recursive typedef.
//   Used purely functionally to get shareable sublists.
//typedef LinkedList = Pair<Dynamic, LinkedList>;
	var LinkedList = function(t1, t2) {
		return makePair(t1, t2);
	};

// Parser state contains position in string and some accumulated data.
//typedef ParserState = Pair<Int, LinkedList>;
	var ParserState = function(t1, t2) {
		return makePair(t1, t2);
	};

// Parser accepts string and state, returns another state.
//typedef Parser = String->ParserState->ParserState;

	// A parser state that indicates failure.
	var fail = new ParserState(-1, null);

	// Check for failure.
	var failed = function(state) {
		return (state.head === -1);
	};

	// Advance a parser state by n characters.
	var advance = function(state, n) {
		return new ParserState(state.head + n, state.tail);
	};

	// Match a specified string.
	var token = function(tok) {
		var len = tok.length;
		return function(s, state) {
			return (s.substr(state.head, len) === tok) ? advance(state, len) : fail;
		};
	};

	// Match a string without regard to case.
	var caseInsensitiveToken = function(tok) {
		var len = tok.length;
		tok = tok.toLowerCase();
		return function(s, state) {
			return (s.substr(state.head, len).toLowerCase() === tok) ? advance(state, len) : fail;
		};
	};

	// Match a single character in a specified range.
	var range = function(startChar, endChar) {
		var startCode = startChar.charCodeAt(0);
		var endCode = endChar.charCodeAt(0);
		return function(s, state) {
			var code = s.charCodeAt(state.head);
			return ((code >= startCode) && (code <= endCode)) ? advance(state, 1) : fail;
		};
	};

	// Match any character outside a certain set.
	//   This combinator is intended only for single character parsers.
	var anythingExcept = function(parser) {
		return function(s, state) {
			return ((s.length > state.head) && failed(parser(s, state))) ? advance(state, 1) : fail;
		};
	};

	// Match thing1, then thing2, ..., then thingN.
	var sequence = function(parsers) {
		return function(s, state) {
			for (var i = 0; i < parsers.length; i++) {
				state = parsers[i](s, state);
				if (failed(state)) {
					return fail;
                }
			}
			return state;
		};
	};

	// Match thing1, or thing2, ..., or thingN.
	var choice = function(parsers) {
		return function(s, state) {
			for (var i = 0; i < parsers.length; i++) {
				var newState = parsers[i](s, state);
				if (!failed(newState)) {
					return newState;
                }
			}
			return fail;
		};
	};

	// Match immediately, without regard to what's in the string.
	var nothing = function(s, state) {
		return state;
	};

	// Match this thing or nothing.
	var maybe = function(parser) {
		return choice([parser, nothing]);
	};

	// Match minCount or more repetitions of this thing.
	var repeat = function(minCount, parser) {
		return function(s, state) {
			var count = 0;
			while (true) {
				var newState = parser(s, state);
				if (failed(newState)) {
					return (count >= minCount) ? state : fail;
				} else {
					count += 1;
					state = newState;
				}
			}
			// return fail;
		};
	};

	// Match a list of minCount or more instances of thing1, separated by thing2.
	var separatedList = function(minCount, parser, separator) {
		var parser1 = sequence([parser, repeat(minCount - 1, sequence([separator, parser]))]);
		return (minCount > 0) ? parser1 : choice([parser1, nothing]);
	};

	var whitespace = repeat(0, choice([
		token(' '),
		token('\t'),
		token('\n')
	]));

	// Same as separatedList, but can have whitespace between items and separators.
	var whitespaceSeparatedList = function(minCount, parser, separator) {
		return separatedList(minCount, parser, sequence([whitespace, separator, whitespace]));
	};

	// Same as sequence, but can have whitespace between items.
	var whitespaceSeparatedSequence = function(parsers) {
		var newParsers = [];
		for (var i = 0; i < parsers.length; i++) {
			if (newParsers.length > 0) { newParsers.push(whitespace); }
			newParsers.push(parsers[i]);
		}
		return sequence(newParsers);
	};

	// This combinator captures the string that the parser matched
	//   and adds it to the current parser state, consing a new state.
	var capture = function(parser) {
		return function(s, state) {
			var newState = parser(s, state);
			return failed(newState) ? fail : new ParserState(newState.head, new LinkedList(s.substr(state.head, newState.head - state.head), newState.tail));
		};
	};

	// This combinator passes the accumulated parser state to a given
	//  function for processing. The result goes into the new state.
	var action = function(parser, func) {
		return function(s, state) {
			var oldState = state;
			var newState = parser(s, new ParserState(oldState.head, null));
			return failed(newState) ? fail : new ParserState(newState.head, new LinkedList(func(newState.tail), oldState.tail));
		};
	};

	// Define a syntactic subset of SQL WHERE clauses.
	var fieldName = capture(repeat(1, choice([
		range('a', 'z'),
		range('A', 'Z'),
		range('а', 'я'),
		range('А', 'Я'),
		range('0', '9'),
		token('_')
	])));

	var fieldNameWithSpaces = capture(repeat(1, choice([
		range('a', 'z'),
		range('A', 'Z'),
		range('а', 'я'),
		range('А', 'Я'),
		range('0', '9'),
		token('_'),
		token(' ')
	])));

	var quotedFieldName = choice([
		fieldName,
		sequence([token('"'), fieldNameWithSpaces, token('"')]),
		sequence([token('`'), fieldNameWithSpaces, token('`')])
	]);

	var stringLiteral = sequence([
		token('\''),
		capture(repeat(0, anythingExcept(token('\'')))),
		token('\'')
	]);

	var digits = repeat(1, range('0', '9'));

	var numberLiteral = capture(sequence([
		maybe(token('-')),
		digits,
		maybe(sequence([token('.'), digits]))
	]));

	var literal = choice([numberLiteral, stringLiteral]);

	var applyParser = function(s, parser) {
		return parser(s, new ParserState(0, null));
	};

	// Order is important here: longer ops should be tried first.
	var opTerm = action(
		whitespaceSeparatedSequence([
			quotedFieldName,
			capture(choice([
				token('=='),
				token('!='),
				token('<>'),
				token('<='),
				token('>='),
				token('='),
				token('<'),
				token('>'),
				caseInsensitiveToken('LIKE')
			])),
            choice([literal, quotedFieldName])
		]),
		function(state) {
			// Linked list contains fieldname, operation, value
			// (in reverse order).

			var fieldName = state.tail.tail.head;
			var op = state.tail.head;
			var referenceValue = state.head;

			var matchPattern = null;
			if (op.toUpperCase() === 'LIKE') {
				matchPattern = function(fieldValue) {
					var matchFrom = null;
					matchFrom = function(referenceIdx, fieldIdx) {
						var referenceChar = referenceValue.charAt(referenceIdx);
						var fieldChar = fieldValue.charAt(fieldIdx);
						if (referenceChar === '') {
							return (fieldChar === '');
						} else if (referenceChar === '%') {
							return matchFrom(referenceIdx + 1, fieldIdx) || ((fieldChar !== '') && matchFrom(referenceIdx, fieldIdx + 1));
						} else {
							return (referenceChar === fieldChar) && matchFrom(referenceIdx + 1, fieldIdx + 1);
                        }
					};
					return matchFrom(0, 0);
				};
			}

			return function(props, indexes, types) {
				var fieldValue = props[indexes[fieldName]],
                    rValue = referenceValue;
                if (referenceValue in indexes) { rValue = props[indexes[rValue]]; }
                if ((types[fieldName] === 'date' || types[fieldName] === 'datetime') && typeof rValue === 'string') { rValue = L.gmxUtil.getUnixTimeFromStr(rValue); }
                if (typeof fieldValue === 'boolean' && typeof rValue === 'string') {
                    fieldValue = fieldValue ? 'True' : 'False';
                }
				if (fieldValue === null) { return false; }
				if (matchPattern !== null) { return matchPattern(fieldValue);
/*eslint-disable eqeqeq */
                } else if ((op === '=') || (op === '==')) { return (fieldValue == rValue);
				} else if ((op === '!=') || (op === '<>')) { return (fieldValue != rValue);
/*eslint-enable */
                } else {
                    var f1, f2;
					if (!(referenceValue in indexes) && typeof rValue === 'string' && applyParser(rValue, numberLiteral).head === rValue.length) {
						f1 = parseFloat(fieldValue);
						f2 = parseFloat(rValue);
						if (op === '<') { return (f1 < f2);
						} else if (op === '>') { return (f1 > f2);
						} else if (op === '<=') { return (f1 <= f2);
						} else if (op === '>=') { return (f1 >= f2);
						} else { return false;
                        }
					} else {
						f1 = fieldValue;
						f2 = rValue;
						if (op === '<') { return (f1 < f2);
						} else if (op === '>') { return (f1 > f2);
						} else if (op === '<=') { return (f1 <= f2);
						} else if (op === '>=') { return (f1 >= f2);
						} else { return false;
                        }
					}
				}
			};
		}
	);

	var inTerm = action(
		whitespaceSeparatedSequence([
			quotedFieldName,
			caseInsensitiveToken('IN'),
			token('('),
			whitespaceSeparatedList(0, literal, token(',')),
			token(')')
		]),
		function(state) {
			// Linked list contains fieldname and multiple values
			//   (in reverse order).

			var node = state;
			while (node.tail != null) {
				node = node.tail;
			}
            var fieldName = node.head;

			return function(props, indexes) {
				var value = props[indexes[fieldName]];
				if (value == null) { return false; }
				var node = state;
				while (node.tail !== null) {
					if (node.head === value) { return true; }
					node = node.tail;
				}
				return false;
			};
		}
	);

	// Forward declarations to allow mutually recursive grammar definitions.
	var term = function(s, state) { return term(s, state); };
	var expression = function(s, state) { return expression(s, state); };

	var notTerm = action(
		whitespaceSeparatedSequence([caseInsensitiveToken('NOT'), term]),
		function(state) {
			// Linked list contains only processed inner term.
			var innerTerm = state.head;
			return function(props, indexes, types) {
				return !innerTerm(props, indexes, types);
			};
		}
	);

	term = choice([
		notTerm,
		opTerm,
		inTerm,
		whitespaceSeparatedSequence([token('('), expression, token(')')])
	]);

	// AND and OR expressions must have at least 2 terms,
	//   to disambiguate them from a single term.

	var andExpression = action(
		whitespaceSeparatedList(2, term, caseInsensitiveToken('AND')),
		function(state) {
			// Linked list contains multiple processed inner terms
			//   (in reverse order).
			return function(props, indexes, types) {
				var flag = true;
				var node = state;
				while (node != null) {
					flag = flag && node.head(props, indexes, types);
					node = node.tail;
				}
				return flag;
			};
		}
	);

	var orExpression = action(
		whitespaceSeparatedList(2, term, caseInsensitiveToken('OR')),
		function(state) {
			// Linked list contains multiple processed inner terms
			//   (in reverse order).
			return function(props, indexes, types) {
				var flag = false;
				var node = state;
				while (node != null) {
					flag = flag || node.head(props, indexes, types);
					node = node.tail;
				}
				return flag;
			};
		}
	);

	// Order is important here: term should be tried last,
	//   because andExpression and orExpression start with it.
	expression = choice([
		andExpression,
		orExpression,
		term
	]);

	var whereClause = sequence([whitespace, expression, whitespace]);

	Parsers.parseSQL = function(str) {
		var result = applyParser(str, whereClause);
		return result.head === str.length ?
			result.tail.head :
            (applyParser(str, whitespace).head === str.length) ?
				function(/*props*/) { return true; } :
				null;
	};

	var additiveExpression = function(s, state) { return additiveExpression(s, state); };
	var multiplicativeExpression = function(s, state) { return multiplicativeExpression(s, state); };
	additiveExpression = action(
		whitespaceSeparatedList(
			1,
			multiplicativeExpression,
			capture(choice([token('+'), token('-')]))
		),
		function(state)
		{
			return function(props, indexes, types)
			{
				var pos = state;
				var term = 0.0;
				while (pos !== null) {
					term += pos.head(props, indexes, types);
					if (pos.tail === null) {
						return term;
					} else {
						if (pos.tail.head === '-') { term = -term; }
						pos = pos.tail.tail;
					}
				}
				return term;
			};
		}
	);

	var multiplicativeTerm = choice([
		action(
			numberLiteral,
			function(state) {
				return function(/*props, indexes, types*/) {
					return parseFloat(state.head);
				};
			}
		),
		action(
			sequence([token('floor('), additiveExpression, token(')')]),
			function(state) {
				return function(props, indexes, types) {
					var res = state.head(props, indexes, types);
					return Math.floor(res);
				};
			}
		),
		action(
			sequence([token('['), fieldName, token(']')]),
			function(state) {
				return function(props, indexes) {
					return parseFloat(props[indexes[state.head]]);
				};
			}
		),
		whitespaceSeparatedSequence([
			token('('),
			additiveExpression,
			token(')')
		])
	]);
	multiplicativeTerm = choice([
		multiplicativeTerm,
		action(
			whitespaceSeparatedSequence([token('-'), multiplicativeTerm]),
			function(state) {
				return function(props, indexes, types) {
					return -state.head(props, indexes, types);
				};
			}
		)
	]);
	multiplicativeExpression = action(
		whitespaceSeparatedList(
			1,
			multiplicativeTerm,
			capture(choice([token('*'), token('/')]))
		),
		function(state)
		{
			return function(props, indexes, types) {
				var pos = state;
				var term = 1.0;
				while (pos !== null) {
					term *= pos.head(props, indexes, types);
					if (pos.tail === null) {
						return term;
					} else {
						if (pos.tail.head === '/') { term = 1.0 / term; }
						pos = pos.tail.tail;
					}
				}
				return term;
			};
		}
	);

	multiplicativeTerm = choice([
		multiplicativeTerm,
		action(
			whitespaceSeparatedSequence([token('-'), multiplicativeTerm]),
			function(state) {
				return function(props, indexes, types) {
					return -state.head(props, indexes, types);
				};
			}
		)
	]);

	var arithmeticExpression = sequence([whitespace, additiveExpression, whitespace]);
	Parsers.parseExpression = function(s) {
		var result = applyParser(s, arithmeticExpression);
        return result.head === s.length ? result.tail.head : null;
        // return result.head === s.length ? Parsers.functionFromExpression(s) : null;
	};

	var svgPath = action(
		repeat(0, choice([
			numberLiteral,
			token(','),
			token('M'),
			token('C'),
			repeat(1, choice([
				token(' '),
				token('\t'),
				token('\r'),
				token('\n')
			]))
		])),
		function(state) {
			var coords = [];
			while (state !== null) {
				coords.push(parseFloat(state.head));
				state = state.tail;
			}
			coords.reverse();
			return coords;
		}
	);

	Parsers.parseSVGPath = function(s) {
		var result = applyParser(s, svgPath);
		if (result.head === s.length) {
			return result.tail.head;
		} else {
			return [];
        }
	};

	//extend L.gmx namespace
    L.gmx = L.gmx || {};
	L.gmx.Parsers = Parsers;
})();


//all the methods can be called without instance itself
//For example:
//
// var def = new Deferred();
// doSomething(def.resolve) (instead of doSomething(def.resolve.bind(def))
var Deferred = function(cancelFunc) {
    var resolveCallbacks = [],
        rejectCallbacks = [],
        isFulfilled = false,
        isResolved = false,
        fulfilledData,
        onceAdded = false,
        isCancelled = false;

    var fulfill = this._fulfill = function(resolved /*, data*/) {
        if (isFulfilled) {
            return;
        }
        var callbacks = resolved ? resolveCallbacks : rejectCallbacks;
        fulfilledData = [].slice.call(arguments, 1);
        isFulfilled = true;
        isResolved = resolved;

        callbacks.forEach(function(callback) { callback.apply(null, fulfilledData); });
        resolveCallbacks = rejectCallbacks = [];
    };

    this.resolve = function(/*data*/) {
        isCancelled || fulfill.apply(null, [true].concat([].slice.call(arguments)));
    };

    this.reject = function(/*data*/) {
        isCancelled || fulfill.apply(null, [false].concat([].slice.call(arguments)));
    };

    var cancel = this.cancel = function() {
        if (!isCancelled && !isFulfilled) {
            isCancelled = true;
            cancelFunc && cancelFunc();
        }
    };

    var then = this.then = function(resolveCallback, rejectCallback) {
        if (isCancelled) {
            return null;
        }

        var userFuncDef = null;
        var def = new Deferred(function() {
            cancel();
            userFuncDef && userFuncDef.cancel();
        });

        var fulfillFunc = function(func, resolved) {
            return function(/*data*/) {
                if (!func) {
                    def._fulfill.apply(null, [resolved].concat([].slice.call(arguments)));
                } else {
                    var res = func.apply(null, arguments);
                    if (res instanceof Deferred) {
                        userFuncDef = res;
                        res.then(def.resolve, def.reject);
                    } else {
                        def.resolve(res);
                    }
                }
            };
        };

        if (isFulfilled) {
            fulfillFunc(isResolved ? resolveCallback : rejectCallback, isResolved).apply(null, fulfilledData);
        } else {
            resolveCallbacks.push(fulfillFunc(resolveCallback, true));
            rejectCallbacks.push(fulfillFunc(rejectCallback, false));
        }
        return def;
    };

    this.once = function(onceResolveCallback) {
        if (!onceAdded) {
            onceAdded = true;
            then(onceResolveCallback);
        }
    };

    this.always = function(callback) {
        then(callback, callback);
    };

    this.getFulfilledData = function() {
        return fulfilledData;
    };
};

Deferred.all = function() {
    var defArray = [].slice.apply(arguments);
    var resdef = new Deferred();
    var left = defArray.length;
    var results = new Array(defArray.length);

    if (left) {
        defArray.forEach(function(def, i) {
            def.then(function(res) {
                results[i] = res;
                left--;
                if (left === 0) {
                    resdef.resolve.apply(resdef, results);
                }
            }, function() {
                resdef.reject();
            });
        });
    } else {
        resdef.resolve();
    }

    return resdef;
};

L.gmx = L.gmx || {};
L.gmx.Deferred = Deferred;


(function() {

var ImageRequest = function(id, url, options) {
    this._id = id;
    this.def = new L.gmx.Deferred(L.gmx.imageLoader._cancelRequest.bind(L.gmx.imageLoader, this));
    this.remove = L.gmx.imageLoader._removeRequestFromCache.bind(L.gmx.imageLoader, this);
    this.url = url;
    this.options = options || {};
};

var GmxImageLoader = L.Class.extend({
    includes: L.Mixin.Events,
    statics: {
        MAX_COUNT: 20 // max number of parallel requests
    },

    initialize: function() {
        this.curCount = 0;        // number of currently processing requests (number of items in "inProgress")
        this.requests = [];       // not yet processed image requests
        this.inProgress = {};     // hash of in progress image loadings
        this.requestsCache = {};  // for requests cache by uniqueID
        this.uniqueID = 0;
    },

    _resolveRequest: function(request, image, canceled) {
        var def = request.def;
        if (image) {
            if (!canceled && request.options.cache) {
                var url = request.url,
                    cacheItem = this.requestsCache[url],
                    cacheKey = request._id;
                if (!cacheItem) { cacheItem = this.requestsCache[url] = {image: image, requests:{}}; }
                if (!cacheItem.requests[cacheKey]) { cacheItem.requests[cacheKey] = request; }
            }
            def.resolve(image);
        } else if (!canceled) {
            def.reject();
        }
        this.fire('requestdone', {request: request});
    },

    _imageLoaded: function(url, image, canceled) {
        if (url in this.inProgress) {
            var resolveRequest = function(it) {
                this._resolveRequest(it, image, canceled);
            };
            this.inProgress[url].requests.forEach(resolveRequest.bind(this));
            --this.curCount;
            delete this.inProgress[url];
        }
        L.gmxUtil.loaderStatus(url, true);
        this.fire('imageloaded', {url: url});
        this._nextLoad();
    },

    _nextLoad: function() {  // загрузка следующего
        if (this.curCount >= GmxImageLoader.MAX_COUNT || !this.requests.length) {
            return;
        }

        var request = this.requests.shift(),
            url = request.url;

        if (url in this.inProgress) {
            this.inProgress[url].requests.push(request);
        } else {
            var requests = [request];
            this.inProgress[url] = {requests: requests};
            ++this.curCount;

            for (var k = this.requests.length - 1; k >= 0; k--) {
                if (this.requests[k].url === url) {
                    requests.push(this.requests[k]);
                    this.requests.splice(k, 1);
                }
            }

            var image = this._loadImage(request);
            if (!image.width) {
                L.gmxUtil.loaderStatus(url);
            }

            //theoretically image loading can be synchronous operation
            if (this.inProgress[url]) {
                this.inProgress[url].image = image;
            }
        }
    },

    _loadImage: function(request) {
        var imageObj = new Image(),
            url = request.url,
            _this = this;

        if (request.options.crossOrigin) {
            imageObj.crossOrigin = request.options.crossOrigin;
        }

        imageObj.onload = this._imageLoaded.bind(this, url, imageObj, false);
        imageObj.onerror = function() {
            _this._imageLoaded(url);
        };
        imageObj.src = url;

        this.fire('imageloadstart', {url: url});

        return imageObj;
    },

    _cancelRequest: function(request) {
        var id = request._id,
            url = request.url,
            i = 0, len;
        if (url in this.inProgress) {
            var loadingImg = this.inProgress[url],
                requests = loadingImg.requests;

            len = requests.length;
            if (len === 1 && requests[0]._id === id) {
                loadingImg.image.onload = L.Util.falseFn;
                loadingImg.image.onerror = L.Util.falseFn;
                loadingImg.image.src = L.Util.emptyImageUrl;
                this._imageLoaded(url, null, true);
            } else {
                for (i = 0; i < len; i++) {
                    if (requests[i]._id === id) {
                        requests.splice(i, 1);
                        break;
                    }
                }
            }
        } else {
            for (i = 0, len = this.requests.length; i < len; i++) {
                if (this.requests[i]._id === id) {
                    this.requests.splice(i, 1);
                    break;
                }
            }
        }

        this.fire('requestdone', {request: request});
    },

    _removeRequestFromCache: function(request) {    // remove request from cache
        this._cancelRequest(request);
        this._clearCacheItem(request.url, request._id);
    },

    _clearCacheItem: function(url, cacheKey) {    // remove cache item
        if (this.requestsCache[url]) {
            var cacheItem = this.requestsCache[url];
            delete cacheItem.requests[cacheKey];
            if (Object.keys(cacheItem.requests).length === 0) {
                delete this.requestsCache[url];
            }
        }
    },
    _add: function(atBegin, url, options) {
		url = url.replace(/^http:/, L.gmxUtil.protocol);

		var id = 'id' + (++this.uniqueID),
            request = new ImageRequest(id, url, options);

        if (url in this.inProgress) {
            this.inProgress[url].requests.push(request);
        } else {
            atBegin ? this.requests.unshift(request) : this.requests.push(request);
            this._nextLoad();
        }

        this.fire('request', {request: request});

        return request;
    },

    push: function(url, options) {  // добавить запрос в конец очереди
        return this._add(false, url, options);
    },

    unshift: function(url, options) {   // добавить запрос в начало очереди
        return this._add(true, url, options);
    }
});

L.gmx.imageLoader = new GmxImageLoader();

})();


/**
* @name L.gmxUtil
* @namespace
*/
var gmxAPIutils = {
    lastMapId: 0,
	fromWebMercY: function(y) {
		return 90 * (4 * Math.atan(Math.exp(y / gmxAPIutils.rMajor)) / Math.PI - 1);
	},

    newId: function()
    {
        gmxAPIutils.lastMapId += 1;
        return '_' + gmxAPIutils.lastMapId;
    },

    uniqueGlobalName: function(thing)
    {
        var id = gmxAPIutils.newId();
        window[id] = thing;
        return id;
    },

    isPageHidden: function()	{		// Видимость окна браузера
        return document.hidden || document.msHidden || document.webkitHidden || document.mozHidden || false;
    },

    normalizeHostname: function(hostName) {
        var parsedHost = L.gmxUtil.parseUri((hostName.substr(0, 4) !== 'http' ? L.gmxUtil.protocol + '//' : '') + hostName); // Bug in gmxAPIutils.parseUri for 'localhost:8000'

        hostName = parsedHost.host + parsedHost.directory;

        if (hostName[hostName.length - 1] === '/') {
            hostName = hostName.substring(0, hostName.length - 1);
        }

        return hostName;
    },

	getLayerItemFromServer: function(options) {
        var query = options.query ? options.query : '[' + options.field + ']=' + options.value,
			kosmosnimkiURL = L.gmxUtil.protocol + '//maps.kosmosnimki.ru/',
            req = {
                WrapStyle: 'func',
                geometry: true,
                layer: options.layerID,
                query: query
            };
        if (options.border) { req.border = options.border; }
        return gmxAPIutils.requestJSONP(
            options.url || (window.serverBase || kosmosnimkiURL) + 'VectorLayer/Search.ashx',
            req,
            options
        );
    },

	getCadastreFeatures: function(options) {
		// example: L.gmxUtil.getCadastreFeatures({latlng: L.latLng(48.350039, 45.152757), callbackParamName: 'callback'});
        if (options.latlng) {
			var latlng = options.latlng,
				req = {
					WrapStyle: 'func',
					text: (latlng.lat + ' ' + latlng.lng).replace(/\./g, ','),
					tolerance: options.tolerance || 0
				};
			return gmxAPIutils.requestJSONP(
				options.url || 'http://pkk5.rosreestr.ru/api/features/',
				req,
				options
			);
		} else {
			return null;
		}
    },

	getFormData: function(json) {
		var arr = [];
		for (var key in json) {
			var val = json[key];
			arr.push(key + '=' + (typeof val === 'object' ? JSON.stringify(val) : val));
		}
		return arr.join('&');
    },

    /** Sends JSONP requests
     * @memberof L.gmxUtil
     * @param {String} url - request URL
     * @param {Object} params - request params
     * @param {Object} [options] - additional request options
     * @param {String} [options.callbackParamName=CallbackName] - Name of param, that will be used for callback id.
       If callbackParamName is set to null, no params will be added (StaticJSONP)
     * @return {Deferred} Promise with server JSON response or with error status
    */
	requestJSONP: function(url, params, options) {
        options = options || {};
        var def = new L.gmx.Deferred();

        var script = document.createElement('script');
        script.setAttribute('charset', 'UTF-8');
        var callbackParamName = 'callbackParamName' in options ? options.callbackParamName : 'CallbackName';
        var urlParams = L.extend({}, params, L.gmx.gmxMapManager.syncParams);

        if (callbackParamName) {
            var callbackName = gmxAPIutils.uniqueGlobalName(function(obj) {
                delete window[callbackName];
                def.resolve(obj, options);
            });

            urlParams[callbackParamName] = callbackName;
        }

        var paramsStringItems = [];

        for (var p in urlParams) {
            paramsStringItems.push(p + '=' + encodeURIComponent(urlParams[p]));
        }

        var src = url + (url.indexOf('?') === -1 ? '?' : '&') + paramsStringItems.join('&');

        script.onerror = function(e) {
            def.reject(e);
            L.gmxUtil.loaderStatus(src, true);
            script.parentNode.removeChild(script);
        };
        script.onload = function() {
            L.gmxUtil.loaderStatus(src, true);
            script.parentNode.removeChild(script);
        };
        L.gmxUtil.loaderStatus(src, null, 'vector');
        script.setAttribute('src', src);

        document.getElementsByTagName('head').item(0).appendChild(script);
        return def;
    },
    getXmlHttp: function() {
        var xmlhttp;
        if (typeof XMLHttpRequest !== 'undefined') {
            xmlhttp = new XMLHttpRequest();
        } else {
          try {
            xmlhttp = new ActiveXObject('Msxml2.XMLHTTP');
          } catch (e) {
            try {
              xmlhttp = new ActiveXObject('Microsoft.XMLHTTP');
            } catch (E) {
              xmlhttp = false;
            }
          }
        }
        return xmlhttp;
    },
    request: function(ph) { // {'type': 'GET|POST', 'url': 'string', 'callback': 'func'}
        var xhr = gmxAPIutils.getXmlHttp();
        if (xhr) {
            xhr.open((ph.type ? ph.type : 'GET'), ph.url, ph.async || false);
            if (ph.headers) {
                for (var key in ph.headers) {
                    xhr.setRequestHeader(key, ph.headers[key]);
                }
            }
            var reqId = L.gmxUtil.loaderStatus();
            if (ph.async) {
                if (ph.withCredentials) {
                    xhr.withCredentials = true;
                }
                xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4) {
                        L.gmxUtil.loaderStatus(reqId, true);
                        if (xhr.status === 200) {
                            ph.callback(xhr.responseText);
                            xhr = null;
                        } else if (ph.onError) {
                            ph.onError(xhr);
                        }
                    }
                };
            }
			var params = null;
			if (ph.params) {
				params = ph.params;
				var syncParams = L.gmx.gmxMapManager.getSyncParams(true);
				if (syncParams) {
					params += '&' + syncParams;
				}
			}
            xhr.send(params);
            if (!ph.async && xhr.status === 200) {
                ph.callback(xhr.responseText);
                L.gmxUtil.loaderStatus(reqId, true);
                return xhr.status;
            }
            return true;
        }
        if (ph.onError) {
            ph.onError({Error: 'bad XMLHttpRequest!'});
        }
        return false;
    },

    tileSizes: [], // Размеры тайла по zoom
    getTileNumFromLeaflet: function (tilePoint, zoom) {
        if ('z' in tilePoint) {
            zoom = tilePoint.z;
        }
        var pz = Math.pow(2, zoom),
            tx = tilePoint.x % pz + (tilePoint.x < 0 ? pz : 0),
            ty = tilePoint.y % pz + (tilePoint.y < 0 ? pz : 0);
        return {
            z: zoom,
            x: tx % pz - pz / 2,
            y: pz / 2 - 1 - ty % pz
        };
    },

	getTilePosZoomDelta: function(tilePoint, zoomFrom, zoomTo) {		// получить смещение тайла на меньшем zoom
        var dz = Math.pow(2, zoomFrom - zoomTo),
            size = 256 / dz,
            dx = tilePoint.x % dz,
            dy = tilePoint.y % dz;
		return {
			size: size,
			zDelta: dz,
			x: size * (dx < 0 ? dz + dx : dx),
			y: size * (dy < 0 ? -(1 + tilePoint.y) % dz : dz - 1 - dy)
		};
    },

    geoItemBounds: function(geo) {  // get item bounds array by geometry
        if (!geo) {
            return {
                bounds: null,
                boundsArr: []
            };
        }
        var type = geo.type,
            coords = geo.coordinates,
            b = null,
            i = 0,
            len = 0,
            bounds = null,
            boundsArr = [];
        if (type === 'MULTIPOLYGON' || type === 'MultiPolygon') {
            bounds = gmxAPIutils.bounds();
            for (i = 0, len = coords.length; i < len; i++) {
                var arr1 = [];
                for (var j = 0, len1 = coords[i].length; j < len1; j++) {
                    b = gmxAPIutils.bounds(coords[i][j]);
                    arr1.push(b);
                    if (j === 0) { bounds.extendBounds(b); }
                }
                boundsArr.push(arr1);
            }
        } else if (type === 'POLYGON' || type === 'Polygon') {
            bounds = gmxAPIutils.bounds();
            for (i = 0, len = coords.length; i < len; i++) {
                b = gmxAPIutils.bounds(coords[i]);
                boundsArr.push(b);
                if (i === 0) { bounds.extendBounds(b); }
            }
        } else if (type === 'POINT' || type === 'Point') {
            bounds = gmxAPIutils.bounds([coords]);
        } else if (type === 'MULTIPOINT' || type === 'MultiPoint') {
            bounds = gmxAPIutils.bounds();
            for (i = 0, len = coords.length; i < len; i++) {
                b = gmxAPIutils.bounds([coords[i]]);
                bounds.extendBounds(b);
            }
        } else if (type === 'LINESTRING' || type === 'LineString') {
            bounds = gmxAPIutils.bounds(coords);
            //boundsArr.push(bounds);
        } else if (type === 'MULTILINESTRING' || type === 'MultiLineString') {
            bounds = gmxAPIutils.bounds();
            for (i = 0, len = coords.length; i < len; i++) {
                b = gmxAPIutils.bounds(coords[i]);
                bounds.extendBounds(b);
                //boundsArr.push(b);
            }
        }
        return {
            bounds: bounds,
            boundsArr: boundsArr
        };
    },

    getUnFlattenGeo: function(geo) {  // get unFlatten geometry
        var type = geo.type,
            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,
            coords = geo.coordinates,
            coordsOut = coords;

        if (isLikePolygon) {
            coordsOut = [];
            var isPolygon = type === 'POLYGON' || type === 'Polygon';
            if (isPolygon) { coords = [coords]; }
            for (var i = 0, len = coords.length; i < len; i++) {
                var ring = [];
                for (var j = 0, len1 = coords[i].length; j < len1; j++) {
                    ring[j] = gmxAPIutils.unFlattenRing(coords[i][j]);
                }
                coordsOut.push(ring);
            }
            if (isPolygon) { coordsOut = coordsOut[0]; }
        }
        return {type: type, coordinates: coordsOut};
    },

    unFlattenRing: function(arr) {
        if (typeof arr[0] !== 'number') {
            return arr;
        }
        var len = arr.length,
            cnt = 0,
            res = new Array(len / 2);

        for (var i = 0; i < len; i += 2) {
            res[cnt++] = [arr[i], arr[i + 1]];
        }
        return res;
    },

    geoFlatten: function(geo) {  // get flatten geometry
        var type = geo.type,
            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,
            isPolygon = type === 'POLYGON' || type === 'Polygon',
            coords = geo.coordinates;

        if (isLikePolygon) {
            if (isPolygon) { coords = [coords]; }
            for (var i = 0, len = coords.length; i < len; i++) {
                for (var j = 0, len1 = coords[i].length; j < len1; j++) {
                    coords[i][j] = gmxAPIutils.flattenRing(coords[i][j]);
                }
            }
        }
    },

    flattenRing: function(arr) {
        var len = arr.length,
            cnt = 0,
            CurArray = typeof Float64Array === 'function' ? Float64Array : Array,
            res = new CurArray(2 * len);

        for (var i = 0; i < len; i++) {
            res[cnt++] = arr[i][0];
            res[cnt++] = arr[i][1];
        }
        return res;
    },

    /** Check rectangle type by coordinates
     * @memberof L.gmxUtil
     * @param {coordinates} coordinates - geoJSON coordinates data format
     * @return {Boolean}
    */
    isRectangle: function(coords) {
        return (coords && coords[0] && (coords[0].length === 5 || coords[0].length === 4)
            && ((coords[0][0][0] === coords[0][1][0]) || (coords[0][0][1] === coords[0][1][1]))
            && ((coords[0][1][0] === coords[0][2][0]) || (coords[0][1][1] === coords[0][2][1]))
            && ((coords[0][2][0] === coords[0][3][0]) || (coords[0][2][1] === coords[0][3][1]))
            && ((coords[0][3][0] === coords[0][0][0]) || (coords[0][3][1] === coords[0][0][1]))
        );
    },

    /** Get bounds from geometry
     * @memberof L.gmxUtil
     * @param {geometry} geometry - Geomixer or geoJSON data format
     * @return {Object} bounds
    */
    getGeometryBounds: function(geo) {
        var pt = gmxAPIutils.geoItemBounds(geo);
        return pt.bounds;
    },

    getMarkerPolygon: function(bounds, dx, dy) {
        var x = (bounds.min.x + bounds.max.x) / 2,
            y = (bounds.min.y + bounds.max.y) / 2;
        return [
            [x - dx, y - dy],
            [x - dx, y + dy],
            [x + dx, y + dy],
            [x + dx, y - dy],
            [x - dx, y - dy]
        ];
    },

    getQuicklookPointsFromProperties: function(pArr, gmx) {
        var indexes = gmx.tileAttributeIndexes;
        var points = {
                x1: gmxAPIutils.getPropItem(gmx.quicklookX1 || ('x1' in indexes ? 'x1' : 'X1'), pArr, indexes) || 0,
                y1: gmxAPIutils.getPropItem(gmx.quicklookY1 || ('y1' in indexes ? 'y1' : 'Y1'), pArr, indexes) || 0,
                x2: gmxAPIutils.getPropItem(gmx.quicklookX2 || ('x2' in indexes ? 'x2' : 'X2'), pArr, indexes) || 0,
                y2: gmxAPIutils.getPropItem(gmx.quicklookY2 || ('y2' in indexes ? 'y2' : 'Y2'), pArr, indexes) || 0,
                x3: gmxAPIutils.getPropItem(gmx.quicklookX3 || ('x3' in indexes ? 'x3' : 'X3'), pArr, indexes) || 0,
                y3: gmxAPIutils.getPropItem(gmx.quicklookY3 || ('y3' in indexes ? 'y3' : 'Y3'), pArr, indexes) || 0,
                x4: gmxAPIutils.getPropItem(gmx.quicklookX4 || ('x4' in indexes ? 'x4' : 'X4'), pArr, indexes) || 0,
                y4: gmxAPIutils.getPropItem(gmx.quicklookY4 || ('y4' in indexes ? 'y4' : 'Y4'), pArr, indexes) || 0
            },
            bounds = gmxAPIutils.bounds([
                [points.x1, points.y1],
                [points.x2, points.y2],
                [points.x3, points.y3],
                [points.x4, points.y4]
            ]);

        if (bounds.max.x === bounds.min.x || bounds.max.y === bounds.min.y) {
            return null;
        }

        if (!gmx.quicklookPlatform) {
			var crs = gmx.srs === '3857' ? L.CRS.EPSG3857 : L.Projection.Mercator;
            var merc = crs.project(L.latLng(points.y1, points.x1));
            points.x1 = merc.x; points.y1 = merc.y;
            merc = crs.project(L.latLng(points.y2, points.x2));
            points.x2 = merc.x; points.y2 = merc.y;
            merc = crs.project(L.latLng(points.y3, points.x3));
            points.x3 = merc.x; points.y3 = merc.y;
            merc = crs.project(L.latLng(points.y4, points.x4));
            points.x4 = merc.x; points.y4 = merc.y;
        }

        return points;
    },

    /** Get hash properties from array properties
     * @memberof L.gmxUtil
     * @param {Array} properties in Array format
     * @param {Object} keys indexes
     * @return {Object} properties in Hash format
    */
    getPropertiesHash: function(arr, indexes) {
        var properties = {};
        for (var key in indexes) {
            properties[key] = arr[indexes[key]];
        }
        return properties;
    },

    getPropItem: function(key, arr, indexes) {
        return key in indexes ? arr[indexes[key]] : '';
    },

    dec2rgba: function(i, a)	{				// convert decimal to rgb
        var r = (i >> 16) & 255,
            g = (i >> 8) & 255,
            b = i & 255;
		return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';
	},

    dec2hex: function(i) {					// convert decimal to hex
        return (i + 0x1000000).toString(16).substr(-6);
    },

    dec2color: function(i, a)   {   // convert decimal to canvas color
        return a < 1 ? this.dec2rgba(i, a) : '#' + this.dec2hex(i);
    },

    oneDay: 60 * 60 * 24,			// один день

    isTileKeysIntersects: function(tk1, tk2) { // пересечение по номерам двух тайлов
        if (tk1.z < tk2.z) {
            var t = tk1; tk1 = tk2; tk2 = t;
        }

        var dz = tk1.z - tk2.z;
        return tk1.x >> dz === tk2.x && tk1.y >> dz === tk2.y;
	},

    rotatePoints: function(arr, angle, iconScale, center) {			// rotate - массива точек
        var out = [];
        angle *= Math.PI / 180.0;
        var sin = Math.sin(angle);
        var cos = Math.cos(angle);
        if (!iconScale) { iconScale = 1; }
        for (var i = 0; i < arr.length; i++) {
            var x = iconScale * arr[i].x - center.x;
            var y = iconScale * arr[i].y - center.y;
            out.push({
                'x': cos * x - sin * y + center.x,
                'y': sin * x + cos * y + center.y
            });
        }
        return out;
    },
    getPatternIcon: function(item, style, indexes) { // получить bitmap стиля pattern
        if (!style.fillPattern) { return null; }

        var notFunc = true,
            pattern = style.fillPattern,
            prop = item ? item.properties : null,
            step = pattern.step > 0 ? pattern.step : 0,
            patternDefaults = {
                minWidth: 1,
                maxWidth: 1000,
                minStep: 0,
                maxStep: 1000
            };
        if (pattern.patternStepFunction && prop !== null) {
            step = pattern.patternStepFunction(prop, indexes);
            notFunc = false;
        }
        if (step > patternDefaults.maxStep) {
            step = patternDefaults.maxStep;
        }
        else if (step < patternDefaults.minStep) {
            step = patternDefaults.minStep;
        }

        var size = pattern.width > 0 ? pattern.width : 8;
        if (pattern.patternWidthFunction && prop !== null) {
            size = pattern.patternWidthFunction(prop, indexes);
            notFunc = false;
        }
        if (size > patternDefaults.maxWidth) {
            size = patternDefaults.maxWidth;
        } else if (size < patternDefaults.minWidth) {
            size = patternDefaults.minWidth;
        }

        var op = style.fillOpacity;
        if (style.opacityFunction && prop !== null) {
            op = style.opacityFunction(prop, indexes) / 100;
            notFunc = false;
        }

        var rgb = [0xff0000, 0x00ff00, 0x0000ff],
            arr = (pattern.colors != null ? pattern.colors : rgb),
            count = arr.length,
            resColors = [],
            i = 0;

        for (i = 0; i < count; i++) {
            var col = arr[i];
            if (pattern.patternColorsFunction && pattern.patternColorsFunction[i] !== null) {
                col = (prop !== null ? pattern.patternColorsFunction[i](prop, indexes) : rgb[i % 3]);
                notFunc = false;
            }
            resColors.push(col);
        }
        if (count === 0) { resColors = [0]; op = 0; count = 1; }   // pattern without colors

        var delta = size + step,
            allSize = delta * count,
            center = 0,
            //radius,
            rad = 0,
            hh = allSize,				// высота битмапа
            ww = allSize,				// ширина битмапа
            type = pattern.style || 'horizontal',
            flagRotate = false;

        if (type === 'diagonal1' || type === 'diagonal2' || type === 'cross' || type === 'cross1') {
            flagRotate = true;
        } else if (type === 'circle') {
            ww = hh = 2 * delta;
            center = Math.floor(ww / 2);	// центр круга
            //radius = Math.floor(size / 2);	// радиус
            rad = 2 * Math.PI / count;		// угол в рад.
        } else if (type === 'vertical') {
            hh = 1;
        } else if (type === 'horizontal') {
            ww = 1;
        }
        if (ww * hh > patternDefaults.maxWidth) {
            console.log({'func': 'getPatternIcon', 'Error': 'MAX_PATTERN_SIZE', 'alert': 'Bitmap from pattern is too big'});
            return null;
        }

        var canvas = document.createElement('canvas');
        canvas.width = ww; canvas.height = hh;
        var ptx = canvas.getContext('2d');
        ptx.clearRect(0, 0, canvas.width, canvas.height);
        if (type === 'diagonal2' || type === 'vertical') {
            ptx.translate(ww, 0);
            ptx.rotate(Math.PI / 2);
        }

        for (i = 0; i < count; i++) {
            ptx.beginPath();
            var fillStyle = gmxAPIutils.dec2color(resColors[i], op);
            ptx.fillStyle = fillStyle;

            if (flagRotate) {
                var x1 = i * delta; var xx1 = x1 + size;
                ptx.moveTo(x1, 0); ptx.lineTo(xx1, 0); ptx.lineTo(0, xx1); ptx.lineTo(0, x1); ptx.lineTo(x1, 0);

                x1 += allSize; xx1 = x1 + size;
                ptx.moveTo(x1, 0); ptx.lineTo(xx1, 0); ptx.lineTo(0, xx1); ptx.lineTo(0, x1); ptx.lineTo(x1, 0);
                if (type === 'cross' || type === 'cross1') {
                    x1 = i * delta; xx1 = x1 + size;
                    ptx.moveTo(ww, x1); ptx.lineTo(ww, xx1); ptx.lineTo(ww - xx1, 0); ptx.lineTo(ww - x1, 0); ptx.lineTo(ww, x1);

                    x1 += allSize; xx1 = x1 + size;
                    ptx.moveTo(ww, x1); ptx.lineTo(ww, xx1); ptx.lineTo(ww - xx1, 0); ptx.lineTo(ww - x1, 0); ptx.lineTo(ww, x1);
                }
            } else if (type === 'circle') {
                ptx.arc(center, center, size, i * rad, (i + 1) * rad);
                ptx.lineTo(center, center);
            } else {
                ptx.fillRect(0, i * delta, ww, size);
            }
            ptx.closePath();
            ptx.fill();
        }
        var canvas1 = document.createElement('canvas');
        canvas1.width = ww;
        canvas1.height = hh;
        var ptx1 = canvas1.getContext('2d');
        ptx1.drawImage(canvas, 0, 0, ww, hh);
        return {'notFunc': notFunc, 'canvas': canvas1};
    },

    getSVGIcon: function (options) {
        var svg = '<svg xmlns="' + L.Path.SVG_NS + '" xmlns:xlink="http://www.w3.org/1999/xlink"',
            type = options.type,
            fill = options.fillStyle || 'rgba(255, 255, 255, 0.5)',
            stroke = options.strokeStyle || '#0000ff',
            strokeWidth = options.lineWidth || 2,
            iconOptions = {
                className: 'gmx-svg-icon'
            };

        if (options.className) {
            iconOptions.className = options.className;
        }
        var size = options.iconSize;
        iconOptions.iconSize = [size, size];
        svg += ' height = "' + size + 'px"  width = "' + size + 'px">';

        if (type === 'circle') {
            if (options.fillRadialGradient) {
                svg += '<defs><radialGradient id="myRadialGradient4" spreadMethod="pad">';
                var stopColor = options.fillRadialGradient.colorStop || options.fillRadialGradient.addColorStop
                    || [     // [%, color, opacity]
                        [0, '#ffff00', 0.8],
                        [1, '#ff0000', 0.8]
                    ];

                for (var i = 0, len = stopColor.length; i < len; i++) {
                    var it = stopColor[i];
                    svg += '<stop offset="' + (100 * it[0]) + '%"   stop-color="' + it[1] + '" stop-opacity="' + it[2] + '"/>';
                }
                svg += '</radialGradient></defs>';
                fill = 'url(#myRadialGradient4)';
                stroke = strokeWidth = null;
            }
            size /= 2;
            svg += '<g><circle cx="' + size + '" cy="' + size + '" r="' + size + '" style="';
            if (fill) { svg += ' fill:' + fill + ';'; }
            if (stroke) { svg += ' stroke:"' + stroke + ';'; }
            if (strokeWidth) { svg += ' stroke-width:"' + strokeWidth + ';'; }
            svg += ';" />';
        } else if (type === 'square') {
            svg += '<g><rect width="' + size + '" height="' + size + '" style="';
            if (fill) { svg += ' fill:' + fill + ';'; }
            if (stroke) { svg += ' stroke:' + stroke + ';'; }
            if (strokeWidth) { svg += ' stroke-width:' + 2 * strokeWidth + ';'; }
            svg += '" />';
        }
        if (options.text) {
            var text = options.text;
            svg += '<text x="50%" y="50%" dy="0.4em"';
            for (var key in text) {
                if (key !== 'count') { svg += ' ' + key + '="' + text[key] + '"'; }
            }
            svg += '>' + text.count + '</text>';
        }
        svg += '</g></svg>';
        iconOptions.html = svg;

        return new L.DivIcon(iconOptions);
    },

    toPixels: function(p, tpx, tpy, mInPixel) { // get pixel point
        var px1 = p[0] * mInPixel; 	px1 = (0.5 + px1) << 0;
        var py1 = p[1] * mInPixel;	py1 = (0.5 + py1) << 0;
        return [px1 - tpx, tpy - py1].concat(p.slice(2));
    },

    getPixelPoint: function(attr, coords) {
        var gmx = attr.gmx,
            mInPixel = gmx.mInPixel,
            item = attr.item,
            currentStyle = item.currentStyle || item.parsedStyleKeys || {},
            style = attr.style || {},
            iconScale = currentStyle.iconScale || 1,
            iconCenter = currentStyle.iconCenter || false,
            sx = currentStyle.sx || style.sx || 4,
            sy = currentStyle.sy || style.sy || 4,
            weight = currentStyle.weight || style.weight || 0,
            iconAnchor = currentStyle.iconAnchor || style.iconAnchor || null,
            px = attr.tpx,
            py = attr.tpy;

        if (!iconCenter && iconAnchor) {
            px1 -= iconAnchor[0];
            py1 -= iconAnchor[1];
        }
        sx *= iconScale;
        sy *= iconScale;
        sx += weight;
        sy += weight;

        var py1 = py - coords[1] * mInPixel,
			px1 = coords[0] * mInPixel - px;

		if (px1 - sx > 256) {
			px1 = (coords[0] - 2 * gmxAPIutils.worldWidthMerc) * mInPixel - px;
		} else if (px1 < -sx) {
			px1 = (coords[0] + 2 * gmxAPIutils.worldWidthMerc) * mInPixel - px;
		}

        return py1 - sy > 256 || px1 - sx > 256 || px1 + sx < 0 || py1 + sy < 0
			? null :
            {
                sx: sx,
                sy: sy,
                px1: (0.5 + px1) << 0,
                py1: (0.5 + py1) << 0
            }
        ;
    },
    getImageData: function(img) {
        if (L.gmxUtil.isIE9 || L.gmxUtil.isIE10) { return null; }
        var canvas = document.createElement('canvas'),
            ww = img.width,
            hh = img.height;

        canvas.width = ww; canvas.height = hh;
        var ptx = canvas.getContext('2d');
        ptx.drawImage(img, 0, 0);
        return ptx.getImageData(0, 0, ww, hh).data;
    },
    DEFAULT_REPLACEMENT_COLOR: 0xff00ff,
    isIE: function(v) {
        return v === gmxAPIutils.getIEversion();
    },
    gtIE: function(v) {
        return v < gmxAPIutils.getIEversion();
    },

    getIEversion: function() {
        var ua = navigator.userAgent || '',
            msie = ua.indexOf('MSIE ');
        if (msie > 0) {
            // IE 10 or older => return version number
            return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
        }

        var trident = ua.indexOf('Trident/');
        if (trident > 0) {
            // IE 11 => return version number
            var rv = ua.indexOf('rv:');
            return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
        }

        var edge = ua.indexOf('Edge/');
        if (edge > 0) {
            // Edge (IE 12+) => return version number
            return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
        }

        // other browser
        return -1;
    },

    replaceColor: function(img, color, fromData) {
        if (L.gmxUtil.isIE9 || L.gmxUtil.isIE10) { return img; }
        var canvas = document.createElement('canvas'),
            ww = img.width,
            hh = img.height;

        canvas.width = ww; canvas.height = hh;
        var flag = false,
            imageData,
            ptx = canvas.getContext('2d');

        if (typeof color === 'string') {
            color = parseInt('0x' + color.replace(/#/, ''));
        }
        if (color !== this.DEFAULT_REPLACEMENT_COLOR) {
            var r = (color >> 16) & 255,
                g = (color >> 8) & 255,
                b = color & 255;

            if (fromData) {
                imageData = ptx.createImageData(ww, hh);
            } else {
                ptx.drawImage(img, 0, 0);
                imageData = ptx.getImageData(0, 0, ww, hh);
                fromData = imageData.data;
            }
            var toData = imageData.data;
            for (var i = 0, len = fromData.length; i < len; i += 4) {
                if ((fromData[i] === 0xff || fromData[i] === 238)
                    && fromData[i + 1] === 0
                    && fromData[i + 2] === 0xff
                    ) {
                    toData[i] = r;
                    toData[i + 1] = g;
                    toData[i + 2] = b;
                    toData[i + 3] = fromData[i + 3];
                    flag = true;
                }
            }
        }
        if (flag) {
            ptx.putImageData(imageData, 0, 0);
        } else {
            ptx.drawImage(img, 0, 0);
        }
        return canvas;
    },

    drawIconPath: function(path, attr) { // draw iconPath in canvas
        if (!L.Util.isArray(path) || path.length < 3 || !attr.ctx) { return; }
        var trFlag = false,
            ctx = attr.ctx,
            rad = attr.radian;

        if (attr.px || attr.py) { ctx.translate(attr.px || 0, attr.py || 0); trFlag = true; }
        if (!rad && attr.rotateRes) { rad = Math.PI + gmxAPIutils.degRad(attr.rotateRes); }
        if (rad) { ctx.rotate(rad); trFlag = true; }
        ctx.moveTo(path[0], path[1]);
        for (var i = 2, len = path.length; i < len; i += 2) {
            ctx.lineTo(path[i], path[i + 1]);
        }
        if (trFlag) { ctx.setTransform(1, 0, 0, 1, 0, 0); }
    },

    pointToCanvas: function(attr) { // Точку в canvas
        var gmx = attr.gmx,
            pointAttr = attr.pointAttr,
            style = attr.style || {},
            item = attr.item,
            currentStyle = item.currentStyle || item.parsedStyleKeys,
            iconScale = currentStyle.iconScale || 1,
            image = currentStyle.image,
            sx = pointAttr.sx,
            sy = pointAttr.sy,
            px1 = pointAttr.px1,
            py1 = pointAttr.py1,
            px1sx = px1,
            py1sy = py1,
            ctx = attr.ctx;

        if (currentStyle.type === 'image') {
            sx = style.sx;
            sy = style.sy;
            image = style.image;
        }
        if (currentStyle.iconCenter) {
            px1sx -= sx / 2;
            py1sy -= sy / 2;
        } else if (style.type === 'circle') {
            px1 += sx / 2;
            py1 += sy / 2;
        }
        if (currentStyle.iconPath) {
            attr.px = px1;
            attr.py = py1;
            attr.rotateRes = currentStyle.rotate || 0;
        }
        if (image) {
            if ('iconColor' in currentStyle) {
                image = this.replaceColor(image, currentStyle.iconColor, attr.imageData);
            }
            style.rotateRes = currentStyle.rotate || 0;
            if ('opacity' in style) { ctx.globalAlpha = currentStyle.opacity || style.opacity; }
            if (gmx.transformFlag) {
                ctx.setTransform(gmx.mInPixel, 0, 0, gmx.mInPixel, -attr.tpx, attr.tpy);
                ctx.drawImage(image, px1, -py1, sx, sy);
                ctx.setTransform(gmx.mInPixel, 0, 0, -gmx.mInPixel, -attr.tpx, attr.tpy);
            } else {
				if (iconScale !== 1) {
					sx *= iconScale;
					sy *= iconScale;
					px1 = pointAttr.px1;
					py1 = pointAttr.py1;
					px1sx = px1;
					py1sy = py1;
					if (currentStyle.iconCenter) {
						px1sx -= sx / 2;
						py1sy -= sy / 2;
					}
				}
				if (style.rotateRes) {
					ctx.translate(px1, py1);
					ctx.rotate(gmxAPIutils.degRad(style.rotateRes));
					ctx.translate(-px1, -py1);
					ctx.drawImage(image, px1sx, py1sy, sx, sy);
					ctx.setTransform(1, 0, 0, 1, 0, 0);
				} else {
					ctx.drawImage(image, px1sx, py1sy, sx, sy);
				}
            }
            if ('opacity' in style) { ctx.globalAlpha = 1; }
        } else if (style.fillColor || currentStyle.fillRadialGradient) {
            ctx.beginPath();
            if (currentStyle.iconPath) {
                gmxAPIutils.drawIconPath(currentStyle.iconPath, attr);
            } else if (style.type === 'circle' || currentStyle.fillRadialGradient) {
                var circle = style.iconSize / 2;
                if (currentStyle.fillRadialGradient) {
                    var rgr = currentStyle.fillRadialGradient;
                    circle = rgr.r2 * iconScale;
                    var radgrad = ctx.createRadialGradient(px1 + rgr.x1, py1 + rgr.y1, rgr.r1 * iconScale, px1 + rgr.x2, py1 + rgr.y2, circle);
                    for (var i = 0, len = rgr.addColorStop.length; i < len; i++) {
                        var arr = rgr.addColorStop[i];
                        radgrad.addColorStop(arr[0], arr[1]);
                    }
                    ctx.fillStyle = radgrad;
                }
                ctx.arc(px1, py1, circle, 0, 2 * Math.PI);
            } else {
                ctx.fillRect(px1sx, py1sy, sx, sy);
            }
            ctx.fill();
        }
        if (currentStyle.strokeStyle) {
            ctx.beginPath();
            if (currentStyle.iconPath) {
                gmxAPIutils.drawIconPath(currentStyle.iconPath, attr);
            } else if (style.type === 'circle') {
                ctx.arc(px1, py1, style.iconSize / 2, 0, 2 * Math.PI);
            } else {
                ctx.strokeRect(px1sx, py1sy, sx, sy);
            }
            ctx.stroke();
        }
    },
    lineToCanvasAsIcon: function(pixels, attr) {  // add line(as icon) to canvas
        var len = pixels.length,
            ctx = attr.ctx,
            item = attr.item,
            currentStyle = item.currentStyle || item.parsedStyleKeys,
            iconPath = currentStyle.iconPath;

        if (len > 0) {
            if ('getLineDash' in ctx && ctx.getLineDash().length > 0) {
                ctx.setLineDash([]);
            }
            ctx.beginPath();
            for (var i = 0, p; i < len; i++) {
                p = pixels[i];
                gmxAPIutils.drawIconPath(iconPath, {ctx: ctx, px: p.x, py: p.y, radian: p.radian});
            }
            if (currentStyle.strokeStyle) {
                ctx.stroke();
            }
            if (currentStyle.fillStyle) {
                ctx.fill();
            }
        }
    },
    lineToCanvas: function(attr) {  // Lines in canvas
        var gmx = attr.gmx,
            coords = attr.coords,
            ctx = attr.ctx,
            item = attr.item,
            currentStyle = item.currentStyle || item.parsedStyleKeys,
            pixels = currentStyle.iconPath ? [] : null;

        var lastX = null, lastY = null;
        ctx.beginPath();
        for (var i = 0, len = coords.length; i < len; i++) {
            var p = gmxAPIutils.toPixels(coords[i], attr.tpx, attr.tpy, gmx.mInPixel),
                x = p[0],
                y = p[1];
            if (lastX !== x || lastY !== y) {
                if (pixels) { pixels.push({x: x, y: y, radian: p[2]}); }
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                lastX = x; lastY = y;
            }
        }
        ctx.stroke();
        return pixels;
    },

    getCoordsPixels: function(attr) {
        var gmx = attr.gmx,
            coords = attr.coords,
            hiddenLines = attr.hiddenLines || [],
            pixels = [],
            hidden = [],
            hiddenFlag = false,
            hash = {
                gmx: gmx,
                tpx: attr.tpx,
                tpy: attr.tpy,
                coords: null,
                hiddenLines: null
            };
        for (var j = 0, len = coords.length; j < len; j++) {
            var coords1 = coords[j],
                hiddenLines1 = hiddenLines[j] || [],
                pixels1 = [], hidden1 = [];
            for (var j1 = 0, len1 = coords1.length; j1 < len1; j1++) {
                hash.coords = coords1[j1];
                hash.hiddenLines = hiddenLines1[j1] || [];
                var res = gmxAPIutils.getRingPixels(hash);
                pixels1.push(res.coords);
                hidden1.push(res.hidden);
                if (res.hidden) {
                    hiddenFlag = true;
                }
            }
            pixels.push(pixels1);
            hidden.push(hidden1);
        }
        return {coords: pixels, hidden: hiddenFlag ? hidden : null, z: gmx.currentZoom};
    },

    getRingPixels: function(attr) {
        if (attr.coords.length === 0) { return null; }
        var gmx = attr.gmx,
            mInPixel = gmx.mInPixel,
            coords = attr.coords,
            hiddenLines = attr.hiddenLines || null,
            px = attr.tpx,
            py = attr.tpy,
            cnt = 0, cntHide = 0,
            lastX = null, lastY = null,
            vectorSize = typeof coords[0] === 'number' ? 2 : 1,
            pixels = [], hidden = [];
        for (var i = 0, len = coords.length; i < len; i += vectorSize) {
            var lineIsOnEdge = false;
            if (hiddenLines && i === hiddenLines[cntHide]) {
                lineIsOnEdge = true;
                cntHide++;
            }
            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],
                x1 = c[0] * mInPixel, y1 = c[1] * mInPixel,
                x2 = Math.round(x1 - px), y2 = Math.round(py - y1);

            if (lastX !== x2 || lastY !== y2) {
                lastX = x2; lastY = y2;
                if (lineIsOnEdge) {
                    hidden.push(cnt);
                }
                pixels[cnt++] = x1;
                pixels[cnt++] = y1;
            }
        }
        return {coords: pixels, hidden: hidden.length ? hidden : null};
    },

    polygonToCanvas: function(attr) {       // Polygons in canvas
        if (attr.coords.length === 0) { return null; }
        var hiddenLines = attr.hiddenLines || null,
            coords = attr.coords,
            ctx = attr.ctx,
            px = attr.tpx,
            py = attr.tpy,
            cnt = 0, cntHide = 0,
            vectorSize = typeof coords[0] === 'number' ? 2 : 1,
            lastX = null, lastY = null;

        ctx.beginPath();
        for (var i = 0, len = coords.length; i < len; i += vectorSize) {
            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],
                x = Math.round(c[0] - px),
                y = Math.round(py - c[1]),
                lineIsOnEdge = false,
				lineCap = 'round';

            if (hiddenLines && i === hiddenLines[cntHide]) {
                lineIsOnEdge = true;
				lineCap = 'butt';
                cntHide++;
            }
			if (ctx.lineCap !== lineCap) { ctx.lineCap = lineCap; }

            if (lastX !== x || lastY !== y) {
                ctx[(lineIsOnEdge ? 'moveTo' : 'lineTo')](x, y);
                lastX = x; lastY = y;
                cnt++;
            }
        }
        if (cnt === 1) { ctx.lineTo(lastX + 1, lastY); }
        ctx.stroke();
    },

    polygonToCanvasFill: function(attr) {     // Polygon fill
        if (attr.coords.length < 3) { return; }
        var coords = attr.coords,
            px = attr.tpx,
            py = attr.tpy,
            vectorSize = 1,
            ctx = attr.ctx;

        ctx.lineWidth = 0;
        if (typeof coords[0] === 'number') {
            vectorSize = 2;
            ctx.moveTo(Math.round(coords[0] - px), Math.round(py - coords[1]));
        } else {
            ctx.moveTo(Math.round(coords[0][0] - px), Math.round(py - coords[0][1]));
        }
        for (var i = vectorSize, len = coords.length; i < len; i += vectorSize) {
            var c = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]];
            ctx.lineTo(Math.round(c[0] - px), Math.round(py - c[1]));
        }
    },

    isPatternNode: function(it) {
        return it instanceof HTMLCanvasElement || it instanceof HTMLImageElement;
    },
    labelCanvasContext: null,    // 2dContext canvas for Label size
    getLabelWidth: function(txt, style) {   // Get label size Label
        if (style) {
            if (!gmxAPIutils.labelCanvasContext) {
                var canvas = document.createElement('canvas');
                canvas.width = canvas.height = 512;
                gmxAPIutils.labelCanvasContext = canvas.getContext('2d');
            }
            var ptx = gmxAPIutils.labelCanvasContext;
            ptx.clearRect(0, 0, 512, 512);

            if (ptx.font !== style.font) { ptx.font = style.font; }
            //if (ptx.strokeStyle !== style.strokeStyle) { ptx.strokeStyle = style.strokeStyle; }
            if (ptx.fillStyle !== style.fillStyle) { ptx.fillStyle = style.fillStyle; }
			var arr = txt.split('\n');
            return arr.map(function(it) {
				ptx.fillText(it, 0, 0);
				return [it, ptx.measureText(it).width];
			});
        }
        return 0;
    },
    setLabel: function(ctx, txt, coord, style) {
        var x = coord[0],
            y = coord[1];

        if (ctx.shadowColor !== style.strokeStyle) { ctx.shadowColor = style.strokeStyle; }
        if (ctx.shadowBlur !== style.shadowBlur) { ctx.shadowBlur = style.shadowBlur; }
        if (ctx.font !== style.font) { ctx.font = style.font; }
		if (L.Browser.gecko) {	// Bug with perfomance in FireFox
			if (ctx.strokeStyle !== style.fillStyle) { ctx.strokeStyle = style.fillStyle; }
		} else {
			if (ctx.strokeStyle !== style.strokeStyle) { ctx.strokeStyle = style.strokeStyle; }
			if (ctx.fillStyle !== style.fillStyle) { ctx.fillStyle = style.fillStyle; }
		}
        ctx.strokeText(txt, x, y);
		if (!L.Browser.gecko) {
			ctx.fillText(txt, x, y);
		}
    },
    worldWidthMerc: 20037508,
    rMajor: 6378137.000,
    degRad: function(ang) {
        return ang * (Math.PI / 180.0);
    },

    distVincenty: function(lon1, lat1, lon2, lat2) {
        var p1 = {
            lon: gmxAPIutils.degRad(lon1),
            lat: gmxAPIutils.degRad(lat1)
        },
            p2 = {
            lon: gmxAPIutils.degRad(lon2),
            lat: gmxAPIutils.degRad(lat2)
        },
            a = gmxAPIutils.rMajor,
            b = 6356752.3142,
            f = 1 / 298.257223563;  // WGS-84 ellipsiod

        var L1 = p2.lon - p1.lon,
            U1 = Math.atan((1 - f) * Math.tan(p1.lat)),
            U2 = Math.atan((1 - f) * Math.tan(p2.lat)),
            sinU1 = Math.sin(U1), cosU1 = Math.cos(U1),
            sinU2 = Math.sin(U2), cosU2 = Math.cos(U2),
            lambda = L1,
            lambdaP = 2 * Math.PI,
            iterLimit = 20;
        while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0) {
                var sinLambda = Math.sin(lambda), cosLambda = Math.cos(lambda),
                    sinSigma = Math.sqrt((cosU2 * sinLambda) * (cosU2 * sinLambda) +
                    (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
                if (sinSigma === 0) { return 0; }
                var cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda,
                    sigma = Math.atan2(sinSigma, cosSigma),
                    sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma,
                    cosSqAlpha = 1 - sinAlpha * sinAlpha,
                    cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;
                if (isNaN(cos2SigmaM)) { cos2SigmaM = 0; }
                var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));
                lambdaP = lambda;
                lambda = L1 + (1 - C) * f * sinAlpha *
                    (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
        }
        if (iterLimit === 0) { return NaN; }

        var uSq = cosSqAlpha * ((a * a) / (b * b) - 1),
        //var uSq = cosSqAlpha * (a * a - b * b) / (b*b),
            A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq))),
            B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq))),
            deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) -
                B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM))),
            s = b * A * (sigma - deltaSigma);

        //s = s.toFixed(3);
        return s;
    },

    _vfi: function(fi, a, b) {
        return [
            -Math.cos(fi) * Math.sin(a) + Math.sin(fi) * Math.sin(b) * Math.cos(a),
            Math.cos(fi) * Math.cos(a) + Math.sin(fi) * Math.sin(b) * Math.sin(a),
            -Math.sin(fi) * Math.cos(b)
        ];
    },

    getCircleLatLngs: function(latlng, r) {   // Get latlngs for circle
        var x = 0, y = 0;
        if (latlng instanceof L.LatLng) {
            x = latlng.lng;
            y = latlng.lat;
        } else if (L.Util.isArray(latlng)) {
            x = latlng[1];
            y = latlng[0];
        } else {
            return null;
        }

        var rad = Math.PI / 180,
            a = x * rad,  //долгота центра окружности в радианах
            b = y * rad,  //широта центра окружности в радианах
            R = gmxAPIutils.rMajor,
            d = R * Math.sin(r / R),
            Rd = R * Math.cos(r / R),
            VR = [
                Rd * Math.cos(b) * Math.cos(a),
                Rd * Math.cos(b) * Math.sin(a),
                Rd * Math.sin(b)
            ],
            latlngs = [];

        for (var fi = 0, limit = 2 * Math.PI + 0.000001; fi < limit; fi += rad) {
            var v = gmxAPIutils._vfi(fi, a, b),
                circle = [];
            for (var i = 0; i < 3; i++) { circle[i] = VR[i] + d * v[i]; }

            var t2 = Math.acos(circle[0] / Math.sqrt(circle[0] * circle[0] + circle[1] * circle[1])) / rad;
            if (circle[1] < 0) { t2 = -t2; }

            if (t2 < x - 180) {
                t2 += 360;
            } else if (t2 > x + 180) {
                t2 -= 360;
            }
            latlngs.push([Math.asin(circle[2] / R) / rad, t2]);
        }
        return latlngs;
    },

    /** Get point coordinates from string
     * @memberof L.gmxUtil
     * @param {String} text - point coordinates in following formats:
         <br/><i>55.74312, 37.61558</i>
         <br/><i>55°44'35" N, 37°36'56" E</i>
         <br/><i>4187347, 7472103</i>
         <br/><i>4219783, 7407468 (EPSG:3395)</i>
         <br/><i>4219783, 7442673 (EPSG:3857)</i>
     * @return {Array} [lat, lng] or null
    */
    parseCoordinates: function(text) {
        var crs = null,
            regex = /\(EPSG:(\d+)\)/g,
            t = regex.exec(text);

        if (t) {
            crs = t[1];
            text = text.replace(regex, '');
        }

        if (text.match(/[йцукенгшщзхъфывапролджэячсмитьбюЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮqrtyuiopadfghjklzxcvbmQRTYUIOPADFGHJKLZXCVBM_:]/)) {
            return null;
        }

        //there should be a separator in the string (exclude strings like "11E11")
        if (text.indexOf(' ') === -1 && text.indexOf(',') === -1) {
            return null;
        }

        if (text.indexOf(' ') !== -1) {
            text = text.replace(/,/g, '.');
        }
        var results = [];
        regex = /(-?\d+(\.\d+)?)([^\d\-]*)/g;
        t = regex.exec(text);
        while (t) {
            results.push(t[1]);
            t = regex.exec(text);
        }
        if (results.length < 2) {
            return null;
        }
        var ii = Math.floor(results.length / 2),
            y = 0,
            mul = 1,
            i;
        for (i = 0; i < ii; i++) {
            y += parseFloat(results[i]) * mul;
            mul /= 60;
        }
        var x = 0;
        mul = 1;
        for (i = ii; i < results.length; i++) {
            x += parseFloat(results[i]) * mul;
            mul /= 60;
        }

        if (Math.max(text.indexOf('N'), text.indexOf('S')) > Math.max(text.indexOf('E'), text.indexOf('W'))) {
            t = x;
            x = y;
            y = t;
        }

        var pos;
        if (crs === '3857') {
            pos = L.Projection.SphericalMercator.unproject(new L.Point(y, x)._divideBy(gmxAPIutils.rMajor));
            x = pos.lng;
            y = pos.lat;
        }
        if (Math.abs(x) > 180 || Math.abs(y) > 180) {
            pos = L.Projection.Mercator.unproject(new L.Point(y, x));
            x = pos.lng;
            y = pos.lat;
        }

        if (text.indexOf('W') !== -1) {
            x = -x;
        }

        if (text.indexOf('S') !== -1) {
            y = -y;
        }
        return [y, x];
    },

	pad2: function(t) {
		return (t >= 0 && t < 10) ? ('0' + t) : ('' + t);
	},

	trunc: function(x) {
		return ('' + (Math.round(10000000 * x) / 10000000 + 0.00000001)).substring(0, 9);
	},

	formatDegrees: function(angle, format) {
		angle = Math.round(10000000 * angle) / 10000000 + 0.00000001;
		var a1 = Math.floor(angle),
			a2 = Math.floor(60 * (angle - a1)),
			a3 = gmxAPIutils.toPrecision(3600 * (angle - a1 - a2 / 60), 2),
			st = gmxAPIutils.pad2(a1) + '°';

		if (format ===  undefined ) { format = 2; }
		if (format > 0) {
			st += gmxAPIutils.pad2(a2) + '\'';
		}
		if (format > 1) {
			st += gmxAPIutils.pad2(a3) + '"';
		}
		return st;
	},

    /** Get point coordinates in string format with degrees
     * @memberof L.gmxUtil
     * @param {Number} lng - point longitude
     * @param {Number} lat - point latitude
     * @return {String} point coordinates in string format with degrees
    */
	latLonFormatCoordinates: function(x, y) {
        x %= 360;
        if (x > 180) { x -= 360; }
        else if (x < -180) { x += 360; }
		return  gmxAPIutils.formatDegrees(Math.abs(y)) + (y > 0 ? ' N, ' : ' S, ') +
			gmxAPIutils.formatDegrees(Math.abs(x)) + (x > 0 ? ' E' : ' W');
	},

	formatCoordinates: function(x, y) {
		return  gmxAPIutils.latLonFormatCoordinates(x, y);
	},

    /** Get point coordinates in string format
     * @memberof L.gmxUtil
     * @param {Number} lng - point longitude
     * @param {Number} lat - point latitude
     * @return {String} point coordinates in string format
    */
	latLonFormatCoordinates2: function(x, y) {
		return  gmxAPIutils.trunc(Math.abs(y)) + (y > 0 ? ' N, ' : ' S, ') +
			gmxAPIutils.trunc(Math.abs(x)) + (x > 0 ? ' E' : ' W');
	},
	formatCoordinates2: function(x, y) {
		return  gmxAPIutils.latLonFormatCoordinates2(x, y);
	},

    getPixelScale: function(zoom) {
        return 256 / gmxAPIutils.tileSizes[zoom];
    },

    forEachPoint: function(coords, callback) {
        if (!coords || coords.length === 0) { return []; }
        var i, len, ret = [];
        if (!coords[0].length) {
            if (coords.length === 2) {
                return callback(coords);
            } else {
                for (i = 0, len = coords.length / 2; i < len; i++) {
                    ret.push(callback([coords[i * 2], coords[i * 2 + 1]]));
                }
            }
        } else {
            for (i = 0, len = coords.length; i < len; i++) {
                if (typeof coords[i] !== 'string') {
                    ret.push(gmxAPIutils.forEachPoint(coords[i], callback));
                }
            }
        }
        return ret;
    },
/*
	getQuicklookPoints: function(coord) { // получить 4 точки привязки снимка
		var d1 = Number.MAX_VALUE;
		var d2 = Number.MAX_VALUE;
		var d3 = Number.MAX_VALUE;
		var d4 = Number.MAX_VALUE;
		var x1, y1, x2, y2, x3, y3, x4, y4;
		this.forEachPoint(coord, function(p) {
			var x = p[0];
			var y = p[1];
			if ((x - y) < d1) {
				d1 = x - y;
				x1 = p[0];
				y1 = p[1];
			}
			if ((-x - y) < d2) {
				d2 = -x - y;
				x2 = p[0];
				y2 = p[1];
			}
			if ((-x + y) < d3) {
				d3 = -x + y;
				x3 = p[0];
				y3 = p[1];
			}
			if ((x + y) < d4) {
				d4 = x + y;
				x4 = p[0];
				y4 = p[1];
			}
		});
		return {x1: x1, y1: y1, x2: x2, y2: y2, x3: x3, y3: y3, x4: x4, y4: y4};
	},
*/
    getItemCenter: function(item, geoItems) {
        var bounds = item.bounds,
            min = bounds.min, max = bounds.max,
            type = item.type,
            isPoint = type === 'POINT' || type === 'MULTIPOINT',
            center = isPoint ? [min.x, min.y] : [(min.x + max.x) / 2, (min.y + max.y) / 2];

        if (type === 'MULTIPOLYGON') {
			return center;
		} else if (type === 'POLYGON') {
            for (var i = 0, len = geoItems.length; i < len; i++) {
                var it = geoItems[i],
                    geom = it.geo,
                    coords = geom.coordinates,
                    dataOption = it.dataOption,
                    bbox = dataOption.bounds;

                if (bbox.contains(center)) {
                    if (geom.type === 'POLYGON') { coords = [coords]; }
                    for (var j = 0, len1 = coords.length; j < len1; j++) {
                        for (var j1 = 0, coords1 = coords[j], len2 = coords1.length; j1 < len2; j1++) {
                            var pt = gmxAPIutils.getHSegmentsInPolygon(center[1], coords1[j1]);
                            if (pt) {
                                return pt.max.center;
                            }
                        }
                    }
                }
            }
        } else if (type === 'POINT' || type === 'MULTIPOINT') {
            return center;
        } else if (type === 'LINESTRING' || type === 'MULTILINESTRING') {
            return center;
        }
        return null;
    },

    getHSegmentsInPolygon: function(y, poly) {
        var s = [], i, len, out,
            vectorSize = 1,
            p1 = poly[0];

        if (typeof poly[0] === 'number') {
            vectorSize = 2;
            p1 = [poly[0], poly[1]];
        }
        var isGt1 = y > p1[1];
        for (i = vectorSize, len = poly.length; i < len; i += vectorSize) {
            var p2 = vectorSize === 1 ? poly[i] : [poly[i], poly[i + 1]],
                isGt2 = y > p2[1];
            if (isGt1 !== isGt2) {
                s.push(p1[0] - (p1[0] - p2[0]) * (p1[1] - y) / (p1[1] - p2[1]));
            }
            p1 = p2;
            isGt1 = isGt2;
        }
        len = s.length;
        if (len) {
            s = s.sort();
            var max = 0,
                index = -1;
            for (i = 1; i < len; i += 2) {
                var j = i - 1,
                    d = Math.abs(s[i] - s[j]);
                if (d > max) {
                    max = d;
                    index = j;
                }
            }
            out = {
                y: y,
                segArr: s,
                max: {
                    width: max,
                    center: [(s[index] + s[index + 1]) / 2, y]
                }
            };
        }
        return out;
    },

    isPointInPolygonArr: function(chkPoint, coords) { // Проверка точки на принадлежность полигону в виде массива
        var isIn = false,
            x = chkPoint[0],
            y = chkPoint[1],
            vectorSize = 1,
            p1 = coords[0];

        if (typeof coords[0] === 'number') {
            vectorSize = 2;
            p1 = [coords[0], coords[1]];
        }

        for (var i = vectorSize, len = coords.length; i < len; i += vectorSize) {
            var p2 = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]],
                xmin = Math.min(p1[0], p2[0]),
                xmax = Math.max(p1[0], p2[0]),
                ymax = Math.max(p1[1], p2[1]);
            if (x > xmin && x <= xmax && y <= ymax && p1[0] !== p2[0]) {
                var xinters = (x - p1[0]) * (p2[1] - p1[1]) / (p2[0] - p1[0]) + p1[1];
                if (p1[1] === p2[1] || y <= xinters) { isIn = !isIn; }
            }
            p1 = p2;
        }
        return isIn;
    },

    /** Is point in polygon with holes
     * @memberof L.gmxUtil
     * @param {chkPoint} chkPoint - point in [x, y] format
     * @param {coords} coords - polygon from geoJSON coordinates data format
     * @return {Boolean} true if polygon contain chkPoint
    */
    isPointInPolygonWithHoles: function(chkPoint, coords) {
        if (!gmxAPIutils.isPointInPolygonArr(chkPoint, coords[0])) { return false; }
        for (var j = 1, len = coords.length; j < len; j++) {
            if (gmxAPIutils.isPointInPolygonArr(chkPoint, coords[j])) { return false; }
        }
        return true;
    },

    /** Is polygon clockwise
     * @memberof L.gmxUtil
     * @param {ring} ring - ring from geoJSON coordinates data format
     * @return {Boolean} true if ring is clockwise
    */
    isClockwise: function(ring) {
        var area = 0;
        for (var i = 0, j, len = ring.length; i < len; i++) {
            j = (i + 1) % len;
            area += ring[i][0] * ring[j][1];
            area -= ring[j][0] * ring[i][1];
        }
        return (area < 0);
    },

    isPointInPolyLine: function(chkPoint, lineHeight, coords, hiddenLines) {
        // Проверка точки(с учетом размеров) на принадлежность линии
        var dx = chkPoint[0], dy = chkPoint[1],
            nullPoint = {x: dx, y: dy},
            minx = dx - lineHeight, maxx = dx + lineHeight,
            miny = dy - lineHeight, maxy = dy + lineHeight,
            cntHide = 0;

        lineHeight *= lineHeight;
        for (var i = 1, len = coords.length; i < len; i++) {
            if (hiddenLines && i === hiddenLines[cntHide]) {
                cntHide++;
            } else {
                var p1 = coords[i - 1], p2 = coords[i],
                    x1 = p1[0], y1 = p1[1],
                    x2 = p2[0], y2 = p2[1];

                if (!(Math.max(x1, x2) < minx
                    || Math.min(x1, x2) > maxx
                    || Math.max(y1, y2) < miny
                    || Math.min(y1, y2) > maxy)) {
                    var sqDist = L.LineUtil._sqClosestPointOnSegment(nullPoint, {x: x1, y: y1}, {x: x2, y: y2}, true);
                    if (sqDist < lineHeight) {
                        return true;
                    }
                }
            }
        }
        return false;
    },

    isPointInLines: function (attr) {
        var arr = attr.coords,
            point = attr.point,
            delta = attr.delta,
            boundsArr = attr.boundsArr,
            hidden = attr.hidden;
        for (var j = 0, len = arr.length, flag = false; j < len; j++) {
            flag = boundsArr[j] ? boundsArr[j].contains(point) : true;
            if (flag
                && gmxAPIutils.isPointInPolyLine(point, delta, arr[j], hidden ? hidden[j] : null)
            ) {
               return true;
            }
        }
        return false;
    },

    /** Get length
     * @memberof L.gmxUtil
     * @param {Array} latlngs array
     * @param {Boolean} isMerc - true if coordinates in Mercator
     * @param {Boolean} isWebMerc - true if coordinates in WebMercator	- TODO
     * @return {Number} length
    */
    getLength: function(latlngs, isMerc) {
        var length = 0;
        if (latlngs && latlngs.length) {
            var lng = false,
                lat = false;

            isMerc = isMerc === undefined || isMerc;
            latlngs.forEach(function(latlng) {
                if (L.Util.isArray(latlng)) {
                    if (L.Util.isArray(latlng[0])) {
                        length += gmxAPIutils.getLength(latlng, isMerc);
                        return length;
                    } else if (isMerc) {   // From Mercator array
                        latlng = L.Projection.Mercator.unproject({x: latlng[0], y: latlng[1]});
                    }
                }
                if (lng !== false && lat !== false) {
                    length += parseFloat(gmxAPIutils.distVincenty(lng, lat, latlng.lng, latlng.lat));
                }
                lng = latlng.lng;
                lat = latlng.lat;
            });
        }
        return length;
    },

    /** Get prettify length
     * @memberof L.gmxUtil
     * @param {Number} area
     * @param {String} type: ('km', 'm', 'nm')
     * @return {String} prettify length
    */
    prettifyDistance: function(length, type) {
        var km = ' ' + L.gmxLocale.getText('units.km');
        if (type === 'nm') {
            return (Math.round(0.539956803 * length) / 1000) + ' ' + L.gmxLocale.getText('units.nm');
        } else if (type === 'km') {
            return (Math.round(length) / 1000) + km;
        } else if (length < 2000 || type === 'm') {
            return Math.round(length) + ' ' + L.gmxLocale.getText('units.m');
        } else if (length < 200000) {
            return (Math.round(length / 10) / 100) + km;
        }
        return Math.round(length / 1000) + km;
    },

    /** Get geoJSON length
     * @memberof L.gmxUtil
     * @param {Object} geoJSON - object in <a href="http://geojson.org/geojson-spec.html">GeoJSON format</a>
     * @return {Number} length
    */
    geoJSONGetLength: function(geoJSON) {
        var out = 0,
            i, j, len, len1, coords;

        if (geoJSON.type === 'GeometryCollection') {
            out += geoJSON.geometries.forEach(gmxAPIutils.geoJSONGetLength);
        } else if (geoJSON.type === 'Feature') {
            out += gmxAPIutils.geoJSONGetLength(geoJSON.geometry);
        } else if (geoJSON.type === 'FeatureCollection') {
            out += geoJSON.features.forEach(gmxAPIutils.geoJSONGetLength);
        } if (geoJSON.type === 'LineString' || geoJSON.type === 'MultiLineString') {
            coords = geoJSON.coordinates;
            if (geoJSON.type === 'LineString') { coords = [coords]; }
            for (i = 0, len = coords.length; i < len; i++) {
                out += gmxAPIutils.getRingLength(coords[i]);
            }
        } if (geoJSON.type === 'Polygon' || geoJSON.type === 'MultiPolygon') {
            coords = geoJSON.coordinates;
            if (geoJSON.type === 'Polygon') { coords = [coords]; }
            for (i = 0, len = coords.length; i < len; i++) {
                for (j = 0, len1 = coords[i].length; j < len1; j++) {
                    out += gmxAPIutils.getRingLength(coords[i][j]);
                }
            }
        }
        return out;
    },

    getRingLength: function(coords) {
        var length = 0;
        if (coords && coords.length) {
            var lng = false, lat = false;
            coords.forEach(function(lnglat) {
                if (L.Util.isArray(lnglat)) {
                    if (lnglat.length > 2) {
                        length += gmxAPIutils.getRingLength(lnglat);
                        return length;
                    }
                }
                if (lng !== false && lat !== false) {
                    length += parseFloat(gmxAPIutils.distVincenty(lng, lat, lnglat[0], lnglat[1]));
                }
                lng = lnglat[0];
                lat = lnglat[1];
            });
        }
        return length;
    },

    /** Get geoJSON area
     * @memberof L.gmxUtil
     * @param {Object} geojson - object in <a href="http://geojson.org/geojson-spec.html">GeoJSON format</a>
     * @return {Number} area in square meters
    */
    geoJSONGetArea: function(geoJSON) {
        var out = 0;

        if (geoJSON.type === 'GeometryCollection') {
            out += geoJSON.geometries.forEach(gmxAPIutils.geoJSONGetArea);
        } else if (geoJSON.type === 'Feature') {
            out += gmxAPIutils.geoJSONGetArea(geoJSON.geometry);
        } else if (geoJSON.type === 'FeatureCollection') {
            out += geoJSON.features.forEach(gmxAPIutils.geoJSONGetArea);
        } if (geoJSON.type === 'Polygon' || geoJSON.type === 'MultiPolygon') {
            var coords = geoJSON.coordinates;
            if (geoJSON.type === 'Polygon') { coords = [coords]; }
            for (var i = 0, len = coords.length; i < len; i++) {
                out += gmxAPIutils.getRingArea(coords[i][0]);
                for (var j = 1, len1 = coords[i].length; j < len1; j++) {
                    out -= gmxAPIutils.getRingArea(coords[i][j]);
                }
            }
        }
        return out;
    },

    geoJSONGetLatLng: function(geoJSON) {
        if (geoJSON.type === 'Feature') {
            return gmxAPIutils.geoJSONGetLatLng(geoJSON.geometry);
        } else if (geoJSON.type === 'Point') {
            return L.latLng(geoJSON.coordinates[1], geoJSON.coordinates[0]);
        } else {
            throw new Error('cannot get ' + geoJSON.type + ' latLng');
        }
    },

    getRingArea: function(coords) {
        var area = 0;
        for (var i = 0, len = coords.length; i < len; i++) {
            var ipp = (i === (len - 1) ? 0 : i + 1),
                p1 = coords[i], p2 = coords[ipp];
            area += p1[0] * Math.sin(gmxAPIutils.degRad(p2[1])) - p2[0] * Math.sin(gmxAPIutils.degRad(p1[1]));
        }
        var out = Math.abs(area * gmxAPIutils.lambertCoefX * gmxAPIutils.lambertCoefY / 2);
        return out;
    },

    /** Get area
     * @memberof L.gmxUtil
     * @param {Array} L.latLng array
     * @return {Number} area in square meters
    */
    getArea: function(arr) {
        var area = 0;
        for (var i = 0, len = arr.length; i < len; i++) {
            var ipp = (i === (len - 1) ? 0 : i + 1),
                p1 = arr[i], p2 = arr[ipp];
            area += p1.lng * Math.sin(gmxAPIutils.degRad(p2.lat)) - p2.lng * Math.sin(gmxAPIutils.degRad(p1.lat));
        }
        return Math.abs(area * gmxAPIutils.lambertCoefX * gmxAPIutils.lambertCoefY / 2);
    },

    /** Get prettified size of area
     * @memberof L.gmxUtil
     * @param {Number} area in square meters
     * @param {String} type: ('km2', 'ha', 'm2')
     * @return {String} prettified area
    */
    prettifyArea: function(area, type) {
        var km2 = ' ' + L.gmxLocale.getText('units.km2');

        if (type === 'km2') {
            return ('' + (Math.round(area / 100) / 10000)) + km2;
        } else if (type === 'ha') {
            return ('' + (Math.round(area / 100) / 100)) + ' ' + L.gmxLocale.getText('units.ha');
        } else if (area < 100000 || type === 'm2') {
            return Math.round(area) + ' ' + L.gmxLocale.getText('units.m2');
        } else if (area < 3000000) {
            return ('' + (Math.round(area / 1000) / 1000)).replace('.', ',') + km2;
        } else if (area < 30000000) {
            return ('' + (Math.round(area / 10000) / 100)).replace('.', ',') + km2;
        } else if (area < 300000000) {
            return ('' + (Math.round(area / 100000) / 10)).replace('.', ',') + km2;
        }
        return (Math.round(area / 1000000)) + km2;
    },

    geoLength: function(geom) {
        var ret = 0,
            type = geom.type;
        if (type === 'MULTILINESTRING' || type === 'MultiLineString') {
            for (var i = 0, len = geom.coordinates.length; i < len; i++) {
                ret += gmxAPIutils.geoLength({type: 'LINESTRING', coordinates: geom.coordinates[i]});
            }
            return ret;
        } else if (type === 'LINESTRING' || type === 'LineString') {
            ret = gmxAPIutils.getLength(geom.coordinates);
        }
        return ret;
    },

    /** Converts Geomixer geometry to geoJSON geometry
     * @memberof L.gmxUtil
     * @param {Object} geometry - Geomixer geometry
     * @param {Boolean} mercFlag - true if coordinates in Mercator
     * @param {Boolean} webmercFlag - true if coordinates in WebMercator
     * @return {Object} geoJSON geometry
    */
    geometryToGeoJSON: function (geom, mercFlag, webmercFlag) {
        if (!geom) {
            return null;
        }

        var type = geom.type === 'MULTIPOLYGON' ? 'MultiPolygon'
                : geom.type === 'POLYGON' ? 'Polygon'
                : geom.type === 'MULTILINESTRING' ? 'MultiLineString'
                : geom.type === 'LINESTRING' ? 'LineString'
                : geom.type === 'MULTIPOINT' ? 'MultiPoint'
                : geom.type === 'POINT' ? 'Point'
                : geom.type,
            coords = geom.coordinates;
        if (mercFlag) {
            coords = gmxAPIutils.coordsFromMercator(type, coords, webmercFlag);
        }
        return {
            type: type,
            coordinates: coords
        };
    },

    convertGeometry: function (geom, fromMerc, webmercFlag) {
        var type = geom.type === 'MULTIPOLYGON' ? 'MultiPolygon'
                : geom.type === 'POLYGON' ? 'Polygon'
                : geom.type === 'MULTILINESTRING' ? 'MultiLineString'
                : geom.type === 'LINESTRING' ? 'LineString'
                : geom.type === 'MULTIPOINT' ? 'MultiPoint'
                : geom.type === 'POINT' ? 'Point'
                : geom.type,
            coords = geom.coordinates;
        if (fromMerc) {
            coords = gmxAPIutils.coordsFromMercator(type, coords, webmercFlag);
        } else {
            coords = gmxAPIutils.coordsToMercator(type, coords);
        }
        return {
            type: geom.type,
            coordinates: coords
        };
    },

    /** Converts GeoJSON object into GeoMixer format
     * @memberof L.gmxUtil
     * @param {Object} geometry - GeoJSON object
     * @param {Boolean} mercFlag - true if resulting Geomixer object should has coordinates in Mercator projection
     * @return {Object} Geometry in GeoMixer format
    */
    geoJSONtoGeometry: function (geoJSON, mercFlag) {
        if (geoJSON.type === 'FeatureCollection') {
            return gmxAPIutils.geoJSONtoGeometry(geoJSON.features[0], mercFlag);
        } else if (geoJSON.type === 'Feature') {
            return gmxAPIutils.geoJSONtoGeometry(geoJSON.geometry, mercFlag);
        } else if (geoJSON.type === 'FeatureCollection') {
            return gmxAPIutils.geoJSONtoGeometry(geoJSON.features[0], mercFlag);
        }

        var type = geoJSON.type === 'MultiPolygon' ? 'MULTIPOLYGON'
                : geoJSON.type === 'Polygon' ? 'POLYGON'
                : geoJSON.type === 'MultiLineString' ? 'MULTILINESTRING'
                : geoJSON.type === 'LineString' ? 'LINESTRING'
                : geoJSON.type === 'MultiPoint' ? 'MULTIPOINT'
                : geoJSON.type === 'Point' ? 'POINT'
                : geoJSON.type,
            coords = geoJSON.coordinates;
        if (mercFlag) {
            coords = gmxAPIutils.coordsToMercator(geoJSON.type, coords);
        }
        return {
            type: type,
            coordinates: coords
        };
    },

    _coordsConvert: function(type, coords, toMerc, webmercFlag) {
        var i, len, p,
            resCoords = [];
        if (type === 'Point') {
            if (toMerc) {
                p = L.Projection.Mercator.project({lat: coords[1], lng: coords[0]});
                resCoords = [p.x, p.y];
            } else {
                p = L.Projection.Mercator.unproject({y: coords[1], x: coords[0]});
                resCoords = [p.lng, p.lat];
				if (webmercFlag) {
					resCoords[1] = gmxAPIutils.fromWebMercY(coords[1]);
				}
            }
        } else if (type === 'LineString' || type === 'MultiPoint') {
            for (i = 0, len = coords.length; i < len; i++) {
                resCoords.push(gmxAPIutils._coordsConvert('Point', coords[i], toMerc, webmercFlag));
            }
        } else if (type === 'Polygon' || type === 'MultiLineString') {
            for (i = 0, len = coords.length; i < len; i++) {
                resCoords.push(gmxAPIutils._coordsConvert('MultiPoint', coords[i], toMerc, webmercFlag));
            }
        } else if (type === 'MultiPolygon') {
            for (i = 0, len = coords.length; i < len; i++) {
                resCoords.push(gmxAPIutils._coordsConvert('Polygon', coords[i], toMerc, webmercFlag));
            }
        }
        return resCoords;
    },

    coordsFromMercator: function(type, coords, webmercFlag) {
        return gmxAPIutils._coordsConvert(type, coords, false, webmercFlag);
    },

    coordsToMercator: function(type, coords) {
        return gmxAPIutils._coordsConvert(type, coords, true);
    },

    transformGeometry: function(geom, callback) {
        return !geom ? geom : {
            type: geom.type,
            coordinates: gmxAPIutils.forEachPoint(geom.coordinates, function(p) {
                return callback(p);
            })
        };
    },

    /** Get area for geometry
     * @memberof L.gmxUtil
     * @param {Object} geometry
     * @param {Boolean} [isMerc=true] - true if coordinates in Mercator
     * @param {Boolean} isWebMerc - true if coordinates in WebMercator	- TODO
     * @return {Number} area in square meters
    */
    geoArea: function(geom, isMerc) {
        var i, len, ret = 0,
            type = geom.type || '';
        isMerc = isMerc === undefined || isMerc;
        if (type === 'MULTIPOLYGON' || type === 'MultiPolygon') {
            for (i = 0, len = geom.coordinates.length; i < len; i++) {
                ret += gmxAPIutils.geoArea({type: 'POLYGON', coordinates: geom.coordinates[i]}, isMerc);
            }
            return ret;
        } else if (type === 'POLYGON' || type === 'Polygon') {
            ret = gmxAPIutils.geoArea(geom.coordinates[0], isMerc);
            for (i = 1, len = geom.coordinates.length; i < len; i++) {
                ret -= gmxAPIutils.geoArea(geom.coordinates[i], isMerc);
            }
            return ret;
        } else if (geom.length) {
            var latlngs = [],
                vectorSize = typeof geom[0] === 'number' ? 2 : 1;

            for (i = 0, len = geom.length; i < len; i += vectorSize) {
                var p = vectorSize === 1 ? geom[i] : [geom[i], geom[i + 1]];
                latlngs.push(
                    isMerc ?
                    L.Projection.Mercator.unproject({y: p[1], x: p[0]}) :
                    {lat: p[1], lng: p[0]}
                );
            }
            return gmxAPIutils.getArea(latlngs);
        }
        return 0;
    },

    /** Get summary for geoJSON geometry
     * @memberof L.gmxUtil
     * @param {Object} geoJSON geometry
     * @param {Object} unitOptions {
     *                  distanceUnit: '',   // m - meters, km - kilometers, nm - nautilus miles, auto - default
     *                  squareUnit: ''      // m2 - square meters, km2 - square kilometers, ha - hectares, auto - default
     *               }
     * @return {String} Summary string for geometry
    */
    getGeoJSONSummary: function(geom, unitOptions) {
        var type = geom.type,
            units = unitOptions || {},
            out = 0,
            i, len, coords;
        if (type === 'Point') {
            coords = geom.coordinates;
            out = gmxAPIutils.formatCoordinates(coords[0], coords[1]);
        } else if (type === 'Polygon') {
            out = gmxAPIutils.prettifyArea(gmxAPIutils.geoArea(geom, false), units.squareUnit);
        } else if (type === 'MultiPolygon') {
            coords = geom.coordinates;
            for (i = 0, len = coords.length; i < len; i++) {
                out += gmxAPIutils.geoArea({type: 'Polygon', coordinates: coords[i]}, false);
            }
            out = gmxAPIutils.prettifyArea(out, units.squareUnit);
        } else if (type === 'LineString') {
            out = gmxAPIutils.prettifyDistance(gmxAPIutils.geoJSONGetLength(geom), units.distanceUnit);
        } else if (type === 'MultiLineString') {
            coords = geom.coordinates;
            for (i = 0, len = coords.length; i < len; i++) {
                out += gmxAPIutils.geoJSONGetLength({type: 'LineString', coordinates: coords[i]});
            }
            out = gmxAPIutils.prettifyDistance(out, units.distanceUnit);
        }
        return out;
    },

    /** Get summary for point
     * @memberof L.gmxUtil
     * @param {latlng} point
     * @param {num} format number:
     *         0: 62°52'30.68" N, 22°48'27.42" E
     *         1: 62.875188 N, 22.807617 E
     *         2: 2538932, 9031643 (EPSG:3395)
     *         3: 2538932, 9069712 (EPSG:3857)
     * @return {String} Summary string for LatLng point
    */
    getCoordinatesString: function(latlng, num) {
        var x = latlng.lng,
            y = latlng.lat,
            formats = [
                '',
                '',
                ' (EPSG:3395)',
                ' (EPSG:3857)'
            ],
            len = formats.length,
            merc,
            out = '';
        num = num || 0;
        if (x > 180) { x -= 360; }
        if (x < -180) { x += 360; }
        if (num % len === 0) {
            out = gmxAPIutils.formatCoordinates2(x, y);
        } else if (num % len === 1) {
            out = gmxAPIutils.formatCoordinates(x, y);
        } else if (num % len === 2) {
            merc = L.Projection.Mercator.project(new L.LatLng(y, x));
            out = '' + Math.round(merc.x) + ', ' + Math.round(merc.y) + formats[2];
        } else {
            merc = L.CRS.EPSG3857.project(new L.LatLng(y, x));
            out = '' + Math.round(merc.x) + ', ' + Math.round(merc.y) + formats[3];
        }
        return out;
    },

    /** Get summary for geometries array
     * @memberof L.gmxUtil
     * @param {Array} geometries array in Geomixer format
     * @param {Object} units Options for length and area
     * @return {String} Summary string for geometries array
    */
    getGeometriesSummary: function(arr, unitOptions) {
        var out = '',
            type = '',
            res = 0;
        if (!unitOptions) { unitOptions = {}; }
        if (arr) {
            arr.forEach(function(geom) {
                if (geom) {
                    type = geom.type.toUpperCase();
					var latLngGeometry = L.gmxUtil.geometryToGeoJSON(geom, true, unitOptions.srs === '3857');
                    if (type.indexOf('POINT') !== -1) {
                        var latlng = L.latLng(latLngGeometry.coordinates.reverse());
                        out = '<b>' + L.gmxLocale.getText('Coordinates') + '</b>: '
                            + gmxAPIutils.getCoordinatesString(latlng, unitOptions.coordinatesFormat);
                    } else if (type.indexOf('LINESTRING') !== -1) {
                        res += gmxAPIutils.geoJSONGetLength(latLngGeometry);
                    } else if (type.indexOf('POLYGON') !== -1) {
                        res += gmxAPIutils.geoJSONGetArea(latLngGeometry);
                    }
                }
            });
        }
        if (!out) {
            if (type.indexOf('LINESTRING') !== -1) {
                out = '<b>' + L.gmxLocale.getText('Length') + '</b>: '
                    + gmxAPIutils.prettifyDistance(res, unitOptions.distanceUnit);
            } else if (type.indexOf('POLYGON') !== -1) {
                out = '<b>' + L.gmxLocale.getText('Area') + '</b>: '
                    + gmxAPIutils.prettifyArea(res, unitOptions.squareUnit);
            }
        }
        return out;
    },

    getGeometrySummary: function(geom, unitOptions) {
        return gmxAPIutils.getGeometriesSummary([geom], unitOptions || {});
    },

    chkOnEdge: function(p1, p2, ext) { // отрезок на границе
        if ((p1[0] < ext.min.x && p2[0] < ext.min.x) || (p1[0] > ext.max.x && p2[0] > ext.max.x)) { return true; }
        if ((p1[1] < ext.min.y && p2[1] < ext.min.y) || (p1[1] > ext.max.y && p2[1] > ext.max.y)) { return true; }
        return false;
    },

    getHidden: function(coords, tb) {  // массив точек на границах тайлов
        var hiddenLines = [],
            vectorSize = typeof coords[0] === 'number' ? 2 : 1,
            prev = null;
        for (var i = 0, len = coords.length; i < len; i += vectorSize) {
            var p = vectorSize === 1 ? coords[i] : [coords[i], coords[i + 1]];
            if (prev && gmxAPIutils.chkOnEdge(p, prev, tb)) {
                hiddenLines.push(i);
            }
            prev = p;
        }
        return hiddenLines;
    },

    getNormalizeBounds: function (screenBounds, mercDeltaY) { // get bounds array from -180 180 lng
        var northWest = screenBounds.getNorthWest(),
            southEast = screenBounds.getSouthEast(),
            minX = northWest.lng,
            maxX = southEast.lng,
            w = (maxX - minX) / 2,
            minX1 = null,
            maxX1 = null,
            out = [];

        if (w >= 180) {
            minX = -180; maxX = 180;
        } else if (maxX > 180 || minX < -180) {
            var center = ((maxX + minX) / 2) % 360;
            if (center > 180) { center -= 360; }
            else if (center < -180) { center += 360; }
            minX = center - w; maxX = center + w;
            if (minX < -180) {
                minX1 = minX + 360; maxX1 = 180; minX = -180;
            } else if (maxX > 180) {
                minX1 = -180; maxX1 = maxX - 360; maxX = 180;
            }
        }
        var m1 = {x: minX, y: southEast.lat},
            m2 = {x: maxX, y: northWest.lat};

        if (mercDeltaY !== undefined) {
            m1 = L.Projection.Mercator.project(new L.LatLng([southEast.lat, minX]));
            m2 = L.Projection.Mercator.project(new L.LatLng([northWest.lat, maxX]));
            m1.y -= mercDeltaY;
            m2.y -= mercDeltaY;
        }
        out.push(gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]));

        if (minX1) {
            var m11 = {x: minX1, y: southEast.lat},
                m12 = {x: maxX1, y: northWest.lat};
            if (mercDeltaY !== undefined) {
                m11 = L.Projection.Mercator.project(new L.LatLng([southEast.lat, minX1]));
                m12 = L.Projection.Mercator.project(new L.LatLng([northWest.lat, maxX1]));
                m11.y -= mercDeltaY;
                m12.y -= mercDeltaY;
            }
            out.push(gmxAPIutils.bounds([[m11.x, m11.y], [m12.x, m12.y]]));
        }
        return out;
    },

    toPrecision: function(x, prec) {
        var zn = Math.pow(10, prec ? prec : 4);
        return Math.round(zn * x) / zn;
    },

    getTileBounds: function(x, y, z) {  //x, y, z - GeoMixer tile coordinates
        var tileSize = gmxAPIutils.tileSizes[z],
            minx = x * tileSize,
            miny = y * tileSize;
        return gmxAPIutils.bounds([[minx, miny], [minx + tileSize, miny + tileSize]]);
    },

    parseTemplate: function(str, properties) {
        var matches = str.match(/\[([^\]]+)\]/ig);
        if (matches) {
            for (var i = 0, len = matches.length; i < len; i++) {
                var key1 = matches[i],
                    key = key1.substr(1, key1.length - 2),
                    res = key in properties ? properties[key] : '';

                str = str.replace(key1, res);
            }
        }
        return str;
    },

    getDefaultBalloonTemplate: function(properties, tileAttributeTypes) {
        var str = '';
        for (var key in properties) {
            if (!tileAttributeTypes || (key in tileAttributeTypes)) {
				str += '<b>' + key + ':</b> [' +  key + ']<br />';
			}
        }
        str += '<br />[SUMMARY]<br />';
        return str;
    },

    parseBalloonTemplate: function(str, options) {
        var properties = options.properties;

        if (!str) {
            str = gmxAPIutils.getDefaultBalloonTemplate(properties, options.tileAttributeTypes);
        }
        var matches = str.match(/\[([^\]]+)\]/ig);
        if (matches) {
            var tileAttributeTypes = options.tileAttributeTypes,
                unitOptions = options.unitOptions,
                geometries = options.geometries;
            for (var i = 0, len = matches.length; i < len; i++) {
                var key1 = matches[i],
                    key = key1.substr(1, key1.length - 2),
                    res = '';

                if (key in properties) {
                    res = L.gmxUtil.attrToString(tileAttributeTypes[key], properties[key]);
                } else if (key === 'SUMMARY') {
                    res = options.summary || L.gmxUtil.getGeometriesSummary(geometries, unitOptions);
                }
                str = str.replace(key1, res);
            }
        }
        return str;
    },

    styleKeys: {
        marker: {
            server: ['image',   'angle',     'scale',     'minScale',     'maxScale',     'size',         'circle',     'center',     'color'],
            client: ['iconUrl', 'iconAngle', 'iconScale', 'iconMinScale', 'iconMaxScale', 'iconSize', 'iconCircle', 'iconCenter', 'iconColor']
        },
        outline: {
            server: ['color',  'opacity',   'thickness', 'dashes'],
            client: ['color',  'opacity',   'weight',    'dashArray']
        },
        fill: {
            server: ['color',     'opacity',   'image',       'pattern',     'radialGradient',     'linearGradient'],
            client: ['fillColor', 'fillOpacity', 'fillIconUrl', 'fillPattern', 'fillRadialGradient', 'fillLinearGradient']
        },
        label: {
            server: ['text',      'field',      'template',      'color',      'haloColor',      'size',          'spacing',      'align'],
            client: ['labelText', 'labelField', 'labelTemplate', 'labelColor', 'labelHaloColor', 'labelFontSize', 'labelSpacing', 'labelAlign']
        }
    },
    styleFuncKeys: {
        iconSize: 'iconSizeFunction',
        iconAngle: 'rotateFunction',
        iconScale: 'scaleFunction',
        iconColor: 'iconColorFunction',
        opacity: 'opacityFunction',
        fillOpacity: 'fillOpacityFunction',
        color: 'colorFunction',
        fillColor: 'fillColorFunction'
    },
    styleFuncError: {
        iconSize: function() { return 8; },
        iconAngle: function() { return 0; },
        iconScale: function() { return 1; },
        iconColor: function() { return 0xFF; },
        opacity: function() { return 1; },
        fillOpacity: function() { return 0.5; },
        color: function() { return 0xFF; },
        fillColor: function() { return 0xFF; }
    },
    defaultStyles: {
       MinZoom: 1,
       MaxZoom: 21,
       Filter: '',
       Balloon: '',
       DisableBalloonOnMouseMove: true,
       DisableBalloonOnClick: false,
       RenderStyle: {
            point: {    // old = {outline: {color: 255, thickness: 1}, marker:{size: 8}},
                color: 0xFF,
                weight: 1,
                iconSize: 8
            },
            linestring: {    // old = {outline: {color: 255, thickness: 1}},
                color: 0xFF,
                weight: 1
            },
            polygon: {    // old = {outline: {color: 255, thickness: 1}},
                color: 0xFF,
                weight: 1
            }
        }
    },

    getDefaultStyle: function(type) {
        var from = gmxAPIutils.defaultStyles,
            out = L.extend({}, from);
        out.RenderStyle = from.RenderStyle[type];
        return out;
    },

    toServerStyle: function(style) {   // Style leaflet->Scanex
        var out = {};

        for (var key in gmxAPIutils.styleKeys) {
            var keys = gmxAPIutils.styleKeys[key];
            for (var i = 0, len = keys.client.length; i < len; i++) {
                var key1 = keys.client[i];
                if (key1 in style) {
                    if (!out[key]) { out[key] = {}; }
                    var zn = style[key1];
                    if (key1 === 'opacity' || key1 === 'fillOpacity') {
                        zn *= 100;
                    }
                    out[key][keys.server[i]] = zn;
                }
            }
        }
        if ('iconAnchor' in style) {
            if (!out.marker) { out.marker = {}; }
            out.marker.dx = -style.iconAnchor[0];
            out.marker.dy = -style.iconAnchor[1];
        }
        return out;
    },

    fromServerStyle: function(style) {   // Style Scanex->leaflet
        var st, i, len, key, key1,
            out = {
                type: ''    // 'polygon', 'line', 'circle', 'square', 'image'
            };

        for (key in gmxAPIutils.styleKeys) {
            var keys = gmxAPIutils.styleKeys[key];
            for (i = 0, len = keys.client.length; i < len; i++) {
                key1 = keys.client[i];
                if (key1 in style) {
                    out[key1] = style[key1];
                }
            }
            st = style[key];
            if (st && typeof (st) === 'object') {
                for (i = 0, len = keys.server.length; i < len; i++) {
                    key1 = keys.server[i];
                    if (key1 in st) {
                        var newKey = keys.client[i],
                            zn = st[key1];
                        if (typeof (zn) === 'string') {
                            if (gmxAPIutils.styleFuncKeys[newKey]) {
                                if (zn.match(/[^\d\.]/) === null) {
                                    zn = Number(zn);
                                } else {
                                    var func = L.gmx.Parsers.parseExpression(zn);
                                    if (func === null) {
                                        zn = gmxAPIutils.styleFuncError[newKey]();
                                    } else {
                                        out[gmxAPIutils.styleFuncKeys[newKey]] = func;
                                    }
                                }
                            }
                        } else if (key1 === 'opacity') {
                            zn /= 100;
                        }
                        out[newKey] = zn;
                    }
                }
            }
        }
        if (style.marker) {
            st = style.marker;
            if ('dx' in st || 'dy' in st) {
                var dx = st.dx || 0,
                    dy = st.dy || 0;
                out.iconAnchor = [-dx, -dy];    // For leaflet type iconAnchor
            }
        }
        for (key in style) {
			if (!gmxAPIutils.styleKeys[key]) {
				out[key] = style[key];
			}
        }
        return out;
    },

    getUnixTimeFromStr: function(st) {
		var arr1 = L.Util.trim(st).split(' '),
			arr = arr1[0].split('.'),
			tm = arr1[1] ? arr1[1].split(':') : [0, 0, 0];

        if (arr[2].length === 4) {
			arr = arr.reverse();
		}
		return Date.UTC(arr[0], arr[1] - 1, arr[2], tm[0] || 0, tm[1] || 0, tm[2] || 0) / 1000;
    },

    getDateFromStr: function(st) {
		var arr = L.Util.trim(st).split(' ');
		arr = arr[0].split('.');

        if (arr[2].length === 4) {
			arr = arr.reverse();
		}
		var dt = new Date(arr[0], arr[1] - 1, arr[2]);
        return dt;
    },

    getUTCdate: function(utime) {
        var dt = new Date(utime * 1000);

        return [
            dt.getUTCFullYear(),
            gmxAPIutils.pad2(dt.getUTCMonth() + 1),
            gmxAPIutils.pad2(dt.getUTCDate())
        ].join('.');
    },

    getUTCtime: function(utime) {
        var h = Math.floor(utime / 3600),
            m = Math.floor((utime - h * 3600) / 60),
            s = Math.floor(utime - h * 3600 - m * 60);

        return [
            //gmxAPIutils.pad2(h - new Date().getTimezoneOffset() / 60),
            gmxAPIutils.pad2(h),
            gmxAPIutils.pad2(m),
            gmxAPIutils.pad2(s)
        ].join(':');
    },

    getUTCdateTime: function(utime) {
        var time = utime % (3600 * 24);

        if (time) {
            return [
                gmxAPIutils.getUTCdate(utime),
                gmxAPIutils.getUTCtime(utime % (3600 * 24))
            ].join(' ');
        } else {
            return gmxAPIutils.getUTCdate(utime);
        }
    },

    attrToString: function(type, value) {
        if (type === 'date') {
            return value ? L.gmxUtil.getUTCdate(value) : value;
        } else if (type === 'time') {
            return value ? L.gmxUtil.getUTCtime(value) : value;
        } else if (type === 'datetime') {
            return value ? L.gmxUtil.getUTCdateTime(value) : value;
        } else {
            return value;
        }
    },

    getTileAttributes: function(prop) {
        var tileAttributeIndexes = {},
            tileAttributeTypes = {};
        if (prop.attributes) {
            var attrs = prop.attributes,
                attrTypes = prop.attrTypes || null;
            if (prop.identityField) { tileAttributeIndexes[prop.identityField] = 0; }
            for (var a = 0; a < attrs.length; a++) {
                var key = attrs[a];
                tileAttributeIndexes[key] = a + 1;
                tileAttributeTypes[key] = attrTypes ? attrTypes[a] : 'string';
            }
        }
        return {
            tileAttributeTypes: tileAttributeTypes,
            tileAttributeIndexes: tileAttributeIndexes
        };
    }
};

gmxAPIutils.lambertCoefX = 100 * gmxAPIutils.distVincenty(0, 0, 0.01, 0);				// 111319.5;
gmxAPIutils.lambertCoefY = 100 * gmxAPIutils.distVincenty(0, 0, 0, 0.01) * 180 / Math.PI;	// 6335440.712613423;

(function() {
    //pre-calculate tile sizes
    for (var z = 0; z < 30; z++) {
        gmxAPIutils.tileSizes[z] = 40075016.685578496 / Math.pow(2, z);
    }
})();

gmxAPIutils.Bounds = function(arr) {
    this.min = {
        x: Number.MAX_VALUE,
        y: Number.MAX_VALUE
    };
    this.max = {
        x: -Number.MAX_VALUE,
        y: -Number.MAX_VALUE
    };
    this.extendArray(arr);
};
gmxAPIutils.Bounds.prototype = {
    extend: function(x, y) {
        if (x < this.min.x) { this.min.x = x; }
        if (x > this.max.x) { this.max.x = x; }
        if (y < this.min.y) { this.min.y = y; }
        if (y > this.max.y) { this.max.y = y; }
        return this;
    },
    extendBounds: function(bounds) {
        return this.extendArray([[bounds.min.x, bounds.min.y], [bounds.max.x, bounds.max.y]]);
    },
    extendArray: function(arr) {
        if (!arr || !arr.length) { return this; }
        var i, len;
        if (typeof arr[0] === 'number') {
            for (i = 0, len = arr.length; i < len; i += 2) {
                this.extend(arr[i], arr[i + 1]);
            }
        } else {
            for (i = 0, len = arr.length; i < len; i++) {
                this.extend(arr[i][0], arr[i][1]);
            }
        }
        return this;
    },
    addBuffer: function(dxmin, dymin, dxmax, dymax) {
        this.min.x -= dxmin;
        this.min.y -= dymin || dxmin;
        this.max.x += dxmax || dxmin;
        this.max.y += dymax || dymin || dxmin;
        return this;
    },
    contains: function (point) { // ([x, y]) -> Boolean
        var min = this.min, max = this.max,
            x = point[0], y = point[1];
        return x >= min.x && x <= max.x && y >= min.y && y <= max.y;
    },
    getCenter: function () {
        var min = this.min, max = this.max;
        return [(min.x + max.x) / 2, (min.y + max.y) / 2];
    },
    addOffset: function (offset) {
        this.min.x += offset[0]; this.max.x += offset[0];
        this.min.y += offset[1]; this.max.y += offset[1];
        return this;
    },
    intersects: function (bounds) { // (Bounds) -> Boolean
        var min = this.min,
            max = this.max,
            min2 = bounds.min,
            max2 = bounds.max;
        return max2.x > min.x && min2.x < max.x && max2.y > min.y && min2.y < max.y;
    },
    intersectsWithDelta: function (bounds, dx, dy) { // (Bounds, dx, dy) -> Boolean
        var min = this.min,
            max = this.max,
            x = dx || 0,
            y = dy || 0,
            min2 = bounds.min,
            max2 = bounds.max;
        return max2.x + x > min.x && min2.x - x < max.x && max2.y + y > min.y && min2.y - y < max.y;
    },
    isEqual: function (bounds) { // (Bounds) -> Boolean
        var min = this.min,
            max = this.max,
            min2 = bounds.min,
            max2 = bounds.max;
        return max2.x === max.x && min2.x === min.x && max2.y === max.y && min2.y === min.y;
    },
    isNodeIntersect: function (coords) {
        for (var i = 0, len = coords.length; i < len; i++) {
            if (this.contains(coords[i])) {
                return {
                    num: i,
                    point: coords[i]
                };
            }
        }
        return null;
    },
    clipPolygon: function (coords) { // (coords) -> clip coords
        var min = this.min,
            max = this.max,
            clip = [[min.x, min.y], [max.x, min.y], [max.x, max.y], [min.x, max.y]],
            cp1, cp2, s, e,
            inside = function (p) {
                return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0]);
            },
            intersection = function () {
                var dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]],
                    dp = [s[0] - e[0], s[1] - e[1]],
                    n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],
                    n2 = s[0] * e[1] - s[1] * e[0],
                    n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);
                return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3];
            };

        var outputList = coords;
        cp1 = clip[3];
        for (var j = 0; j < 4; j++) {
            cp2 = clip[j];
            var inputList = outputList,
                len = inputList.length;
            outputList = [];
            s = inputList[len - 1]; //last on the input list
            for (var i = 0; i < len; i++) {
                e = inputList[i];
                if (inside(e)) {
                    if (!inside(s)) { outputList.push(intersection()); }
                    outputList.push(e);
                } else if (inside(s)) {
                    outputList.push(intersection());
                }
                s = e;
            }
            cp1 = cp2;
        }
        return outputList;
    },
    clipPolyLine: function (coords, angleFlag, delta) { // (coords) -> clip coords
        delta = delta || 0;
        var min = this.min,
            max = this.max,
            bbox = [min.x - delta, min.y - delta, max.x + delta, max.y + delta],
            bitCode = function (p) {
                var code = 0;

                if (p[0] < bbox[0]) code |= 1; // left
                else if (p[0] > bbox[2]) code |= 2; // right

                if (p[1] < bbox[1]) code |= 4; // bottom
                else if (p[1] > bbox[3]) code |= 8; // top

                return code;
            },
            getAngle = function (a, b) {
                return Math.PI / 2 + Math.atan2(b[1] - a[1], a[0] - b[0]);
            },
            intersect = function (a, b, edge) {
                return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : // top
                       edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : // bottom
                       edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : // right
                       edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : // left
                       null;
            },
            result = [],
            len = coords.length,
            codeA = bitCode(coords[0], bbox),
            part = [],
            i, a, b, c, codeB, lastCode;

        for (i = 1; i < len; i++) {
            a = coords[i - 1];
            b = coords[i];
            if (a[0] === b[0] && a[1] === b[1]) { continue; }
            codeB = lastCode = bitCode(b, bbox);

            while (true) {

                if (!(codeA | codeB)) { // accept
                    if (angleFlag) {
                        a[2] = getAngle(a, b);
                        c = coords[i + 1];
                        b[2] = c ? getAngle(b, c) : a[2];
                    }
                    part.push(a);

                    if (codeB !== lastCode) { // segment went outside
                        part.push(b);

                        if (i < len - 1) { // start a new line
                            result.push(part);
                            part = [];
                        }
                    } else if (i === len - 1) {
                        part.push(b);
                    }
                    break;

                } else if (codeA & codeB) { // trivial reject
                    break;

                } else if (codeA) { // a outside, intersect with clip edge
                    a = intersect(a, b, codeA, bbox);
                    codeA = bitCode(a, bbox);

                } else { // b outside
                    b = intersect(a, b, codeB, bbox);
                    codeB = bitCode(b, bbox);
                }
            }

            codeA = lastCode;
        }

        if (part.length) result.push(part);

        return result;
    },
    toLatLngBounds: function(isWebMerc) {
		var proj = L.Projection.Mercator,
			min = proj.unproject(this.min),
			max = proj.unproject(this.max),
			arr = [[min.lat, min.lng], [max.lat, max.lng]];

		if (isWebMerc) {
			arr[0][0] = gmxAPIutils.fromWebMercY(this.min.y);
			arr[1][0] = gmxAPIutils.fromWebMercY(this.max.y);
		}
		return L.latLngBounds(arr);
    }
};

gmxAPIutils.bounds = function(arr) {
    return new gmxAPIutils.Bounds(arr);
};

//скопирована из API для обеспечения независимости от него
gmxAPIutils.parseUri = function (str) {
    var	o   = gmxAPIutils.parseUri.options,
        m   = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str),
        uri = {},
        i   = 14;

    while (i--) {
        uri[o.key[i]] = m[i] || '';
    }

    uri[o.q.name] = {};
    uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
        if ($1) { uri[o.q.name][$1] = $2; }
    });

    uri.hostOnly = uri.host;
    uri.host = uri.authority; // HACK

    return uri;
};

gmxAPIutils.parseUri.options = {
    strictMode: false,
    key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
    q:   {
        name:   'queryKey',
        parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
        strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
        loose:  /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
};

if (!L.gmxUtil) { L.gmxUtil = {}; }

//public interface
L.extend(L.gmxUtil, {
    newId: gmxAPIutils.newId,
	isPageHidden: gmxAPIutils.isPageHidden,
    protocol: location.protocol !== 'https:' ? 'http:' : location.protocol,
    loaderStatus: function () {},
    isIE9: gmxAPIutils.isIE(9),
    isIE10: gmxAPIutils.isIE(10),
    isIE11: gmxAPIutils.isIE(11),
    gtIE11: gmxAPIutils.gtIE(11),
    getFormData: gmxAPIutils.getFormData,
    requestJSONP: gmxAPIutils.requestJSONP,
    getCadastreFeatures: gmxAPIutils.getCadastreFeatures,
    request: gmxAPIutils.request,
    getLayerItemFromServer: gmxAPIutils.getLayerItemFromServer,
    fromServerStyle: gmxAPIutils.fromServerStyle,
    toServerStyle: gmxAPIutils.toServerStyle,
    getDefaultStyle: gmxAPIutils.getDefaultStyle,
    bounds: gmxAPIutils.bounds,
    getNormalizeBounds: gmxAPIutils.getNormalizeBounds,
    getGeometryBounds: gmxAPIutils.getGeometryBounds,
    tileSizes: gmxAPIutils.tileSizes,
    getDateFromStr: gmxAPIutils.getDateFromStr,
    getUnixTimeFromStr: gmxAPIutils.getUnixTimeFromStr,
    getUTCdate: gmxAPIutils.getUTCdate,
    getUTCtime: gmxAPIutils.getUTCtime,
    getUTCdateTime: gmxAPIutils.getUTCdateTime,
    attrToString: gmxAPIutils.attrToString,
    getTileAttributes: gmxAPIutils.getTileAttributes,
    formatCoordinates: function (latlng, type) {
        return gmxAPIutils['formatCoordinates' + (type ? '2' : '')](latlng.lng, latlng.lat);
    },
    formatDegrees: gmxAPIutils.formatDegrees,
    pad2: gmxAPIutils.pad2,
    dec2hex: gmxAPIutils.dec2hex,
	dec2rgba: gmxAPIutils.dec2rgba,
    trunc: gmxAPIutils.trunc,
    latLonFormatCoordinates: gmxAPIutils.latLonFormatCoordinates,
    latLonFormatCoordinates2: gmxAPIutils.latLonFormatCoordinates2,
    getLength: gmxAPIutils.getLength,
    geoLength: gmxAPIutils.geoLength,
    prettifyDistance: gmxAPIutils.prettifyDistance,
    getArea: gmxAPIutils.getArea,
    prettifyArea: gmxAPIutils.prettifyArea,
    geoArea: gmxAPIutils.geoArea,
    parseBalloonTemplate: gmxAPIutils.parseBalloonTemplate,
    getSVGIcon: gmxAPIutils.getSVGIcon,
    getCoordinatesString: gmxAPIutils.getCoordinatesString,
    getGeometriesSummary: gmxAPIutils.getGeometriesSummary,
    getGeometrySummary: gmxAPIutils.getGeometrySummary,
    getGeoJSONSummary: gmxAPIutils.getGeoJSONSummary,
    getPropertiesHash: gmxAPIutils.getPropertiesHash,
    distVincenty: gmxAPIutils.distVincenty,
    parseCoordinates: gmxAPIutils.parseCoordinates,
    geometryToGeoJSON: gmxAPIutils.geometryToGeoJSON,
    coordsFromMercator: gmxAPIutils.coordsFromMercator,
    convertGeometry: gmxAPIutils.convertGeometry,
    transformGeometry: gmxAPIutils.transformGeometry,
    geoJSONtoGeometry: gmxAPIutils.geoJSONtoGeometry,
    geoJSONGetArea: gmxAPIutils.geoJSONGetArea,
    geoJSONGetLength: gmxAPIutils.geoJSONGetLength,
    geoJSONGetLatLng: gmxAPIutils.geoJSONGetLatLng,
	fromWebMercY: gmxAPIutils.fromWebMercY,
    parseUri: gmxAPIutils.parseUri,
    isRectangle: gmxAPIutils.isRectangle,
    isClockwise: gmxAPIutils.isClockwise,
    isPointInPolygonWithHoles: gmxAPIutils.isPointInPolygonWithHoles,
    getPatternIcon: gmxAPIutils.getPatternIcon,
    getCircleLatLngs: gmxAPIutils.getCircleLatLngs,
    normalizeHostname: gmxAPIutils.normalizeHostname,
    getTileBounds: gmxAPIutils.getTileBounds,
    parseTemplate: gmxAPIutils.parseTemplate
});

(function() {
    var requests = {};
    var lastRequestId = 0;

    var processMessage = function(e) {

        if (!(e.origin in requests)) {
            return;
        }

        var dataStr = decodeURIComponent(e.data.replace(/\n/g, '\n\\'));
        try {
            var dataObj = JSON.parse(dataStr);
        } catch (ev) {
            console.log({Status:'error', ErrorInfo: {ErrorMessage: 'JSON.parse exeption', ExceptionType: 'JSON.parse', StackTrace: dataStr}});
        }
        var request = requests[e.origin][dataObj.CallbackName];
        if (!request) {
            return;    // message от других запросов
        }

        delete requests[e.origin][dataObj.CallbackName];
        delete dataObj.CallbackName;

        if (request.iframe.parentNode) {
            request.iframe.parentNode.removeChild(request.iframe);
        }
        if ('callback' in request) { request.callback(dataObj); }
    };

    L.DomEvent.on(window, 'message', processMessage);

    function createPostIframe2(id, callback, url) {
        var uniqueId = 'gmxAPIutils_id' + (lastRequestId++),
            iframe = L.DomUtil.create('iframe');

        iframe.style.display = 'none';
        iframe.setAttribute('id', id);
        iframe.setAttribute('name', id);    /*eslint-disable no-script-url */
        iframe.src = 'javascript:true';     /*eslint-enable */
        iframe.callbackName = uniqueId;

        var parsedURL = gmxAPIutils.parseUri(url);
        var origin = (parsedURL.protocol ? (parsedURL.protocol + ':') : L.gmxUtil.protocol) + '//' + (parsedURL.host || window.location.host);

        requests[origin] = requests[origin] || {};
        requests[origin][uniqueId] = {callback: callback, iframe: iframe};

        return iframe;
    }

	//расширяем namespace
    gmxAPIutils.createPostIframe2 = createPostIframe2;

})();

// кроссдоменный POST запрос
(function()
{
	/** Посылает кроссдоменный POST запрос
	* @namespace L.gmxUtil
    * @ignore
	* @function
	*
	* @param url {string} - URL запроса
	* @param params {object} - хэш параметров-запросов
	* @param callback {function} - callback, который вызывается при приходе ответа с сервера. Единственный параметр ф-ции - собственно данные
	* @param baseForm {DOMElement} - базовая форма запроса. Используется, когда нужно отправить на сервер файл.
	*                                В функции эта форма будет модифицироваться, но после отправления запроса будет приведена к исходному виду.
	*/
	function sendCrossDomainPostRequest(url, params, callback, baseForm) {
        var form,
            id = '$$iframe_' + gmxAPIutils.newId();

        var iframe = gmxAPIutils.createPostIframe2(id, callback, url),
            originalFormAction;

        if (baseForm) {
            form = baseForm;
            originalFormAction = form.getAttribute('action');
            form.setAttribute('action', url);
            form.target = id;
        } else if (L.Browser.ielt9) {
            var str = '<form id=' + id + '" enctype="multipart/form-data" style="display:none" target="' + id + '" action="' + url + '" method="post"></form>';
            form = document.createElement(str);
        } else {
            form = document.createElement('form');
            form.style.display = 'none';
            form.setAttribute('enctype', 'multipart/form-data');
            form.target = id;
            form.setAttribute('method', 'POST');
            form.setAttribute('action', url);
            form.id = id;
        }

        var hiddenParamsDiv = document.createElement('div');
        hiddenParamsDiv.style.display = 'none';

        if (params.WrapStyle === 'window') {
            params.WrapStyle = 'message';
        }

        if (params.WrapStyle === 'message') {
            params.CallbackName = iframe.callbackName;
        }

        for (var paramName in params) {
            var input = document.createElement('input');
            var value = typeof params[paramName] !== 'undefined' ? params[paramName] : '';
            input.setAttribute('type', 'hidden');
            input.setAttribute('name', paramName);
            input.setAttribute('value', value);
            hiddenParamsDiv.appendChild(input);
        }

        form.appendChild(hiddenParamsDiv);

        if (!baseForm) {
            document.body.appendChild(form);
        }
        document.body.appendChild(iframe);

        form.submit();

        if (baseForm) {
            form.removeChild(hiddenParamsDiv);
            if (originalFormAction !== null) {
                form.setAttribute('action', originalFormAction);
            } else {
                form.removeAttribute('action');
            }
        } else {
            form.parentNode.removeChild(form);
        }
    }
    //расширяем namespace
    L.gmxUtil.sendCrossDomainPostRequest = gmxAPIutils.sendCrossDomainPostRequest = sendCrossDomainPostRequest;
})();


var styleCanvasKeys = ['strokeStyle', 'fillStyle', 'lineWidth'],
    styleCanvasKeysLen = styleCanvasKeys.length,
    utils = gmxAPIutils;

var setCanvasStyle = function(prop, indexes, ctx, style) {
    for (var i = 0; i < styleCanvasKeysLen; i++) {
        var key = styleCanvasKeys[i],
            valKey = style[key];
        if (valKey !== ctx[key]) {
            ctx[key] = valKey;
        }
    }
    if (style.dashArray) {
        var dashes = style.dashArray,
            dashOffset = style.dashOffset || 0;
        if ('setLineDash' in ctx) {
            ctx.setLineDash(dashes);
            if (ctx.lineDashOffset !== dashOffset) {
                ctx.lineDashOffset = dashOffset;
            }
        }
    } else if ('getLineDash' in ctx && ctx.getLineDash().length > 0) {
        ctx.setLineDash([]);
    }
    if (ctx.lineCap !== 'round') { ctx.lineCap = 'round'; }
    if (ctx.lineJoin !== 'round') { ctx.lineJoin = 'round'; }

    if (style.canvasPattern) {
        ctx.fillStyle = ctx.createPattern(style.canvasPattern.canvas, 'repeat');
    } else if (style.fillLinearGradient) {
        var rgr = style.fillLinearGradient,
            x1 = rgr.x1Function ? rgr.x1Function(prop, indexes) : rgr.x1,
            y1 = rgr.y1Function ? rgr.y1Function(prop, indexes) : rgr.y1,
            x2 = rgr.x2Function ? rgr.x2Function(prop, indexes) : rgr.x2,
            y2 = rgr.y2Function ? rgr.y2Function(prop, indexes) : rgr.y2,
            lineargrad = ctx.createLinearGradient(x1, y1, x2, y2);
        for (var j = 0, len = rgr.addColorStop.length; j < len; j++) {
            var arr1 = rgr.addColorStop[j],
                arrFunc = rgr.addColorStopFunctions[j],
                p0 = (arrFunc[0] ? arrFunc[0](prop, indexes) : arr1[0]),
                p2 = (arr1.length < 3 ? 100 : (arrFunc[2] ? arrFunc[2](prop, indexes) : arr1[2])),
                p1 = utils.dec2color(arrFunc[1] ? arrFunc[1](prop, indexes) : arr1[1], p2 > 1 ? p2 / 100 : p2);
            lineargrad.addColorStop(p0, p1);
        }
        ctx.fillStyle = style.fillStyle = lineargrad;
    }
};

/*
geoItem
     properties: объект (в формате векторного тайла)
     dataOption: дополнительные свойства объекта
item
     skipRasters: скрыть растр
     currentStyle: текущий canvas стиль объекта
     parsedStyleKeys: стиль прошедший парсинг
options
     ctx: canvas context
     tbounds: tile bounds
     tpx: X смещение тайла
     tpy: Y смещение тайла
     gmx: ссылка на layer._gmx
        gmx.currentZoom
        gmx.lastHover
        gmx.tileAttributeIndexes
     bgImage: растр для background
     rasters: растры по объектам для background
currentStyle
    текущий стиль
style
    стиль в новом формате
    style.image - для type='image' (`<HTMLCanvasElement || HTMLImageElement>`)
*/
L.gmxUtil.drawGeoItem = function(geoItem, item, options, currentStyle, style) {
    var propsArr = geoItem.properties,
        idr = propsArr[0],
        i, len, j, len1,
        gmx = options.gmx,
        ctx = options.ctx,
        geom = propsArr[propsArr.length - 1],
        coords = null,
        dataOption = geoItem.dataOption,
        rasters = options.rasters || {},
        tbounds = options.tbounds;

    item.currentStyle = L.extend({}, currentStyle);
    if (style) {
        if (gmx.styleHook) {
            if (!geoItem.styleExtend) {
                geoItem.styleExtend = gmx.styleHook(item, gmx.lastHover && idr === gmx.lastHover.id);
            }
            if (geoItem.styleExtend) {
                item.currentStyle = L.extend(item.currentStyle, geoItem.styleExtend);
            } else {
                return false;
            }
        }
        setCanvasStyle(propsArr, gmx.tileAttributeIndexes, ctx, item.currentStyle);
    } else {
        style = {};
    }

    var geoType = geom.type,
        dattr = {
            gmx: gmx,
            item: item,
            style: style,
            styleExtend: geoItem.styleExtend || {},
            ctx: ctx,
            tpx: options.tpx,
            tpy: options.tpy
        };
    if (geoType === 'POINT') {
        dattr.pointAttr = utils.getPixelPoint(dattr, geom.coordinates);
        if (!dattr.pointAttr) { return false; }   // point not in canvas tile
    }
    if (geoType === 'POINT' || geoType === 'MULTIPOINT') { // Отрисовка геометрии точек
        coords = geom.coordinates;
        if ('iconColor' in style && style.image) {
            if (style.lastImage !== style.image) {
                style.lastImage = style.image;
                style.lastImageData = utils.getImageData(style.image);
            }
            dattr.imageData = style.lastImageData;
        }

        if (geoType === 'MULTIPOINT') {
            for (i = 0, len = coords.length; i < len; i++) {
                dattr.coords = coords[i];
                utils.pointToCanvas(dattr);
            }
        } else {
            dattr.coords = coords;
            utils.pointToCanvas(dattr);
        }
    } else if (geoType === 'POLYGON' || geoType === 'MULTIPOLYGON') {
        if (style.image) { // set MULTIPOLYGON as marker
            dattr.coords = [(dataOption.bounds.min.x + dataOption.bounds.max.x) / 2, (dataOption.bounds.min.y + dataOption.bounds.max.y) / 2];
            dattr.pointAttr = utils.getPixelPoint(dattr, dattr.coords);
            if (dattr.pointAttr) {
                utils.pointToCanvas(dattr);
            }
        } else {
            coords = geom.coordinates;
            if (geoType === 'POLYGON') { coords = [coords]; }

            var hiddenLines = dataOption.hiddenLines || [],
                pixelsMap = dataOption.pixels,
                flagPixels = true;

            if (!pixelsMap || pixelsMap.z !== gmx.currentZoom) {
                pixelsMap = dataOption.pixels = utils.getCoordsPixels({
                    gmx: gmx,
                    coords: coords,
                    tpx: options.tpx,
                    tpy: options.tpy,
                    hiddenLines: hiddenLines
                });
            }

            var coordsToCanvas = function(func, flagFill) {
                coords = pixelsMap.coords;
                hiddenLines = pixelsMap.hidden || [];
                dattr.flagPixels = flagPixels;
                for (i = 0, len = coords.length; i < len; i++) {
                    var coords1 = coords[i];
                    var hiddenLines1 = hiddenLines[i] || [];
                    ctx.beginPath();
                    for (j = 0, len1 = coords1.length; j < len1; j++) {
                        dattr.coords = coords1[j];
                        dattr.hiddenLines = hiddenLines1[j] || [];
                        func(dattr);
                    }
                    ctx.closePath();
                    if (flagFill) { ctx.fill(); }
                }
            };
            var strokeStyle = item.currentStyle.strokeStyle || style.strokeStyle,
                lineWidth = item.currentStyle.lineWidth || style.lineWidth;
            if (strokeStyle && lineWidth) {
                coordsToCanvas(utils.polygonToCanvas);
            }
            if (options.bgImage) {
                dattr.bgImage = options.bgImage;
            } else if (rasters[idr]) {
                dattr.bgImage = rasters[idr];
            }
            if (dattr.styleExtend.skipRasters || item.skipRasters) {
                delete dattr.bgImage;
            }
            if (style.imagePattern) {
                item.currentStyle.fillStyle = ctx.createPattern(style.imagePattern, 'repeat');
            } else if (dattr.bgImage && tbounds.intersectsWithDelta(dataOption.bounds, -1, -1)) {
                if (utils.isPatternNode(dattr.bgImage)) {
                    if ('rasterOpacity' in gmx) { ctx.globalAlpha = gmx.rasterOpacity; }
                    ctx.fillStyle = ctx.createPattern(dattr.bgImage, 'no-repeat');
                    style.bgImage = true;
                }
                coordsToCanvas(utils.polygonToCanvasFill, true);
                ctx.globalAlpha = 1;
            }
            if (item.currentStyle.fillStyle || item.currentStyle.canvasPattern) {
                ctx.fillStyle = item.currentStyle.canvasPattern || item.currentStyle.fillStyle;
                coordsToCanvas(utils.polygonToCanvasFill, true);
            }
        }
    } else if (geoType === 'LINESTRING' || geoType === 'MULTILINESTRING') {
        coords = geom.coordinates;
        if (geoType === 'LINESTRING') { coords = [coords]; }
        var st = item.currentStyle || item.parsedStyleKeys;
        var isIconPath = st.iconPath || st.iconPath;
        var size = (item.currentStyle.maxSize || item.currentStyle.lineWidth) / gmx.mInPixel;
        for (i = 0, len = coords.length; i < len; i++) {
			if (isIconPath) {
				var arr = tbounds.clipPolyLine(coords[i], true, size);
				for (j = 0, len1 = arr.length; j < len1; j++) {
					dattr.coords = arr[j];
					var pixels = utils.lineToCanvas(dattr);
					if (pixels) {
						ctx.save();
						utils.lineToCanvasAsIcon(pixels, dattr);
						ctx.restore();
					}
				}
			} else {
				dattr.coords = coords[i];
				utils.lineToCanvas(dattr);
			}
        }
    }
    return true;
};


/** Asynchronously request session keys from GeoMixer servers (given apiKey and server host)
*/
var gmxSessionManager = {
    APIKEY_PARAM: 'key',
    SCRIPT_REGEXP: [
		/\bleaflet-geomixer(-\w*)?\.js\b/,
		/\bgeomixer(-\w*)?\.js\b/
	],
    _scriptSearched: false,
    _scriptAPIKey: null,
    _searchScriptAPIKey: function() {
        var _this = this;
        if (this._scriptSearched) {
            return this._scriptAPIKey;
        }

        var scripts = document.getElementsByTagName('script');
        for (var i = 0; i < scripts.length; i++) {
            var src = scripts[i].getAttribute('src'),
				arr = this.SCRIPT_REGEXP;
			for (var j = 0, len = arr.length; j < len; j++) {
				if (arr[j].exec(src)) {
					var query = src.split('?')[1];

					if (query) {
						var params = query.split('&');
						for (var p = 0; p < params.length; p++) {
							var parsedParam = params[p].split('=');
							if (parsedParam[0] === _this.APIKEY_PARAM) {
								_this._scriptAPIKey = parsedParam[1];
								break;
							}
						}
					}
					break;
				}
            }
			if (_this._scriptAPIKey) {
				break;
			}
        }
        this._scriptSearched = true;
        return this._scriptAPIKey;
    },

    //we will search apiKey in script tags iff apiKey parameter is undefined.
    //if it is defined as falsy (null, '', etc), we won't send any requests to server
    requestSessionKey: function(serverHost, apiKey) {
        var keys = this._sessionKeys;

        if (!(serverHost in keys)) {
            apiKey = typeof apiKey === 'undefined' ? this._searchScriptAPIKey() : apiKey;
            keys[serverHost] = new L.gmx.Deferred();
            if (apiKey) {
                gmxAPIutils.requestJSONP(
                    L.gmxUtil.protocol + '//' + serverHost + '/ApiKey.ashx',
                    {
                        WrapStyle: 'func',
                        Key: apiKey
                    }
                ).then(function(response) {
                    if (response && response.Status === 'ok') {
                        keys[serverHost].resolve(response.Result.Key);
                    } else {
                        keys[serverHost].reject();
                    }
                }, keys[serverHost].reject);
            } else {
                keys[serverHost].resolve('');
            }
        }
        return keys[serverHost];
    },

    //get already received session key
    getSessionKey: function(serverHost) {
        var keyPromise = this._sessionKeys[serverHost];

        return keyPromise && keyPromise.getFulfilledData() && keyPromise.getFulfilledData()[0];
    },
    _sessionKeys: {} //deferred for each host
};
L.gmx = L.gmx || {};
L.gmx.gmxSessionManager = gmxSessionManager;


/** Asynchronously request information about map given server host and map name
*/
var gmxMapManager = {
    //serverHost should be host only string like 'maps.kosmosnimki.ru' without any slashes or 'http://' prefixes
    getMap: function(serverHost, apiKey, mapName, skipTiles, srs) {
		return gmxMapManager.loadMapProperties({
			srs: srs,
			hostName: serverHost,
			apiKey: apiKey,
			mapName: mapName,
			skipTiles: skipTiles
		});
    },

	loadMapProperties: function(options) {
        var maps = this._maps,
			serverHost = options.hostName || options.serverHost,
			mapName = options.mapName;

        if (!maps[serverHost] || !maps[serverHost][mapName]) {
			var opt = {
				WrapStyle: 'func',
				skipTiles: options.skipTiles || 'None', // All, NotVisible, None
				MapName: mapName,
				srs: options.srs || '',
				ModeKey: 'map'
			};
			if (options.srs === 3857) { opt.cs = 'wm'; }
            var def = new L.gmx.Deferred();
            maps[serverHost] = maps[serverHost] || {};
            maps[serverHost][mapName] = {promise: def};

            gmxSessionManager.requestSessionKey(serverHost, options.apiKey).then(function(sessionKey) {
				opt.key = sessionKey;

				gmxAPIutils.requestJSONP(L.gmxUtil.protocol + '//' + serverHost + '/TileSender.ashx', opt).then(function(json) {
                    if (json && json.Status === 'ok' && json.Result) {
                        json.Result.properties.hostName = serverHost;
                        def.resolve(json.Result);
                    } else {
                        def.reject(json);
                    }
                }, def.reject);
            }, def.reject);
        }
        return maps[serverHost][mapName].promise;
    },

	syncParams: {},
    // установка дополнительных параметров для серверных запросов
    setSyncParams: function(hash) {
		this.syncParams = hash;
    },
    getSyncParams: function(stringFlag) {
		var res = this.syncParams;
		if (stringFlag) {
			var arr = [];
			for (var key in res) {
				arr.push(key + '=' + res[key]);
			}
			res = arr.join('&');
		}
		return res;
    },

    //we will (lazy) create index by layer name to speed up multiple function calls
    findLayerInfo: function(serverHost, mapID, layerID) {
        var hostMaps = this._maps[serverHost],
            mapInfo = hostMaps && hostMaps[mapID];

        if (!mapInfo) {
            return null;
        }

        if (mapInfo.layers) {
            return mapInfo.layers[layerID];
        }

        var serverData = mapInfo.promise.getFulfilledData();

        if (!serverData) {
            return null;
        }

        mapInfo.layers = {};

        //create index by layer name
        gmxMapManager.iterateLayers(serverData[0], function(layerInfo) {
            mapInfo.layers[layerInfo.properties.name] = layerInfo;
        });

        return mapInfo.layers[layerID];
    },
    iterateLayers: function(treeInfo, callback) {
        var iterate = function(arr) {
            for (var i = 0, len = arr.length; i < len; i++) {
                var layer = arr[i];

                if (layer.type === 'group') {
                    iterate(layer.content.children);
                } else if (layer.type === 'layer') {
                    callback(layer.content);
                }
            }
        };

        treeInfo && iterate(treeInfo.children);
    },
    iterateNode: function(treeInfo, callback) {
        var iterate = function(node) {
			var arr = node.children;
            for (var i = 0, len = arr.length; i < len; i++) {
                var layer = arr[i];

				callback(layer);
                if (layer.type === 'group') {
                    iterate(layer.content);
                }
            }
        };

        treeInfo && iterate(treeInfo);
    },
    _maps: {} //Promise for each map. Structure: maps[serverHost][mapID]: {promise:, layers:}
};

L.gmx.gmxMapManager = gmxMapManager;


//Helper class, that represents layers of single Geomixer's map
//Creates layers from given map description
var gmxMap = L.Class.extend({
    includes: L.Mixin.Events,

    initialize: function(mapInfo, commonLayerOptions) {
		this.layers = [];
		this.layersByTitle = {};
		this.layersByID = {};
		this.dataManagers = {};

		var _this = this;

		this.properties = L.extend({}, mapInfo.properties);
		this.properties.BaseLayers = this.properties.BaseLayers ? JSON.parse(this.properties.BaseLayers) : [];
		this.rawTree = mapInfo;

		this.layersCreated = new L.gmx.Deferred();

		var missingLayerTypes = {},
			dataSources = {};

		gmxMapManager.iterateLayers(mapInfo, function(layerInfo) {
			var props = layerInfo.properties,
				meta = props.MetaProperties || {},
				options = {
					mapID: mapInfo.properties.name,
					layerID: props.name
				};

			props.hostName = mapInfo.properties.hostName;
			if (mapInfo.srs) {
				props.srs = mapInfo.srs;
			}

			var type = props.ContentID || props.type,
				layerOptions = L.extend(options, commonLayerOptions);

			if (props.dataSource || 'parentLayer' in meta) {      	// Set dataSource layer
				layerOptions.parentLayer = props.dataSource || '';
				if ('parentLayer' in meta) {      	// todo удалить после изменений вов вьювере
					layerOptions.parentLayer = meta.parentLayer.Value || '';
				}
				dataSources[options.layerID] = {
					info: layerInfo,
					options: layerOptions
				};
			} else if (type in L.gmx._layerClasses) {
				_this.addLayer(L.gmx.createLayer(layerInfo, layerOptions));
			} else {
				missingLayerTypes[type] = missingLayerTypes[type] || [];
				missingLayerTypes[type].push({
					info: layerInfo,
					options: layerOptions
				});
			}
		});

		//load missing layer types
		var loaders = [];
		for (var type in missingLayerTypes) {
			loaders.push(L.gmx._loadLayerClass(type).then(/*eslint-disable no-loop-func */function (type) {/*eslint-enable */
				var it = missingLayerTypes[type];
				for (var i = 0, len = it.length; i < len; i++) {
					_this.addLayer(L.gmx.createLayer(it[i].info, it[i].options));
				}
			}.bind(null, type)));
		}
		var hosts = {}, host, id, it;
		for (id in dataSources) {
			it = dataSources[id];
			var opt = it.options,
				pId = opt.parentLayer,
				pLayer = this.layersByID[pId];
			if (pLayer) {
				it.options.parentOptions = pLayer.getGmxProperties();
				it.options.dataManager = this.dataManagers[pId] || new DataManager(it.options.parentOptions, true);
				this.dataManagers[pId] = it.options.dataManager;
				this.addLayer(L.gmx.createLayer(it.info, it.options));
			} else {
				host = opt.hostName;
				if (!hosts[host]) { hosts[host] = {}; }
				if (!hosts[host][pId]) { hosts[host][pId] = []; }
				hosts[host][pId].push(id);
			}
		}
		for (host in hosts) {
			var arr = [],
				prefix = L.gmxUtil.protocol + '//' + host;
			for (id in hosts[host]) {
				arr.push({Layer: id});
			}
			loaders.push(L.gmxUtil.requestJSONP(prefix + '/Layer/GetLayerJson.ashx',
				{
					WrapStyle: 'func',
					Layers: JSON.stringify(arr)
				},
				{
					ids: hosts[host]
				}
			).then(function(json, opt) {
				if (json && json.Status === 'ok' && json.Result) {
					json.Result.forEach(function(it) {
						var dataManager = _this.addDataManager(it),
							props = it.properties,
							pId = props.name;
						if (opt && opt.ids && opt.ids[pId]) {
							opt.ids[pId].forEach(function(id) {
								var pt = dataSources[id];
								pt.options.parentOptions = it.properties;
								pt.options.dataManager = dataManager;
								_this.addLayer(L.gmx.createLayer(pt.info, pt.options));
							});
						}
					});
				} else {
					console.info('Error: loading ', prefix + '/Layer/GetLayerJson.ashx', json.ErrorInfo);
					if (opt && opt.ids) {
						for (var pId in opt.ids) {
							opt.ids[pId].forEach(function(id) {
								_this.addLayer(new L.gmx.DummyLayer(dataSources[id].info.properties));
							});
						}
					}
				}
			}));
		}
		L.gmx.Deferred.all.apply(null, loaders).then(this.layersCreated.resolve);
	},

	addDataManager: function(it) {
		var pid = it.properties.name;
		if (!this.dataManagers[pid]) {
			this.dataManagers[pid] = new DataManager(it.properties);
		}
		return this.dataManagers[pid];
	},
	getDataManager: function(id) {
		return this.dataManagers[id];
	},

	addLayer: function(layer) {
		var props = layer.getGmxProperties();

		this.layers.push(layer);
		this.layersByTitle[props.title] = layer;
		this.layersByID[props.name] = layer;
		this.fire('layeradd', {layer: layer});

		return this;
	},

	removeLayer: function(layer) {
		var props = layer.getGmxProperties();

		for (var i = 0; i < this.layers.length; i++) {
			if (this.layers[i].getGmxProperties().name === props.name) {
				this.layers.splice(i, 1);
				break;
			}
		}

		delete this.layersByTitle[props.title];
		delete this.layersByID[props.name];
		this.fire('layerremove', {layer: layer});

		return this;
	},

	addLayersToMap: function(leafletMap) {
		for (var l = this.layers.length - 1; l >= 0; l--) {
			var layer = this.layers[l];
			if (layer.getGmxProperties().visible) {
				leafletMap.addLayer(layer);
			}
		}

		return this;
	}
});
L.gmx = L.gmx || {};
L.gmx.gmxMap = gmxMap;


/*
 * gmxEventsManager - handlers manager
 */
var GmxEventsManager = L.Handler.extend({
    options: {
    },

    initialize: function (map) {
        this._map = map;
        this._layers = {};
        this._lastLayer = null;
        this._lastId = null;
        var _this = this;
        this._drawstart = null;
        this._lastCursor = '';

        var isDrawing = function () {
            if (_this._drawstart) {
                return true;
            } else if (_this._drawstart === null) {
                if (map.gmxControlsManager) {
                    var drawingControl = map.gmxControlsManager.get('drawing');
                    if (drawingControl) {
                        drawingControl.on('activechange', function (ev) {
                            _this._drawstart = ev.activeIcon;
                            map._container.style.cursor = _this._drawstart ? 'pointer' : '';
                        });
                    }
                }
                _this._drawstart = false;
            }
            return false;
        };

        var getDomIndex = function (layer) {
            var container = layer._container;
            if (container) {
                var arr = container.parentNode.childNodes;
                for (var i = 0, len = arr.length; i < len; i++) {
                    if (container === arr[i]) {
                        return i;
                    }
                }
            }
            return 0;
        };

        var skipNodeName = {
            IMG: true,
            DIV: true,
            path: true
        };

        var clearLastHover = function () {
            if (_this._lastLayer) {
                _this._lastLayer.gmxEventCheck({type: 'mousemove'}, true);
                _this._lastLayer = null;
            }
        };

        var eventCheck = function (ev) {
            var type = ev.type,
                map = _this._map,
                skipNode = false;
            if (ev.originalEvent) {
                map.gmxMouseDown = L.Browser.webkit ? ev.originalEvent.which : ev.originalEvent.buttons;
                var target = ev.originalEvent.target;
                skipNode = skipNodeName[target.nodeName] && !L.DomUtil.hasClass(target, 'leaflet-tile') && !L.DomUtil.hasClass(target, 'leaflet-popup-tip-container');
            }
            if (map._animatingZoom ||
                isDrawing() ||
                skipNode ||
                (type === 'click' &&  map._skipClick) ||        // from drawing
                (type === 'mousemove' &&  map.gmxMouseDown)
                ) {
                clearLastHover();
                map._skipClick = false;
                return;
            }
            if (ev.layerPoint) {
                map._gmxMouseLatLng = ev.latlng;
                map.gmxMousePos = map.getPixelOrigin().add(ev.layerPoint);
            }

            var arr = Object.keys(_this._layers).sort(function(a, b) {
                var la = map._layers[a],
                    lb = map._layers[b];
                if (la && lb) {
                    var oa = la.options, ob = lb.options,
                        za = (oa.zIndexOffset || 0) + (oa.zIndex || 0),
                        zb = (ob.zIndexOffset || 0) + (ob.zIndex || 0),
                        delta = zb - za;
                    return delta ? delta : _this._layers[b] - _this._layers[a];
                }
                return 0;
            });

            var layer,
                foundLayer = null,
                cursor = '';

            for (var i = 0, len = arr.length; i < len; i++) {
                var id = arr[i];
                layer = map._layers[id];
                if (layer && layer._map && !layer._animating && layer.options.clickable) {
                    if (layer.gmxEventCheck(ev)) {
                        if (layer.hasEventListeners('mouseover')) {
                            cursor = 'pointer';
                        }
                        foundLayer = layer;
                        break;
                    }
                }
            }
            if (_this._lastCursor !== cursor && !isDrawing()) {
                map._container.style.cursor = cursor;
            }
            _this._lastCursor = cursor;

            if (type !== 'zoomend') {
                if (foundLayer) {
                    if (_this._lastLayer !== foundLayer) {
                        clearLastHover();
                    }
                    _this._lastLayer = foundLayer;
                } else {
                    clearLastHover();
                }
            }
        };

        map.on({
            zoomend: function () {
                if (map._gmxMouseLatLng) {
                    setTimeout(function () {
                        eventCheck({type: 'mousemove', latlng: map._gmxMouseLatLng});
                    }, 0);
                }
            },
            click: eventCheck,
            dblclick: eventCheck,
            mousedown: eventCheck,
            mouseup: eventCheck,
            mousemove: eventCheck,
            contextmenu: eventCheck,
            layeradd: function (ev) {
                var layer = ev.layer;
                if ('gmxEventCheck' in layer && layer.options.clickable) {
                    _this._layers[layer._leaflet_id] = getDomIndex(layer);
                }
            },
            layerremove: function (ev) {
                var id = ev.layer._leaflet_id;
                delete _this._layers[id];
                if (_this._lastLayer && _this._lastLayer._leaflet_id === id) {
                    _this._lastLayer = null;
                    _this._lastId = 0;
                }
            }
        }, this);
    }
});

L.Map.addInitHook(function () {
    // Check to see if handler has already been initialized.
    if (!this._gmxEventsManager) {
        this._gmxEventsManager = new GmxEventsManager(this);
		this.isGmxDrawing = function () {
			return this._gmxEventsManager._drawstart;
		};

        this.on('remove', function () {
            if (this._gmxEventsManager) {
                this._gmxEventsManager.removeHooks();
            }
        });
    }
});


(function() {
    var DEFAULT_LANGUAGE = 'rus',
        _setKeyText = function(lang, key, item, hash) {
            if (!hash[lang]) { hash[lang] = {}; }
            hash[lang][key] = item;
        };
    L.gmxLocale = {

        setLanguage: function(lang) {
            this._language = lang;
        },

        getLanguage: function() {
            return window.language || this._language || DEFAULT_LANGUAGE;
        }
    };

    L.gmxLocaleMixin = {
        addText: function() {
            var lang = arguments[0],
                newHash = arguments[1];
            if (arguments.length === 1) {
                newHash = lang;
                lang = null;
            }
            for (var k in newHash) {
                if (lang === null) {
                    for (var k1 in newHash[k]) {
                        _setKeyText(k, k1, newHash[k][k1], this);
                    }
                } else {
                    _setKeyText(lang, k, newHash[k], this);
                }
            }
            return this;
        },

        getText: function(key) {
            var lang = L.gmxLocale.getLanguage(),
                locale = this[lang] || {};

            var keyArr = key ? key.split(/\./) : [];
            for (var i = 0, len = keyArr.length; i < len; i++) {
                if (!locale) { break; }
                locale = locale[keyArr[i]];
            }
            return locale;
        }
    };
    L.extend(L.gmxLocale, L.gmxLocaleMixin);
})();


L.extend(L.gmxLocale, {
    rus: {
        Coordinates : 'Координаты',
        Length : 'Длина',
        nodeLength : 'Длина от начала',
        edgeLength : 'Длина сегмента',
        Area : 'Площадь',
        Perimeter : 'Периметр',
        units: {
            m: 'м',
            nm: 'м.мили',
            km: 'км',
            m2: 'кв. м',
            km2: 'кв. км',
            ha: 'га',
            m2html: 'м<sup>2',
            km2html: 'км<sup>2'
        }
    }
});


L.extend(L.gmxLocale, {
    eng: {
        Coordinates : 'Coordinates',
        Length : 'Length',
        nodeLength : 'From start point',
        edgeLength : 'Segment length',
        Area : 'Area',
        Perimeter : 'Perimeter',
        units: {
            m: 'm',
            nm: 'nmi',
            km: 'km',
            m2: 'sq. m',
            km2: 'sq. km',
            ha: 'ha',
            m2html: 'm<sup>2',
            km2html: 'km<sup>2'
        }
    }
});


var gmxVectorTileLoader = {
    _loadedTiles: {},
    _getKey: function(ti) {
        return [ti.layerID, ti.x, ti.y, ti.z, typeof ti.d === 'undefined' ? -1 : ti.d, typeof ti.s === 'undefined' ? -1 : ti.s, ti.v].join(':');
    },
    load: function(tileSenderPrefix, tileInfo) {
        var key = gmxVectorTileLoader._getKey(tileInfo);

        if (!this._loadedTiles[key]) {
            var def = new L.gmx.Deferred();
            this._loadedTiles[key] = def;

            var requestParams = {
                ModeKey: 'tile',
                r: 'j',
                LayerName: tileInfo.layerID,
                z: tileInfo.z,
                x: tileInfo.x,
                y: tileInfo.y,
                v: tileInfo.v
            };

            if (tileInfo.srs) {
                requestParams.srs = tileInfo.srs;
            }
            if (tileInfo.d !== -1) {
                requestParams.Level = tileInfo.d;
                requestParams.Span = tileInfo.s;
            }

            gmxAPIutils.requestJSONP(tileSenderPrefix, requestParams, {callbackParamName: null}).then(null, function() {
                def.reject();
            });
        }

        return this._loadedTiles[key];
    }
};

window.gmxAPI = window.gmxAPI || {};
window.gmxAPI._vectorTileReceiver = window.gmxAPI._vectorTileReceiver || function(data) {
    var key = gmxVectorTileLoader._getKey({
        layerID: data.LayerName,
        x: data.x,
        y: data.y,
        z: data.z,
        d: data.level,
        s: data.span,
        v: data.v
    });

    gmxVectorTileLoader._loadedTiles[key] && gmxVectorTileLoader._loadedTiles[key].resolve(data.values, data.bbox, data.srs, data.isGeneralized);
};


//Single vector tile, received from GeoMixer server
//  dataProvider: has single method "load": function(x, y, z, v, s, d, callback), which calls "callback" with the following parameters:
//      - {Object[]} data - information about vector objects in tile
//      - {Number[4]} [bbox] - optional bbox of objects in tile
//  options:
//      x, y, z, v, s, d: GeoMixer vector tile point
//      dateZero: zero Date for temporal layers
//      isGeneralized: flag for generalized tile
var VectorTile = function(dataProvider, options) {
    this.dataProvider = dataProvider;
    this.loadDef = new L.gmx.Deferred();
    this.data = null;
    this.dataOptions = null;

    this.x = options.x;
    this.y = options.y;
    this.z = options.z;
    this.v = options.v;
    this.s = options.s || -1;
    this.d = options.d || -1;
    // this._itemsArr = options._itemsArr;
    this.attributes = options.attributes;
    this.isGeneralized = options.isGeneralized;
    this.isFlatten = options.isFlatten;
    this.bounds = gmxAPIutils.getTileBounds(this.x, this.y, this.z);
    this.gmxTilePoint = {x: this.x, y: this.y, z: this.z, s: this.s, d: this.d};
    this.vectorTileKey = VectorTile.makeTileKey(this.x, this.y, this.z, this.v, this.s, this.d);

    if (this.s >= 0 && options.dateZero) {
        this.beginDate = new Date(options.dateZero.valueOf() + this.s * this.d * gmxAPIutils.oneDay * 1000);
        this.endDate = new Date(options.dateZero.valueOf() + (this.s + 1) * this.d * gmxAPIutils.oneDay * 1000);
    }

    this.state = 'notLoaded'; //notLoaded, loading, loaded
};

VectorTile.prototype = {
    addData: function(data, keys) {

        if (keys) {
            this.removeData(keys, true);
        }

        var len = data.length,
            dataOptions = new Array(len),
            dataBounds = gmxAPIutils.bounds();
        for (var i = 0; i < len; i++) {
            var dataOption = this._parseItem(data[i]);
            dataOptions[i] = dataOption;
            dataBounds.extendBounds(dataOption.bounds);
        }

        if (!this.data) {
            this.data = data;
            this.dataOptions = dataOptions;
        } else {
            this.data = this.data.concat(data);
            this.dataOptions = this.dataOptions.concat(dataOptions);
        }

        this.state = 'loaded';

        this.loadDef.resolve(this.data);
        return dataBounds;
    },

    removeData: function(keys) {
        for (var arr = this.data || [], i = arr.length - 1; i >= 0; i--) {
            if (keys[arr[i][0]]) {
                arr.splice(i, 1);
                if (this.dataOptions) { this.dataOptions.splice(i, 1); }
            }
        }
    },

    load: function() {
        if (this.state === 'notLoaded') {
            this.state = 'loading';
            var _this = this;
            this.dataProvider.load(_this.x, _this.y, _this.z, _this.v, _this.s, _this.d, function(data, bbox, srs, isGeneralized) {
                _this.bbox = bbox;
                _this.srs = srs;
                if (isGeneralized) { _this.isGeneralized = isGeneralized; }
                _this.addData(data);
            });
        }

        return this.loadDef;
    },

    clear: function() {
        this.state = 'notLoaded';
        this.data = null;
        this.dataOptions = null;

        this.loadDef = new L.gmx.Deferred();
    },

    // TODO: Для упаковки атрибутов
	// _getLinkProp: function(nm, val) {
		// var attr = this.attributes,
			// name = attr[nm - 1],
			// arr = this._itemsArr[name],
			// len = arr.length,
			// i = 0;

		// for (; i < len; i++) {
			// if (val === arr[i]) { return i; }
		// }
		// arr[i] = val;
		// return i;
    // },

    _parseItem: function(it) {
        var len = it.length - 1,
			// props = new Uint32Array(len),
			i;

        // props[0] = it[0];
		// TODO: old properties null = ''
        for (i = 1; i < len; i++) {
            if (it[i] === null) { it[i] = ''; }
			// props[i] = this._getLinkProp(i, it[i]);
        }

        var geo = it[len],
            needFlatten = this.isFlatten,
            type = geo.type,
            isLikePolygon = type.indexOf('POLYGON') !== -1 || type.indexOf('Polygon') !== -1,
            isPolygon = type === 'POLYGON' || type === 'Polygon',
            coords = geo.coordinates,
            hiddenLines = [],
            bounds = null,
            boundsArr = [];

        if (isLikePolygon) {
            if (isPolygon) { coords = [coords]; }
            bounds = gmxAPIutils.bounds();
            var edgeBounds = gmxAPIutils.bounds().extendBounds(this.bounds).addBuffer(-0.05),
                hiddenFlag = false;
            for (i = 0, len = coords.length; i < len; i++) {
                var arr = [],
                    hiddenLines1 = [];

                for (var j = 0, len1 = coords[i].length; j < len1; j++) {
                    if (needFlatten && typeof coords[i][j][0] !== 'number') {
                        coords[i][j] = gmxAPIutils.flattenRing(coords[i][j]);
                    }
                    var b = gmxAPIutils.bounds(coords[i][j]);
                    arr.push(b);
                    if (j === 0) { bounds.extendBounds(b); }
                    // EdgeLines calc
                    var edgeArr = gmxAPIutils.getHidden(coords[i][j], edgeBounds);
                    hiddenLines1.push(edgeArr);
                    if (edgeArr.length) {
                        hiddenFlag = true;
                    }
                }
                boundsArr.push(arr);
                hiddenLines.push(hiddenLines1);
            }
            if (!hiddenFlag) { hiddenLines = null; }
            if (isPolygon) { boundsArr = boundsArr[0]; }
        } else if (type === 'POINT' || type === 'Point') {
            bounds = gmxAPIutils.bounds([coords]);
        } else if (type === 'MULTIPOINT' || type === 'MultiPoint') {
            bounds = gmxAPIutils.bounds();
            for (i = 0, len = coords.length; i < len; i++) {
                bounds.extendBounds(gmxAPIutils.bounds([coords[i]]));
            }
        } else if (type === 'LINESTRING' || type === 'LineString') {
            bounds = gmxAPIutils.bounds(coords);
        } else if (type === 'MULTILINESTRING' || type === 'MultiLineString') {
            bounds = gmxAPIutils.bounds();
            for (i = 0, len = coords.length; i < len; i++) {
                bounds.extendBounds(gmxAPIutils.bounds(coords[i]));
            }
        }
        var dataOption = {
            // props: props,
            bounds: bounds,
            boundsArr: boundsArr
        };
        if (hiddenLines) {
            dataOption.hiddenLines = hiddenLines;
        }
        return dataOption;
    }
};
//class methods

VectorTile.makeTileKey = function(x, y, z, v, s, d) {
    return z + '_' + x + '_' + y + '_' + v + '_' + s + '_' + d;
};

VectorTile.createTileKey = function(opt) {
    return [opt.z, opt.x, opt.y, opt.v, opt.s, opt.d].join('_');
};

VectorTile.parseTileKey = function(gmxTileKey) {
    var p = gmxTileKey.split('_').map(function(it) { return Number(it); });
    return {z: p[0], x: p[1], y: p[2], v: p[3], s: p[4], d: p[5]};
};

VectorTile.boundsFromTileKey = function(gmxTileKey) {
    var p = VectorTile.parseTileKey(gmxTileKey);
    return gmxAPIutils.getTileBounds(p.x, p.y, p.z);
};


//Single observer with vector data
var Observer = L.Class.extend({
    includes: L.Mixin.Events,
    /* options : {
            type: 'resend | update',    // `resend` - send all data (like screen tile observer)
                                        // `update` - send only changed data
            callback: Func,             // will be called when layer's data for this observer is changed
            dateInterval: [dateBegin,dateEnd], // temporal interval
            bbox: bbox,                 // bbox to observe on Mercator
            filters: [String]           // filter keys array
            active: [Boolean=true]      // is this observer active
            layerID: String           	// ID слоя view
			target: String				// ключ назначения обсервера
            targetZoom: [Number]        // for zoom generalized type default(null)
            needBbox: [Boolean=false]   // режим запросов списка тайлов по BBOX
        }
    */
    initialize: function(options) {
        this.type = options.type || 'update';
        this._callback = options.callback;
        this.layerID = options.layerID;
        this.target = options.target;
        this.itemHook = options.itemHook;	// set hook for item (set empty data for callback function)
        this._items = null;
        this.bbox = options.bbox;      		// set bbox by Mercator bounds
        this.needBbox = options.needBbox;   // режим запросов списка тайлов по BBOX
        this.filters = options.filters || [];
        this.targetZoom = options.targetZoom || null;
        this.active = 'active' in options ? options.active : true;
        this.srs = options.srs || '3395';	// '3857'

        if (options.bounds) {   // set bbox by LatLngBounds
            this.setBounds(options.bounds);
        }

		var w = gmxAPIutils.worldWidthMerc,
			dx;
        if (!this.bbox) {
            this.bbox = gmxAPIutils.bounds([[-w, -w], [w, w]]);
            this.world = true;
        } else if (this.bbox.max.x > w) {
			dx = this.bbox.max.x - w;
            this.bbox1 = gmxAPIutils.bounds([[dx - w, this.bbox.max.y], [-(dx + w), this.bbox.min.y]]);
        } else if (this.bbox.min.x < -w) {
			dx = this.bbox.min.x + w;
            this.bbox1 = gmxAPIutils.bounds([[dx + w, this.bbox.max.y], [w - dx, this.bbox.min.y]]);
        }

        if (options.dateInterval) {
            this._setDateInterval(options.dateInterval[0], options.dateInterval[1]);
        }
    },

    hasFilter: function(filterName) {
        for (var i = 0, len = this.filters.length; i < len; i++) {
            if (this.filters[i] === filterName) {
                return true;
            }
        }
        return false;
    },

    activate: function() {
        if (!this.active) {
            this.active = true;
            this.fire('activate');
        }
        return this;
    },

    deactivate: function() {
        if (this.active) {
            this.active = false;
            this.fire('activate');
        }
        return this;
    },

    toggleActive: function(isActive) {
        return isActive ? this.activate() : this.deactivate();
    },

    isActive: function() {
        return this.active;
    },

    updateData: function(data) {
        var len = data.length,
            out = {count: len};

        if (this.type === 'update') {
            //calculate difference with previous data
            if (!this._items) { this._items = {}; }
            var prevItems = this._items,
                newItems = {},
                added = [],
                removed = [],
                key;

            for (var i = 0; i < len; i++) {
                var it = data[i];

                key = it.id + '_' + it.tileKey;

                newItems[key] = it;

                if (!prevItems[key]) {
                    added.push(it);
                }
            }

            for (key in prevItems) {
                if (!newItems[key]) {
                    removed.push(prevItems[key]);
                }
            }

            if (added.length) {
                out.added = added;
            }
            if (removed.length) {
                out.removed = removed;
            }

            this._items = newItems;

        } else {
            out.added = data;
        }
		this.fire('data', {data: this._callback(out)});
        out = null;
        data = null;

        return this;
    },

    removeData: function(keys) {
        if (this.type !== 'update' || !this._items) {
            return this;
        }

        var items = this._items,
            removed = [];

        for (var id in keys) {
            if (items[id]) {
                removed.push(items[id]);
                delete items[id];
            }
        }

        if (removed.length) {
            this._callback({removed: removed});
        }

        return this;
    },

    /*setFilter: function (func) {
        this._filters.userFilter = func;
        this.fire('update');
        return this;
    },

    removeFilter: function () {
        delete this._filters.userFilter;
        this.fire('update');
        return this;
    },*/

    setBounds: function(bounds, buffer) {
        var w;
        if (!bounds) {
            if (!this.world) {
                w = gmxAPIutils.worldWidthMerc;
                this.bbox = gmxAPIutils.bounds([[-w, -w], [w, w]]);
                this.bbox1 = null;
                this.world = true;
                this.fire('update');
            }
            return this;
        }

        var min = bounds.min,
            max = bounds.max;
        if (!min || !max) {
            var latLngBounds = L.latLngBounds(bounds),
                sw = latLngBounds.getSouthWest(),
                ne = latLngBounds.getNorthEast();
            min = {x: sw.lng, y: sw.lat};
            max = {x: ne.lng, y: ne.lat};
        }
        var minX = min.x, maxX = max.x,
            minY = min.y, maxY = max.y,
            minX1 = null,
            maxX1 = null;

        this.world = false;
        w = (maxX - minX) / 2;
        if (w >= 180) {
            minX = -180; maxX = 180;
            this.world = true;
        } else if (maxX > 180 || minX < -180) {
            var center = ((maxX + minX) / 2) % 360;
            if (center > 180) { center -= 360; }
            else if (center < -180) { center += 360; }
            minX = center - w; maxX = center + w;
            if (minX < -180) {
                minX1 = minX + 360; maxX1 = 180; minX = -180;
            } else if (maxX > 180) {
                minX1 = -180; maxX1 = maxX - 360; maxX = 180;
            }
        }
		var crs = this.srs === '3857' ? L.CRS.EPSG3857 : L.Projection.Mercator,
			m1 = crs.project(L.latLng(minY, minX)),
			m2 = crs.project(L.latLng(maxY, maxX));

		this.bbox = gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]);
		if (buffer) { this.bbox.addBuffer(buffer); }
        this.bbox1 = null;
        if (minX1) {
            m1 = crs.project(L.latLng(minY, minX1));
            m2 = crs.project(L.latLng(maxY, maxX1));
            this.bbox1 = gmxAPIutils.bounds([[m1.x, m1.y], [m2.x, m2.y]]);
			if (buffer) { this.bbox1.addBuffer(buffer); }
        }

        this.fire('update');
        return this;
    },

    intersects: function(bounds) {
        return this.world || this.bbox.intersects(bounds) || !!(this.bbox1 && this.bbox1.intersects(bounds));
    },

    intersectsWithTile: function(tile) {
        if (this.targetZoom && !this.needBbox) {
            var z = this.targetZoom + (this.targetZoom % 2 ? 1 : 0);
            if ((tile.isGeneralized && tile.z !== z) || tile.z > z) { return false; }
        }
        var di = this.dateInterval;
        return this.intersects(tile.bounds) && (!tile.beginDate || (di && di.endDate >= tile.beginDate && di.beginDate <= tile.endDate));
    },

    intersectsWithGeometry: function(geometry) {
        var type = geometry.type.toUpperCase(),
			coords = geometry.coordinates;
		if (type === 'POINT') {
			return this.world || this.bbox.contains(coords) || !!(this.bbox1 && this.bbox1.contains(coords));
		} else if (type === 'POLYGON') {
			coords = [coords[0]];
		} else if (type === 'MULTIPOLYGON') {
			coords = coords.map(function(arr) { return arr[0]; });
        } else if (type === 'LINESTRING') {
			coords = [coords];
        // } else if (type === 'MULTILINESTRING') {
		}
		for (var i = 0, len = coords.length; i < len; i++) {
			if (this.bbox.clipPolygon(coords[i]).length || (this.bbox1 && this.bbox1.clipPolygon(coords[i]).length)) {
				return true;
			}
		}
		return false;
    },

    _setDateInterval: function(beginDate, endDate) {
        if (beginDate && endDate) {
            // var beginValue = beginDate.valueOf(),
                // endValue = endDate.valueOf();
            this.dateInterval = {
                beginDate: beginDate,
                endDate: endDate
            };
        } else {
            this.dateInterval = null;
        }
    },

    setDateInterval: function(beginDate, endDate) {
        var isValid = beginDate && endDate;

        if (!this.dateInterval !== !isValid ||
            isValid && (
                this.dateInterval.beginDate.valueOf() !== beginDate.valueOf() ||
                this.dateInterval.endDate.valueOf() !== endDate.valueOf()
            )
        ) {
            this._setDateInterval(beginDate, endDate);
            this.fire('update', {temporalFilter: true});
        }
        return this;
    }
});
L.gmx.observer = function(options) {
    return new Observer(options);
};


(function() {
//tree for fast tiles selection inside temporal interval
//  options:
//      TemporalTiles: tilePoints array
//      TemporalVers: tiles version array
//      TemporalPeriods: periods
//      ZeroDate: start Date
var TilesTree = function(options) {
    var _rootNodes = [],
        tiles = options.TemporalTiles || [],
        vers = options.TemporalVers || [],
        periods = options.TemporalPeriods || [],
        maxPeriod = periods[periods.length - 1],
        smin = Number.MAX_VALUE,
        arr = options.ZeroDate.split('.'),
        zn = new Date(
            (arr.length > 2 ? arr[2] : 2008),
            (arr.length > 1 ? arr[1] - 1 : 0),
            (arr.length > 0 ? arr[0] : 1)
        ),
        dateZero = new Date(zn.getTime()  - zn.getTimezoneOffset() * 60000),
        zeroUT = dateZero.getTime() / 1000;

    this.dateZero = dateZero;

    var addTile = function (node, tile, key) {
        var d = node.d;
        if (tile.d === periods[d]) {
            node.count++;
            node.tiles.push(key);
            return;
        }

        var pd = periods[d - 1],
            childrenCount = periods[d] / pd;

        if (!('children' in node)) {
            node.children = new Array(childrenCount);
        }

        var sChild = Math.floor(tile.s * tile.d / pd),
            ds = sChild - node.s * childrenCount;

        if (!node.children[ds]) {
            var pdOneDay = pd * gmxAPIutils.oneDay,
                t1 = sChild * pdOneDay + zeroUT;
            node.children[ds] = {
                d: d - 1,
                s: sChild,
                t1: t1,
                t2: t1 + pdOneDay,
                count: 0,
                children: [],
                tiles: []
            };
        }

        addTile(node.children[ds], tile, key);
    };

    var dmax = periods.length - 1,
        dmaxOneDay = periods[dmax] * gmxAPIutils.oneDay,
        i, len;

    for (i = 0, len = tiles.length; i < len; i++) {
        arr = tiles[i];
        var s = Number(arr[1]),
            d = Number(arr[0]);

        if (d === maxPeriod) {
            smin = Math.min(smin, s);
        }
    }
    for (i = 0, len = tiles.length; i < len; i++) {
        arr = tiles[i];
        var t = {
            x: Number(arr[2]),
            y: Number(arr[3]),
            z: Number(arr[4]),
            v: Number(vers[i]),
            s: Number(arr[1]),
            d: Number(arr[0])
        };
        if (t.d < 0) {
            continue;
        }

        var ds = Math.floor(t.s * t.d / periods[dmax]) - smin,
            cs = ds + smin;

        _rootNodes[ds] = _rootNodes[ds] || {
            d: dmax,
            s: cs,
            t1: cs * dmaxOneDay + zeroUT,
            t2: (cs + 1) * dmaxOneDay + zeroUT,
            count: 0,
            tiles: []
        };
        var key = VectorTile.createTileKey(t);

        addTile(_rootNodes[ds], t, key);
    }
    tiles = vers = null;

    //options: bounds (in mercator projection)
    this.selectTiles = function(t1, t2, options) {

        options = options || {};

        var t1Val = t1.valueOf() / 1000,
            t2Val = t2.valueOf() / 1000;

        // We will restrict tile levels by the nearest two levels to target date interval length
        // For example, if date interval length is 3 days, we wll search tiles among 1-day and 4-day tiles
        var minLevel = 0,
            dateIntervalLength = (t2Val - t1Val) / 3600 / 24;

        for (var i = 0; i < periods.length; i++) {
            if (periods[i] > dateIntervalLength) {
                minLevel = Math.max(0, i - 1);
                break;
            }
        }

        if (periods[periods.length - 1] <= dateIntervalLength) {
            minLevel = periods.length - 1;
        }

        var maxLevel = Math.min(periods.length - 1, minLevel + Number(dateIntervalLength > periods[minLevel]));

        var getCountOfIntersected = function(tileBounds, bounds) {
            var count = 0;
            for (var t = 0; t < tileBounds.length; t++) {
                if (tileBounds[t].intersects(bounds)) {
                    count++;
                }
            }

            return count;
        };

        // --------------------
        var selectTilesForNode = function(node, t1, t2) {
            if (t1 >= node.t2 || t2 <= node.t1) {
                return {count: 0, tiles: [], nodes: []};
            }

            if (options.bounds && !node.tileBounds) {
                node.tileBounds = node.tiles.map(function(it) {
                    return VectorTile.boundsFromTileKey(it);
                });
            }

            if (node.d === minLevel) {
                var count = options.bounds ? getCountOfIntersected(node.tileBounds, options.bounds) : node.count;
                return {
                    tiles: node.tiles,
                    count: count,
                    nodes: [node]
                };
            }

            var childrenCount = 0, //number of tiles if we use shorter intervals
                childrenRes = [],
				len = node.children ? node.children.length : 0,
                ds;

            for (ds = 0; ds < len; ds++) {
                if (node.children[ds]) {
                    childrenRes[ds] = selectTilesForNode(node.children[ds], Math.max(t1, node.t1), Math.min(t2, node.t2));
                } else {
                    childrenRes[ds] = {count: 0, tiles: [], nodes: []};
                }
                childrenCount += childrenRes[ds].count;
            }

            var intersectCount = options.bounds ? getCountOfIntersected(node.tileBounds, options.bounds) : node.count;

            if (node.d > maxLevel || childrenCount < intersectCount) {
                var resTilesArr = [],
                    resNodesArr = [];
                for (ds = 0; ds < childrenRes.length; ds++) {
                    resNodesArr.push(childrenRes[ds].nodes);
                    resTilesArr.push(childrenRes[ds].tiles);
                }

                return {
                    tiles: [].concat.apply([], resTilesArr),
                    count: childrenCount,
                    nodes: [].concat.apply([], resNodesArr)
                };
            } else {
                return {
                    tiles: node.tiles,
                    count: intersectCount,
                    nodes: [node]
                };
            }
        };

        var resTiles = [];
        for (var ds = 0; ds < _rootNodes.length; ds++) {
            if (_rootNodes[ds]) {
                var nodeSelection = selectTilesForNode(_rootNodes[ds], t1Val, t2Val);
                if (nodeSelection.tiles.length) {
                    resTiles = resTiles.concat(nodeSelection.tiles);
                }
            }
        }

        var resTilesHash = {};
        for (var t = 0; t < resTiles.length; t++) {
            resTilesHash[resTiles[t]] = true;
        }

        return {tiles: resTilesHash};
    };

    this.getNode = function(d, s) {
        if (d < 0 || s < 0) {
            return null;
        }

        var findNode = function(node, d, s) {
            if (!node) { return null; }

            if (periods[node.d] === d) {
                return node.s === s ? node : null;
            }

            var childrenCount = periods[node.d] / periods[node.d - 1];
            var sChild = Math.floor(s * d / periods[node.d - 1]);
            var ds = sChild - node.s * childrenCount;

            return node.children[ds] ? findNode(node.children[ds], d, s) : null;
        };

        for (var ds = 0; ds < _rootNodes.length; ds++) {
            var node = findNode(_rootNodes[ds], d, s);
            if (node) {
                return node;
            }
        }

        return null;
    };
};
L.gmx.tilesTree = function(options) {
    return new TilesTree(options);
};
})();


var ObserverTileLoader = L.Class.extend({
    includes: L.Mixin.Events,
    initialize: function(dataManager) {
        this._dataManager = dataManager;
        this._observerData = {};
        this._tileData = {};
    },

    addObserver: function(observer) {
        this._observerData[observer.id] = {
            observer: observer,
            tiles: {},
            leftToLoad: 0,
            loadingState: false //are we loading any tiles for this observer?
        };

        observer.on('update', this._updateObserver.bind(this, observer));

        this._updateObserver(observer);

        return this;
    },

    removeObserver: function(id) {
        var obsTiles = this._observerData[id].tiles;

        for (var tileId in obsTiles) {
            delete this._tileData[tileId].observers[id];
        }

        delete this._observerData[id];

        return this;
    },

    addTile: function(tile) {
        var leftToLoadDelta = tile.state === 'loaded' ? 0 : 1;
        tile.loadDef.then(this._tileLoadedCallback.bind(this, tile));

        var tileObservers = {};

        for (var key in this._observerData) {
            var obsInfo = this._observerData[key];

            if (obsInfo.observer.intersectsWithTile(tile)) {
                obsInfo.tiles[tile.vectorTileKey] = true;
                obsInfo.leftToLoad += leftToLoadDelta;
                tileObservers[key] = true;
            }
        }

        this._tileData[tile.vectorTileKey] = {
            observers: tileObservers,
            tile: tile
        };

        return this;
    },

    removeTile: function(tileId) {
        var tileData = this._tileData[tileId],
            leftToLoadDelta = tileData.tile.state === 'loaded' ? 0 : 1;

        for (var id in tileData.observers) {
            var observerData = this._observerData[id];
            observerData.leftToLoad -= leftToLoadDelta;
            delete observerData.tiles[tileId];
        }

        delete this._tileData[tileId];

        return this;
    },

    startLoadTiles: function(observer) {

        //force active tile list update
        this._dataManager._getActiveTileKeys();

        var obsData = this._observerData[observer.id];
        if (obsData.leftToLoad === 0) {
            this.fire('observertileload', {observer: observer});
            return this;
        }

        if (!obsData.loadingState) {
            obsData.loadingState = true;
            observer.fire('startLoadingTiles');
        }

        for (var tileId in obsData.tiles) {
            this._tileData[tileId].tile.load();
        }

        return this;
    },

    getTileObservers: function(tileId) {
        return this._tileData[tileId].observers;
    },

    getObserverLoadingState: function(observer) {
        return this._observerData[observer.id].loadingState;
    },

    getObserverLeftToLoad: function(observer) {
        return this._observerData[observer.id].leftToLoad;
    },

    _updateObserver: function(observer) {
        var obsData = this._observerData[observer.id],
            newObserverTiles = {},
            leftToLoad = 0,
            key;

        for (key in this._tileData) {
            var tile = this._tileData[key].tile;
            if (observer.intersectsWithTile(tile)) {
                newObserverTiles[key] = true;
                if (tile.state !== 'loaded') {
                    leftToLoad++;
                }
                this._tileData[key].observers[observer.id] = true;
            }
        }

        for (key in obsData.tiles) {
            if (!(key in newObserverTiles)) {
                delete this._tileData[key].observers[observer.id];
            }
        }

        obsData.tiles = newObserverTiles;
        obsData.leftToLoad = leftToLoad;
    },

    _tileLoadedCallback: function(tile) {
        this.fire('tileload', {tile: tile});

        if (!(tile.vectorTileKey in this._tileData)) {
            return;
        }

        var tileObservers = this._tileData[tile.vectorTileKey].observers;
        for (var id in tileObservers) {
            var obsData = this._observerData[id];
            obsData.leftToLoad--;

            if (obsData.leftToLoad === 0) {
                if (obsData.loadingState) {
                    obsData.loadingState = false;
                    obsData.observer.fire('stopLoadingTiles');
                }
                this.fire('observertileload', {observer: obsData.observer});
            }
        }
    }
});

var DataManager = L.Class.extend({
    includes: L.Mixin.Events,

    options: {
        name: null,                         // layer ID
		srs: '',							// geometry projection (3395 or 3857)
        identityField: '',                  // attribute name for identity items
        attributes: [],                     // attributes names
        attrTypes: [],                      // attributes types
        tiles: null,                        // tiles array for nontemporal data
        tilesVers: null,                    // tiles version array for nontemporal data
        LayerVersion: -1,                   // layer version
        GeoProcessing: null,                // processing data
        Temporal: false,                    // only for temporal data
        TemporalColumnName: '',             // temporal attribute name
        ZeroDate: '01.01.2008',             // 0 date string
        TemporalPeriods: [],                // temporal periods
        TemporalTiles: [],                  // temporal tiles array
        TemporalVers: [],                   // temporal version array
        hostName: 'maps.kosmosnimki.ru',    // default hostName
        sessionKey: '',                     // session key
        isGeneralized: false,               // flag for use generalized tiles
		needBbox: false,               		// flag for get tiles list by BBOX
        isFlatten: false                    // flag for flatten geometry
    },

    setOptions: function(options) {
        this._clearProcessing();
        if (options.GeoProcessing) {
            this.processingTile = this.addData([]);
            this._chkProcessing(options.GeoProcessing);
        }
        L.setOptions(this, options);
        this.optionsLink = options;
        this._isTemporalLayer = this.options.Temporal;

        var tileAttributes = L.gmxUtil.getTileAttributes(this.options);
        this.tileAttributeIndexes = tileAttributes.tileAttributeIndexes;
        this.temporalColumnType = tileAttributes.tileAttributeTypes[this.options.TemporalColumnName];

        var hostName = this.options.hostName,
            sessionKey = this.options.sessionKey;

        if (!sessionKey) {
            sessionKey = L.gmx.gmxSessionManager.getSessionKey(hostName);
        }
        this.tileSenderPrefix = L.gmxUtil.protocol + '//' + hostName + '/' +
            'TileSender.ashx?WrapStyle=None' +
            '&key=' + encodeURIComponent(sessionKey);

        this._needCheckActiveTiles = true;
    },

    _vectorTileDataProviderLoad: function(x, y, z, v, s, d, callback) {
        var _this = this;
        gmxVectorTileLoader.load(
            _this.tileSenderPrefix,
            {x: x, y: y, z: z, v: v, s: s, d: d, srs: this.options.srs, layerID: _this.options.name}
        ).then(callback, function() {
            console.log('Error loading vector tile');
            callback([]);
            _this.fire('chkLayerUpdate', {dataProvider: _this}); //TODO: do we really need event here?
        });
    },

    initialize: function(options, clearVersion) {
        this._tilesTree = null;
        this._activeTileKeys = {};
        this._endDate = null;
        this._beginDate = null;

        this._tiles = {};
        this._filters = {};
        this._filtersView = {};
        this._freeSubscrID = 0;
        this._items = {};
        this._observers = {};

        this._needCheckDateInterval = false;
        this._needCheckActiveTiles = true;

        var _this = this;
        this._vectorTileDataProvider = {
            load: this._vectorTileDataProviderLoad.bind(this)
        };

        this._observerTileLoader = new ObserverTileLoader(this);
        this._observerTileLoader.on('tileload', function(event) {
            var tile = event.tile;
            _this._updateItemsFromTile(tile);

            if (_this._tilesTree) {
                var treeNode = _this._tilesTree.getNode(tile.d, tile.s);
                treeNode && treeNode.count--; //decrease number of tiles to load inside this node
            }
        });

        this._observerTileLoader.on('observertileload', function(event) {
            var observer = event.observer;
            if (observer.isActive()) {
                observer.needRefresh = false;
                observer.updateData(_this.getItems(observer.id));
            }
        });
        this.setOptions(options);
        if (clearVersion) {
			this.options.LayerVersion = -1;
		}
        if (this._isTemporalLayer) {
            this.addFilter('TemporalFilter', function(item, tile, observer) {
                var unixTimeStamp = item.options.unixTimeStamp,
                    dates = observer.dateInterval;
                return dates && unixTimeStamp >= dates.beginDate.valueOf() && unixTimeStamp < dates.endDate.valueOf();
            });
        }
    },

    _getActiveTileKeys: function() {

        this._chkMaxDateInterval();
        if (!this._needCheckActiveTiles) {
            return this._activeTileKeys;
        }

        this._needCheckActiveTiles = false;

		if (this._isTemporalLayer) {
			var newTileKeys = {};
			if (this._beginDate && this._endDate) {
				if (!this._tilesTree) {
					this.initTilesTree();
				}

				/*var commonBounds = L.gmxUtil.bounds();
				for (var obs in this._observers) {
					commonBounds.extendBounds(this._observers[obs].bbox);
				}*/

				newTileKeys = this._tilesTree.selectTiles(this._beginDate, this._endDate).tiles;
			}
			this._updateActiveTilesList(newTileKeys);
		} else {
			this.initTilesList();
		}

        return this._activeTileKeys;
    },

    getViewFilters: function(name, layerID) {
        var out = [];
		name = (name || 'screen');
		for (var key in this._filtersView[layerID]) {
			if (key.indexOf(name) === 0) {
				out.push(key);
			}
		}
        return out;
    },

    _getObserversByFilterName: function(filterName, target) {
        var oKeys = {};
        for (var id in this._observers) {
			var observer = this._observers[id];
			if (observer.hasFilter(filterName)) {
				oKeys[id] = true;
			} else if (target && target === observer.target) {
				observer.filters.push(filterName);
                oKeys[id] = true;
			}
        }
        return oKeys;
    },

    addLayerFilter: function(filterFunc, options) {
        if (options && options.layerID) {
			var	layerID = options.layerID,
				name = options.target || 'screen';

			if (!this._filtersView[layerID]) { this._filtersView[layerID] = {}; }
			if (options.id) { name += '_' + options.id; }

			this._filtersView[layerID][name] = filterFunc;
			this._triggerObservers(this._getObserversByFilterName(name, options.target));
		}
		return this;
    },

    removeLayerFilter: function(options) {
        if (this._filtersView[options.layerID]) {
			var	layerID = options.layerID,
				name = options.target || 'screen';
			if (options.id) { name += '_' + options.id; }

            if (this._filtersView[layerID][name]) {
				var oKeys = this._getObserversByFilterName(name);
				delete this._filtersView[layerID][name];
				this._triggerObservers(oKeys);
			}
        }
		return this;
    },

    addFilter: function(filterName, filterFunc) {
        this._filters[filterName] = filterFunc;
        this._triggerObservers(this._getObserversByFilterName(filterName));
		return this;
    },

    removeFilter: function(filterName) {
        if (this._filters[filterName]) {
            var oKeys = this._getObserversByFilterName(filterName);
            delete this._filters[filterName];
            this._triggerObservers(oKeys);
        }
		return this;
    },

    getItems: function(oId) {
        var resArr = [],
            observer = this._observers[oId];

        if (!observer) {
            return [];
        }

        //add internal filters
        var layerID = observer.layerID,
			_filtersView = this._filtersView[layerID] || {},
			filters = observer.filters.concat('processingFilter');
        this._isTemporalLayer && filters.push('TemporalFilter');

        filters = filters.filter(function(filter) {
            return (filter in this._filters) || (filter in _filtersView);
        }.bind(this));

        var _this = this,
            putData = function(tile) {
                var data = tile.data,
					lastIndex = resArr.length,
					len = data.length;

				resArr.length = lastIndex + len;
                for (var i = 0; i < len; i++) {
                    var dataOption = tile.dataOptions[i];
                    if (!observer.intersects(dataOption.bounds)) { continue; }

                    var it = data[i],
                        id = it[0],
                        item = _this.getItem(id),
						geom = it[it.length - 1],
                        isFiltered = false;

                    for (var f = 0; f < filters.length; f++) {
                        var name = filters[f],
							filterFunc = _this._filters[name] || _filtersView[name];
                        if (filterFunc && !filterFunc(item, tile, observer, geom, dataOption)) {
                            isFiltered = true;
                            break;
                        }
                    }

                    if (!isFiltered) {
						var rItem = {
                            id: id,
                            properties: it,
                            item: item,
                            dataOption: dataOption,
                            tileKey: tile.vectorTileKey
                        };
						if (observer.itemHook) {
							observer.itemHook(rItem);
						} else {
							resArr[lastIndex++] = rItem;
						}
                    }
                }
				resArr.length = lastIndex;
            };
        var activeTileKeys =  this._getActiveTileKeys();
        for (var tkey in activeTileKeys) {
            var tile = _this._tiles[tkey].tile;
            if (tile.data && tile.data.length > 0 && (tile.z === 0 || observer.intersectsWithTile(tile))) {
                putData(tile);
            }
        }

        return resArr;
    },

    _updateItemsFromTile: function(tile) {
        var vectorTileKey = tile.vectorTileKey,
            data = tile.data || [],
            len = data.length,
            geomIndex = data[0] && (data[0].length - 1);

        for (var i = 0; i < len; i++) {
            var it = data[i],
                geom = it[geomIndex],
                id = it[0],
                item = this._items[id];
            if (item) {
                if (!item.processing) {
                    item.properties = it;
                    if (item.type.indexOf('MULTI') === -1) {
                        item.type = 'MULTI' + item.type;
                    }
                } else {
                    tile.data[i] = item.properties;
                }
                delete item.bounds;
                item.currentFilter = null;
            } else {
                item = {
                    id: id,
                    type: geom.type,
                    properties: it,
                    options: {
                        fromTiles: {}
                    }
                };
                this._items[id] = item;
            }
            item.options.fromTiles[vectorTileKey] = i;
            if (tile.isGeneralized) {
                item.options.isGeneralized = true;
            }

            if (this.options.TemporalColumnName) {
                var zn = it[this.tileAttributeIndexes[this.options.TemporalColumnName]];
                item.options.unixTimeStamp = zn * 1000;
            }
        }
        return len;
    },

    getMaxDateInterval: function() {
        this._chkMaxDateInterval();
		return {
			beginDate: this._beginDate,
			endDate: this._endDate
		};
    },

    _chkMaxDateInterval: function() {
        if (this._isTemporalLayer && this._needCheckDateInterval) {
            this._needCheckDateInterval = false;
            var observers = this._observers,
                newBeginDate = null,
                newEndDate = null;
            for (var oId in observers) {
                var observer = observers[oId],
                    dateInterval = observer.dateInterval;

                if (!dateInterval) {
                    continue;
                }

                if (!newBeginDate || dateInterval.beginDate < newBeginDate) {
                    newBeginDate = dateInterval.beginDate;
                }

                if (!newEndDate || dateInterval.endDate > newEndDate) {
                    newEndDate = dateInterval.endDate;
                }
            }
            if (newBeginDate && newEndDate && (this._beginDate !== newBeginDate || this._endDate !== newEndDate)) {
                this._beginDate = newBeginDate;
                this._endDate = newEndDate;
                this._needCheckActiveTiles = true;
            }
        }
    },

    addObserver: function(options, id) {
        id = id || 's' + (++this._freeSubscrID);
        var _this = this,
            observer = new Observer(options);

        observer.id = id;
        observer.needRefresh = true;
        this._observerTileLoader.addObserver(observer);

        observer
            .on('update', function(ev) {
                observer.needRefresh = true;
                if (ev.temporalFilter) {
                    _this._needCheckDateInterval = true;
                }

                _this._waitCheckObservers();
            })
            .on('activate', function() {
                _this.fire('observeractivate');
                _this.checkObserver(observer);
            });

        _this._needCheckDateInterval = true;
        this._observers[id] = observer;
        this._waitCheckObservers();

        if (observer.isActive()) {
            this.fire('observeractivate');
        }

        return observer;
    },

    getActiveObserversCount: function() {
        var count = 0;
        for (var k in this._observers) {
            if (this._observers[k].isActive()) { count++; }
        }
        return count;
    },

    getObserver: function(id) {
        return this._observers[id];
    },

    removeObserver: function(id) {
        if (this._observers[id]) {
            this._observerTileLoader.removeObserver(id);
            var isActive = this._observers[id].isActive();

            delete this._observers[id];

            if (isActive) {
                this.fire('observeractivate');
            }
        }
    },

    getObserverLoadingState: function(observer) {
        return this._observerTileLoader.getObserverLoadingState(observer);
    },

    getObserverLeftToLoad: function(observer) {
        return this._observerTileLoader.getObserverLeftToLoad(observer);
    },

    getTileKeysToLoad: function(beginDate, endDate) {
		var newTileKeys = this._tilesTree.selectTiles(beginDate, endDate).tiles;
        return newTileKeys;
    },

    getItemsBounds: function() {
        if (!this._itemsBounds) {
            this._itemsBounds = gmxAPIutils.bounds();
            for (var id in this._items) {
                var item = this.getItem(id);
                this._itemsBounds.extendBounds(item.bounds);
            }
        }
        return this._itemsBounds;
    },

    //combine and return all parts of geometry
    getItem: function(id) {
        var item = this._items[id];
        if (item && !item.bounds) {
            var fromTiles = item.options.fromTiles,
                arr = [];
            for (var key in fromTiles) {    // get full object bounds
                if (this._tiles[key]) {
                    var num = fromTiles[key],
                        tile = this._tiles[key].tile;
                    if (tile.state === 'loaded' && tile.dataOptions[num]) {
                        arr.push(tile.dataOptions[num].bounds);
                    } else {
                        delete fromTiles[key];
                    }
                }
            }
            if (arr.length === 1) {
                item.bounds = arr[0];
            } else {
                item.bounds = gmxAPIutils.bounds();
                var w = gmxAPIutils.worldWidthMerc;
                for (var i = 0, len = arr.length; i < len; i++) {
                    var it = arr[i];
                    if (item.bounds.max.x - it.min.x > w) {
                        it = gmxAPIutils.bounds([
                            [it.min.x + 2 * w, it.min.y],
                            [it.max.x + 2 * w, it.max.y]
                        ]);
                    }
                    item.bounds.extendBounds(it);
                }
            }
        }
        return item;
    },

    getItemMembers: function(id) {
        var fromTiles = this._items[id].options.fromTiles,
            members = [];
        for (var key in fromTiles) {
            if (this._tiles[key]) {
                var tile = this._tiles[key].tile;
                if (tile.data) {
                    var objIndex = fromTiles[key],
                        props = tile.data[objIndex],
                        dataOption = tile.dataOptions[objIndex],
                        bbox = dataOption.bounds;

                    members.push({
                        geo: props[props.length - 1],
                        width: bbox.max.x - bbox.min.x,
                        dataOption: dataOption
                    });
                }

            }
        }
        return members.sort(function(a, b) {
            return b.width - a.width;
        });
    },

    getItemGeometries: function(id) {
        var fromTiles = this._items[id] ? this._items[id].options.fromTiles : {},
            geomItems = [];
        for (var key in fromTiles) {
            if (this._tiles[key] && this._tiles[key].tile.data) {
                var tileData = this._tiles[key].tile.data,
                    props = tileData[fromTiles[key]];

                geomItems.push(gmxAPIutils.getUnFlattenGeo(props[props.length - 1]));
            }
        }
        return geomItems;
    },

    addTile: function(tile) {
        this._tiles[tile.vectorTileKey] = {tile: tile};
        this._getActiveTileKeys()[tile.vectorTileKey] = true;
        this._observerTileLoader.addTile(tile);
        this.checkObservers();
    },

    checkObserver: function(observer) {
        if (observer.needRefresh && observer.isActive()) {
            this._observerTileLoader.startLoadTiles(observer);
        }
    },

    checkObservers: function() {
        var observers = this._observers;
        for (var id in this._observers) {
            this.checkObserver(observers[id]);
        }
    },

    _waitCheckObservers: function() {
        //TODO: refactor
        if (this._checkObserversTimer) {
            clearTimeout(this._checkObserversTimer);
        }

        this._checkObserversTimer = setTimeout(L.bind(this.checkObservers, this), 0);
    },

    _triggerObservers: function(oKeys) {
        var keys = oKeys || this._observers;

        for (var id in keys) {
            if (this._observers[id]) {
                this._observers[id].needRefresh = true;
            }
        }
        this._waitCheckObservers();
    },

    _removeDataFromObservers: function(data) {
        var keys = this._observers;
        for (var id in keys) {
            this._observers[id].removeData(data);
        }
        this._waitCheckObservers();
    },

    preloadTiles: function(dateBegin, dateEnd, bounds) {
        var tileKeys = {};
        if (this._isTemporalLayer) {
            if (!this._tilesTree) {
                this.initTilesTree();
            }
            tileKeys = this._tilesTree.selectTiles(dateBegin, dateEnd).tiles;
        } else {
            this._needCheckActiveTiles = true;
            tileKeys = this._getActiveTileKeys();
        }

        var loadingDefs = [];
        for (var key in tileKeys) {
            var tile = this._getVectorTile(key, true).tile;

            if (tile.state !== 'notLoaded') {
                continue;
            }

            if (bounds && !bounds.intersects(tile.bounds)) {
                continue;
            }

            var loadDef = tile.load();
            loadingDefs.push(loadDef);
        }

        return Deferred.all.apply(null, loadingDefs);
    },

    _updateActiveTilesList: function(newTilesList) {

        if (this._tileFilteringHook) {
            var filteredTilesList = {};
            for (var tk in newTilesList) {
                if (this._tileFilteringHook(this._getVectorTile(tk, true).tile)) {
                    filteredTilesList[tk] = true;
                }
            }
            newTilesList = filteredTilesList;
        }

        var oldTilesList = this._activeTileKeys || {};

        var observersToUpdate = {},
            _this = this,
            key;

        if (this.processingTile) {
            newTilesList[this.processingTile.vectorTileKey] = true;
        }
        if (this._rasterVectorTile) {
			key = this._rasterVectorTile.vectorTileKey;
            newTilesList[key] = true;
			this._tiles[key] = {tile: this._rasterVectorTile};
		}

        var checkSubscription = function(vKey) {
            var observerIds = _this._observerTileLoader.getTileObservers(vKey);
            for (var sid in observerIds) {
                observersToUpdate[sid] = true;
            }
        };

        for (key in newTilesList) {
            if (!oldTilesList[key]) {
                this._observerTileLoader.addTile(this._getVectorTile(key, true).tile);
                checkSubscription(key);
            }
        }

        for (key in oldTilesList) {
            if (!newTilesList[key]) {
                checkSubscription(key);
                this._observerTileLoader.removeTile(key);
            }
        }

        this._activeTileKeys = newTilesList;

        this._triggerObservers(observersToUpdate);
    },

    _propertiesToArray: function(it) {
        var prop = it.properties,
            indexes = this.tileAttributeIndexes,
            arr = [];

        for (var key in indexes)
            arr[indexes[key]] = prop[key];

        arr[arr.length] = it.geometry;
        arr[0] = it.id;
        return arr;
    },

    _clearProcessing: function() {
        if (this.processingTile) {
            var _items = this._items,
                tile = this.processingTile,
                vKey = tile.vectorTileKey,
                data = tile.data || [];
            for (var i = 0, len = data.length; i < len; i++) {
                var id = data[i][0];
                if (_items[id]) {
                    var item = _items[id];
                    item.processing = null;
                    item.currentFilter = null;
                    delete item.options.fromTiles[vKey];
                    delete item.fromServerProps;
                    delete item.geometry;
               }
            }
            tile.clear();
        }
    },

    _chkProcessing: function(processing) {
        var _items = this._items,
            needProcessingFilter = false,
            skip = {},
            id, i, len, it, data;

        if (processing) {
            if (processing.Deleted) {
                for (i = 0, len = processing.Deleted.length; i < len; i++) {
                    id = processing.Deleted[i];
                    skip[id] = true;
                    if (_items[id]) {
                        _items[id].processing = true;
                        _items[id].currentFilter = null;
                    }
                    if (len > 0) { needProcessingFilter = true; }
                }
            }

            var out = {};
            if (processing.Inserted) {
                for (i = 0, len = processing.Inserted.length; i < len; i++) {
                    it = processing.Inserted[i];
                    if (!skip[it[0]]) { out[it[0]] = it; }
                }
            }

            if (processing.Updated) {
                for (i = 0, len = processing.Updated.length; i < len; i++) {
                    it = processing.Updated[i];
                    if (!skip[it[0]]) { out[it[0]] = it; }
                }
                if (!needProcessingFilter && len > 0) { needProcessingFilter = true; }
            }

            data = [];
            for (id in out) {
                if (this._items[id]) {
                    this._items[id].properties = out[id];
                    this._items[id].processing = true;
                    this._items[id].currentFilter = null;
                }
                data.push(out[id]);
            }

            if (data.length > 0) {
                this.processingTile = this.addData(data);
            }
        }
        if (needProcessingFilter) {
            this.addFilter('processingFilter', function(item, tile) {
                return tile.z === 0 || !item.processing;
            });
        } else {
            this.removeFilter('processingFilter');
        }
    },

    enableGeneralization: function() {
        if (!this.options.isGeneralized) {
            this.options.isGeneralized = true;
            this._resetTilesTree();
        }
    },

    disableGeneralization: function() {
        if (this.options.isGeneralized) {
            this.options.isGeneralized = false;
            this._resetTilesTree();
        }
    },

    _resetTilesTree: function() {
        this._tilesTree = null;
        this._needCheckActiveTiles = true;
        this._getActiveTileKeys(); //force list update
    },

    updateVersion: function(options, tiles) {
		if (!L.gmx.skipLoadTiles) {
			if (options) {
				this.setOptions(options);
			}
			if (tiles) {	// есть списки тайлов по BBOX
				this._needCheckActiveTiles = false;
				var tKey, newTiles = {}, newActiveTileKeys = {};
				for (var i = 0, cnt = 0, len = tiles.length; i < len; i += 6, cnt++) {
					tKey = VectorTile.createTileKey({z: Number(tiles[i]), x: Number(tiles[i + 1]), y: Number(tiles[i + 2]), v: Number(tiles[i + 3]), d: Number(tiles[i + 4]), s: Number(tiles[i + 5])});
					newTiles[tKey] = this._getVectorTile(tKey, true);
					newActiveTileKeys[tKey] = true;
				}
				this._tiles = newTiles;
				if (this.processingTile) {
					this._tiles[this.processingTile.vectorTileKey] = {
						tile: this.processingTile
					};
				}
				this._updateActiveTilesList(newActiveTileKeys);
			} else {
				this._resetTilesTree();
			}
		}
    },

    getNotLoadedVectorTiles: function(options) {
		var count = 0;

        if (options.tiles) {
				// options.tilesOrder = ["Z", "X", "Y", "V", "Level", "Span"]
            var arr = options.tiles || [];

            for (var i = 0, cnt = 0, len = arr.length; i < len; i += 6, cnt++) {
                if (!this._tiles[VectorTile.createTileKey({z: Number(arr[i]), x: Number(arr[i + 1]), y: Number(arr[i + 2]), v: Number(arr[i + 3]), d: Number(arr[i + 4]), s: Number(arr[i + 5])})]) {
					count++;
				}
			}
		}
		return count;
    },

    _getDataKeys: function(data) {
        var chkKeys = {};
        for (var i = 0, len = data.length; i < len; i++) {
            chkKeys[data[i][0]] = true;
        }
        return chkKeys;
    },

    _getProcessingTile: function() {
        if (!this.processingTile) {
        var x = -0.5, y = -0.5, z = 0, v = 0, s = -1, d = -1, isFlatten = this.options.isFlatten;

            this.processingTile = new VectorTile({load: function(x, y, z, v, s, d, callback) {
                            callback([]);
            }}, {x: x, y: y, z: z, v: v, s: s, d: d, isFlatten: isFlatten});

            this.addTile(this.processingTile);
        }
        return this.processingTile;
    },

    addData: function(data) {
        if (!data) {
            data = [];
        }
        var vTile = this._getProcessingTile(),
            chkKeys = this._getDataKeys(data),
            dataBounds = vTile.addData(data, chkKeys);

        if (this._itemsBounds) {
            this._itemsBounds.extendBounds(dataBounds);
        }
        this._updateItemsFromTile(vTile);
        this._triggerObservers();
        return vTile;
    },

    removeData: function(data) {
        this._itemsBounds = null;
        var vTile = this.processingTile;
        if (vTile) {
            var chkKeys = {};

            if (!data || !data.length) {
                return vTile;
            }

            for (var i = 0, len = data.length; i < len; i++) {
                var id = data[i];
                chkKeys[id] = true;
                delete this._items[id];
            }
            this._removeDataFromObservers(chkKeys);
            vTile.removeData(chkKeys, true);
            this._updateItemsFromTile(vTile);

            this._triggerObservers();
        }

        return vTile;
    },

    initTilesTree: function() {
        this._tilesTree = L.gmx.tilesTree(this.options);
        this.options.TemporalTiles = this.options.TemporalVers = null;

        if ('TemporalTiles' in this.optionsLink) {
            this.optionsLink.TemporalVers = this.optionsLink.TemporalTiles = null;
        }
        this.dateZero = this._tilesTree.dateZero;
        if (this.processingTile) {
            this._tiles[this.processingTile.vectorTileKey] = {
                tile: this.processingTile
            };
        }
    },

    _getVectorTile: function(vKey, createFlag) {
        if (!this._tiles[vKey] && createFlag) {
            var info = VectorTile.parseTileKey(vKey);
            info.dateZero = this.dateZero;
            this._addVectorTile(info);
        }
        return this._tiles[vKey];
    },

    _addVectorTile: function(info) {
        info.isFlatten = this.options.isFlatten;
        info.needBbox = this.options.needBbox;
        info.attributes = this.options.attributes;
        var tile = new VectorTile(this._vectorTileDataProvider, info),
            vKey = tile.vectorTileKey;

        this._tiles[vKey] = {tile: tile};
        return vKey;
    },

    _getGeneralizedTileKeys: function(vTilePoint) {
        var dz = vTilePoint.z % 2 ? 1 : 2,
            pz = Math.pow(2, dz),
            z = vTilePoint.z - dz,
            x = Math.floor(vTilePoint.x / pz),
            y = Math.floor(vTilePoint.y / pz),
            temp = {v: vTilePoint.v, s: -1, d: -1, isGeneralized: true},
            keys = {};

        while (z > 1) {
            var gKey = [z, x, y].join('_');
            keys[gKey] = L.extend({}, temp, {x: x, y: y, z: z});
            z -= 2;
            x = Math.floor(x / 4);
            y = Math.floor(y / 4);
        }
        return keys;
    },

    initTilesList: function() {         // For non temporal layers we create all Vector tiles
        var newActiveTileKeys = {};
        if (this.options.tiles) {
            var arr = this.options.tiles || [],
                vers = this.options.tilesVers,
                generalizedKeys = this.options.isGeneralized ? {} : null,
                newTiles = {},
                gKey, tKey, info, tHash;

            for (var i = 0, cnt = 0, len = arr.length; i < len; i += 3, cnt++) {
                info = {
                    x: Number(arr[i]),
                    y: Number(arr[i + 1]),
                    z: Number(arr[i + 2]),
                    v: Number(vers[cnt]),
                    s: -1,
                    d: -1
                };

                tHash = this._getVectorTile(VectorTile.createTileKey(info), true);
                tKey = tHash.tile.vectorTileKey;
                newTiles[tKey] = tHash;
                newActiveTileKeys[tKey] = true;
                if (generalizedKeys) {
                    var gKeys = this._getGeneralizedTileKeys(info);
                    for (gKey in gKeys) {
                        var gPoint = gKeys[gKey];
                        if (generalizedKeys[gKey]) {
                            generalizedKeys[gKey].v = Math.max(gPoint.v, generalizedKeys[gKey].v);
                        } else {
                            generalizedKeys[gKey] = gPoint;
                        }
                    }
                }
            }
            if (generalizedKeys) {
                for (gKey in generalizedKeys) {
                    info = generalizedKeys[gKey];
                    tKey = VectorTile.createTileKey(info);
                    if (!newTiles[tKey]) {
                        if (!this._tiles[tKey]) { this._addVectorTile(info); }
                        newTiles[tKey] = this._tiles[tKey];
                        newActiveTileKeys[tKey] = true;
                    }
                }
            }
            this._tiles = newTiles;
            if (this.processingTile) {
                this._tiles[this.processingTile.vectorTileKey] = {
                    tile: this.processingTile
                };
            }
        }
        this._updateActiveTilesList(newActiveTileKeys);
    },

    //Tile filtering hook filters out active vector tiles.
    //Can be used to prevent loading data from some spatial-temporal region
    setTileFilteringHook: function(filteringHook) {
        this._tileFilteringHook = filteringHook;
        this._needCheckActiveTiles = true;
        this._getActiveTileKeys(); //force list update
    },

    removeTileFilteringHook: function() {
        this._tileFilteringHook = null;
        this._needCheckActiveTiles = true;
        this._getActiveTileKeys(); //force list update
    }

});
L.gmx = L.gmx || {};
L.gmx.DataManager = DataManager;


L.gmx.VectorLayer = L.TileLayer.Canvas.extend(
{
    options: {
        openPopups: [],
        minZoom: 1,
        zIndexOffset: 0,
        isGeneralized: true,
        isFlatten: false,
        useWebGL: false,
		skipTiles: 'None', // All, NotVisible, None
        clickable: true
    },

    initialize: function(options) {
        options = L.setOptions(this, options);

        this.initPromise = new L.gmx.Deferred();

        this._drawQueue = [];
        this._drawQueueHash = {};

        this._drawInProgress = {};

        this._anyDrawings = false; //are we drawing something?
        this.repaintObservers = {};    // external observers like screen

        var _this = this;

        this._gmx = {
            hostName: gmxAPIutils.normalizeHostname(options.hostName || 'maps.kosmosnimki.ru'),
            mapName: options.mapID,
            skipTiles: options.skipTiles,
            needBbox: options.skipTiles === 'All',
            useWebGL: options.useWebGL,
			srs: options.srs || '',
            layerID: options.layerID,
            beginDate: options.beginDate,
            endDate: options.endDate,
            sortItems: options.sortItems || null,
            styles: options.styles || [],
            tileSubscriptions: {},
            _tilesToLoad: 0,
            shiftXlayer: 0,
            shiftYlayer: 0,
            renderHooks: [],
            preRenderHooks: [],
            _needPopups: {}
        };
        if (options.crossOrigin) {
            this._gmx.crossOrigin = options.crossOrigin;
        }

        this.on('tileunload', function(e) {
            _this._clearTileSubscription(e.tile.zKey);
        });
    },

    // extended from L.TileLayer.Canvas
    _removeTile: function (zKey) {
        var tileLink = this._tiles[zKey];
        if (tileLink) {
            var tile = tileLink.el;
            if (tile && tile.parentNode) {
                tile.parentNode.removeChild(tile);
            }

            delete this._tiles[zKey];
        }
    },

    onAdd: function(map) {
        if (map.options.crs !== L.CRS.EPSG3857 && map.options.crs !== L.CRS.EPSG3395) {
            throw 'GeoMixer-Leaflet: map projection is incompatible with GeoMixer layer';
        }
        var gmx = this._gmx;

        gmx.shiftY = 0;
        gmx.applyShift = map.options.crs === L.CRS.EPSG3857 && gmx.srs !== '3857';
        gmx.currentZoom = map.getZoom();
        gmx.styleManager.initStyles();

        L.TileLayer.Canvas.prototype.onAdd.call(this, map);

        map.on('zoomstart', this._zoomStart, this);
        map.on('zoomend', this._zoomEnd, this);
        if (gmx.properties.type === 'Vector') {
            map.on('moveend', this._moveEnd, this);
        }
        if (this.options.clickable === false) {
            this._container.style.pointerEvents = 'none';
        }
        if (gmx.balloonEnable && !this._popup) { this.bindPopup(''); }
        this.on('stylechange', this._onStyleChange, this);
        this.on('versionchange', this._onVersionChange, this);

        // this._zIndexOffsetCheck();
        L.gmx.layersVersion.add(this);
        this.fire('add');
    },

    onRemove: function(map) {
        if (this._container) {
            this._container.parentNode.removeChild(this._container);
        }

        map.off({
            'viewreset': this._reset,
            'moveend': this._update
        }, this);

        if (this._animated) {
            map.off({
                'zoomanim': this._animateZoom,
                'zoomend': this._endZoomAnim
            }, this);
        }

        if (!this.options.updateWhenIdle) {
            map.off('move', this._limitedUpdate, this);
        }
        this._container = null;
        this._map = null;

        this._clearAllSubscriptions();
        map.off('zoomstart', this._zoomStart, this);
        map.off('zoomend', this._zoomEnd, this);
        this.off('stylechange', this._onStyleChange, this);

        var gmx = this._gmx;

        delete gmx.map;
        if (gmx.properties.type === 'Vector') {
            map.off('moveend', this._moveEnd, this);
        }
        if (gmx.dataManager && !gmx.dataManager.getActiveObserversCount()) {
            L.gmx.layersVersion.remove(this);
        }
        this.fire('remove');
    },

    _initContainer: function () {
        L.TileLayer.Canvas.prototype._initContainer.call(this);
        this._prpZoomData();
        this.setZIndexOffset();
    },

    _updateZIndex: function () {
        if (this._container) {
            var options = this.options,
                zIndex = options.zIndex || 0,
                zIndexOffset = options.zIndexOffset || 0;

            this._container.style.zIndex = zIndexOffset + zIndex;
        }
    },

    _update: function () {
        if (!this._map ||
            this.isExternalVisible && this.isExternalVisible(this._map._zoom) // External layer enabled on this.zoom
            ) {
            this._clearAllSubscriptions();
            return;
        }
        this._gmx.styleManager.deferred.then(this.__update.bind(this));
    },

    _addTile: function (zKey, tilePoint) {
        var myLayer = this,
            zoom = this._map._zoom,
            gmx = this._gmx;

        if (!gmx.layerType || !gmx.styleManager.isVisibleAtZoom(zoom)) {
            this._tileLoaded();
            return;
        }

        if (!gmx.tileSubscriptions[zKey]) {
            gmx._tilesToLoad++;
            var isDrawnFirstTime = false,
                gmxTilePoint = gmxAPIutils.getTileNumFromLeaflet(tilePoint, zoom),
                done = function() {
                    if (!isDrawnFirstTime) {
                        gmx._tilesToLoad--;
                        myLayer._tileLoaded();
                        isDrawnFirstTime = true;
                    }
                },
				filters = gmx.dataManager.getViewFilters('screen', gmx.layerID),
                attr = {
                    type: 'resend',
                    layerID: gmx.layerID,
                    needBbox: gmx.needBbox,
                    srs: gmx.srs,
                    target: 'screen',
                    active: false,
                    bbox: gmx.styleManager.getStyleBounds(gmxTilePoint),
                    filters: ['clipFilter', 'userFilter_' + gmx.layerID, 'styleFilter', 'userFilter'].concat(filters),
                    callback: function(data) {
                        myLayer._drawTileAsync(tilePoint, zoom, data).always(done);
                    }
                };
            if (this.options.isGeneralized) {
                attr.targetZoom = zoom;
            }
            if (gmx.layerType === 'VectorTemporal') {
                attr.dateInterval = [gmx.beginDate, gmx.endDate];
            }

            var observer = gmx.dataManager.addObserver(attr, zKey);
            observer.on('activate', function() {
                //if observer is deactivated before drawing,
                //we can consider corresponding tile as already drawn
                if (!observer.isActive()) {
                    done();
                }
            });

            observer.on('startLoadingTiles', this._chkDrawingState, this);

            gmx.tileSubscriptions[zKey] = {
                z: zoom,
                x: tilePoint.x,
                y: tilePoint.y,
                px: 256 * gmxTilePoint.x,
                py: 256 * (1 + gmxTilePoint.y)
            };
            observer.activate();
        }
    },

    _chkDrawingState: function() {
        var gmx = this._gmx,
            isDrawing = this._drawQueue.length > 0 || Object.keys(this._drawInProgress).length > 0;

        if (!isDrawing) {
            for (var key in gmx.tileSubscriptions) {
                var observer = gmx.dataManager.getObserver(key);
                if (observer && gmx.dataManager.getObserverLoadingState(observer)) {
                    isDrawing = true;
                    break;
                }
            }
        }

        if (!isDrawing && this._anyDrawings) {
            this.fire('doneDraw');
        } else  if (isDrawing && !this._anyDrawings) {
            this.fire('startDraw');
        }

        this._anyDrawings = isDrawing;
    },

    _getLoadedTilesPercentage: function (container) {
        if (!container) { return 0; }
        var len = 0, count = 0;
        var arr = ['img', 'canvas'];
        for (var key in arr) {
            var tiles = container.getElementsByTagName(arr[key]);
            if (tiles && tiles.length > 0) {
                len += tiles.length;
                for (var i = 0, len1 = tiles.length; i < len1; i++) {
                    if (tiles[i]._tileComplete) {
                        count++;
                    }
                }
            }
        }
        if (len < 1) { return 0; }
        return count / len;
    },

    _tileLoaded: function () {
        if (this._animated) {
            L.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');
        }
        if (this._gmx._tilesToLoad === 0) {
            this.fire('load');

            if (this._animated) {
                // clear scaled tiles after all new tiles are loaded (for performance)
                this._setClearBgBuffer(0);
            }
        }
    },

    _tileOnLoad: function (tile) {
        if (tile) { L.DomUtil.addClass(tile, 'leaflet-tile-loaded'); }
        this._tileLoaded();
    },

    _tileOnError: function () {
    },

    tileDrawn: function (tile) {
        this._tileOnLoad(tile);
    },

    // prepare for Leaflet 1.0 - this methods exists in L.GridLayer
    // converts tile coordinates to key for the tile cache
    _tileCoordsToKey: function (coords, zoom) {
        return coords.x + ':' + coords.y + ':' + (coords.z || zoom);
    },

    _getTiledPixelBounds: function (center) {
        var map = this._map,
            gmx = this._gmx,
            shiftPoint = new L.Point(gmx.shiftX, gmx.shiftY),
            pixelCenter = map.project(center, this._tileZoom).add(shiftPoint)._floor(),
            halfSize = map.getSize().divideBy(2);

        return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
    },

    _pxBoundsToTileRange: function (bounds) {
        var tileSize = this.options.tileSize;
        return new L.Bounds(
            bounds.min.divideBy(tileSize)._floor(),
            bounds.max.divideBy(tileSize)._round());
    },

    // original for L.gmx.VectorLayer

    //public interface
    initFromDescription: function(ph) {
        var gmx = this._gmx;

        gmx.properties = ph.properties;
        gmx.geometry = ph.geometry;

        if (gmx.properties._initDone) {    // need delete tiles key
            delete gmx.properties[gmx.properties.Temporal ? 'TemporalTiles' : 'tiles'];
        }
        gmx.properties._initDone = true;

        if (!gmx.geometry) {
            var worldSize = gmxAPIutils.tileSizes[1];
            gmx.geometry = {
                type: 'POLYGON',
                coordinates: [[[-worldSize, -worldSize], [-worldSize, worldSize], [worldSize, worldSize], [worldSize, -worldSize], [-worldSize, -worldSize]]]
            };
        }

        // Original properties from the server.
        // Descendant classes can override this property
        // Not so good solution, but it works
        gmx.rawProperties = ph.rawProperties || ph.properties;

        this._updateProperties(ph.properties);
        if (gmx.srs) {
			ph.properties.srs = gmx.srs;
		}

        ph.properties.needBbox = gmx.needBbox;
        ph.properties.isGeneralized = this.options.isGeneralized;
        ph.properties.isFlatten = this.options.isFlatten;

        gmx.dataManager = this.options.dataManager || new DataManager(ph.properties);

        if (this.options.parentOptions) {
			if (!ph.properties.styles) { ph.properties.styles = this.options.parentOptions.styles; }
			gmx.dataManager.on('versionchange', this._onVersionChange, this);
		}

		gmx.styleManager = new StyleManager(gmx);
        this.options.minZoom = gmx.styleManager.minZoom;
        this.options.maxZoom = gmx.styleManager.maxZoom;

        gmx.dataManager.on('observeractivate', function() {
            if (gmx.dataManager.getActiveObserversCount()) {
                L.gmx.layersVersion.add(this);
            } else {
                L.gmx.layersVersion.remove(this);
            }
        }, this);

        if (gmx.properties.type === 'Vector' && !('chkUpdate' in this.options)) {
            this.options.chkUpdate = true; //Check updates for vector layers by default
        }
        if (gmx.rawProperties.type !== 'Raster' && this._objectsReorderInit) {
            this._objectsReorderInit(this);
        }

        if (gmx.clusters) {
            this.bindClusters(JSON.parse(gmx.clusters));
        }
        if (gmx.filter) {
            var func = L.gmx.Parsers.parseSQL(gmx.filter.replace(/[\[\]]/g, '"'));
            if (func) {
				gmx.dataManager.addFilter('userFilter_' + gmx.layerID, function(item) {
					return gmx.layerID !== this._gmx.layerID || !func || func(item.properties, gmx.tileAttributeIndexes, gmx.tileAttributeTypes) ? item.properties : null;
				}.bind(this));
            }
        }
        if (gmx.dateBegin && gmx.dateEnd) {
            this.setDateInterval(gmx.dateBegin, gmx.dateEnd);
        }

        this.initPromise.resolve();
        return this;
    },

    getDataManager: function () {
		return this._gmx.dataManager;
    },

    enableGeneralization: function () {
        if (!this.options.isGeneralized) {
            this.options.isGeneralized = true;
            if (this._gmx.dataManager) {
                this._clearAllSubscriptions();
                this._gmx.dataManager.enableGeneralization();
                this.redraw();
            }
        }
    },

    disableGeneralization: function () {
        if (this.options.isGeneralized) {
            this.options.isGeneralized = false;
            if (this._gmx.dataManager) {
                this._clearAllSubscriptions();
                this._gmx.dataManager.disableGeneralization();
                this.redraw();
            }
        }
    },

    setRasterOpacity: function (opacity) {
        var _this = this;
        if (this._gmx.rasterOpacity !== opacity) {
            this._gmx.rasterOpacity = opacity;
            this.initPromise.then(function() {
                _this.repaint();
            });
        }
        return this;
    },

    getStyles: function () {
        return this._gmx.styleManager.getStyles();
    },

    getIcons: function (callback) {
        this._gmx.styleManager.getIcons(callback);
        return this;
    },

    setStyles: function (styles) {
        var _this = this;

        this.initPromise.then(function() {
            _this._gmx.styleManager.clearStyles();
            if (styles) {
                styles.forEach(function(it, i) {
                    _this.setStyle(it, i, true);
                });
            } else {
                _this.fire('stylechange');
            }
        });
        return this;
    },

    getStyle: function (num) {
        return this.getStyles()[num];
    },

    setStyle: function (style, num, createFlag) {
        var _this = this,
            gmx = this._gmx;
        this.initPromise.then(function() {
            gmx.styleManager.setStyle(style, num, createFlag).then(function () {
                _this.fire('stylechange', {num: num || 0});
            });
        });
        return this;
    },

    setStyleHook: function (func) {
        this._gmx.styleHook = func;
        this.repaint();
        return this;
    },

    removeStyleHook: function () {
        this._gmx.styleHook = null;
        return this;
    },

    setRasterHook: function (func) {
        this._gmx.rasterProcessingHook = func;
        this.repaint();
        return this;
    },

    removeRasterHook: function () {
        this._gmx.rasterProcessingHook = null;
        this.repaint();
        return this;
    },

    setFilter: function (func) {
        var gmx = this._gmx;
        gmx.dataManager.addFilter('userFilter', function(item) {
            return gmx.layerID !== this._gmx.layerID || !func || func(item) ? item.properties : null;
        }.bind(this));
        return this;
    },

    removeFilter: function () {
        this._gmx.dataManager.removeFilter('userFilter');
        return this;
    },

    addLayerFilter: function (func, options) {
        var gmx = this._gmx;

		options = options || {};
		options.layerID = gmx.layerID;

        gmx.dataManager.addLayerFilter(function(item) {
            return !func || func(item) ? item.properties : null;
        }.bind(this), options);

        return this;
    },

    removeLayerFilter: function (options) {
		options = options || {};
		options.layerID = this._gmx.layerID;
        this._gmx.dataManager.removeLayerFilter(options);
        return this;
    },

    setDateInterval: function (beginDate, endDate) {
        var gmx = this._gmx;

        if (gmx.dateBegin && gmx.dateEnd) {
			beginDate = gmx.dateBegin;
			endDate = gmx.dateEnd;
		}

        //check that something changed
        if (!gmx.beginDate !== !beginDate ||
            !gmx.endDate !== !endDate ||
            beginDate && (gmx.beginDate.valueOf() !== beginDate.valueOf()) ||
            endDate && (gmx.endDate.valueOf() !== endDate.valueOf())
        ) {
            if (gmx.rawProperties.maxShownPeriod && beginDate) {
                var msecPeriod = gmx.rawProperties.maxShownPeriod * 24 * 3600 * 1000;
                beginDate = new Date(Math.max(beginDate.valueOf(), endDate.valueOf() - msecPeriod));
            }

            gmx.beginDate = beginDate;
            gmx.endDate = endDate;

            var observer = null,
				dataManager = gmx.dataManager;
            for (var key in gmx.tileSubscriptions) {
                observer = dataManager.getObserver(key);
                observer.setDateInterval(beginDate, endDate);
            }
            observer = dataManager.getObserver('_Labels');
            if (observer) {
                observer.setDateInterval(beginDate, endDate);
            }
			if (gmx.skipTiles === 'NotVisible' || gmx.needBbox || gmx.properties.UseTiles === false) {
				if (!gmx.needBbox) {
					gmx.properties.LayerVersion = -1;
					dataManager.setOptions({LayerVersion: -1});
				}
				if (this._map) {
					L.gmx.layersVersion.now();
				}
			}
            this.fire('dateIntervalChanged');
        }

        return this;
    },

    getDateInterval: function() {
        return {
            beginDate: this._gmx.beginDate,
            endDate: this._gmx.endDate
        };
    },

    addObserver: function (options) {
        return this._gmx.dataManager.addObserver(options);
    },

    removeObserver: function(observer) {
        return this._gmx.dataManager.removeObserver(observer.id);
    },

    setPositionOffset: function(dx, dy) {
        var gmx = this._gmx;
        gmx.shiftXlayer = dx;
        gmx.shiftYlayer = dy;
        this._update();
        return this;
    },

    getPositionOffset: function() {
        var gmx = this._gmx;
        return {shiftX: gmx.shiftXlayer, shiftY: gmx.shiftYlayer};
    },

    setZIndexOffset: function (offset) {
        if (arguments.length) {
            this.options.zIndexOffset = offset;
        }
        this._updateZIndex();
        return this;
    },

    repaint: function (zKeys) {
        if (this._map) {
            if (!zKeys) {
                zKeys = {};
                for (var key in this._gmx.tileSubscriptions) { zKeys[key] = true; }
                L.extend(zKeys, this.repaintObservers);
            }
            this._gmx.dataManager._triggerObservers(zKeys);
        }
    },

    redrawItem: function (id) {
        if (this._map) {
            var item = this._gmx.dataManager.getItem(id),
                gmxTiles = this._getTilesByBounds(item.bounds);

            this.repaint(gmxTiles);
        }
    },

    gmxGetCanvasTile: function (tilePoint) {
        var zKey = this._tileCoordsToKey(tilePoint);

        if (zKey in this._tiles) {
            return this._tiles[zKey];
        }
        // save tile in cache
        var tile = this._getTile();
        this._tiles[zKey] = {
            el: tile,
            coords: tilePoint,
            current: true
        };

        // tile._zKey = zKey;
        tile._zoom = this._map._zoom;
        tile._tileComplete = true;
        tile._tilePoint = tilePoint;
        this.tileDrawn(tile);
        return this._tiles[zKey];
    },

    appendTileToContainer: function (tile) {
        this._tileContainer.appendChild(tile);
        var tilePos = this._getTilePos(tile._tilePoint);
        L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome || L.Browser.android23);
    },

    addData: function(data, options) {
        if (!this._gmx.mapName) {     // client side layer
            this._gmx.dataManager.addData(data, options);
            this.repaint();
        }
        return this;
    },

    removeData: function(data, options) {
        if (!this._gmx.mapName) {     // client side layer
            this._gmx.dataManager.removeData(data, options);
            this.repaint();
        }
        return this;
    },

    getStylesByProperties: function(propArray, zoom) {
        return this._gmx.styleManager.getCurrentFilters(propArray, zoom);
    },

    getItemStyle: function(id) {
        var gmx = this._gmx,
            item = gmx.dataManager.getItem(id);
        return gmx.styleManager.getObjStyle(item);
    },

    getTileAttributeTypes: function() {
        return this._gmx.tileAttributeTypes;
    },

    getTileAttributeIndexes: function() {
        return this._gmx.tileAttributeIndexes;
    },

    getItemBalloon: function(id) {
        var gmx = this._gmx,
            item = gmx.dataManager.getItem(id),
            styles = this.getStyles(),
            out = '';

        if (item && styles[item.currentFilter]) {
            var propsArr = item.properties;
            out = L.gmxUtil.parseBalloonTemplate(styles[item.currentFilter].Balloon, {
                properties: this.getItemProperties(propsArr),
                geometries: [propsArr[propsArr.length - 1]],
                tileAttributeTypes: gmx.tileAttributeTypes,
                unitOptions: this._map ? this._map.options : {}
            });
        }
        return out;
    },

    getItemProperties: function(propArray) {
        var properties = {},
            indexes = this._gmx.tileAttributeIndexes;
        for (var key in indexes) {
            properties[key] = propArray[indexes[key]];
        }
        return properties;
    },

    addPreRenderHook: function(renderHook) {
        this._gmx.preRenderHooks.push(renderHook);
        this.repaint();
    },

    removePreRenderHook: function(hook) {
        var arr = this._gmx.preRenderHooks;
        for (var i = 0, len = arr.length; i < len; i++) {
            if (arr[i] === hook) {
                arr.splice(i, 1);
                this.repaint();
                break;
            }
        }
    },

    addRenderHook: function(renderHook) {
        this._gmx.renderHooks.push(renderHook);
        this.repaint();
    },

    removeRenderHook: function(hook) {
        var arr = this._gmx.renderHooks;
        for (var i = 0, len = arr.length; i < len; i++) {
            if (arr[i] === hook) {
                arr.splice(i, 1);
                this.repaint();
                break;
            }
        }
    },

    //get original properties from the server
    getGmxProperties: function() {
        return this._gmx.rawProperties;
    },

    //returns L.LatLngBounds
    getBounds: function() {
        var gmxBounds = this._gmx.layerID ? gmxAPIutils.geoItemBounds(this._gmx.geometry).bounds : this._gmx.dataManager.getItemsBounds();

        if (gmxBounds) {
			return gmxBounds.toLatLngBounds(this._gmx.srs === '3857');
        } else {
            return new L.LatLngBounds();
        }
    },

    getGeometry: function() {
        if (!this._gmx.latLngGeometry) {
            this._gmx.latLngGeometry = L.gmxUtil.geometryToGeoJSON(this._gmx.geometry, true, this._gmx.srs === '3857');
        }

        return this._gmx.latLngGeometry;
    },

    // internal methods
    _clearTileSubscription: function(zKey) {
        var gmx = this._gmx;

        if (zKey in gmx.tileSubscriptions) {
            var subscription = gmx.tileSubscriptions[zKey];
            if (subscription.screenTile) {
                subscription.screenTile.destructor();
            }
			var observer = gmx.dataManager.getObserver(zKey);
            if (observer) { observer.deactivate(); }
            delete gmx.tileSubscriptions[zKey];
            this._removeTile(zKey);

            if (this._anyDrawings) {
                this._chkDrawingState();
            }
        }

        if (zKey in this._drawQueueHash) {
            this._drawQueueHash[zKey].cancel();
        }
    },

    _clearAllSubscriptions: function() {
        while (this._drawQueue.length) {
            this._drawQueue[0].def.cancel();
        }

        var gmx = this._gmx;

        for (var zKey in gmx.tileSubscriptions) {
            var subscription = gmx.tileSubscriptions[zKey];
            if (subscription.screenTile) {
                subscription.screenTile.destructor();
            }
			var observer = gmx.dataManager.getObserver(zKey);
            if (observer) { observer.deactivate(); }
            gmx.dataManager.removeObserver(zKey);
            delete gmx.tileSubscriptions[zKey];
            delete this._tiles[zKey];
        }

        if (this._anyDrawings) {
            this._chkDrawingState();
        }

        gmx._tilesToLoad = 0;
    },

    _zoomStart: function() {
        this._gmx.zoomstart = true;
    },

    _zoomEnd: function() {
        this._gmx.zoomstart = false;
        this.setCurrentZoom(this._map);
        // this._zIndexOffsetCheck();
    },

    _moveEnd: function() {
        if ('dataManager' in this._gmx) {
            this._gmx.dataManager.fire('moveend');
        }
    },

    _onStyleChange: function() {
        var gmx = this._gmx;
        if (!gmx.balloonEnable && this._popup) {
            this.unbindPopup();
        } else if (gmx.balloonEnable && !this._popup) {
            this.bindPopup('');
        }
        if (this._map) {
            if (this.options.minZoom !== gmx.styleManager.minZoom || this.options.maxZoom !== gmx.styleManager.maxZoom) {
                this.options.minZoom = gmx.styleManager.minZoom;
                this.options.maxZoom = gmx.styleManager.maxZoom;
                this._map._updateZoomLevels();
            }
            if (gmx.labelsLayer) {
                this._map._labelsLayer.add(this);
            } else if (!gmx.labelsLayer) {
                this._map._labelsLayer.remove(this);
            }
            if (Object.keys(gmx.tileSubscriptions).length > 0) {
                for (var key in gmx.tileSubscriptions) {    // recheck bbox on screen observers
                    var observer = gmx.dataManager.getObserver(key),
                        parsedKey = gmx.tileSubscriptions[key],
                        gmxTilePoint = gmxAPIutils.getTileNumFromLeaflet(parsedKey, parsedKey.z),
                        bbox = gmx.styleManager.getStyleBounds(gmxTilePoint);
                    if (!observer.bbox.isEqual(bbox)) {
                        observer.setBounds(bbox.toLatLngBounds(this._gmx.srs === '3857'));
                    }
                }
            } else {
                this.redraw();
            }
        }
    },

    _removeInProgressDrawing: function(zKey) {
        delete this._drawInProgress[zKey];
        this._chkDrawingState();
    },

    _drawTileAsync: function (tilePoint, zoom, data) {
        var queue = this._drawQueue,
            isEmpty = queue.length === 0,
            zKey = this._tileCoordsToKey(tilePoint, zoom),
            _this = this;

        if (this._drawQueueHash[zKey]) {
            this._drawQueueHash[zKey].cancel();
        }

        var drawNextTile = function() {
            _this._chkDrawingState();

            if (!queue.length) {
                return;
            }

            var queueItem = queue.shift();
            delete _this._drawQueueHash[queueItem.zKey];
            if (_this._map && queueItem.z === _this._map._zoom) {
                queueItem.drawDef = _this._gmxDrawTile(queueItem.tp, queueItem.z, queueItem.data);

                _this._drawInProgress[queueItem.zKey] = true;

                queueItem.drawDef.always(_this._removeInProgressDrawing.bind(_this, queueItem.zKey));

                queueItem.drawDef.then(
                    queueItem.def.resolve.bind(queueItem.def, queueItem.data),
                    queueItem.def.reject
                );
            } else {
                queueItem.def.reject();
            }
            setTimeout(drawNextTile, 0);
        };

        var gtp = gmxAPIutils.getTileNumFromLeaflet(tilePoint, zoom);
        var queueItem = {gtp: gtp, tp: tilePoint, z: zoom, zKey: zKey, data: data};
        var def = queueItem.def = new L.gmx.Deferred(function() {
            queueItem.drawDef && queueItem.drawDef.cancel();

            _this._removeInProgressDrawing(zKey);

            delete _this._drawQueueHash[zKey];
            for (var i = queue.length - 1; i >= 0; i--) {
                var elem = queue[i];
                if (elem.zKey === zKey) {
                    queue.splice(i, 1);
                    break;
                }
            }
        });
        queue.push(queueItem);

        this._drawQueueHash[zKey] = def;

        if (isEmpty) {
            setTimeout(drawNextTile, 0);
        }

        return def;
    },

    _updateShiftY: function() {
        var gmx = this._gmx,
            map = this._map,
            deltaY = 0;

        if (gmx.applyShift && map) {
            var pos = map.getCenter();
            deltaY = map.options.crs.project(pos).y - L.Projection.Mercator.project(pos).y;
        }

        gmx.shiftX = Math.floor(gmx.mInPixel * (gmx.shiftXlayer || 0));
        gmx.shiftY = Math.floor(gmx.mInPixel * (deltaY + (gmx.shiftYlayer || 0)));
        gmx.shiftPoint = new L.Point(gmx.shiftX, -gmx.shiftY);     // Сдвиг слоя

        L.DomUtil.setPosition(this._tileContainer, gmx.shiftPoint);
    },

    _prpZoomData: function() {
        this.setCurrentZoom(this._map);
        // this.repaint();
    },

    setCurrentZoom: function(map) {
        var gmx = this._gmx;
        gmx.currentZoom = map._zoom;
        gmx.tileSize = gmxAPIutils.tileSizes[gmx.currentZoom];
        gmx.mInPixel = 256 / gmx.tileSize;
    },

    // _zIndexOffsetCheck: function() {
        // var gmx = this._gmx;
        // if (gmx.properties.fromType !== 'Raster' && (gmx.IsRasterCatalog || gmx.Quicklook)) {
            // var minZoom = gmx.IsRasterCatalog ? gmx.minZoomRasters : gmx.minZoomQuicklooks;
            // var zIndexOffset = this._map._zoom < minZoom ? L.gmx.VectorLayer.prototype.options.zIndexOffset : 0;
            // if (zIndexOffset !== this.options.zIndexOffset) {
                // this.setZIndexOffset(zIndexOffset);
            // }
        // }
    // },

    _setClearBgBuffer: function (zd) {
        if (this._clearBgBufferTimer) { clearTimeout(this._clearBgBufferTimer); }
        var _this = this;
        this._clearBgBufferTimer = setTimeout(function () {
            if (_this._bgBuffer) {
                _this._clearBgBuffer();
            }
        }, zd || 0);
    },

    _getNeedPopups: function () {
        var out = {},
            openPopups = this.options.openPopups;
        for (var i = 0, len = openPopups.length; i < len; i++) {
            out[openPopups[i]] = false;
        }
        return out;
    },

    __update: function () {
        var map = this._map;
        if (!map) { return; }
        var zoom = map.getZoom(),
            center = map.getCenter();

        // if (this._gmx.applyShift) {
            this._updateShiftY();
        // }
        this._tileZoom = zoom;
        if (this.options.openPopups.length) {
            this._gmx._needPopups = this._getNeedPopups();
            this.options.openPopups = [];
        }

        var pixelBounds = this._getTiledPixelBounds(center),
            tileRange = this._pxBoundsToTileRange(pixelBounds),
            limit = this._getWrapTileNum();

        if (tileRange.min.y < 0) { tileRange.min.y = 0; }
        if (tileRange.max.y >= limit.y) { tileRange.max.y = limit.y - 1; }

        this._chkTileSubscriptions(zoom, tileRange);

        if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
            this._setClearBgBuffer(500);
            return;
        }

        // create a queue of coordinates to load tiles from
        for (var j = tileRange.min.y, lenj = tileRange.max.y; j <= lenj; j++) {
            for (var i = tileRange.min.x, leni = tileRange.max.x; i <= leni; i++) {
                var coords = new L.Point(i, j);
                coords.z = this._tileZoom;
                var zKey = this._tileCoordsToKey(coords);

                if (!this._tiles[zKey]) {
                    this._addTile(zKey, coords);
                }
            }
        }
    },

    _chkTileSubscriptions: function (zoom, tileRange) {
        //L.TileVector will remove all tiles from other zooms.
        //But it will not remove subscriptions without tiles - we should do it ourself
        var gmx = this._gmx,
            min = tileRange.min,
            max = tileRange.max;

        for (var zKey in gmx.tileSubscriptions) {
            var subscription = gmx.tileSubscriptions[zKey];
            if (subscription.z !== zoom
                || subscription.x < min.x
                || subscription.x > max.x
                || subscription.y < min.y
                || subscription.y > max.y
            ) {
                this._clearTileSubscription(zKey);
            }
        }
    },

    _getScreenTile: function (tilePoint, zoom) {
        var gmx = this._gmx,
            zKey = this._tileCoordsToKey(tilePoint, zoom),
            subscription = gmx.tileSubscriptions[zKey],
            screenTile = null;
        if (subscription) {
            if (subscription.screenTile) {
                screenTile = subscription.screenTile;
            } else {
                subscription.screenTile = screenTile = new ScreenVectorTile(this, tilePoint, zoom);
            }
        }
        return screenTile;
    },

    _gmxDrawTile: function (tilePoint, zoom, data) {
        var gmx = this._gmx,
            cancelled = false,
            screenTileDrawPromise = null,
            def = new L.gmx.Deferred(function() {
                cancelled = true;
                screenTileDrawPromise && screenTileDrawPromise.cancel();
            });

        if (!this._map) {
            def.reject();
            return def;
        }
        var screenTile = this._getScreenTile(tilePoint, zoom || this._map._zoom);
        if (screenTile) {
            gmx.styleManager.deferred.then(function () {
                if (!cancelled) {
                    screenTileDrawPromise = screenTile.drawTile(data);
                    screenTileDrawPromise.then(def.resolve.bind(def, data), def.reject);
                }
            });
        }
       return def;
    },

    _getTilesByBounds: function (bounds) {    // Получить список gmxTiles по bounds
        var gmx = this._gmx,
            zoom = this._map._zoom,
            shiftX = gmx.shiftX || 0,   // Сдвиг слоя
            shiftY = gmx.shiftY || 0,   // Сдвиг слоя + OSM
			latLngBounds = bounds.toLatLngBounds(gmx.srs === '3857'),
            minLatLng = latLngBounds.getSouthWest(),
            maxLatLng = latLngBounds.getNorthEast(),
            screenBounds = this._map.getBounds(),
            sw = screenBounds.getSouthWest(),
            ne = screenBounds.getNorthEast(),
            dx = 0;

        if (ne.lng - sw.lng < 360) {
            if (maxLatLng.lng < sw.lng) {
                dx = 360 * (1 + Math.floor((sw.lng - maxLatLng.lng) / 360));
            } else if (minLatLng.lng > ne.lng) {
                dx = 360 * Math.floor((ne.lng - minLatLng.lng) / 360);
            }
        }
        minLatLng.lng += dx;
        maxLatLng.lng += dx;

        var pixelBounds = this._map.getPixelBounds(),
            minPoint = this._map.project(minLatLng),
            maxPoint = this._map.project(maxLatLng);

        var minY, maxY, minX, maxX;
        if (pixelBounds) {
            minY = Math.floor((Math.max(maxPoint.y, pixelBounds.min.y) + shiftY) / 256);
            maxY = Math.floor((Math.min(minPoint.y, pixelBounds.max.y) + shiftY) / 256);
            minX = minLatLng.lng <= -180 ? pixelBounds.min.x : Math.max(minPoint.x, pixelBounds.min.x);
            minX = Math.floor((minX + shiftX) / 256);
            maxX = maxLatLng.lng >= 180 ? pixelBounds.max.x : Math.min(maxPoint.x, pixelBounds.max.x);
            maxX = Math.floor((maxX + shiftX) / 256);
        } else {
            minY = Math.floor((maxPoint.y + shiftY) / 256);
            maxY = Math.floor((minPoint.y + shiftY) / 256);
            minX = Math.floor((minPoint.x + shiftX) / 256);
            maxX = Math.floor((maxPoint.x + shiftX) / 256);
        }
        var gmxTiles = {};
        for (var x = minX; x <= maxX; x++) {
            for (var y = minY; y <= maxY; y++) {
                var zKey = this._tileCoordsToKey({x: x, y: y}, zoom);
                gmxTiles[zKey] = true;
            }
        }
        return gmxTiles;
    },

    _updateProperties: function (prop) {
        var gmx = this._gmx,
            apikeyRequestHost = this.options.apikeyRequestHost || gmx.hostName;

        gmx.sessionKey = prop.sessionKey = this.options.sessionKey || gmxSessionManager.getSessionKey(apikeyRequestHost); //should be already received

        if (this.options.parentOptions) {
			prop = this.options.parentOptions;
		}

        gmx.identityField = prop.identityField; // ogc_fid
        gmx.GeometryType = (prop.GeometryType || '').toLowerCase();   // тип геометрий обьектов в слое
        gmx.minZoomRasters = prop.RCMinZoomForRasters || 1;// мин. zoom для растров
        gmx.minZoomQuicklooks = gmx.minZoomRasters; // по умолчанию minZoom для квиклуков и КР равны

        var type = prop.type || 'Vector';
        if (prop.Temporal) { type += 'Temporal'; }
        gmx.layerType = type;   // VectorTemporal Vector
        gmx.items = {};

        L.extend(gmx, L.gmxUtil.getTileAttributes(prop));
        if (gmx.dataManager) {
            gmx.dataManager.setOptions(prop);
        }
        if ('ZIndexField' in prop) {
            if (prop.ZIndexField in gmx.tileAttributeIndexes) {
                gmx.zIndexField = gmx.tileAttributeIndexes[prop.ZIndexField];   // sort field index
            }
        }
        if (this._objectsReorder) {
            this._objectsReorder.initialize();
        }

        // if ('clusters' in prop) {
            // gmx.clusters = prop.clusters;
        // }

        gmx.filter = prop.filter; 	// for dataSource attr
        gmx.dateBegin = prop.dateBegin;
        gmx.dateEnd = prop.dateEnd;
        gmx.dataSource = prop.dataSource;
        if ('MetaProperties' in gmx.rawProperties) {
            var meta = gmx.rawProperties.MetaProperties;
            if ('srs' in meta) {  		// проекция слоя
                gmx.srs = meta.srs.Value || '';
            }
            if ('parentLayer' in meta) {  // фильтр слоя		// todo удалить после изменений вов вьювере
                gmx.dataSource = meta.parentLayer.Value || '';
            }
            if ('filter' in meta) {  // фильтр слоя
                gmx.filter = meta.filter.Value || '';
            }
            if ('dateBegin' in meta) {  // фильтр для мультивременного слоя
                gmx.dateBegin = L.gmxUtil.getDateFromStr(meta.dateBegin.Value || '01.01.1980');
            }
            if ('dateEnd' in meta) {  // фильтр для мультивременного слоя
                gmx.dateEnd = L.gmxUtil.getDateFromStr(meta.dateEnd.Value || '01.01.1980');
            }
            if ('shiftX' in meta || 'shiftY' in meta) {  // сдвиг всего слоя
                gmx.shiftXlayer = meta.shiftX ? Number(meta.shiftX.Value) : 0;
                gmx.shiftYlayer = meta.shiftY ? Number(meta.shiftY.Value) : 0;
            }
            if ('shiftXfield' in meta || 'shiftYfield' in meta) {    // поля сдвига растров объектов слоя
                if (meta.shiftXfield) { gmx.shiftXfield = meta.shiftXfield.Value; }
                if (meta.shiftYfield) { gmx.shiftYfield = meta.shiftYfield.Value; }
            }
            if ('quicklookPlatform' in meta) {    // тип спутника
                gmx.quicklookPlatform = meta.quicklookPlatform.Value;
                if (gmx.quicklookPlatform === 'image') { delete gmx.quicklookPlatform; }
            }
            if ('quicklookX1' in meta) { gmx.quicklookX1 = meta.quicklookX1.Value; }
            if ('quicklookY1' in meta) { gmx.quicklookY1 = meta.quicklookY1.Value; }
            if ('quicklookX2' in meta) { gmx.quicklookX2 = meta.quicklookX2.Value; }
            if ('quicklookY2' in meta) { gmx.quicklookY2 = meta.quicklookY2.Value; }
            if ('quicklookX3' in meta) { gmx.quicklookX3 = meta.quicklookX3.Value; }
            if ('quicklookY3' in meta) { gmx.quicklookY3 = meta.quicklookY3.Value; }
            if ('quicklookX4' in meta) { gmx.quicklookX4 = meta.quicklookX4.Value; }
            if ('quicklookY4' in meta) { gmx.quicklookY4 = meta.quicklookY4.Value; }

            if ('multiFilters' in meta) {    // проверка всех фильтров для обьектов слоя
                gmx.multiFilters = meta.multiFilters.Value === '1' ? true : false;
            }
            if ('isGeneralized' in meta) {    // Set generalization
                this.options.isGeneralized = meta.isGeneralized.Value !== 'false';
            }
            if ('isFlatten' in meta) {        // Set flatten geometry
                this.options.isFlatten = meta.isFlatten.Value !== 'false';
            }
        }
        if (prop.Temporal) {    // Clear generalization flag for Temporal layers
            this.options.isGeneralized = false;
        }

        if (prop.IsRasterCatalog) {
            gmx.IsRasterCatalog = prop.IsRasterCatalog;
            var layerLink = gmx.tileAttributeIndexes.GMX_RasterCatalogID;
            if (layerLink) {
                gmx.rasterBGfunc = function(x, y, z, item) {
                    var properties = item.properties,
						url = L.gmxUtil.protocol + '//' + gmx.hostName
							+ '/TileSender.ashx?ModeKey=tile'
							+ '&x=' + x
							+ '&y=' + y
							+ '&z=' + z;
					if (gmx.srs) { url += '&srs=' + gmx.srs; }
					if (gmx.crossOrigin) { url += '&cross=' + gmx.crossOrigin; }
					url += '&LayerName=' + properties[layerLink];
					if (gmx.sessionKey) { url += '&key=' + encodeURIComponent(gmx.sessionKey); }
                    return url;
                };
            }
        }
        if (prop.Quicklook) {
            var quicklookParams;

            //раньше это была просто строка с шаблоном квиклука, а теперь стало JSON'ом
            if (prop.Quicklook[0] === '{') {
                quicklookParams = JSON.parse(prop.Quicklook);
            } else {
                quicklookParams = {
                    minZoom: gmx.minZoomRasters,
                    template: prop.Quicklook
                };
            }

            if ('X1' in quicklookParams) { gmx.quicklookX1 = quicklookParams.X1; }
            if ('Y1' in quicklookParams) { gmx.quicklookY1 = quicklookParams.Y1; }
            if ('X2' in quicklookParams) { gmx.quicklookX2 = quicklookParams.X2; }
            if ('Y2' in quicklookParams) { gmx.quicklookY2 = quicklookParams.Y2; }
            if ('X3' in quicklookParams) { gmx.quicklookX3 = quicklookParams.X3; }
            if ('Y3' in quicklookParams) { gmx.quicklookY3 = quicklookParams.Y3; }
            if ('X4' in quicklookParams) { gmx.quicklookX4 = quicklookParams.X4; }
            if ('Y4' in quicklookParams) { gmx.quicklookY4 = quicklookParams.Y4; }

            var template = gmx.Quicklook = quicklookParams.template;
            if ('minZoom' in quicklookParams) { gmx.minZoomQuicklooks = quicklookParams.minZoom; }
            gmx.quicklookBGfunc = function(item) {
                var url = template,
                    reg = /\[([^\]]+)\]/,
                    matches = reg.exec(url);
                while (matches && matches.length > 1) {
                    url = url.replace(matches[0], item.properties[gmx.tileAttributeIndexes[matches[1]]]);
                    matches = reg.exec(url);
                }
				if (gmx.srs) { url += (url.indexOf('?') === -1 ? '?' : '&') + 'srs=' + gmx.srs; }
                return url;
            };
            gmx.imageQuicklookProcessingHook = L.gmx.gmxImageTransform;
        }
        this.options.attribution = prop.Copyright || '';
    },

    _onVersionChange: function () {
        this._updateProperties(this._gmx.rawProperties);
    },

    getViewRasters: function() {
        var gmx = this._gmx,
			hash = {},
			out = [];

        for (var zKey in gmx.tileSubscriptions) {
            var subscription = gmx.tileSubscriptions[zKey],
				screenTile = subscription.screenTile;
            if (screenTile) {
                screenTile.itemsView.forEach(function(it) {
					hash[it.id] = true;
				});
            }
        }
        for (var id in hash) {
			out.push(id);
		}

        return out;
    },

    getPropItem: function (key, propArr) {
        return gmxAPIutils.getPropItem(key, propArr, this._gmx.tileAttributeIndexes);
    }
});
L.Map.addInitHook(function () {
	// Check to see if Labels has already been initialized.
    if (L.Mixin.ContextMenu) {
		L.gmx.VectorLayer.include(L.Mixin.ContextMenu);
	}
});


// Single tile on screen with vector data
function ScreenVectorTile(layer, tilePoint, zoom) {
    this.layer = layer;
    this.tilePoint = tilePoint;
    this.zoom = zoom;
    this.gmx = layer._gmx;
    this.zKey = this.layer._tileCoordsToKey(tilePoint, zoom);
    var utils = gmxAPIutils;
    this.worldWidthMerc = utils.worldWidthMerc;
    var gmxTilePoint = utils.getTileNumFromLeaflet(tilePoint, zoom);
    this.tbounds = utils.getTileBounds(gmxTilePoint.x, gmxTilePoint.y, gmxTilePoint.z);
    this.tpx = 256 * gmxTilePoint.x;
    this.tpy = 256 * (1 + gmxTilePoint.y);

    this.gmxTilePoint = gmxTilePoint;

    this.showRaster =
        (zoom >= this.gmx.minZoomRasters && 'rasterBGfunc' in this.gmx) ||
        (zoom >= this.gmx.minZoomQuicklooks && 'quicklookBGfunc' in this.gmx);
    this.rasters = {}; //combined and processed canvases for each vector item in tile
    this.rasterRequests = {};   // all cached raster requests
    this.itemsView = [];   		// items on screen tile + todo: without not visible
    this._uniqueID = 0;         // draw attempt id
    this.gmx.badTiles = this.gmx.badTiles || {};
}

ScreenVectorTile.prototype = {

    //return promise, which resolves with object {gtp, image}
    _loadTileRecursive: function (gtp, urlFunction) {
        var gmx = this.gmx,
            _this = this,
            requestPromise = null,
            currentUrl,
            def = new L.gmx.Deferred(function() {
                if (requestPromise) {
                    //don't store cancelled requests in request cache
                    delete _this.rasterRequests[currentUrl];
                    requestPromise.cancel();
                }
            });

        var tryLoad = function(gtp, crossOrigin) {
            var rUrl = urlFunction(gtp);

            var tryHigherLevelTile = function() {
                if (gtp.z > 1) {
                    tryLoad({
                        x: Math.floor(gtp.x / 2),
                        y: Math.floor(gtp.y / 2),
                        z: gtp.z - 1
                    }, ''); // 'anonymous' 'use-credentials'
                } else {
                    def.reject();
                }
            };

            if (gmx.badTiles[rUrl] || (gmx.maxNativeZoom && gmx.maxNativeZoom < gtp.z)) {
                tryHigherLevelTile();
                return;
            }
            var request = _this.rasterRequests[rUrl];
            if (!request) {
                if (gmx.rasterProcessingHook) {
                    crossOrigin = 'anonymous';
                }
                request = L.gmx.imageLoader.push(rUrl, {
                    tileRastersId: _this._uniqueID,
                    zoom: _this.zoom,
                    cache: true,
                    crossOrigin: gmx.crossOrigin || crossOrigin || ''
                });
                _this.rasterRequests[rUrl] = request;
            } else {
                request.options.tileRastersId = _this._uniqueID;
            }
            currentUrl = rUrl;
            requestPromise = request.def;

            requestPromise.then(
                function(imageObj) {
                    def.resolve({gtp: gtp, image: imageObj});
                },
                function() {
                    gmx.badTiles[rUrl] = true;
                    tryHigherLevelTile();
                }
            );
        };

        tryLoad(gtp);
        return def;
    },

    _rasterHook: function (attr) {
        var source = attr.sourceTilePoint || attr.destinationTilePoint,
            info = {
                geoItem: attr.geoItem,
                destination: {
                    z: attr.destinationTilePoint.z,
                    x: attr.destinationTilePoint.x,
                    y: attr.destinationTilePoint.y
                },
                source: {
                    z: source.z,
                    x: source.x,
                    y: source.y
                }
            };
        if (attr.url) { info.quicklook = attr.url; }
        return (this.gmx.rasterProcessingHook || this._defaultRasterHook)(
            attr.res, attr.image,
            attr.sx || 0, attr.sy || 0, attr.sw || 256, attr.sh || 256,
            attr.dx || 0, attr.dy || 0, attr.dw || 256, attr.dh || 256,
            info
        );
    },

    // default rasterHook: res - result canvas other parameters as http://www.w3schools.com/tags/canvas_drawimage.asp
    _defaultRasterHook: function (res, image, sx, sy, sw, sh, dx, dy, dw, dh) {
        var ptx = res.getContext('2d');
        ptx.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);
    },

    // get pixels parameters for shifted object
    _getShiftPixels: function (it) {
        var w = it.dx + (it.dx < 0 ? 256 : 0),
            h = it.dy + (it.dy < 0 ? 256 : 0),
            sx = 0, sw = 256 - w, dx = w, dw = sw;
        if (it.tx > it.x) {
            sx = sw; sw = w; dx = 0; dw = sw;
        }
        if (sx === 256 || sw < 1) { return null; }

        var sy = h, sh = 256 - h, dy = 0, dh = sh;
        if (it.ty > it.y) {
            sy = 0; dy = sh; sh = h; dh = sh;
        }
        if (sy === 256 || sh < 1) { return null; }

        return {
            sx: sx, sy: sy, sw: sw, sh: sh,
            dx: dx, dy: dy, dw: dw, dh: dh
        };
    },

    // get tiles parameters for shifted object
    _getShiftTilesArray: function (bounds, shiftX, shiftY) {
        var mInPixel = this.gmx.mInPixel,
            gmxTilePoint = this.gmxTilePoint,
            px = shiftX * mInPixel,
            py = shiftY * mInPixel,
            deltaX = Math.floor(0.5 + px % 256),            // shift on tile in pixel
            deltaY = Math.floor(0.5 + py % 256),
            tileSize = 256 / mInPixel,
            tminX = gmxTilePoint.x - shiftX / tileSize,     // by screen tile
            tminY = gmxTilePoint.y - shiftY / tileSize,
            rminX = Math.floor(tminX),
            rmaxX = rminX + (tminX === rminX ? 0 : 1),
            rminY = Math.floor(tminY),
            rmaxY = rminY + (tminY === rminY ? 0 : 1),
            minX = Math.floor((bounds.min.x - shiftX) / tileSize),  // by geometry bounds
            maxX = Math.floor((bounds.max.x - shiftX) / tileSize),
            minY = Math.floor((bounds.min.y - shiftY) / tileSize),
            maxY = Math.floor((bounds.max.y - shiftY) / tileSize);

        if (rminX < minX) { rminX = minX; }
        if (rmaxX > maxX) { rmaxX = maxX; }
        if (rminY < minY) { rminY = minY; }
        if (rmaxY > maxY) { rmaxY = maxY; }

        var arr = [];
        for (var j = rminY; j <= rmaxY; j++) {
            for (var i = rminX; i <= rmaxX; i++) {
                arr.push({
                    z: gmxTilePoint.z,
                    x: i,
                    y: j,
                    dx: deltaX,
                    dy: deltaY,
                    tx: tminX,
                    ty: tminY
                });
            }
        }
        return arr;
    },

    // Loads missing rasters for single item and combines them in canvas.
    // Stores resulting canvas in this.rasters
    _getItemRasters: function (geo) {
        var properties = geo.properties,
            idr = properties[0],
            _this = this,
            gmx = this.gmx,
            indexes = gmx.tileAttributeIndexes,
            rasters = this.rasters,
            mainRasterLoader = null,
            recursiveLoaders,
            shiftX = Number(gmx.shiftXfield ? gmxAPIutils.getPropItem(gmx.shiftXfield, properties, indexes) : 0) % this.worldWidthMerc,
            shiftY = Number(gmx.shiftYfield ? gmxAPIutils.getPropItem(gmx.shiftYfield, properties, indexes) : 0),
            isShift = shiftX || shiftY,
            urlBG = gmxAPIutils.getPropItem('urlBG', properties, indexes),
            url = '',
            itemImageProcessingHook = null,
            isTiles = false,
            item = gmx.dataManager.getItem(idr),
            gmxTilePoint = this.gmxTilePoint,
            resCanvas = null,
            imageItem = null;

        if (gmx.IsRasterCatalog && (gmx.rawProperties.type === 'Raster' || gmxAPIutils.getPropItem('GMX_RasterCatalogID', properties, indexes))) {
            isTiles = true;                     // Raster Layer
        } else if (gmx.quicklookBGfunc) {
            url = gmx.quicklookBGfunc(item);    // Quicklook
            itemImageProcessingHook = gmx.imageQuicklookProcessingHook;
        } else if (urlBG) {
            url = urlBG;                        // Image urlBG from properties
            itemImageProcessingHook = gmx.imageQuicklookProcessingHook;
        }
        if (isTiles) {
            mainRasterLoader = new L.gmx.Deferred(function() {
                recursiveLoaders.forEach(function(it) {
                    it.cancel();
                });
                recursiveLoaders = null;
            });
        } else {
            url += (url.indexOf('?') === -1 ? '?' : '&') + gmx.sessionKey;  //  for browser cache from another tabs
			var request = this.rasterRequests[url];
            if (!request) {
                request = L.gmx.imageLoader.push(url, {
                    tileRastersId: _this._uniqueID,
                    crossOrigin: gmx.crossOrigin || 'anonymous'
                });
                this.rasterRequests[url] = request;
            } else {
                request.options.tileRastersId = this._uniqueID;
            }

            // in fact, we want to return request.def, but need to do additional action during cancellation.
            // so, we consctruct new promise and add pipe it with request.def
            mainRasterLoader = new L.gmx.Deferred(function() {
                //don't cache cancelled requests
                delete _this.rasterRequests[url];
                request.def.cancel();
            });
            request.def.then(mainRasterLoader.resolve, mainRasterLoader.reject);
        }
        var itemRasterPromise = new L.gmx.Deferred(function() {
            if (mainRasterLoader) {
                mainRasterLoader.cancel();
                mainRasterLoader = null;
            }
        });

        if (isTiles) {
            var dataOption = geo.dataOption || {},
                tileToLoadPoints = isShift ? this._getShiftTilesArray(dataOption.bounds, shiftX, shiftY) : [gmxTilePoint],
                cnt = tileToLoadPoints.length,
                chkReadyRasters = function() {
                    if (cnt < 1) { mainRasterLoader.resolve(); }
                },
                skipRasterFunc = function() {
                    cnt--;
                    chkReadyRasters();
                },
                urlFunction = function(gtp) {
                    return gmx.rasterBGfunc(gtp.x, gtp.y, gtp.z, item);
                },
                onLoadFunction = function(gtp, p, img) {
                    item.skipRasters = false;
                    var isImage = true;

                    if (itemImageProcessingHook) {
                        img = itemImageProcessingHook(img, {
                            gmx: gmx,
                            geoItem: geo,
                            item: item,
                            gmxTilePoint: gtp
                        });
                        isImage = false;
                    }

                    var info = {
                            geoItem: geo,
                            image: img,
                            destinationTilePoint: gmxTilePoint,
                            sourceTilePoint: gtp,
                            sx: 0, sy: 0, sw: 256, sh: 256,
                            dx: 0, dy: 0, dw: 256, dh: 256
                        };

                    if (isShift) {
                        var pos = _this._getShiftPixels(p);
                        if (pos === null) {
                            skipRasterFunc();
                            return;
                        }
                        L.extend(info, pos);
                        isImage = false;
                    }

                    if (gtp.z !== gmxTilePoint.z) {
                        var posInfo = gmxAPIutils.getTilePosZoomDelta(gmxTilePoint, gmxTilePoint.z, gtp.z);
                        if (posInfo.size < 1 / 256) {// меньше 1px
                            chkReadyRasters();
                            return;
                        }
                        isImage = false;
                        info.sx = Math.floor(posInfo.x);
                        info.sy = Math.floor(posInfo.y);
                        info.sw = info.sh = posInfo.size;
                        if (isShift) {
                            var sw = Math.floor(info.dw / posInfo.zDelta);
                            info.sx = (info.dx === 0 ? info.sw : 256) - sw;
                            info.sw = sw;

                            var sh = Math.floor(info.dh / posInfo.zDelta);
                            info.sy = (info.dy === 0 ? info.sh : 256) - sh;
                            info.sh = sh;
                        }
                    }
                    if (isImage && !gmx.rasterProcessingHook) {
                        cnt--;
                        resCanvas = img;
                        chkReadyRasters();
                    } else {
                        if (!resCanvas) {
                            resCanvas = document.createElement('canvas');
                            resCanvas.width = resCanvas.height = 256;
                        }
                        info.res = resCanvas;
                        var hookResult = _this._rasterHook(info),
                            then = function() {
                                cnt--;
                                p.resImage = resCanvas;
                                chkReadyRasters();
                            };

                        if (hookResult) {
                            if (hookResult instanceof L.gmx.Deferred) {
                                hookResult.then(then);
                            }
                        } else if (hookResult === null) {
                            item.skipRasters = true;
                            skipRasterFunc();
                        } else {
                            then();
                        }
                    }
                };
            recursiveLoaders = tileToLoadPoints.map(function(it) {
                var loader = _this._loadTileRecursive(it, urlFunction);
                loader.then(function(loadResult) {
                    onLoadFunction(loadResult.gtp, it, loadResult.image);
                }, skipRasterFunc);
                return loader;
            });

            mainRasterLoader.then(function() {
                rasters[idr] = resCanvas;
                itemRasterPromise.resolve();
            });
        } else {
            // for quicklook
            item.skipRasters = false;
            var imageLoaded = function(img) {
                var imgAttr = {
                    gmx: gmx,
                    geoItem: geo,
                    item: item,
                    gmxTilePoint: gmxTilePoint
                };
                if (!resCanvas) {
                    resCanvas = document.createElement('canvas');
                    resCanvas.width = resCanvas.height = 256;
                }
                var prepareItem = function(imageElement) {
                    var promise = _this._rasterHook({
                            geoItem: geo,
                            res: resCanvas,
                            image: itemImageProcessingHook ? itemImageProcessingHook(imageElement, imgAttr) : imageElement,
                            destinationTilePoint: gmxTilePoint,
                            url: url
                        }),
                        then = function() {
                            rasters[idr] = resCanvas;
                            itemRasterPromise.resolve();
                        };
                    if (promise) {
                        if (promise instanceof L.gmx.Deferred) {
                            promise.then(then);
                        }
                    } else if (promise === null) {
                        item.skipRasters = true;
                        itemRasterPromise.resolve();
                    } else {
                        then();
                    }
                };
                prepareItem(img);
                delete _this.rasterRequests[url];
            };
            if (imageItem) {
                imageLoaded(imageItem);
            } else {
                mainRasterLoader.then(imageLoaded.bind(this), itemRasterPromise.resolve);
            }
        }
        itemRasterPromise.always(function() {
            mainRasterLoader = null;
            if (recursiveLoaders) {
                recursiveLoaders = null;
            }
        });
        return itemRasterPromise;
    },

    _getVisibleItems: function (geoItems) {
        if (geoItems.length < 2) {
			this.itemsView = geoItems;
            return geoItems;
        }
        if (!gmxAPIutils._tileCanvas) {
            gmxAPIutils._tileCanvas = document.createElement('canvas');
            gmxAPIutils._tileCanvas.width = gmxAPIutils._tileCanvas.height = 256;
        }
        var i, len,
            gmx = this.gmx,
            dm = gmx.dataManager,
            canvas = gmxAPIutils._tileCanvas,
            ctx = canvas.getContext('2d'),
            dattr = {
                tbounds: this.tbounds,
                gmx: gmx,
                tpx: this.tpx,
                tpy: this.tpy,
                ctx: ctx
            };
        ctx.clearRect(0, 0, 256, 256);
        ctx.imageSmoothingEnabled = false;
        for (i = 0, len = geoItems.length; i < len; i++) {
            ctx.fillStyle = gmxAPIutils.dec2rgba(i + 1, 1);
            var geoItem = geoItems[i];
            L.gmxUtil.drawGeoItem(
                geoItem,
                dm.getItem(geoItem.properties[0]),
                dattr,
                {fillStyle: ctx.fillStyle}
            );
        }
        var items = {},
            data = ctx.getImageData(0, 0, 256, 256).data;

        for (i = 0, len = data.length; i < len; i += 4) {
            if (data[i + 3] === 255) {
                var color = data[i + 2];
                if (data[i + 1]) { color += (data[i + 1] << 8); }
                if (data[i]) { color += (data[i] << 16); }
                if (color) { items[color] = true; }
            }
        }
        var out = [];
        for (var num in items) {
            var it = geoItems[Number(num) - 1];
            if (it) { out.push(it); }
        }
		this.itemsView = out;
        return out;
    },

    _getNeedRasterItems: function (geoItems) {
        var gmx = this.gmx,
            indexes = gmx.tileAttributeIndexes,
            tbounds = this.tbounds,
            out = [];
        for (var i = 0, len = geoItems.length; i < len; i++) {
            var geo = geoItems[i],
                properties = geo.properties,
                idr = properties[0],
                dataOption = geo.dataOption || {},
                skipRasters = false;

            if (gmx.quicklookBGfunc && !gmxAPIutils.getPropItem('GMX_RasterCatalogID', properties, indexes)) {
                if (gmx.minZoomQuicklooks && this.zoom < gmx.minZoomQuicklooks) { continue; }
                var platform = gmxAPIutils.getPropItem(gmx.quicklookPlatform, properties, indexes) || gmx.quicklookPlatform || '';
                if ((!platform || platform === 'imageMercator') &&
                    !gmxAPIutils.getQuicklookPointsFromProperties(properties, gmx)
                ) {
                    continue;
                }
            }

            if (gmx.styleHook) {
                geo.styleExtend = gmx.styleHook(
                    gmx.dataManager.getItem(idr),
                    gmx.lastHover && idr === gmx.lastHover.id
                );
                skipRasters = geo.styleExtend && geo.styleExtend.skipRasters;
            }
            if (!skipRasters && tbounds.intersectsWithDelta(dataOption.bounds, -1, -1)) {
                out.push(geo);
            }
        }
        return this._getVisibleItems(out);
    },

    _getTileRasters: function (geoItems) {   //load all missing rasters for items we are going to render
        var itemPromises = [],
            def = new L.gmx.Deferred(function() {
                itemPromises.forEach(function(promise) {
                    promise.cancel();
                });
                itemPromises = null;
            }),
            itemRasters = this._getNeedRasterItems(geoItems),
            needLoadRasters = itemRasters.length;

        if (needLoadRasters) {
            var _this = this,
                chkReadyRasters = function() {
                    if (needLoadRasters < 1) {
                        def.resolve();
                    }
                };
            itemRasters.forEach(function (geo) {
                var itemRasterPromise = _this._getItemRasters(geo);
                itemRasterPromise.then(function() {
                    needLoadRasters--;
                    chkReadyRasters();
                });
                itemPromises.push(itemRasterPromise);
            });
        } else {
            def.resolve();
        }
        return def;
    },

    _chkItems: function (data) {
        var layer = this.layer;
        if (!layer._map) {
            return null;
        }
        var items = data && data.added && data.added.length ? data.added : null;

        if (!items) {
            var tLink = layer._tiles[this.zKey];
            if (tLink && tLink.el) {
                tLink.el.getContext('2d').clearRect(0, 0, 256, 256);
            }
            return null;
        }
        return this.gmx.sortItems ? layer.getSortedItems(items) : items;
    },

    _cancelRastersPromise: function () {
        if (this.rastersPromise) {
            this.rastersPromise.cancel();
            this.rastersPromise = null;
        }
    },

    drawTile: function (data) {
        var drawPromise = this.currentDrawPromise,
            _this = this;

        this._uniqueID++;       // count draw attempt

        if (drawPromise) {
            this._cancelRastersPromise();
            if (this._preRenderPromise) {
                this._preRenderPromise.cancel();        // cancel preRenderHooks chain if exists
            }
            if (this._renderPromise) {
                this._renderPromise.cancel();           // cancel renderHooks chain if exists
            }
            drawPromise.reject();
        }
        drawPromise = new L.gmx.Deferred(this._cancelRastersPromise.bind(this));
        drawPromise.always(function() {
            _this._drawDone();
            _this.currentDrawPromise = null;
            _this.rastersPromise = null;
            _this._preRenderPromise = null;
            _this._renderPromise = null;
        });

        this.currentDrawPromise = drawPromise;

        var geoItems = this._chkItems(data);
        if (!geoItems) {
            drawPromise.resolve();
            return drawPromise;
        }
        var tileLink = this.layer.gmxGetCanvasTile(this.tilePoint),
            tile = tileLink.el,
            ctx = tile.getContext('2d'),
            gmx = this.gmx,
            dattr = {
                tbounds: this.tbounds,
                rasters: this.rasters,
                gmx: gmx,
                tpx: this.tpx,
                tpy: this.tpy,
                ctx: ctx
            };
        tile.zKey = tileLink.el._zKey = this.zKey;

        var doDraw = function() {
            ctx.clearRect(0, 0, 256, 256);
            var hookInfo = {
                    tpx: _this.tpx,
                    tpy: _this.tpy,
                    x: _this.tilePoint.x,
                    y: _this.tilePoint.y,
                    z: _this.zoom
                },
                bgImage = null;

            _this._preRenderPromise = new L.gmx.Deferred();
            _this._preRenderPromise.resolve(bgImage);

            gmx.preRenderHooks.forEach(function (f) {
                _this._preRenderPromise = _this._preRenderPromise.then(function(hookBgImage) {

                    //in-place modifications are possible
                    bgImage = hookBgImage || bgImage;

                    if (!bgImage) {
                        bgImage = document.createElement('canvas');
                        bgImage.width = bgImage.height = 256;
                    }
                    return f(bgImage, hookInfo);
                });
            });
            _this._preRenderPromise.then(function(hookBgImage) {
                bgImage = hookBgImage || bgImage;
                if (bgImage) { dattr.bgImage = bgImage; }
                //ctx.save();
                for (var i = 0, len = geoItems.length; i < len; i++) {
                    var geoItem = geoItems[i],
                        id = geoItem.id,
                        item = gmx.dataManager.getItem(id);
                    if (item) {     // skip removed items   (bug with screen tile screenTileDrawPromise.cancel on hover repaint)
                        var style = gmx.styleManager.getObjStyle(item),
                            hover = gmx.lastHover && gmx.lastHover.id === geoItem.id && style;

                        if (gmx.multiFilters) {
                            for (var j = 0, len1 = item.multiFilters.length; j < len1; j++) {
                                var it = item.multiFilters[j];
                                L.gmxUtil.drawGeoItem(geoItem, item, dattr, hover ? it.parsedStyleHover : it.parsedStyle, it.style);
                            }
                        } else {
                            L.gmxUtil.drawGeoItem(geoItem, item, dattr, hover ? item.parsedStyleHover : item.parsedStyleKeys, style);
                        }
                        if (id in gmx._needPopups && !gmx._needPopups[id]) {
                            gmx._needPopups[id] = true;
                        }
                    }
                }
                //ctx.restore();
                _this.rasters = {}; // clear rasters
                if (_this.layer._map && !tile.parentNode) {
                    _this.layer.appendTileToContainer(tile);
                }
                //async chain
                _this._renderPromise = new L.gmx.Deferred();
                _this._renderPromise.resolve(tile);
                gmx.renderHooks.forEach(function (f) {
                    _this._renderPromise = _this._renderPromise.then(function(hookTile) {
                        tile = hookTile || tile;
                        return f(tile, hookInfo);
                    });
                });
                _this._renderPromise.then(drawPromise.resolve, drawPromise.reject);
            }, drawPromise.reject);
        };

        if (this.showRaster) {
            this.rastersPromise = this._getTileRasters(geoItems);
            this.rastersPromise.then(doDraw, drawPromise.reject); //first load all raster images, then render all of them at once
        } else {
            doDraw();
        }

        return drawPromise;
    },

    destructor: function () {
        this._cancelRastersPromise();
        this._clearCache();

        this.currentDrawPromise && this.currentDrawPromise.reject();
    },

    _drawDone: function () {
        for (var url in this.rasterRequests) {
            var req = this.rasterRequests[url];
            if (this._uniqueID !== req.options.tileRastersId) {
                req.remove();
                delete this.rasterRequests[url];
            }
        }
        // this.layer.fire('tiledrawdone', {zKey: this.zKey});
    },

    _clearCache: function () {
        for (var url in this.rasterRequests) {
            this.rasterRequests[url].remove();
        }
        this.rasterRequests = {};
    }
};


/*
 * ObjectsReorder  - Reorder objects in Gemixer layer
 */
(function() {

var MAX = 1000000,
    ObjectsReorder = function (layer) {
        this.all = {};
        this.userSetSortFunc = false;     // user sort func flag
        this.sortFunc = null;
        this.count = 0;
        this.disabled = false;
        this.layer = layer;
        layer.on('add', this.onAdd, this);
        layer.on('remove', this.onRemove, this);
    };
    ObjectsReorder.prototype = {
        addToReorder: function (id, bottomFlag) {
            ++this.count;
            this.all[id] = bottomFlag ? -this.count : this.count;
        },
        clickFunc: function (ev) {
            if (!this.disabled) {
                var id = ev.gmx.id;
                this.addToReorder(id, ev.originalEvent.ctrlKey);
                this.layer.redrawItem(id);
            }
        },
        sortItems: function(a, b) {     // layer context
            var reorder = this._objectsReorder;
            if (reorder.count > 0) {
                var ap = reorder.all[a.id],
                    bp = reorder.all[b.id];

                if (ap || bp) {
                    ap = ap ? ap + (ap > 0 ? MAX : -MAX) : 0;
                    bp = bp ? bp + (bp > 0 ? MAX : -MAX) : 0;
                    return ap - bp;
                }
            }
            return reorder.sortFunc ? reorder.sortFunc.call(this, a, b) : 0;
        },
        resetSortFunc: function () {
            var layer = this.layer,
                gmx = layer._gmx,
                zIndexField = gmx.zIndexField;
            gmx.sortItems = this.sortItems;
            this.sortFunc = (zIndexField && !this.userSetSortFunc ?
                function(a, b) {    // layer context
                    var res = Number(a.properties[zIndexField]) - Number(b.properties[zIndexField]);
                    return res ? res : a.id - b.id;
                }
                :
                function(a, b) {
                    return a.id - b.id;
                }
            );
        },
        initialize: function () {
            var gmx = this.layer._gmx;
            if (!this.userSetSortFunc && (gmx.GeometryType === 'polygon' || gmx.GeometryType === 'linestring')) {
                this.resetSortFunc();
            }
        },
        onAdd: function () {
            this.initialize();
            this.layer.on('click', this.clickFunc, this);
        },
        onRemove: function () {
            this.layer.off('click', this.clickFunc, this);
        }
    };

L.gmx.VectorLayer.include({
    _objectsReorder: null,

    _objectsReorderInit: function () {
        if (!this._objectsReorder) {
            this._objectsReorder = new ObjectsReorder(this);
        }
    },

    getReorderArrays: function () {
        var out = {top: [], bottom: []};
        if (this._objectsReorder) {
            var reorder = this._objectsReorder,
                arr = Object.keys(reorder.all).sort(function(a, b) {
                    return reorder.all[a] - reorder.all[b];
                });

            for (var i = 0, len = arr.length; i < len; i++) {
                var id = arr[i];
                if (reorder.all[id] > 0) {
                    out.top.push(id);
                } else {
                    out.bottom.push(id);
                }
            }
        }
        return out;
    },

    bringToTopItem: function (id) {
        this._objectsReorderInit();
        this._objectsReorder.addToReorder(id);
        this.redrawItem(id);
        return this;
    },

    bringToBottomItem: function (id) {
        this._objectsReorderInit();
        this._objectsReorder.addToReorder(id, true);
        this.redrawItem(id);
        return this;
    },

    clearReorderArrays: function () {
        if (this._objectsReorder) {
            var reorder = this._objectsReorder;
            reorder.all = {};
            reorder.count = 0;
            this.repaint();
        }
        return this;
    },

    setReorderArrays: function (top, bottom) {
        this._objectsReorderInit();
        var reorder = this._objectsReorder;
        reorder.all = {};
        reorder.count = 0;
        if (bottom) {
			bottom.forEach(function (id) { reorder.addToReorder(id, true); });
		}
        if (top) {
			top.forEach(function (id) { reorder.addToReorder(id); });
		}
        this.repaint();
        return this;
    },

    getSortedItems: function (arr) {
        this._objectsReorderInit();
        return arr.sort(L.bind(this._objectsReorder.count > 0 ? this._gmx.sortItems : this._objectsReorder.sortFunc, this));
    },

    setSortFunc: function (func) {
        this._objectsReorderInit();
        var reorder = this._objectsReorder;
        reorder.sortFunc = func;
        reorder.userSetSortFunc = func ? true : false;
        this._gmx.sortItems = reorder.sortItems;
        this.repaint();
        return this;
    },
    disableFlip: function() {
        this._objectsReorderInit();
        this._objectsReorder.disabled = true;
        return this;
    },
    enableFlip: function() {
        this._objectsReorderInit();
        this._objectsReorder.disabled = false;
        return this;
    }
});
})();


var StyleManager = function(gmx) {
    this.gmx = gmx;
    this.deferred = new L.gmx.Deferred();

    this._maxVersion = 0;
    this._maxStyleSize = 0;
    this._styles = [];
    this._deferredIcons = [];
    this._parserFunctions = {};
    this._serverStylesParsed = false;

    var minZoom = Infinity,
        maxZoom = -Infinity,
        arr = gmx.properties.styles || [];

    for (var i = 0, len = arr.length; i < len; i++) {
        var st = arr[i];
        minZoom = Math.min(minZoom, st.MinZoom);
        maxZoom = Math.max(maxZoom, st.MaxZoom);
    }
    this.minZoom = minZoom === Infinity ? 0 : minZoom;
    this.maxZoom = maxZoom === -Infinity ? 18 : maxZoom;
};
StyleManager.prototype = {
    _getMaxStyleSize: function(zoom) {  // estimete style size for arbitrary object
        var maxSize = 0;
        for (var i = 0, len = this._styles.length; i < len; i++) {
            var style = this._styles[i];
            if (zoom > style.MaxZoom || zoom < style.MinZoom) { continue; }
            var RenderStyle = style.RenderStyle;
            // if (this._needLoadIcons || !RenderStyle || !RenderStyle.common || !('maxSize' in RenderStyle)) {
            if (this._needLoadIcons || !RenderStyle || !('maxSize' in RenderStyle)) {
                maxSize = StyleManager.MAX_STYLE_SIZE;
                break;
            }
            var maxShift = 0;
            if ('iconAnchor' in RenderStyle && !RenderStyle.iconCenter) {
                maxShift = Math.max(
                    Math.abs(RenderStyle.iconAnchor[0]),
                    Math.abs(RenderStyle.iconAnchor[1])
                );
            }
            maxSize = Math.max(RenderStyle.maxSize + maxShift, maxSize);
        }
        return maxSize;
    },

    getStyleBounds: function(gmxTilePoint) {
        if (!gmxTilePoint) {
            return gmxAPIutils.bounds();
        }

        this._maxStyleSize = this._getMaxStyleSize(this.gmx.currentZoom);

        var mercSize = 2 * this._maxStyleSize * gmxAPIutils.tileSizes[gmxTilePoint.z] / 256; //TODO: check formula
        return gmxAPIutils.getTileBounds(gmxTilePoint.x, gmxTilePoint.y, gmxTilePoint.z).addBuffer(mercSize);
    },

    //is any style is visible at given zoom?
    isVisibleAtZoom: function(zoom) {
        for (var i = 0, len = this._styles.length; i < len; i++) {
            var style = this._styles[i];
            if (zoom >= style.MinZoom && zoom <= style.MaxZoom) {
                return true;
            }
        }
        return false;
    },

    getIcons: function(callback) {
        var _this = this;
        this.deferred.then(function() {
            var out = [];
            for (var i = 0, len = _this._styles.length; i < len; i++) {
                var style = _this._styles[i],
                    pt = {};
                if (style.RenderStyle) {
                    pt.RenderStyle = {image: style.RenderStyle.image};
                }
                if (style.HoverStyle) {
                    pt.HoverStyle = {image: style.HoverStyle.image};
                }
                out.push(pt);
            }
            if (callback) {
                callback(out);
            }
        });
        this.initStyles();
    },

    _chkReady: function() {
        if (this._needLoadIcons < 1) {
            var _this = this;
			if (this.gmx.dataManager) {
				this.gmx.dataManager.addFilter('styleFilter', function(it) { return _this._chkStyleFilter(it); });
			}
            this.deferred.resolve();
        }
    },

    initStyles: function() {
        if (!this._serverStylesParsed) {
            this._parseServerStyles();
        }
        for (var i = 0, len = this._deferredIcons.length; i < len; i++) {
            this._getImageSize(this._deferredIcons[i]);
        }
        this._deferredIcons = [];
        this._chkReady();
        return this.deferred;
    },

    getStyles: function () {
        if (!this._serverStylesParsed) {
            this._parseServerStyles();
        }
        var out = [];
        for (var i = 0, len = this._styles.length; i < len; i++) {
            var style = L.extend({}, this._styles[i]);
            style.RenderStyle = StyleManager.getStyleKeys(style.RenderStyle);
            if (style.HoverStyle) {
                style.HoverStyle = StyleManager.getStyleKeys(style.HoverStyle);
            }
            delete style.filterFunction;
            delete style.version;
            delete style.common;
            delete style.type;
            out.push(style);
        }
        return out;
    },

    clearStyles: function () {
        this._styles = [];
        this.gmx.balloonEnable = false;
        this.gmx.labelsLayer = false;
    },

    _changeStylesVersion: function () {
        var _this = this;
        this._styles.map(function(it) {
            it.version = ++_this._maxVersion;
        });
    },

    setStyle: function(st, num, createFlag) {
        num = num || 0;
        if (num < this._styles.length || createFlag) {
            var style = this._styles[num];
            if (!style) {
                style = this._prepareItem({});
                this._styles[num] = style;
            }
            this.deferred = new L.gmx.Deferred();
            style.version = ++this._maxVersion;
            if ('Filter' in st) {
                style.Filter = st.Filter;
                var type = typeof (st.Filter);
                style.filterFunction = type === 'string' ? L.gmx.Parsers.parseSQL(style.Filter.replace(/[\[\]]/g, '"'))
                    : type === 'function' ? style.Filter : null;

                this._changeStylesVersion();
            }
            for (var i = 0, len = StyleManager.DEFAULT_KEYS.length; i < len; i++) {
                var key = StyleManager.DEFAULT_KEYS[i];
                if (key in st) { style[key] = st[key]; }
            }
            if (st.RenderStyle) {
                style.RenderStyle = this._parseStyle(st.RenderStyle);
            }
            if (st.HoverStyle) { style.HoverStyle = this._parseStyle(st.HoverStyle, style.RenderStyle); }
            this._checkStyles();
        }
        return this.initStyles();
    },

    getItemBalloon: function(id) {
        var item = this.gmx.dataManager.getItem(id),
            currentFilter = item ? item.currentFilter : 0,
            style = this._styles[currentFilter];
        return style ? {
                DisableBalloonOnMouseMove: style.DisableBalloonOnMouseMove || false,
                DisableBalloonOnClick: style.DisableBalloonOnClick || false,
                templateBalloon: style.Balloon || null,
                isSummary: /\[SUMMARY\]/.test(style.Balloon)
            }
            : null
        ;
    },

    // apply styleHook func
    // applyStyleHook: function(item, hoverFlag) {
        // return this._itemStyleParser(item, this.gmx.styleHook(item, hoverFlag));
    // },

    getObjStyle: function(item) {
        this._chkStyleFilter(item);
        var style = this._styles[item.currentFilter],
            version;

        if (!style) { return null; }
        if (style.hoverDiff && this.gmx.lastHover && item.id === this.gmx.lastHover.id) {
            if (style.HoverStyle) {
                version = style.HoverStyle.version || -1;
                if (version !== item.styleVersion) {
                    item.parsedStyleHover = this._itemStyleParser(item, style.HoverStyle);
                }
                return style.HoverStyle;
            } else {
                delete item.parsedStyleHover;
            }
            return null;
        }
        version = style.version || -1;
        if (version !== item.styleVersion) {
            item.parsedStyleKeys = this._itemStyleParser(item, style.RenderStyle);
        }
        return style.RenderStyle;
    },

    _needLoadIcons: 0,
    _getImageSize: function(pt) {     // check image size
        var url = pt.iconUrl || pt.fillIconUrl,
            opt = pt.iconAngle || pt.iconScale ? {crossOrigin: 'anonymous'} : {},
            _this = this;

        if (L.gmxUtil.isIE11 && /\.svg$/.test(url)) {
            opt = {};   // skip bug in IE11
        }
        opt.layerID = this.gmx.layerID;
        ++this._needLoadIcons;
        L.gmx.imageLoader.unshift(url, opt).def.then(
            function(it) {
                pt.version = ++_this._maxVersion;
                if (pt.fillIconUrl) {
                    pt.imagePattern = it;
                } else {
                    var w = it.width,
                        h = it.height;
                    if (L.gmxUtil.isIE11 && /\.svg$/.test(url)) {   // skip bug in IE11
                        document.body.appendChild(it);
                        w = it.offsetWidth;
                        h = it.offsetHeight;
                        document.body.removeChild(it);
                    }
                    pt.sx = w;
                    pt.sy = h;
                    pt.image = it;
                    var maxSize = pt.iconAngle ? Math.sqrt(pt.sx * pt.sx + pt.sy * pt.sy) : Math.max(pt.sx, pt.sy);
                    if (!pt.scaleFunction && !pt.rotateFunction) {
                        if (pt.iconScale || pt.iconScale === 1) { maxSize *= pt.iconScale; }
                        pt.common = true;
                    }
                    pt.maxSize = Number(maxSize.toFixed());
                }
                _this._needLoadIcons--;
                _this._chkReady();
            },
            function() {
                pt.version = ++_this._maxVersion;
                pt.sx = 1;
                pt.sy = 0;
                pt.image = null;
                _this._needLoadIcons--;
                _this._chkReady();
                console.log({url: url, func: '_getImageSize', Error: 'image not found'});
            }
        );
    },

    getCurrentFilters: function(propArray, zoom) {
        var gmx = this.gmx,
            indexes = gmx.tileAttributeIndexes,
            types = gmx.tileAttributeTypes,
            z = zoom || 1,
            out = [];

        if (!this._serverStylesParsed) {
            this._parseServerStyles();
        }
        for (var i = 0, len = this._styles.length; i < len; i++) {
            var st = this._styles[i];
            if (z > st.MaxZoom || z < st.MinZoom
                || (st.filterFunction && !st.filterFunction(propArray, indexes, types))) {
                continue;
            }
            out.push(i);
            if (!gmx.multiFilters) { break; }
        }
        return out;
    },

    _chkStyleFilter: function(item) {
        var gmx = this.gmx,
            zoom = gmx.currentZoom,
            fnum = gmx.multiFilters ? -1 : item.currentFilter,
            curr = this._styles[fnum],
            needParse = !curr || curr.version !== item.styleVersion;

        if (needParse || item._lastZoom !== zoom) {
            item.currentFilter = -1;
            item.multiFilters = [];
            var filters = this.getCurrentFilters(item.properties, zoom);
            for (var i = 0, len = filters.length; i < len; i++) {
                var num = filters[i],
                    st = this._styles[num];
                item.hoverDiff = st.hoverDiff;
                item.currentFilter = num;
                if (needParse || fnum !== num) {
                    var parsed = st.common && st.common.RenderStyle || this._itemStyleParser(item, st.RenderStyle),
                        parsedHover = null;

                    item.parsedStyleKeys = parsed;
                    if (st.HoverStyle) {
                        parsedHover = st.common && st.common.HoverStyle || this._itemStyleParser(item, st.HoverStyle);
                        item.parsedStyleHover = parsedHover;
                    }
                    if (gmx.multiFilters) {
                        item.multiFilters.push({
                            style: st.RenderStyle,
                            styleHover: st.HoverStyle,
                            parsedStyle: parsed,
                            parsedStyleHover: parsedHover
                        });
                    }
                }
                item.styleVersion = st.version;
                if (!gmx.multiFilters) { break; }
            }
            item._lastZoom = zoom;
        }
        if (this._styles[item.currentFilter]) {
            return true;
        } else {
            item.currentFilter = -1;
            return false;
        }
    },

    _parseServerStyles: function() {
        var gmx = this.gmx,
            props = gmx.properties,
            arr = props.styles || [{MinZoom: 1, MaxZoom: 21, RenderStyle: StyleManager.DEFAULT_STYLE}],
            len = Math.max(arr.length, gmx.styles.length);

        for (var i = 0; i < len; i++) {
            if (!this._styles[i]) {
                var gmxStyle = gmx.styles[i] || arr[i];
                if (!gmxStyle.RenderStyle) { gmxStyle.RenderStyle = StyleManager.DEFAULT_STYLE; }
                if (gmxStyle.HoverStyle === undefined) {
                    var hoveredStyle = JSON.parse(JSON.stringify(gmxStyle.RenderStyle));
                    if (hoveredStyle.outline) { hoveredStyle.outline.thickness += 1; }
                    gmxStyle.HoverStyle = hoveredStyle;
                } else if (gmxStyle.HoverStyle === null) {
                    delete gmxStyle.HoverStyle;
                }
                var pt = this._prepareItem(gmxStyle);
                this._styles.push(pt);
                if (this._isLabel(pt.RenderStyle)) { gmx.labelsLayer = true; }
            }
        }
        this._checkStyles();
        this._serverStylesParsed = true;
    },

    _checkStyles: function() {
        var minZoom = Infinity,
            maxZoom = -Infinity,
            balloonEnable = false,
            labelsLayer = false;

        for (var i = 0, len = this._styles.length; i < len; i++) {
            var st = this._styles[i];

            st.DisableBalloonOnMouseMove = st.DisableBalloonOnMouseMove === false ? false : true;
            st.DisableBalloonOnClick = st.DisableBalloonOnClick || false;
            if (st.DisableBalloonOnMouseMove === false || st.DisableBalloonOnClick === false) {
                balloonEnable = true;
                st.BalloonEnable = true;
            }
            st.hoverDiff = null;
            st.common = {};
            if (st.RenderStyle) {
                if (!labelsLayer) {
                    if (this._isLabel(st.RenderStyle)) {
                        labelsLayer = true;
                    }
                }
                if (st.RenderStyle.common) {
                    st.common.RenderStyle = this._itemStyleParser({}, st.RenderStyle);
                }
                if (st.HoverStyle) {
                    st.hoverDiff = StyleManager.checkDiff(st.RenderStyle, st.HoverStyle);
                }
            }
            if (st.HoverStyle && st.HoverStyle.common) {
                st.common.HoverStyle = this._itemStyleParser({}, st.HoverStyle);
            }
            minZoom = Math.min(minZoom, st.MinZoom);
            maxZoom = Math.max(maxZoom, st.MaxZoom);
        }
        if (this.minZoom !== Infinity) { this.minZoom = minZoom; }
        if (this.maxZoom !== -Infinity) { this.maxZoom = maxZoom; }
        this.gmx.balloonEnable = balloonEnable;
        this.gmx.labelsLayer = labelsLayer;
    },

    _parseStyle: function(st, renderStyle) {
        if (st) {
            st.common = true;
            for (var key in st) {
                if (gmxAPIutils.styleFuncKeys[key]) {
                    var fkey = gmxAPIutils.styleFuncKeys[key],
                        val = st[key];
                    if (typeof (val) === 'string') {
                        st.common = false;
                        if (renderStyle && renderStyle[key] === val) {
                            st[fkey] = renderStyle[fkey];
                        } else {
                            if (!this._parserFunctions[val]) {
                                this._parserFunctions[val] = L.gmx.Parsers.parseExpression(val);
                            }
                            st[fkey] = this._parserFunctions[val];
                        }
                    } else if (typeof (val) === 'function') {
                        st.common = false;
                        st[fkey] = val;
                    }
                }
            }

            var type = '';
            if ('iconUrl' in st) {
                type = 'image';
                if (st.iconUrl) {
                    st.maxSize = 256;
                    this._deferredIcons.push(st);
                }
            } else if (st.fillIconUrl) {
                type = 'square';
                this._deferredIcons.push(st);
            } else if (st.fillPattern) {
                type = 'square';
                st.common = StyleManager.parsePattern(st.fillPattern);
                st.canvasPattern = gmxAPIutils.getPatternIcon(null, st);
            } else if (st.iconCircle) {
                type = 'circle';
                if (!('iconSize' in st)) { st.iconSize = 4; }
            } else if (st.iconPath) {
                type = 'iconPath';
                var iconSize = 0,
                    arr = L.Util.isArray(st.iconPath) ? st.iconPath : StyleManager.DEFAULT_ICONPATH;
                st.iconPath = StyleManager.DEFAULT_ICONPATH.map(function(it, i) {
                    var z = arr[i] || it;
                    iconSize = Math.max(iconSize, z);
                    return z;
                });
                st.iconSize = 2 * iconSize;
            } else if (st.fillRadialGradient) {
                type = 'circle';
                if (!('iconCenter' in st)) { st.iconCenter = true; }
                var size = StyleManager.parseRadialGradient(st.fillRadialGradient);
                if (size === null) {
                    st.common = false;
                } else {
                    st.iconSize = size;
                }
            } else if (st.fillLinearGradient) {
                type = 'square';
                st.common = StyleManager.parseLinearGradient(st.fillLinearGradient);
            } else if (st.iconSize) {
                type = 'square';
                if (!('iconCenter' in st)) { st.iconCenter = true; }
            }
            st.type = type;
            if (st.common && !st.maxSize) {
                st.maxSize = st.iconSize || 0;
                st.maxSize += st.weight ? st.weight : 0;
                if ('iconScale' in st) { st.maxSize *= st.iconScale; }
            }
        }
        return st;
    },

    _prepareItem: function(style) { // Style Scanex->leaflet
        var pt = {
            MinZoom: style.MinZoom || 0,
            MaxZoom: style.MaxZoom || 18,
            Filter: style.Filter || null,
            Balloon: style.Balloon || '',
            RenderStyle: (style.RenderStyle ? this._parseStyle(L.gmxUtil.fromServerStyle(style.RenderStyle)) : {}),
            version: ++this._maxVersion
        };
        pt.DisableBalloonOnMouseMove = style.DisableBalloonOnMouseMove === false ? false : true;
        pt.DisableBalloonOnClick = style.DisableBalloonOnClick || false;
        if (style.HoverStyle) {
            pt.HoverStyle = this._parseStyle(L.gmxUtil.fromServerStyle(style.HoverStyle), pt.RenderStyle);
        }

        if ('Filter' in style) {
            var ph = L.gmx.Parsers.parseSQL(style.Filter.replace(/[\[\]]/g, '"'));
            if (ph) { pt.filterFunction = ph; }
        }
        return pt;
    },

    _isLabel: function(st) {
        var indexes = this.gmx.tileAttributeIndexes;
        return (st && (st.labelTemplate || (st.labelField && st.labelField in indexes)));
    },

    _itemStyleParser: function(item, pt) {
        pt = pt || {};
        var out = {}, arr, i, len,
            indexes = this.gmx.tileAttributeIndexes,
            prop = item.properties || {},
            itemType = item.type,
            type = pt.type,
            color = 'color' in pt ? pt.color : 255,
            opacity = 'opacity' in pt ? pt.opacity : 1;

        out.sx = pt.sx;
        out.sy = pt.sy;
        if (pt.maxSize) {
            out.maxSize = pt.maxSize;
        }
        if (pt.iconAngle) {
            var rotateRes = pt.iconAngle || 0;
            if (rotateRes && typeof (rotateRes) === 'string') {
                rotateRes = (pt.rotateFunction ? pt.rotateFunction(prop, indexes) : 0);
            }
            out.rotate = rotateRes || 0;
        }
        if ('iconColor' in pt) {
            out.iconColor = 'iconColorFunction' in pt ? pt.iconColorFunction(prop, indexes) : pt.iconColor;
        }
        if ('iconScale' in pt) {
            out.iconScale = 'scaleFunction' in pt ? (pt.scaleFunction ? pt.scaleFunction(prop, indexes) : 1) : pt.iconScale;
        }
        if (type === 'image') {
            out.type = type;
            if (pt.iconUrl) { out.iconUrl = pt.iconUrl; }
            if (pt.image) { out.image = pt.image; }
        } else if (pt.fillRadialGradient) {
            var rgr = pt.fillRadialGradient,
                r1 = (rgr.r1Function ? rgr.r1Function(prop, indexes) : rgr.r1),
                r2 = (rgr.r2Function ? rgr.r2Function(prop, indexes) : rgr.r2),
                x1 = (rgr.x1Function ? rgr.x1Function(prop, indexes) : rgr.x1),
                y1 = (rgr.y1Function ? rgr.y1Function(prop, indexes) : rgr.y1),
                x2 = (rgr.x2Function ? rgr.x2Function(prop, indexes) : rgr.x2),
                y2 = (rgr.y2Function ? rgr.y2Function(prop, indexes) : rgr.y2);
            if (rgr.r2max) {
                r2 = Math.min(r2, rgr.r2max);
            }
            var colorStop = [];
            len = rgr.addColorStop.length;
            if (!rgr.addColorStopFunctions) {
                rgr.addColorStopFunctions = new Array(len);
            }
            for (i = 0; i < len; i++) {
                arr = rgr.addColorStop[i];
                var arrFunc = rgr.addColorStopFunctions[i] || [],
                    p0 = (arrFunc[0] ? arrFunc[0](prop, indexes) : arr[0]),
                    p3 = arr[3];
                if (arr.length < 4) {
                    var op = arr.length < 3 ? 1 : arrFunc[2] ? arrFunc[2](prop, indexes) : arr[2];
                    p3 = gmxAPIutils.dec2color(arrFunc[1] ? arrFunc[1](prop, indexes) : arr[1], op);
                 }
                colorStop.push([p0, p3]);
            }
            out.maxSize = out.sx = out.sy = out.iconSize = r2;
            out.fillRadialGradient = {
                x1:x1, y1:y1, r1:r1, x2:x2, y2:y2, r2:r2,
                addColorStop: colorStop
            };
            out._radialGradientParsed = {
                create: [x1, y1, r1, x2, y2, r2],
                colorStop: colorStop
            };
        } else if (pt.fillLinearGradient) {
            out.fillLinearGradient = pt.fillLinearGradient;
        } else {
            if (pt.fillPattern) {
                out.canvasPattern = (pt.canvasPattern ? pt.canvasPattern : gmxAPIutils.getPatternIcon(item, pt, indexes));
            }

            if (type === 'iconPath') {
                out.type = type;
                out.iconPath = pt.iconPath;
            }

            if (itemType === 'POLYGON' || itemType === 'MULTIPOLYGON' || this.gmx.GeometryType === 'polygon') {
                type = 'polygon';
            }
            if (pt.iconSize) {
                var iconSize = ('sizeFunction' in pt ? pt.sizeFunction(prop, indexes) : pt.iconSize);
                out.sx = out.sy = iconSize;
                // iconSize += pt.weight ? pt.weight : 0;
                out.iconSize = iconSize;
                if ('iconScale' in pt) {
                    out.iconSize *= pt.iconScale;
                }
                out.maxSize = iconSize;
            }
            out.stroke = true;
            if ('colorFunction' in pt || 'opacityFunction' in pt) {
                color = 'colorFunction' in pt ? pt.colorFunction(prop, indexes) : color;
                opacity = 'opacityFunction' in pt ? pt.opacityFunction(prop, indexes) : opacity;
            }
            out.strokeStyle = gmxAPIutils.dec2color(color, opacity);
            out.lineWidth = 'weight' in pt ? pt.weight : 1;
        }

        if ('iconScale' in pt) {
            out.iconScale = 'scaleFunction' in pt ? (pt.scaleFunction ? pt.scaleFunction(prop, indexes) : 1) : pt.iconScale;
        }
        if ('iconAnchor' in pt) {
            out.iconAnchor = pt.iconAnchor;
        }
        if ('iconCenter' in pt) {
            out.iconCenter = pt.iconCenter;
        }

        if (type === 'square' || type === 'polygon' || type === 'circle' || type === 'iconPath') {
            out.type = type;
            var fop = pt.fillOpacity,
                fc = pt.fillColor,
                fcDec = typeof (fc) === 'string' ? parseInt(fc.replace(/#/, ''), 16) : fc;

            if ('fillColor' in pt) {
                out.fillStyle = gmxAPIutils.dec2color(fcDec, 1);
            }
            if ('fillColorFunction' in pt || 'fillOpacityFunction' in pt) {
                color = ('fillColorFunction' in pt ? pt.fillColorFunction(prop, indexes) : fc || 255);
                opacity = ('fillOpacityFunction' in pt ? pt.fillOpacityFunction(prop, indexes) : fop || 1);
                out.fillStyle = gmxAPIutils.dec2color(color, opacity);
            } else if ('fillOpacity' in pt && 'fillColor' in pt) {
                out.fillStyle = gmxAPIutils.dec2color(fcDec, fop);
            }
        }

        if ('dashArray' in pt) { out.dashArray = pt.dashArray; }
        if ('dashOffset' in pt) { out.dashOffset = pt.dashOffset; }

        if (this.gmx.labelsLayer) {
            arr = gmxAPIutils.styleKeys.label.client;
            for (i = 0, len = arr.length; i < len; i++) {
                var it = arr[i];
                if (it in pt) {
                    if (it === 'labelField') {
                        if (!indexes[pt[it]]) {
                            continue;
                        }
                    } else if (it === 'labelTemplate') {
                        var properties = gmxAPIutils.getPropertiesHash(prop, indexes);
                        out.labelText = gmxAPIutils.parseTemplate(pt[it], properties);
                    }
                    out[it] = pt[it];
                }
            }
            if ('labelAnchor' in pt) {
                out.labelAnchor = pt.labelAnchor;
            }
        }
        return out;
    }
};
StyleManager.MAX_STYLE_SIZE = 256;
//StyleManager.DEFAULT_STYLE = {outline: {color: 255, thickness: 1}, marker: {size: 8, circle: true}};
StyleManager.DEFAULT_STYLE = {outline: {color: 255, thickness: 1}, marker: {size: 8}};
StyleManager.DEFAULT_KEYS = ['MinZoom', 'MaxZoom', 'Balloon', 'BalloonEnable', 'DisableBalloonOnMouseMove', 'DisableBalloonOnClick'];
StyleManager.DEFAULT_ICONPATH = [0, 10, 5, -10, -5, -10, 0, 10];  // [TL.x, TL.y, BR.x, BR.y, BL.x, BL.y, TL.x, TL.y]

StyleManager.parsePattern = function(pattern) {
    var common = true,
        parsers = L.gmx.Parsers;
    if ('step' in pattern && typeof (pattern.step) === 'string') {
        pattern.patternStepFunction = parsers.parseExpression(pattern.step);
        common = false;
    }
    if ('width' in pattern && typeof (pattern.width) === 'string') {
        pattern.patternWidthFunction = parsers.parseExpression(pattern.width);
        common = false;
    }
    if ('colors' in pattern) {
        var arr = [];
        for (var i = 0, len = pattern.colors.length; i < len; i++) {
            var rt = pattern.colors[i];
            if (typeof (rt) === 'string') {
                arr.push(parsers.parseExpression(rt));
                common = false;
            } else {
                arr.push(null);
            }
        }
        pattern.patternColorsFunction = arr;
    }
    return common;
};

StyleManager.getStyleKeys = function(style) {
    var out = {};
    for (var key in gmxAPIutils.styleKeys) {
        var keys = gmxAPIutils.styleKeys[key];
        for (var i = 0, len = keys.client.length; i < len; i++) {
            var key1 = keys.client[i];
            if (key1 in style) {
                if (style[key1] !== undefined) {
                    out[key1] = JSON.parse(JSON.stringify(style[key1]));
                }
                if (key1 === 'fillPattern') { delete out[key1].patternColorsFunction; }
                else if (key1 === 'fillLinearGradient') { delete out[key1].addColorStopFunctions; }
            }
        }
    }
    if ('iconAnchor' in style) {
        out.iconAnchor = style.iconAnchor;
    }
    if ('labelAnchor' in style) {
        out.labelAnchor = style.labelAnchor;
    }
    return out;
};

StyleManager.checkDiff = function(st, st1) {
    for (var key in st) {
        if (st[key] !== st1[key]) {
            return key;
        }
    }
    return null;
};

StyleManager.parseRadialGradient = function(rg) {
    //	x1,y1,r1 — координаты центра и радиус первой окружности;
    //	x2,y2,r2 — координаты центра и радиус второй окружности.
    //	addColorStop - стоп цвета объекта градиента [[position, color]...]
    //		position — положение цвета в градиенте. Значение должно быть в диапазоне 0.0 (начало) до 1.0 (конец);
    //		color — код цвета или формула.
    //		opacity — прозрачность
    //		canvasStyleColor — результрующий цвет в формате canvas
    var common = true,
        parsers = L.gmx.Parsers,
        i = 0,
        arr = ['r1', 'x1', 'y1', 'r2', 'x2', 'y2'],
        len = arr.length;
    for (i = 0; i < len; i++) {
        var it = arr[i];
        if (!rg[it]) { rg[it] = 0; }
        if (typeof (rg[it]) === 'string') {
            rg[it + 'Function'] = parsers.parseExpression(rg[it]);
            common = false;
        }
    }

    rg.addColorStop = rg.addColorStop || [[0, 0xFF0000, 0.5], [1, 0xFFFFFF, 0.5]];
    rg.addColorStopFunctions = [];
    for (i = 0, len = rg.addColorStop.length; i < len; i++) {
        arr = rg.addColorStop[i];
        var resFunc = [
                (typeof (arr[0]) === 'string' ? parsers.parseExpression(arr[0]) : null),
                (typeof (arr[1]) === 'string' ? parsers.parseExpression(arr[1]) : null),
                (typeof (arr[2]) === 'string' ? parsers.parseExpression(arr[2]) : null)
            ];
        rg.addColorStopFunctions.push(resFunc);
        if (resFunc[1] === null && resFunc[2] === null) {
            arr[3] = gmxAPIutils.dec2color(arr[1], arr[2] > 1 ? arr[2] / 100 : arr[2]);
        } else {
            common = false;
        }
    }
    if ('r2Function' in rg) { common = false; }
    return common ? Math.max(rg.r1, rg.r2) : null;
};

StyleManager.parseLinearGradient = function(lg) {
    var common = true;
    //	x1,y1 — координаты начальной точки
    //	x2,y2 — координаты конечной точки
    //	addColorStop - стоп цвета объекта градиента [[position, color]...]
    //		position — положение цвета в градиенте. Значение должно быть в диапазоне 0.0 (начало) до 1.0 (конец);
    //		color — код цвета или формула.
    //		opacity — прозрачность
    var i = 0,
        parsers = L.gmx.Parsers,
        arr = ['x1', 'y1', 'x2', 'y2'],
        def = [0, 0, 0, 256],
        len = arr.length;
    for (i = 0; i < len; i++) {
        var it = arr[i];
        if (it in lg) {
            if (typeof (lg[it]) === 'string') {
                lg[it + 'Function'] = parsers.parseExpression(lg[it]);
                common = false;
            }
        } else {
            lg[it] = def[i];
        }
    }

    lg.addColorStop = lg.addColorStop || [[0, 0xFF0000], [1, 0xFFFFFF]];
    lg.addColorStopFunctions = [];
    for (i = 0, len = lg.addColorStop.length; i < len; i++) {
        arr = lg.addColorStop[i];
        lg.addColorStopFunctions.push([
            (typeof (arr[0]) === 'string' ? parsers.parseExpression(arr[0]) : null),
            (typeof (arr[1]) === 'string' ? parsers.parseExpression(arr[1]) : null),
            (typeof (arr[2]) === 'string' ? parsers.parseExpression(arr[2]) : null)
        ]);
    }
    return common;
};


L.gmx.VectorLayer.include({
    bindPopup: function (content, options) {
        var popupOptions = L.extend({maxWidth: 10000, className: 'gmxPopup', layerId: this._gmx.layerID}, options);

        if (this._popup) { this.unbindPopup(); }
        if (content instanceof L.Popup) {
            this._popup = content;
        } else {
            if (!this._popup || options) {
                this._popup = new L.Popup(popupOptions);
            }
            this._popup.setContent(content);
        }
        this._popup._initContent = content;
        this._popup._state = '';

        if (!this._popupHandlersAdded) {
            this
                .on('click', this._openClickPopup, this)
                .on('mousemove', this._movePopup, this)
                .on('mouseover', this._overPopup, this)
                .on('mouseout', this._outPopup, this)
                .on('doneDraw', this._chkNeedOpenPopup, this);

            this._popupHandlersAdded = true;
        }
        if (popupOptions && popupOptions.popupopen) {
            this._popupopen = popupOptions.popupopen;
        }

        this._popup.updateLayout = this._popup._updateLayout;

        return this;
    },

	unbindPopup: function () {
		if (this._popup) {
			this._popup = null;
			this
			    .off('click', this._openClickPopup, this)
                .off('mousemove', this._movePopup, this)
			    .off('mouseover', this._overPopup, this)
                .off('mouseout', this._outPopup, this)
                .off('doneDraw', this._chkNeedOpenPopup, this);

            this._popupopen = null;
			this._popupHandlersAdded = false;
		}
        this._gmx.balloonEnable = false;
		return this;
	},

    _chkNeedOpenPopup: function () {
        for (var id in this._gmx._needPopups) {
            if (this._gmx._needPopups[id]) {
                this.addPopup(id);
                delete this._gmx._needPopups[id];
            }
        }
    },

    disablePopup: function () {
        this._popupDisabled = true;
		return this;
    },

    enablePopup: function () {
        this._popupDisabled = false;
		return this;
    },

	openPopup: function (latlng, options) {

		if (this._popup) {
			// open the popup from one of the path's points if not specified
			latlng = latlng || this._latlng ||
			         this._latlngs[Math.floor(this._latlngs.length / 2)];

			options = options || {};
            options.latlng = latlng;
            this._openPopup(options);
		}

		return this;
	},

	closePopup: function () {
		if (this._popup) {
			this._popup._close();
            this.fire('popupclose', {popup: this._popup});
		}
		return this;
	},

    _movePopup: function (options) {
        if (this._popup._state === 'mouseover') {
            var id = this._popup.options._gmxID || -1;
            if (id !== options.gmx.id) {
                this._setPopupContent(options);
            }
            this._popup.setLatLng(options.latlng);
        }
    },

    _overPopup: function (options) {
        var _popup = this._popup;
        if (!_popup._map) {
            this._openPopup(options);
        } else {
            this.fire('popupopen', {
                popup: _popup,
                gmx: this._setPopupContent(options, _popup)
            });
        }
        if (_popup._state === 'mouseover') {
            _popup.setLatLng(options.latlng);
        }
    },

    _outPopup: function (ev) {
        if (this._popup._state === 'mouseover' && !ev.gmx.prevId) {
            this.closePopup();
        }
    },

    _callBalloonHook: function (props, div) {

        var spans = div.getElementsByTagName('span'),
            hooksCount = {},
            key, i, len;
        for (key in this._balloonHook) {    // collect hook counts
            var hookID = this._balloonHook[key].hookID;
            hooksCount[key] = 0;
            for (i = 0, len = spans.length; i < len; i++) {
                if (spans[i].id === hookID) {
                    hooksCount[key]++;
                }
            }
        }

        for (key in this._balloonHook) {
            var hook = this._balloonHook[key],
                fid = hook.hookID,
                notFound = true;

            for (i = 0, len = spans.length; i < len; i++) {
                var node = spans[i];
                if (node.id === fid) {
                    notFound = false;
                    node.id += '_' + i;
                    hook.callback(props, div, node, hooksCount);
                }
            }
            if (notFound) {
                hook.callback(props, div, null, hooksCount);
            }
        }
    },

    _setPopupContent: function (options, _popup) {
        if (!_popup) { _popup = this._popup; }
        var gmx = options.gmx || {},
            balloonData = gmx.balloonData || {},
            properties = L.extend({}, gmx.properties),
            target = gmx.target || {},
            geometry = target.geometry || {},
            offset = target.offset,
            templateBalloon = _popup._initContent || balloonData.templateBalloon || '',
            type = options.type,
            skipSummary = this.options.isGeneralized && (type === 'mouseover' || type === 'mousemove'),
            outItem = {
                id: gmx.id,
                type: type,
                nodePoint: gmx.nodePoint,
                latlng: options.latlng,
                properties: properties,
                templateBalloon: templateBalloon
            };

        if (geometry.type === 'POINT') {
			var geoJson = L.gmxUtil.geometryToGeoJSON(geometry, true, gmx.srs === '3857');
            outItem.latlng = L.latLng(geoJson.coordinates.reverse());
        }
        if (offset) {
            var protoOffset = L.Popup.prototype.options.offset;
            _popup.options.offset = [-protoOffset[0] - offset[0], protoOffset[1] - offset[1]];
        }

        if (this._popupopen) {
            this._popupopen({
                popup: _popup,
                latlng: outItem.latlng,
                layerPoint: options.layerPoint,
                contentNode: _popup._contentNode,
                containerPoint: options.containerPoint,
                originalEvent: options.originalEvent,
                gmx: outItem
            });
        } else if (!(templateBalloon instanceof L.Popup)) {
            if (!(templateBalloon instanceof HTMLElement)) {
                var geometries,
                    summary = '',
                    unitOptions = this._map ? this._map.options : {};

                if (!skipSummary) {
                    geometries = target.geometry ? [target.geometry] : (gmx.geometries || this._gmx.dataManager.getItemGeometries(gmx.id) || []);
                    outItem.summary = summary = L.gmxUtil.getGeometriesSummary(geometries, unitOptions);
                }
                if (this._balloonHook) {
                    if (!templateBalloon) {
                        templateBalloon = gmxAPIutils.getDefaultBalloonTemplate(properties);
                    }
                    for (var key in this._balloonHook) {
                        properties[key] = gmxAPIutils.parseTemplate(this._balloonHook[key].resStr, properties);
                    }
                }
                templateBalloon = L.gmxUtil.parseBalloonTemplate(templateBalloon, {
                    properties: properties,
                    tileAttributeTypes: this._gmx.tileAttributeTypes,
                    unitOptions: unitOptions,
                    summary: summary,
                    geometries: geometries
                });
            }

            var contentDiv = L.DomUtil.create('div', '');
            contentDiv.innerHTML = templateBalloon;
            _popup.setContent(contentDiv);
            if (this._balloonHook) {
                this._callBalloonHook(gmx.properties, _popup.getContent());
            }
            //outItem.templateBalloon = templateBalloon;
        }
        _popup.options._gmxID = gmx.id;
        return outItem;
    },

    _openClickPopup: function (options) {
        var originalEvent = options.originalEvent || {},
            skip = !options.gmx || this._popupDisabled || originalEvent.ctrlKey || originalEvent.altKey || originalEvent.shiftKey;

        if (!skip) {
            var type = options.type,
                gmx = options.gmx,
                balloonData = gmx.balloonData,
                flag = type === 'click' && balloonData.isSummary && !balloonData.DisableBalloonOnClick,
                item = gmx.target;

            if (flag && item.options.isGeneralized && !item.geometry) {
                var layerProp = gmx.layer.getGmxProperties();
                gmxAPIutils.getLayerItemFromServer({
                    options: options,
                    layerID: layerProp.name,
                    value: item.id,
                    field: layerProp.identityField
                }).then(function(json, params) {
                    if (json && json.Status === 'ok' && json.Result) {
                        var pArr = json.Result.values[0];
                        params.options.gmx.target.fromServerProps = pArr;
                        params.options.gmx.target.geometry = pArr[pArr.length - 1];
                        this._openPopup(params.options);
                    }
                }.bind(this));
            } else {
				if (item.type.indexOf('POINT') !== -1) {
					options.latlng = L.latLng(L.gmxUtil.geometryToGeoJSON(item.properties[item.properties.length - 1], true, this._gmx.srs === '3857').coordinates.reverse());
                }
				this._openPopup(options);
            }
        }
    },

    _openPopup: function (options, notSkip) {
        var map = this._map,
            originalEvent = options.originalEvent || {},
            skip = notSkip ? !notSkip : this._popupDisabled || originalEvent.ctrlKey || originalEvent.altKey || originalEvent.shiftKey;

        if (!skip) {
            var type = options.type,
                _popup = this._popup,
                gmx = options.gmx || {},
                balloonData = gmx.balloonData || {};

            if (type === 'click') {
                if (!notSkip && balloonData.DisableBalloonOnClick && !this.hasEventListeners('popupopen')) { return; }

                if (!('_gmxPopups' in map)) {
                    map._gmxPopups = [];
                }
                if (!('maxPopupCount' in map.options)) { map.options.maxPopupCount = 1; }
                if (!this._gmx._gmxPopupsInit) {
                    this._gmx._gmxPopupsInit = true;
                    map.on({
                        layerremove: function (ev) {
                            if (ev.layer instanceof L.Popup) {
                                this._clearPopup(ev.layer);
                            } else if (ev.layer === this) {
                                if (map._gmxPopups) {
                                    var layerId = this._gmx.layerID;
                                    map._gmxPopups = map._gmxPopups.reduce(function(p, c) {
                                        if (c._map) {
                                            if (c.options.layerId === layerId) { c._map.removeLayer(c); }
                                            else { p.push(c); }
                                        }
                                        return p;
                                    }, []);
                                }
                                this.closePopup();
                            }
                        }
                    }, this);
                }

                this._clearPopup(gmx.id);
                var opt = this._popup ? this._popup.options : {maxWidth: 10000, className: 'gmxPopup', layerId: this._gmx.layerID};
                _popup = new L.Popup(L.extend({}, opt, {closeOnClick: map.options.maxPopupCount === 1, autoPan: true}));
            } else if (type === 'mouseover') {
                if (balloonData.DisableBalloonOnMouseMove) {
                    _popup._state = '';
                    return;
                }
                _popup.options.autoPan = false;
            } else {
                return;
            }
            _popup.options.objectId = gmx.id;
            _popup._state = type;
            var outItem = this._setPopupContent(options, _popup);
            _popup.setLatLng(outItem.latlng);

            this.fire('popupopen', {
                popup: _popup,
                gmx: outItem
            });
            if (type === 'click') {
                if (map._gmxPopups.length >= map.options.maxPopupCount) {
                    map.removeLayer(map._gmxPopups.shift());
                }
                map._gmxPopups.push(_popup);
            }
            _popup.addTo(map);    // this._map.openPopup(_popup);

            if (_popup._closeButton) {
                var closeStyle = _popup._closeButton.style;
                if (type === 'mouseover' && closeStyle !== 'hidden') {
                    closeStyle.visibility = 'hidden';
                    _popup._container.style.marginBottom = '7px';
                    _popup._container.style.pointerEvents = 'none';
                } else if (type === 'click' && closeStyle !== 'inherit') {
                    closeStyle.visibility = 'inherit';
                    _popup._container.style.marginBottom = '';
                    _popup._container.style.pointerEvents = '';
                }
            }
        }
    },

	_clearPopup: function (item /* <L.Popup> or objectId */) {
        var map = this._map;
        if (map && map._gmxPopups) {
            var layerId = this._gmx.layerID,
                flagPopup = item instanceof L.Popup;
            map._gmxPopups = map._gmxPopups.reduce(function(p, c) {
                if (c._map) {
                    if (flagPopup && c === item) { c._map.removeLayer(c); }
                    else if (c.options.layerId === layerId && c.options.objectId === item) { c._map.removeLayer(c); }
                    else { p.push(c); }
                }
                return p;
            }, []);
        }
    },

    getPopups: function (flag) {
        var map = this._map,
            out = [];
        if (map && map._gmxPopups) {
            var layerId = this._gmx.layerID;
            map._gmxPopups.reduce(function(p, c) {
                if (c.options.layerId === layerId) { p.push(flag ? c : c.options.objectId); }
                return p;
            }, out);
        }
        return out;
    },

    addPopup: function (id) {
        var gmx = this._gmx,
            item = gmx.dataManager.getItem(id);
        if (!item || !this._map) {
            gmx._needPopups[id] = false;
        } else {
            var center = item.bounds.getCenter(),
                latlng = L.latLng(L.gmxUtil.coordsFromMercator('Point', center, gmx.srs === '3857').reverse());
            this._openPopup({
                type: 'click',
                latlng: latlng,
                gmx: this.getHoverOption(item)
            }, true);
            delete gmx._needPopups[id];
        }
        return this;
    },

    addPopupHook: function (key, callback) {
        if (!this._balloonHook) { this._balloonHook = {}; }
        if (!this._balloonHook[key]) {
            var hookID = '_' + L.stamp({});
            this._balloonHook[key] = {
                key: key,
                hookID: hookID,
                resStr: '<span id="' + hookID + '"></span>',
                callback: callback
            };
        }
        return this;
    },

    removePopupHook: function(key) {
        if (this._balloonHook) { delete this._balloonHook[key]; }
        return this;
    }
});


L.gmx.VectorLayer.include({
    _gmxFirstObjectsByPoint: function (geoItems, mercPoint, bounds) {    // Получить верхний объект по координатам mouseClick
        var gmx = this._gmx,
            mInPixel = gmx.mInPixel,
            j,
            len;

        for (var i = geoItems.length - 1; i >= 0; i--) {
            var geoItem = geoItems[i].properties,
                idr = geoItem[0],
                dataOption = geoItems[i].dataOption || {},
                item = gmx.dataManager.getItem(idr),
                currentStyle = item.currentStyle || item.parsedStyleKeys || {},
                iconScale = currentStyle.iconScale || 1,
                iconCenter = currentStyle.iconCenter,
                iconAnchor = !iconCenter && currentStyle.iconAnchor ? currentStyle.iconAnchor : null,
                parsedStyle = gmx.styleManager.getObjStyle(item),
                lineWidth = currentStyle.lineWidth || parsedStyle.lineWidth || 0,
                sx = lineWidth + (parsedStyle.sx || currentStyle.sx || 0),
                sy = lineWidth + (parsedStyle.sy || currentStyle.sy || 0),
                offset = [
                    iconScale * sx / 2,
                    iconScale * sy / 2
                ],
                point = mercPoint,
                geom = geoItem[geoItem.length - 1],
                type = geom.type;

            if (type === 'POINT' && parsedStyle.type === 'circle') {
                offset[0] *= 2;
                offset[1] *= 2;
            }
            var radius = offset[0],
                objBounds = gmxAPIutils.bounds()
                    .extendBounds(dataOption.bounds)
                    .addBuffer(offset[0] / mInPixel, offset[1] / mInPixel);
            if (iconAnchor) {
                offset = [
                    iconAnchor[0] - offset[0],
                    iconAnchor[1] - offset[1]
                ];
                point = [
                    mercPoint[0] + offset[0] / mInPixel,
                    mercPoint[1] - offset[1] / mInPixel
                ];
            }
            if (!objBounds.contains(point)) { continue; }

            var fill = currentStyle.fillStyle || currentStyle.canvasPattern || parsedStyle.bgImage || parsedStyle.fillColor,
                marker = parsedStyle && parsedStyle.image ? parsedStyle.image : null,
                chktype = type,
                hiddenLines = dataOption.hiddenLines || [],
                boundsArr = dataOption.boundsArr,
                coords = geom.coordinates,
                nodePoint = null,
                ph = {
                    point: mercPoint,
                    bounds: bounds,
                    coords: coords,
                    boundsArr: boundsArr
                };

            if (type === 'MULTIPOLYGON' || type === 'POLYGON') {
                if (marker) {
                    chktype = 'POINT';
                } else if (!fill) {
                    if (type === 'POLYGON') {
                        chktype = 'MULTILINESTRING';
                        hiddenLines = hiddenLines[0];
                    } else {
                        chktype = 'LIKEMULTILINESTRING';
                    }
                    ph.hidden = hiddenLines;
                }
            }

            if (chktype === 'LINESTRING') {
                if (!gmxAPIutils.isPointInPolyLine(mercPoint, lineWidth / mInPixel, coords)) {
                    nodePoint = gmxAPIutils.bounds([point]).addBuffer(offset[0] / mInPixel, offset[1] / mInPixel).isNodeIntersect(coords);
                    if (nodePoint === null) { continue; }
                }
            } else if (chktype === 'LIKEMULTILINESTRING') {
                ph.delta = lineWidth / mInPixel;
                var flag = false;
                for (j = 0, len = coords.length; j < len; j++) {
                    ph.coords = coords[j];
                    ph.hidden = hiddenLines ? hiddenLines[j] : null;
                    ph.boundsArr = boundsArr[j];
                    if (gmxAPIutils.isPointInLines(ph)) {
                        flag = true;
                        break;
                    }
                }
                if (!flag) { continue; }
            } else if (chktype === 'MULTILINESTRING') {
                ph.delta = lineWidth / mInPixel;
                ph.hidden = hiddenLines;
                if (!gmxAPIutils.isPointInLines(ph)) {
                    var pBounds = gmxAPIutils.bounds([point]).addBuffer(offset[0] / mInPixel, offset[1] / mInPixel);
                    for (j = 0, len = coords.length; j < len; j++) {
                        nodePoint = pBounds.isNodeIntersect(coords[j]);
                        if (nodePoint !== null) {
                            nodePoint.ring = j;
                            break;
                        }
                    }
                    if (nodePoint === null) { continue; }
                }
            } else if (chktype === 'MULTIPOLYGON' || chktype === 'POLYGON') {
                var chkPoint = mercPoint;
                flag = false;
                if (chktype === 'POLYGON') {
                    coords = [geom.coordinates];
                    boundsArr = [dataOption.boundsArr];
                }
                for (j = 0, len = coords.length; j < len; j++) {
                    var arr = coords[j],
                        bbox = boundsArr[j];
                    for (var j1 = 0, len1 = arr.length; j1 < len1; j1++) {
                        var b = bbox[j1];
                        if (b.intersects(bounds)) {
                            if (gmxAPIutils.isPointInPolygonWithHoles(chkPoint, arr)) {
                                flag = j1 === 0 ? true : false;
                                break;
                            }
                        }
                    }
                }
                if (!flag) { continue; }
            } else if (chktype === 'POINT') {
                if (parsedStyle.type === 'circle') {
                    var x = (coords[0] - point[0]) * mInPixel,
                        y = (coords[1] - point[1]) * mInPixel;
                    if (x * x + y * y > radius * radius) { continue; }
                }
            }
            if (!this.isPointInClipPolygons(mercPoint)) {
                continue;
            }

            return {
                id: idr,
                properties: item.properties,
                geometry: geom,
                bounds: item.bounds,
                nodePoint: nodePoint,
                offset: iconAnchor ? offset : null,
                parsedStyle: parsedStyle
            };
        }
        return null;
    },

    gmxEventCheck: function (ev, skipOver) {
        if (!this._map) {
            return 0;
        }
        var layer = this,
            gmx = layer._gmx,
            type = ev.type,
            lastHover = gmx.lastHover,
            chkHover = function (evType) {
                if (lastHover && type === 'mousemove') {
                    if (evType && layer.hasEventListeners(evType)) {
                        ev.gmx = lastHover;
                        layer.fire(evType, ev);
                    }
                    if (lastHover.hoverDiff) { layer.redrawItem(lastHover.id); }
                }
            };

        var zoom = this._map.getZoom();
        if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
            skipOver = true;
        }
        if (skipOver) {
            if (lastHover) { lastHover.prevId = null; }
            chkHover('mouseout');
            gmx.lastHover = null;
        } else if (
            this.hasEventListeners('mouseover') ||
            this.hasEventListeners('mouseout') ||
            this.hasEventListeners(type) ||
            (type === 'mousemove' && gmx.properties.fromType !== 'Raster')
            ) {

            var lng = ev.latlng.lng % 360,
                latlng = new L.LatLng(ev.latlng.lat, lng + (lng < -180 ? 360 : (lng > 180 ? -360 : 0))),
				crs = gmx.srs === '3857' ? L.CRS.EPSG3857 : L.Projection.Mercator,
                point = crs.project(latlng)._subtract(
                    {x: gmx.shiftXlayer || 0, y: gmx.shiftYlayer || 0}
                ),
                delta = Math.max(5, gmx.styleManager._getMaxStyleSize(zoom)) / gmx.mInPixel,
                mercatorPoint = [point.x, point.y],
				filters = gmx.dataManager.getViewFilters('screen', gmx.layerID);

            //создаём observer только для того, чтобы сделать выборку данных вокруг курсора
            var observerOptions = {
                type: 'resend',
				layerID: gmx.layerID,
				needBbox: gmx.needBbox,
                bbox: gmxAPIutils.bounds([mercatorPoint]).addBuffer(delta),
                dateInterval: gmx.layerType === 'VectorTemporal' ? [gmx.beginDate, gmx.endDate] : null,
                filters: ['clipFilter', 'userFilter_' + gmx.layerID, 'styleFilter', 'userFilter'].concat(filters),
                active: false //делаем его неактивным, так как потом будем явно выбирать данные
            };
            if (this.options.isGeneralized) {
                observerOptions.targetZoom = zoom;
            }

            gmx.dataManager.addObserver(observerOptions, 'hover');

            var geoItems = gmx.dataManager.getItems('hover');

            gmx.dataManager.removeObserver('hover');

            if (geoItems && geoItems.length) {
                if (geoItems.length > 1 && gmx.sortItems) { geoItems = this.getSortedItems(geoItems); }

                var target = this._gmxFirstObjectsByPoint(geoItems, mercatorPoint, observerOptions.bbox);
                if (target) {
                    var idr = target.id,
                        item = gmx.dataManager.getItem(idr),
                        prevId = lastHover ? lastHover.id : null,
                        changed = !lastHover || lastHover.id !== idr;
                    if (type === 'mousemove' && lastHover) {
                        if (!changed) {
                            ev.gmx = lastHover;
                            this.fire(type, ev);
                            return idr;
                        }
                        chkHover(item.currentFilter !== lastHover.currentFilter ? 'mouseout' : '');
                        gmx.lastHover = null;
                    }

                    ev.gmx = L.extend(this.getHoverOption(item), {
                        targets: geoItems,
                        nodePoint: target.nodePoint,
                        prevId: prevId,
                        hoverDiff: item.hoverDiff
                    });
                    if (this.hasEventListeners(type)) { this.fire(type, ev); }
                    if (type === 'mousemove' && changed) {
                        lastHover = gmx.lastHover = ev.gmx;
                        chkHover('mouseover');
                        gmx.lastMouseover = gmx.lastHover;
                    }
                    this._map.doubleClickZoom.disable();
                    return idr;
                }
            }
        }
        if (this._map) {
            this._map.doubleClickZoom.enable();
        }
        return 0;
    },

    getHoverOption: function (item) {
        return {
            layer: this,
            target: item,
            balloonData: this._gmx.styleManager.getItemBalloon(item.id),
            properties: this.getItemProperties(item.properties),
            currentFilter: item.currentFilter || 0,
            id: item.id
        };
    }
});


(function() {
var delay = 20000,
    layers = {},
    dataManagersLinks = {},
    script = '/Layer/CheckVersion.ashx',
    intervalID = null,
    timeoutID = null,
    lastLayersStr = '';

var isExistsTiles = function(prop) {
    var tilesKey = prop.Temporal ? 'TemporalTiles' : 'tiles';
    return tilesKey in prop || prop.currentTiles;
};
var getParams = function(prop, dm, gmx) {
    var pt = {
        Name: prop.name,
        Version: isExistsTiles(prop) ? prop.LayerVersion : -1
    };
	if (dm && (prop.UseTiles === false || gmx.skipTiles === 'NotVisible' || gmx.needBbox)) {
		var maxDateInterval = dm.getMaxDateInterval(),
			beginDate = maxDateInterval.beginDate || gmx.beginDate,
			endDate = maxDateInterval.endDate || gmx.endDate;
        if (beginDate) { pt.dateBegin = Math.floor(beginDate.getTime() / 1000); }
        if (endDate) { pt.dateEnd = Math.floor(endDate.getTime() / 1000); }
    }
    return pt;
};
var getRequestParams = function(layer) {
    var hosts = {},
        prop, hostName, dm, gmx;
    if (layer) {
        if (layer.target instanceof L.gmx.DataManager) {
			layer = layer.target;
		}
        if (layer instanceof L.gmx.DataManager) {
			dm = layer;
			prop = dm.options;
		} else {
			prop = layer._gmx.properties;
			dm = layer._gmx.dataManager;
			gmx = layer._gmx;
		}
        hostName = prop.hostName || layer._gmx.hostName;
		hosts[hostName] = [getParams(prop, dm, gmx)];
    } else {
        var skipItems = {};
        for (var id in layers) {
            var obj = layers[id],
				isDataManager = obj instanceof L.gmx.DataManager;
            if (obj.options.chkUpdate || isDataManager) {
				dm = isDataManager ? obj : obj._gmx.dataManager;
                prop = isDataManager ? obj.options : obj._gmx.properties;
				gmx = isDataManager ? obj : obj._gmx;
                hostName = prop.hostName || obj._gmx.hostName;
                var pt = getParams(prop, dm, gmx),
                    key = pt.Name + pt.Version;
                if (!skipItems[key]) {
                    if (hosts[hostName]) { hosts[hostName].push(pt); }
                    else { hosts[hostName] = [pt]; }
                }
                skipItems[key] = true;
            }
        }
    }
    return hosts;
};

var chkVersion = function (layer, callback) {
	var map = layersVersion._map;
    var processResponse = function(res) {
        if (res && res.Status === 'ok' && res.Result) {
			var arr = res.Result,
				len = arr.length,
				count = 0,
				i, key, curLayer, id, item;

			if (layersVersion.needBbox) {
				for (i = 0; i < len; i++) {
					item = arr[i];
					id = item.name || item.properties.name;
					curLayer = null;
					if (layer && layer._gmx.properties.name === id) {
						curLayer = layer;
					} else {
						for (key in layers) {
							curLayer = layers[key];
							if (layer && layer === curLayer && 'updateVersion' in layer) { continue; }
							if (curLayer._gmx && curLayer._gmx.properties.name === id && 'updateVersion' in curLayer) {	// слои
								break;
							} else if (curLayer instanceof L.gmx.DataManager && curLayer.options.name === id) {	// источники данных
								break;
							}
						}
					}
					if (curLayer) {
						count += (curLayer.getDataManager ? curLayer.getDataManager() : curLayer).getNotLoadedVectorTiles(item);
					}
				}
				map.fire('needLoadTiles', {count: count});
				if (L.gmx.skipLoadTiles) {
					console.log('Skiped tiles: ', L.gmx.needLoadTiles);
					return;
				}
			}

            for (i = 0; i < len; i++) {
                item = arr[i];
				id = item.name || item.properties.name;

				if (layer && layer._gmx.properties.name === id && 'updateVersion' in layer) { layer.updateVersion(item); }
                for (key in layers) {
                    curLayer = layers[key];
					if (layer && layer === curLayer) { continue; }
                    if (curLayer._gmx && curLayer._gmx.properties.name === id && 'updateVersion' in curLayer) {	// слои
						curLayer.updateVersion(item);
					} else if (curLayer instanceof L.gmx.DataManager && curLayer.options.name === id) {	// источники данных
						curLayer.updateVersion(item.properties, item.tiles);
					}
                }
            }
        }
        lastLayersStr = '';
        if (callback) { callback(res); }
    };

    if (document.body && !L.gmxUtil.isPageHidden()) {
        var hosts = getRequestParams(layer),
            chkHost = function(hostName) {
				var url = L.gmxUtil.protocol + '//' + hostName + script,
                    layersStr = JSON.stringify(hosts[hostName]);

                if (lastLayersStr !== layersStr) {
                    lastLayersStr = layersStr;
                    if ('FormData' in window) {
						var params = 'WrapStyle=None';
						if (layersVersion.needBbox) {
							var crs = L.Projection.Mercator;
							if (map.options.srs === '3857') {
								params += '&srs=3857';
								crs = L.CRS.EPSG3857;
							}
							var zoom = map.getZoom(),
								bbox = map.getBounds(),
								min = crs.project(bbox.getSouthWest()),
								max = crs.project(bbox.getNorthEast()),
								bboxStr = [min.x, min.y, max.x, max.y].join(',');
							params += '&zoom=' + zoom;
							params += '&bbox=[' + bboxStr + ']';
						}
						params += '&layers=' + encodeURIComponent(layersStr);
                        L.gmxUtil.request({
                            url: url,
                            async: true,
                            headers: {
                                'Content-type': 'application/x-www-form-urlencoded'
                            },
                            type: 'POST',
                            params: params,
                            withCredentials: true,
                            callback: function(response) {
                                processResponse(JSON.parse(response));
                            },
                            onError: function(response) {
                                console.log('Error: LayerVersion ', response);
                            }
                        });
                    } else {
                        L.gmxUtil.sendCrossDomainPostRequest(url, {
                            WrapStyle: 'message',
                            layers: layersStr
                        }, processResponse);
                    }
                    var timeStamp = Date.now();
                    for (var key in layers) {
                        var it = layers[key];
                        var options = it._gmx || it.options;
                        if (options.hostName === hostName) { options._stampVersionRequest = timeStamp; }
                    }
                }
            };
        for (var hostName in hosts) {
            chkHost(hostName);
        }
    }
};

var layersVersion = {
    needBbox: false,

    addDataManager: function(dataManager) {
        var options = dataManager.options,
			id = options.name;
        if (id in layers) {
            return;
		}
		if (options.needBbox && !layersVersion.needBbox) {
			layersVersion.needBbox = options.needBbox;
		}
		dataManager.on('chkLayerUpdate', chkVersion.bind(dataManager));
		layers[id] = dataManager;
    },

    removeDataManager: function(dataManager) {
        var id = dataManager.options.name;
        if (id in layers) {
			dataManager.off('chkLayerUpdate', chkVersion.bind(dataManager));
			delete layers[id];
		}
    },

    remove: function(layer) {
        delete layers[layer._leaflet_id];
        var _gmx = layer._gmx,
			pOptions = layer.options.parentOptions;
		if (pOptions) {
			var pId = pOptions.name;
			if (dataManagersLinks[pId]) {
				delete dataManagersLinks[pId][_gmx.properties.name];
				if (!Object.keys(dataManagersLinks[pId]).length) {
					layersVersion.removeDataManager(_gmx.dataManager);
					delete dataManagersLinks[pId];
				}
			}
		} else {
			_gmx.dataManager.off('chkLayerUpdate', _gmx._chkVersion);
		}
    },

    add: function(layer) {
        var id = layer._leaflet_id;
        if (id in layers) {
            return;
		}

        var _gmx = layer._gmx,
            prop = _gmx.properties;
        if ('LayerVersion' in prop) {
            layers[id] = layer;
            _gmx._chkVersion = function () {
                chkVersion(layer);
            };
            _gmx.dataManager.on('chkLayerUpdate', _gmx._chkVersion);
			var pOptions = layer.options.parentOptions;
			if (pOptions) {
				var pId = pOptions.name;
				layersVersion.addDataManager(_gmx.dataManager);
				if (!dataManagersLinks[pId]) { dataManagersLinks[pId] = {}; }
				dataManagersLinks[pId][prop.name] = layer;
			}

            if (_gmx.needBbox && !layersVersion.needBbox) {
				layersVersion.needBbox = _gmx.needBbox;
			}
			layersVersion.start();
            if (!_gmx._stampVersionRequest || _gmx._stampVersionRequest < Date.now() - 19000 || !isExistsTiles(prop)) {
				layersVersion.now();
            }
        }
    },

    chkVersion: chkVersion,

    now: function() {
		if (timeoutID) { clearTimeout(timeoutID); }
		timeoutID = setTimeout(chkVersion, 0);
    },

    stop: function() {
        if (intervalID) { clearInterval(intervalID); }
        intervalID = null;
    },

    start: function(msec) {
        if (msec) { delay = msec; }
        layersVersion.stop();
        intervalID = setInterval(chkVersion, delay);
    }
};

if (!L.gmx) { L.gmx = {}; }
L.gmx.layersVersion = layersVersion;

L.gmx.VectorLayer.include({
    updateVersion: function (layerDescription) {
        if (layerDescription) {
            var gmx = this._gmx;
            if (layerDescription.geometry) {
                gmx.geometry = layerDescription.geometry;
            }
            if (layerDescription.properties) {
                L.extend(gmx.properties, layerDescription.properties);
                gmx.properties.currentTiles = layerDescription.tiles;
                gmx.properties.GeoProcessing = layerDescription.properties.GeoProcessing;
                gmx.rawProperties = gmx.properties;
                this.fire('versionchange');
            }
			if (!gmx.dataSource && gmx.dataManager) {
				gmx.dataManager.updateVersion(gmx.rawProperties, layerDescription.tiles);
			}
        }
    }
});
L.Map.addInitHook(function () {
	layersVersion._map = this;
	var map = this,
		prev = {};
	this.on('moveend', function () {
		var z = map.getZoom(),
			center = map.getPixelBounds().getCenter();
		if (z !== prev.z || prev.center.distanceTo(center) > 128) {
			chkVersion();
			prev.z = z;
			prev.center = center;
		}
	});
});

})();


//Raster layer is just vector layer with the single object and special background tiles
L.gmx.RasterLayer = L.gmx.VectorLayer.extend(
{
    options: {
        isGeneralized: false,
        zIndexOffset: 0
        //clickable: false
    },
    initFromDescription: function(ph) {
        var props = ph.properties,
            styles = props.styles[0] || {MinZoom: props.MinZoom || 0, MaxZoom: props.MaxZoom || 21},
            vectorProperties = {
                type: 'Vector',
                fromType: props.type,
                identityField: 'ogc_fid',
                GeometryType: 'POLYGON',
                IsRasterCatalog: true,
                Copyright: props.Copyright || '',
                RCMinZoomForRasters: styles.MinZoom,
                visible: props.visible,
                styles: [{
                    DisableBalloonOnClick: true,
                    MinZoom: styles.MinZoom,
                    MaxZoom: styles.MaxZoom,
                    RenderStyle: {outline: {thickness: 0}, fill: {opacity: 100}},
                    HoverStyle: null
                }]
            },
            gmx = this._gmx,
            worldSize = gmxAPIutils.tileSizes[1];

        if (props.MaxZoom) {
            gmx.maxNativeZoom = props.MaxZoom;
        }
        if (!ph.geometry) {
            ph.geometry = {
                type: 'POLYGON',
                coordinates: [[[-worldSize, -worldSize], [-worldSize, worldSize], [worldSize, worldSize], [worldSize, -worldSize], [-worldSize, -worldSize]]]
            };
        }

		L.gmx.VectorLayer.prototype.initFromDescription.call(this, {geometry: ph.geometry, properties: vectorProperties, rawProperties: ph.properties});

        gmx.rasterBGfunc = function(x, y, z) {
			var url = L.gmxUtil.protocol + '//' + gmx.hostName + '/' +
					'TileSender.ashx?ModeKey=tile' +
					'&z=' + z +
					'&x=' + x +
					'&y=' + y;
			if (gmx.srs) { url += '&srs=' + gmx.srs; }
			if (gmx.crossOrigin) { url += '&cross=' + gmx.crossOrigin; }
			url += '&LayerName=' + gmx.layerID;
			if (gmx.sessionKey) { url += '&key=' + encodeURIComponent(gmx.sessionKey); }
			return url;
		};

		var vectorDataProvider = {load: function(x, y, z, v, s, d, callback) {
            var objects = [[777, ph.geometry]],
                itemBounds = gmxAPIutils.geoItemBounds(ph.geometry),
                bounds = itemBounds.bounds;

            if (bounds.max.x > worldSize) {
                // for old layers geometry
                var ww2 = 2 * worldSize,
                    id = 777,
                    coords = ph.geometry.coordinates,
                    bboxArr = itemBounds.boundsArr;

                objects = [];
                if (ph.geometry.type === 'POLYGON') {
                    coords = [coords];
                    bboxArr = [bboxArr];
                }

                for (var i = 0, len = coords.length; i < len; i++) {
                    var it = coords[i],
                        bbox = bboxArr[i][0],
                        arr = it;
                    objects.push([id++, {type: 'POLYGON', coordinates: arr}]);
                    if (bbox.max.x > worldSize) {
                        arr = [];
                        for (var j = 0, len1 = it.length; j < len1; j++) {
                            var it1 = it[j];
                            for (var j1 = 0, arr1 = [], len2 = it1.length; j1 < len2; j1++) {
                                var it2 = it1[j1];
                                arr1.push([it2[0] - ww2, it2[1]]);
                            }
                            arr.push(arr1);
                        }
                        objects.push([id++, {type: 'POLYGON', coordinates: arr}]);
                    }
                }
            }
			callback(objects, [bounds.min.x, bounds.min.y, bounds.max.x, bounds.max.y]);
		}};
		gmx.dataManager._rasterVectorTile = new VectorTile(vectorDataProvider, {x: -0.5, y: -0.5, z: 0, v: 0, s: -2, d: -2});
		gmx.dataManager.addTile(gmx.dataManager._rasterVectorTile);

        return this;
    },

    setZoomBounds: function(minZoom, maxZoom) {
        var styles = this.getStyles().slice(0);
        styles[0] = L.extend({}, styles[0]);
        styles[0].MinZoom = minZoom;
        styles[0].MaxZoom = maxZoom;
        this.setStyles(styles);
    }
});


/*
 (c) 2014, Sergey Alekseev
 Leaflet.LabelsLayer, plugin for Gemixer layers.
*/
L.LabelsLayer = L.Class.extend({

    options: {
        pane: 'overlayPane'
    },

    initialize: function (map, options) {
        L.setOptions(this, options);
        this._observers = {};
        this._styleManagers = {};
        this._labels = {};
        var _this = this;

        this.bbox = gmxAPIutils.bounds();

        var chkData = function (data, layer) {
            if (!data.added && !data.removed) { return; }

            var opt = layer.options,
                added = map._zoom >= opt.minZoom && map._zoom <= opt.maxZoom ? data.added : [],
                layerId = '_' + layer._leaflet_id,
                gmx = layer._gmx,
                labels = {};

            for (var i = 0, len = added.length; i < len; i++) {
                var item = added[i].item,
                    isPoint = item.type === 'POINT' || item.type === 'MULTIPOINT',
                    currentStyle = item.parsedStyleKeys || item.currentStyle || {};

                if (gmx.styleHook) {
                    var styleExtend = gmx.styleHook(item, gmx.lastHover && item.id === gmx.lastHover.id);
                    if (styleExtend) {
                        currentStyle = L.extend({}, currentStyle, styleExtend);
                    } else {
                        continue;
                    }
                }
                if (item.multiFilters) {
                    for (var j = 0, len1 = item.multiFilters.length; j < len1; j++) {
                        var st = item.multiFilters[j].parsedStyle;
                        if ('labelField' in st || 'labelText' in st) {
                            currentStyle = st;
                            break;
                        }
                    }
                }
                var style = gmx.styleManager.getObjStyle(item) || {},
                    labelText = currentStyle.labelText || style.labelText,
                    labelField = currentStyle.labelField || style.labelField,
                    fieldType = gmx.tileAttributeTypes[labelField],
                    txt = String(labelText || L.gmxUtil.attrToString(fieldType, layer.getPropItem(labelField, item.properties)));

                if (style.labelTemplate) {
					var reg = /\[([^\]]*)\]/g,
						match;
					txt = style.labelTemplate;

					while ((match = reg.exec(style.labelTemplate))) {
						if (match.length === 2) {
							labelField = match[1];
							fieldType = gmx.tileAttributeTypes[labelField];
							var val = L.gmxUtil.attrToString(fieldType, layer.getPropItem(labelField, item.properties));
							txt = txt.replace(match[0], val);
						}
					}
                }
				if (txt || txt === 0) {
                    var fontSize = style.labelFontSize || currentStyle.labelFontSize || 12,
                        id = '_' + item.id,
                        changed = true,
                        width = 0,
						arrTxtWidth,
                        options = item.options,
                        labelStyle = {
                            font: fontSize + 'px "Arial"',
                            labelHaloColor: ('labelHaloColor' in currentStyle ? currentStyle.labelHaloColor : ('labelHaloColor' in style ? style.labelHaloColor : 0xffffff)),
                            labelColor: currentStyle.labelColor || style.labelColor,
                            labelAlign: currentStyle.labelAlign || style.labelAlign,
                            labelAnchor: currentStyle.labelAnchor || style.labelAnchor,
                            labelFontSize: fontSize
                        };
                    if (options) {
                        if (!('center' in options)) {
                            var center = gmxAPIutils.getItemCenter(item, gmx.dataManager.getItemMembers(item.id));
                            if (!center) { continue; }
                            options.center = center;
                        }
                        if (options.label) {
                            width = options.label.width;
                            arrTxtWidth = options.label.arrTxtWidth;
                            var pstyle = options.label.style;
                            changed = options.label.txt !== txt ||
                                pstyle.labelHaloColor !== labelStyle.labelHaloColor ||
                                pstyle.labelColor !== labelStyle.labelColor ||
                                pstyle.labelAlign !== labelStyle.labelAlign ||
                                pstyle.labelAnchor !== labelStyle.labelAnchor ||
                                pstyle.labelFontSize !== labelStyle.labelFontSize;
                        }
                    }
                    if (changed) {
						width = 0;
                        arrTxtWidth = gmxAPIutils.getLabelWidth(txt, labelStyle);
						if (arrTxtWidth) {
						    arrTxtWidth.forEach(function(it) {
								width = Math.max(width, it[1]);
							});
						}

                        if (!width) {
                            delete labels[id];
                            continue;
                        }
                        width += 4;
                        item.options.labelStyle = null;
                    }
                    options.label = {
                        isPoint: isPoint,
                        width: width,
                        sx: style.sx || 0,
                        txt: txt,
                        arrTxtWidth: arrTxtWidth,
                        style: labelStyle
                    };
                    labels[id] = item;
                }
            }
            _this._labels[layerId] = labels;
        };

        var addObserver = function (layer, id) {
            var gmx = layer._gmx,
                filters = ['styleFilter', 'userFilter'],
                options = {
                    type: 'resend',
                    bbox: _this.bbox,
                    filters: filters,
                    callback: function(data) {
                        chkData(data, layer);
                        _this.redraw();
                    }
                };
            if (gmx.beginDate && gmx.endDate) {
                options.dateInterval = [gmx.beginDate, gmx.endDate];
            }
            return gmx.dataManager.addObserver(options, '_Labels_' + id);
        };
        this.add = function (layer) {
            var id = layer._leaflet_id,
                gmx = layer._gmx;

            if (!_this._observers[id] && gmx && gmx.labelsLayer && id) {
                gmx.styleManager.deferred.then(function () {
                    var observer = addObserver(layer, id),
						_zoom = _this._map._zoom;
                    if (layer.options.isGeneralized) {
                        observer.targetZoom = _zoom;	//need update to current zoom
                    }
                    if (observer.dateInterval) {
                        layer.on('dateIntervalChanged', function(ev) {
							var dInterval = ev.target.getDateInterval();
							this.setDateInterval(dInterval.beginDate, dInterval.endDate);
						}, observer);
                    }
                    if (!gmx.styleManager.isVisibleAtZoom(_zoom)) {
                        observer.deactivate();
                    }
                    _this._observers[id] = observer;
                    _this._styleManagers[id] = gmx.styleManager;

                    _this._labels['_' + id] = {};
                    _this._updateBbox();
                });
            }
        };
        this.remove = function (layer) {
            var id = layer._leaflet_id;
            if (_this._observers[id]) {
                var gmx = layer._gmx,
                    dataManager = gmx.dataManager;
                dataManager.removeObserver(_this._observers[id].id);
                delete _this._observers[id];
                delete _this._styleManagers[id];
                delete _this._labels['_' + id];
                _this.redraw();
            }
        };
        this._layeradd = function (ev) {
            _this.add(ev.layer);
        };
        this._layerremove = function (ev) {
            _this.remove(ev.layer);
        };
    },

    redraw: function () {
        if (!this._frame && !this._map._animating) {
            this._frame = L.Util.requestAnimFrame(this._redraw, this);
        }
        return this;
    },

    _addToPane: function () {
        var pane = this._map.getPanes()[this.options.pane];
        if (pane) {
            pane.insertBefore(this._canvas, pane.firstChild);
        }
    },

    onAdd: function (map) {
        this._map = map;

        if (!this._canvas) {
            this._initCanvas();
        }
        // this._addToPane();

        map.on('moveend', this._reset, this);
        map.on({
            layeradd: this._layeradd,
            layerremove: this._layerremove
        });
        if (map.options.zoomAnimation && L.Browser.any3d) {
            map.on('zoomanim', this._animateZoom, this);
        }

        this._reset();
    },

    onRemove: function (map) {
        if (this._canvas.parentNode) {
            this._canvas.parentNode.removeChild(this._canvas);
        }

        map.off('moveend', this._reset, this);
        map.off('layeradd', this._layeradd);
        map.off('layerremove', this._layerremove);

        if (map.options.zoomAnimation) {
            map.off('zoomanim', this._animateZoom, this);
        }
    },

    addTo: function (map) {
        map.addLayer(this);
        return this;
    },

    _initCanvas: function () {
        var canvas = L.DomUtil.create('canvas', 'leaflet-labels-layer leaflet-layer'),
            size = this._map.getSize();
        canvas.width  = size.x; canvas.height = size.y;
        canvas.style.pointerEvents = 'none';
        this._canvas = canvas;

        var animated = this._map.options.zoomAnimation && L.Browser.any3d;
        L.DomUtil.addClass(canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));
    },

    _updateBbox: function () {
        var _map = this._map,
            screenBounds = _map.getBounds(),
            southWest = screenBounds.getSouthWest(),
            northEast = screenBounds.getNorthEast(),
			crs = _map.options.srs === '3857' ? L.CRS.EPSG3857 : L.Projection.Mercator,
            m1 = crs.project(southWest),	// предполагаем что все слои в одной проекции
            m2 = crs.project(northEast),
			_zoom = _map.getZoom();

        this.mInPixel = gmxAPIutils.getPixelScale(_zoom);
        this._ctxShift = [m1.x * this.mInPixel, m2.y * this.mInPixel];
        for (var id in this._observers) {
			var observer = this._observers[id];
			if (observer.targetZoom) {
				observer.targetZoom = _zoom;
			}
            observer.setBounds({
                min: {x: southWest.lng, y: southWest.lat},
                max: {x: northEast.lng, y: northEast.lat}
            });
        }
    },

    _reset: function () {
        this._updateBbox();
        for (var id in this._observers) {
            var observer = this._observers[id];
            if (!observer.isActive() &&
                this._styleManagers[id].isVisibleAtZoom(this._map.getZoom())
            ) {
                observer.activate();
            }
            observer.fire('update');
        }
    },

    _redraw: function () {
        var out = [],
            _map = this._map,
            mapSize = _map.getSize(),
            _canvas = this._canvas,
            offset = _map.latLngToContainerPoint(_map.getBounds().getNorthWest()),
            topLeft = _map.containerPointToLayerPoint(offset);

		_canvas.width = mapSize.x; _canvas.height = mapSize.y;
        L.DomUtil.setPosition(_canvas, topLeft);

        var w2 = 2 * this.mInPixel * gmxAPIutils.worldWidthMerc,
            start = w2 * Math.floor(_map.getPixelBounds().min.x / w2),
            ctx = _canvas.getContext('2d'),
            i, len, it;

        for (var layerId in this._labels) {
            var labels = this._labels[layerId];
            for (var id in labels) {
                it = labels[id];
                var options = it.options,
                    label = options.label,
                    style = label.style,
					labelAlign = style.labelAlign || 'center',
                    arrTxtWidth = label.arrTxtWidth,
					count = arrTxtWidth.length || 1,
                    width = label.width,
                    width2 = width / 2,
                    size = style.labelFontSize || 12,
                    size2 = size / 2,
                    center = options.center,
                    pos = [center[0] * this.mInPixel, center[1] * this.mInPixel],
                    isFiltered = false;

                if (label.isPoint) {
                    var delta = label.sx;
                    if (labelAlign === 'left') {
                        pos[0] += width2 + delta;
                    } else if (labelAlign === 'right') {
                        pos[0] -= width + delta;
                    }
                }
                pos[0] -= width2 + this._ctxShift[0];
                pos[1] = -size2 - pos[1] + this._ctxShift[1];
				size2 *= count;
                if (style.labelAnchor) {
                    pos[0] += style.labelAnchor[0];
                    pos[1] += style.labelAnchor[1];
                }

                for (var tx = pos[0] + start; tx < mapSize.x; tx += w2) {
                    var coord = [Math.floor(tx), Math.floor(pos[1])],
                        bbox = gmxAPIutils.bounds([
                            [coord[0] - width2, coord[1] - size2],
                            [coord[0] + width2, coord[1] + size2]
                        ]);
                    for (i = 0, len = out.length; i < len; i++) {
                        if (bbox.intersects(out[i].bbox)) {
                            isFiltered = true;
                            break;
                        }
                    }
                    if (isFiltered) { continue; }

                    if (!options.labelStyle) {
                        options.labelStyle = {
                            font: size + 'px "Arial"',
                            fillStyle: gmxAPIutils.dec2color(style.labelColor || 0, 1),
                            shadowBlur: 4
                        };
                        if (style.labelHaloColor !== -1) {
                            options.labelStyle.strokeStyle =
                            options.labelStyle.shadowColor =
                                gmxAPIutils.dec2color(style.labelHaloColor, 1);
                        }
                    }
                    out.push({
                        arr: it.properties,
                        bbox: bbox,
                        arrTxtWidth: arrTxtWidth,
                        width2: labelAlign === 'center' ? width2 : 0,
                        txt: label.txt,
                        style: options.labelStyle,
                        size: size,
                        coord: coord
                    });
                }
            }
        }
        if (out.length) {
            ctx.clearRect(0, 0, _canvas.width, _canvas.height);
            for (i = 0, len = out.length; i < len; i++) {
                it = out[i];
				it.arrTxtWidth.forEach(function(pt, nm) {
					var coord = [it.coord[0] + it.width2 - pt[1]/2, it.coord[1] + (nm + 1) * it.size];
					gmxAPIutils.setLabel(ctx, pt[0], coord, it.style);
				});
            }
            if (!_canvas.parentNode) { this._addToPane(); }
        } else if (_canvas.parentNode) {
            _canvas.parentNode.removeChild(_canvas);
        }

        this._frame = null;
    },

    _animateZoom: function (e) {
        var scale = this._map.getZoomScale(e.zoom),
            pixelBoundsMin = this._map.getPixelBounds().min;

        var offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());
        if (pixelBoundsMin.y < 0) {
            offset.y += pixelBoundsMin.multiplyBy(-scale).y;
        }

        this._canvas.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ')';
    }
});

L.labelsLayer = function (map, options) {
    return new L.LabelsLayer(map, options);
};

L.Map.addInitHook(function () {
	// Check to see if Labels has already been initialized.
    if (!this._labelsLayer) {
        this._labelsLayer = new L.LabelsLayer(this);
        this._labelsLayer.addTo(this);
    }
});


(function() {
var isBoundsIntersects = function (bounds, clipPolygons) {
    for (var key in clipPolygons) {
        var arr = clipPolygons[key];
        for (var i = 0, len = arr.length; i < len; i++) {
            var it = arr[i],
                type = it.geometry.type,
                boundsArr = it.boundsArr;
            for (var j = 0, len1 = boundsArr.length; j < len1; j++) {
                var bbox = boundsArr[j];
                if (type === 'Polygon') { bbox = [bbox]; }
                for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {
                    if (bbox[j1].intersects(bounds)) { return true; }
                }
            }
        }
    }
    return false;
};
var isObserverIntersects = function (observer, clipPolygons) {
    for (var key in clipPolygons) {
        var arr = clipPolygons[key];
        for (var i = 0, len = arr.length; i < len; i++) {
            var it = arr[i],
                type = it.geometry.type,
                boundsArr = it.boundsArr;
            for (var j = 0, len1 = boundsArr.length; j < len1; j++) {
                var bbox = boundsArr[j];
                if (type === 'Polygon') { bbox = [bbox]; }
                for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {
                    if (observer.intersects(bbox[j1])) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
};

var isPointInClipPolygons = function (chkPoint, clipPolygons) {
    if (!clipPolygons || Object.keys(clipPolygons).length === 0) { return true; }
    for (var key in clipPolygons) {
        var arr = clipPolygons[key];
        for (var i = 0, len = arr.length; i < len; i++) {
            var it = arr[i],
                type = it.geometry.type,
                boundsArr = it.boundsArr;
            for (var j = 0, len1 = boundsArr.length; j < len1; j++) {
                var bbox = boundsArr[j];
                if (type === 'Polygon') { bbox = [bbox]; }
                for (var j1 = 0, len2 = bbox.length; j1 < len2; j1++) {
                    if (bbox[j1].contains(chkPoint)) {
                        var coords = it.geometry.coordinates,
                            isIn = false;
                        if (type === 'Polygon') { coords = [coords]; }
                        for (var j2 = 0, len3 = coords.length; j2 < len3; j2++) {
                            if (gmxAPIutils.isPointInPolygonWithHoles(chkPoint, coords[j2])) {
                                isIn = true;
                                break;
                            }
                        }
                        if (isIn) { return true; }
                    }
                }
            }
        }
    }
    return false;
};

var getClipPolygonItem = function (geo) {
    var geometry = gmxAPIutils.convertGeometry(geo),
        bboxArr = gmxAPIutils.geoItemBounds(geometry);
    bboxArr.geometry = geometry;
    return bboxArr;
};

var clipTileByPolygon = function (dattr) {
    var canvas = document.createElement('canvas');
    canvas.width = canvas.height = 256;
    var ctx = canvas.getContext('2d'),
        clipPolygons = dattr.clipPolygons;

    dattr.ctx = ctx;
    ctx.fillStyle = ctx.createPattern(dattr.tile, 'no-repeat');

    for (var key in clipPolygons) {
        var arr = clipPolygons[key];
        for (var i = 0, len = arr.length; i < len; i++) {
            var geo = arr[i].geometry,
                coords = geo.coordinates;
            if (geo.type === 'Polygon') { coords = [coords]; }
            for (var i1 = 0, len1 = coords.length; i1 < len1; i1++) {
                var coords1 = coords[i1];
                ctx.beginPath();
                for (var j1 = 0, len2 = coords1.length; j1 < len2; j1++) {
                    dattr.coords = coords1[j1];
                    var pixels = gmxAPIutils.getRingPixels(dattr);
                    dattr.coords = pixels.coords;
                    gmxAPIutils.polygonToCanvasFill(dattr);
                }
                ctx.closePath();
                ctx.fill();
            }
        }
    }
    ctx = dattr.tile.getContext('2d');
    ctx.clearRect(0, 0, 256, 256);
    ctx.drawImage(canvas, 0, 0);
};

L.gmx.VectorLayer.include({

    isPointInClipPolygons: function (point) { // point [x, y] in Mercator
        return isPointInClipPolygons(point, this._gmx._clipPolygons);
    },

    addClipPolygon: function (polygon) { // (L.Polygon) or (L.GeoJSON with Polygons)
        var item = [],
            i, len;

        if ('coordinates' in polygon && 'type' in polygon) {
            item.push(getClipPolygonItem(polygon));
        } else if (polygon instanceof L.Polygon) {
            item.push(getClipPolygonItem(polygon.toGeoJSON().geometry));
        } else if (polygon instanceof L.GeoJSON) {
            var layers = polygon.getLayers();
            for (i = 0, len = layers.length; i < len; i++) {
                var layer = layers[i];
                if (layer instanceof L.Polygon && layer.feature) {
                    item.push(getClipPolygonItem(layer.feature.geometry));
                } else if (layer instanceof L.MultiPolygon && layer.feature) {
                    item.push(getClipPolygonItem(layer.feature.geometry));
                }
            }
        }
        if (item.length) {
            var gmx = this._gmx,
                dataManager = gmx.dataManager,
                _this = this,
                id = L.stamp(polygon);

            if (!this._gmx._clipPolygons) { this._gmx._clipPolygons = {}; }
            this._gmx._clipPolygons[id] = item;
            dataManager.setTileFilteringHook(function (tile) {
                return isBoundsIntersects(tile.bounds, _this._gmx._clipPolygons);
            });

            dataManager.addFilter('clipFilter', function (item, tile, observer) {
                return isObserverIntersects(observer, _this._gmx._clipPolygons);
            });

            dataManager.addFilter('clipPointsFilter', function (item) {
                if (item.type === 'POINT') {
                    var propArr = item.properties,
                        geom = propArr[propArr.length - 1];
                    return isPointInClipPolygons(geom.coordinates, _this._gmx._clipPolygons);
                }
                return true;
            });
            if (Object.keys(this._gmx._clipPolygons).length === 1) {
                gmx.renderHooks.unshift(function (tile, hookInfo) {
                    if (tile && Object.keys(_this._gmx._clipPolygons).length > 0) {
                        clipTileByPolygon({
                            tile: tile,
                            tpx: hookInfo.tpx,
                            tpy: hookInfo.tpy,
                            gmx: {mInPixel: gmx.mInPixel},
                            clipPolygons: _this._gmx._clipPolygons
                        });
                    }
                });
            }
        }
        return this;
    },

    removeClipPolygon: function (polygon) {
        var id = L.stamp(polygon);
        if (this._gmx._clipPolygons) {
            delete this._gmx._clipPolygons[id];
            if (Object.keys(this._gmx._clipPolygons).length === 0) {
                this._gmx.dataManager.removeTileFilteringHook();
                this._gmx.dataManager.removeFilter('clipFilter');
            }
        }
        return this;
    }
});
})();


L.gmx.gmxImageTransform = function(img, hash) {
    var gmx = hash.gmx,
        gmxTilePoint = hash.gmxTilePoint,
        mInPixel = gmx.mInPixel,
        geoItem = hash.geoItem,
        properties = geoItem.properties,
        dataOption = geoItem.dataOption || {},
        geom = properties[properties.length - 1],
        coord = geom.coordinates[0],
        indexes = gmx.tileAttributeIndexes,
        quicklookPlatform = properties[indexes[gmx.quicklookPlatform]] || gmx.quicklookPlatform || '',
        points = {};

    if (geom.type === 'MULTIPOLYGON') { coord = coord[0]; }
    if (quicklookPlatform === 'LANDSAT8') {
        points.x1 = dataOption.bounds.min.x; points.y1 = dataOption.bounds.max.y;
        points.x2 = dataOption.bounds.max.x; points.y2 = dataOption.bounds.max.y;
        points.x3 = dataOption.bounds.max.x; points.y3 = dataOption.bounds.min.y;
        points.x4 = dataOption.bounds.min.x; points.y4 = dataOption.bounds.min.y;
    } else {
        points = gmxAPIutils.getQuicklookPointsFromProperties(properties, gmx);
    }

    var x1 = mInPixel * points.x1, y1 = mInPixel * points.y1,
        x2 = mInPixel * points.x2, y2 = mInPixel * points.y2,
        x3 = mInPixel * points.x3, y3 = mInPixel * points.y3,
        x4 = mInPixel * points.x4, y4 = mInPixel * points.y4,
        boundsP = gmxAPIutils.bounds([[x1, y1], [x2, y2], [x3, y3], [x4, y4]]),
        ww = Math.round(boundsP.max.x - boundsP.min.x),
        hh = Math.round(boundsP.max.y - boundsP.min.y),
        dy = 256 - boundsP.max.y + 256 * gmxTilePoint.y,
        itbounds = geoItem.item.bounds,
        wMerc = gmxAPIutils.worldWidthMerc,
        tpx = gmxTilePoint.x;

    if (tpx < 0 && itbounds.max.x > wMerc && itbounds.min.x < -wMerc) {	// For points intersects 180 deg
		tpx += Math.round(wMerc * mInPixel / 128);
	}
	var dx = boundsP.min.x - 256 * tpx;

    x1 -= boundsP.min.x; y1 = boundsP.max.y - y1;
    x2 -= boundsP.min.x; y2 = boundsP.max.y - y2;
    x3 -= boundsP.min.x; y3 = boundsP.max.y - y3;
    x4 -= boundsP.min.x; y4 = boundsP.max.y - y4;

    var shiftPoints = [[x1, y1], [x2, y2], [x3, y3], [x4, y4]];

    if (!gmx.ProjectiveImage) {
        gmx.ProjectiveImage = (gmx.useWebGL ? L.gmx.projectiveImageWebGL() : null) || L.gmx.projectiveImage();
    }
    var pt = gmx.ProjectiveImage.getCanvas({
        imageObj: img,
        points: shiftPoints,
        wView: ww,
        hView: hh,
        deltaX: dx,
        deltaY: dy
    });
    return pt.canvas;
};


(function() {
var ProjectiveImageWebGL = L.Class.extend({
    options: {
        antialias: true,
        depth: false,
        preserveDrawingBuffer: true,
        shaderVS: 'attribute vec2 aVertCoord;\
            uniform mat4 uTransformMatrix;\
            varying vec2 vTextureCoord;\
            void main(void) {\
                vTextureCoord = aVertCoord;\
                gl_Position = uTransformMatrix * vec4(aVertCoord, 0.0, 1.0);\
            }\
        ',
        shaderFS: 'precision mediump float;\
            varying vec2 vTextureCoord;\
            uniform sampler2D uSampler;\
            void main(void) {\
                gl_FragColor = texture2D(uSampler, vTextureCoord);\
            }\
        '
    },

    setOptions: function(options) {
        L.setOptions(this, options);
    },

    initialize: function(options) {
        this.setOptions(options);

        var canvas = document.createElement('canvas'),
            glOpts = {
                antialias: this.options.antialias,
                depth: this.options.depth,
                preserveDrawingBuffer: this.options.preserveDrawingBuffer
            },
            gl = canvas.getContext('webgl', glOpts) || canvas.getContext('experimental-webgl', glOpts);
        if (!gl) { return; }
        var glResources = this._setupGlContext(gl);
        if (!glResources) { return; }

        canvas.width = canvas.height = 256;
        glResources.canvas = canvas;

        this.glResources = glResources;
        this.canvas = canvas;
        this.gl = gl;
    },

    _getShader: function (type, source, gl) {
        var shader = gl.createShader(type);

        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    },

    _setupGlContext: function (gl) {
        // Store return values here
        var vertexShader = this._getShader(gl.VERTEX_SHADER, this.options.shaderVS, gl),
            fragmentShader = this._getShader(gl.FRAGMENT_SHADER, this.options.shaderFS, gl);

        if (vertexShader && fragmentShader) {
            // Compile the program
            var shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                // Find and set up the uniforms and attributes
                gl.useProgram(shaderProgram);
                this.vertices = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
                var vertexBuffer = gl.createBuffer(),    // Create a buffer to hold the vertices
                    vertAttrib = gl.getAttribLocation(shaderProgram, 'aVertCoord');
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);

                // draw the triangles
                gl.enableVertexAttribArray(vertAttrib);
                gl.vertexAttribPointer(vertAttrib, 2, gl.FLOAT, false, 0, 0);
                return {
                    transMatUniform: gl.getUniformLocation(shaderProgram, 'uTransformMatrix'),
                    samplerUniform: gl.getUniformLocation(shaderProgram, 'uSampler'),
                    screenTexture: gl.createTexture() // Create a texture to use for the screen image
                };
            }
        }
        return null;
    },

    _bindTexture: function (gl, image, texture) {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

        // gl.NEAREST is also allowed, instead of gl.LINEAR, as neither mipmap.
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        // Prevents s-coordinate wrapping (repeating).
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        // Prevents t-coordinate wrapping (repeating).
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.bindTexture(gl.TEXTURE_2D, null);
    },

    getCanvas: function (attr) {
        var p = attr.points,
            deltaX = attr.deltaX,
            deltaY = attr.deltaY,
            dstPoints = new Float32Array([
                (p[0][0] + deltaX) / 128 - 1, 1 - (p[0][1] + deltaY) / 128,
                (p[1][0] + deltaX) / 128 - 1, 1 - (p[1][1] + deltaY) / 128,
                (p[3][0] + deltaX) / 128 - 1, 1 - (p[3][1] + deltaY) / 128,
                (p[2][0] + deltaX) / 128 - 1, 1 - (p[2][1] + deltaY) / 128
            ]);

        var v = ProjectiveImageWebGL.Utils.general2DProjection(this.vertices, dstPoints),
            gl = this.gl,
            glResources = this.glResources;

        this._bindTexture(gl, attr.imageObj, glResources.screenTexture);

        gl.viewport(0, 0, 256, 256);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);    // set background to full transparency

        gl.uniformMatrix4fv(
            glResources.transMatUniform,
            false, [
                v[0], v[3],    0, v[6],
                v[1], v[4],    0, v[7],
                   0,    0,    1,    0,
                v[2], v[5],    0,    1
            ]);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, glResources.screenTexture);
        gl.uniform1i(glResources.samplerUniform, 0);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        return this;
    }
});

function adj(m) { // Compute the adjugate of m
    return [
        m[4] * m[8] - m[5] * m[7], m[2] * m[7] - m[1] * m[8], m[1] * m[5] - m[2] * m[4],
        m[5] * m[6] - m[3] * m[8], m[0] * m[8] - m[2] * m[6], m[2] * m[3] - m[0] * m[5],
        m[3] * m[7] - m[4] * m[6], m[1] * m[6] - m[0] * m[7], m[0] * m[4] - m[1] * m[3]
    ];
}

function multmm(a, b) { // multiply two matrices
    var c = Array(9);
    for (var i = 0; i !== 3; ++i) {
        for (var j = 0; j !== 3; ++j) {
            var cij = 0;
            for (var k = 0; k !== 3; ++k) {
                cij += a[3 * i + k] * b[3 * k + j];
            }
            c[3 * i + j] = cij;
        }
    }
    return c;
}

function multmv(m, v) { // multiply matrix and vector
    return [
        m[0] * v[0] + m[1] * v[1] + m[2] * v[2],
        m[3] * v[0] + m[4] * v[1] + m[5] * v[2],
        m[6] * v[0] + m[7] * v[1] + m[8] * v[2]
    ];
}

function basisToPoints(p) {
    var m = [
        p[0], p[2], p[4],
        p[1], p[3], p[5],
        1,  1,  1
    ];
    var v = multmv(adj(m), [p[6], p[7], 1]);
    return multmm(m, [
        v[0], 0, 0,
        0, v[1], 0,
        0, 0, v[2]
    ]);
}

ProjectiveImageWebGL.Utils = {
    general2DProjection: function(from, to) {
        var arr = multmm(basisToPoints(to), adj(basisToPoints(from)));
        if (arr[8]) {
            for (var i = 0; i !== 9; ++i) {
                arr[i] = arr[i] / arr[8];
            }
        }
        return arr;
    },

    getWebGlResources: function(options) {
        var obj = new ProjectiveImageWebGL(options);
        return obj.gl ? obj : null;
    }
};
L.gmx.projectiveImageWebGL = function(options) {
    var res = new ProjectiveImageWebGL(options);
    return res.gl ? res : null;
};
})();


(function() {
// ProjectiveImage - projective transform that maps [0,1]x[0,1] onto the given set of points.
var ProjectiveImage = function() {
	var cnt = 0,
        limit = 4,
        patchSize = 64,
        transform = null;

	var allocate = function (w, h) {
	  var values = [];
	  for (var i = 0; i < h; ++i) {
		values[i] = [];
		for (var j = 0; j < w; ++j) {
		  values[i][j] = 0;
		}
	  }
	  return values;
	};

	var Matrix = function (w, h, values) {
	  this.w = w;
	  this.h = h;
	  this.values = values || allocate(h);
	};

	var cloneValues = function (values) {
		var clone = [];
		for (var i = 0; i < values.length; ++i) {
			clone[i] = [].concat(values[i]);
		}
		return clone;
	};

	Matrix.prototype = {
		add : function (operand) {
			if (operand.w !== this.w || operand.h !== this.h) {
				throw new Error('Matrix add size mismatch');
			}

			var values = allocate(this.w, this.h);
			for (var y = 0; y < this.h; ++y) {
				for (var x = 0; x < this.w; ++x) {
				  values[y][x] = this.values[y][x] + operand.values[y][x];
				}
			}
			return new Matrix(this.w, this.h, values);
		},
		transformProjectiveVector : function (operand) {
			var out = [], x, y;
			for (y = 0; y < this.h; ++y) {
				out[y] = 0;
				for (x = 0; x < this.w; ++x) {
					out[y] += this.values[y][x] * operand[x];
				}
			}
			var zn = out[out.length - 1];
			if (zn) {
				var iz = 1 / (out[out.length - 1]);
				for (y = 0; y < this.h; ++y) {
					out[y] *= iz;
				}
			}
			return out;
		},
		multiply : function (operand) {
			var values, x, y;
			if (+operand !== operand) {
				// Matrix mult
				if (operand.h !== this.w) {
					throw new Error('Matrix mult size mismatch');
				}
				values = allocate(this.w, this.h);
				for (y = 0; y < this.h; ++y) {
					for (x = 0; x < operand.w; ++x) {
						var accum = 0;
						for (var s = 0; s < this.w; s++) {
							accum += this.values[y][s] * operand.values[s][x];
						}
						values[y][x] = accum;
					}
				}
				return new Matrix(operand.w, this.h, values);
			}
			else {
				// Scalar mult
				values = allocate(this.w, this.h);
				for (y = 0; y < this.h; ++y) {
					for (x = 0; x < this.w; ++x) {
						values[y][x] = this.values[y][x] * operand;
					}
				}
				return new Matrix(this.w, this.h, values);
			}
		},
		rowEchelon : function () {
			if (this.w <= this.h) {
				throw new Error('Matrix rowEchelon size mismatch');
			}

			var temp = cloneValues(this.values);

			// Do Gauss-Jordan algorithm.
			for (var yp = 0; yp < this.h; ++yp) {
				// Look up pivot value.
				var pivot = temp[yp][yp];
				while (pivot === 0) {
					// If pivot is zero, find non-zero pivot below.
					for (var ys = yp + 1; ys < this.h; ++ys) {
						if (temp[ys][yp] !== 0) {
							// Swap rows.
							var tmpRow = temp[ys];
							temp[ys] = temp[yp];
							temp[yp] = tmpRow;
							break;
						}
					}
					if (ys === this.h) {
						// No suitable pivot found. Abort.
						return new Matrix(this.w, this.h, temp);
					}
					else {
						pivot = temp[yp][yp];
					}
				}
				// Normalize this row.
				var scale = 1 / pivot;
				for (var x = yp; x < this.w; ++x) {
					temp[yp][x] *= scale;
				}
				// Subtract this row from all other rows (scaled).
				for (var y = 0; y < this.h; ++y) {
					if (y === yp) { continue; }
					var factor = temp[y][yp];
					temp[y][yp] = 0;
					for (x = yp + 1; x < this.w; ++x) {
						temp[y][x] -= factor * temp[yp][x];
					}
				}
			}

			return new Matrix(this.w, this.h, temp);
		},
		invert : function () {
			var x, y;

			if (this.w !== this.h) {
				throw new Error('Matrix invert size mismatch');
			}

			var temp = allocate(this.w * 2, this.h);

			// Initialize augmented matrix
			for (y = 0; y < this.h; ++y) {
				for (x = 0; x < this.w; ++x) {
					temp[y][x] = this.values[y][x];
					temp[y][x + this.w] = (x === y) ? 1 : 0;
				}
			}

			temp = new Matrix(this.w * 2, this.h, temp);
			temp = temp.rowEchelon();

			// Extract right block matrix.
			var values = allocate(this.w, this.h);
			for (y = 0; y < this.w; ++y) {
				// @todo check if "x < this.w;" is mistake
				for (x = 0; x < this.w; ++x) {
					values[y][x] = temp.values[y][x + this.w];
				}
			}
			return new Matrix(this.w, this.h, values);
		}
	};

	var getProjectiveTransform = function (points) {
	  var eqMatrix = new Matrix(9, 8, [
		[1, 1, 1,   0, 0, 0, -points[2][0], -points[2][0], -points[2][0]],
		[0, 1, 1,   0, 0, 0,  0, -points[3][0], -points[3][0]],
		[1, 0, 1,   0, 0, 0, -points[1][0], 0, -points[1][0]],
		[0, 0, 1,   0, 0, 0,  0, 0, -points[0][0]],

		[0, 0, 0,  -1, -1, -1,  points[2][1], points[2][1], points[2][1]],
		[0, 0, 0,   0, -1, -1,  0, points[3][1], points[3][1]],
		[0, 0, 0,  -1,  0, -1,  points[1][1], 0, points[1][1]],
		[0, 0, 0,   0,  0, -1,  0, 0, points[0][1]]

	  ]);

	  var kernel = eqMatrix.rowEchelon().values;
	  var transform = new Matrix(3, 3, [
		[-kernel[0][8], -kernel[1][8], -kernel[2][8]],
		[-kernel[3][8], -kernel[4][8], -kernel[5][8]],
		[-kernel[6][8], -kernel[7][8],             1]
	  ]);
	  return transform;
	};

	var divide = function (u1, v1, u4, v4, p1, p2, p3, p4, limit, attr) {
		if (limit) {
			// Measure patch non-affinity.
			var d1 = [p2[0] + p3[0] - 2 * p1[0], p2[1] + p3[1] - 2 * p1[1]];
			var d2 = [p2[0] + p3[0] - 2 * p4[0], p2[1] + p3[1] - 2 * p4[1]];
			var d3 = [d1[0] + d2[0], d1[1] + d2[1]];
			var r = Math.abs((d3[0] * d3[0] + d3[1] * d3[1]) / (d1[0] * d2[0] + d1[1] * d2[1]));

			// Measure patch area.
			d1 = [p2[0] - p1[0] + p4[0] - p3[0], p2[1] - p1[1] + p4[1] - p3[1]];
			d2 = [p3[0] - p1[0] + p4[0] - p2[0], p3[1] - p1[1] + p4[1] - p2[1]];
			var area = Math.abs(d1[0] * d2[1] - d1[1] * d2[0]);

			// Check area > patchSize pixels (note factor 4 due to not averaging d1 and d2)
			// The non-affinity measure is used as a correction factor.
			if ((u1 === 0 && u4 === 1) || ((.25 + r * 5) * area > (patchSize * patchSize))) {
				// Calculate subdivision points (middle, top, bottom, left, right).
				var umid = (u1 + u4) / 2;
				var vmid = (v1 + v4) / 2;
				var pmid = transform.transformProjectiveVector([umid, vmid, 1]);
				var pt   = transform.transformProjectiveVector([umid, v1, 1]);
				var pb   = transform.transformProjectiveVector([umid, v4, 1]);
				var pl   = transform.transformProjectiveVector([u1, vmid, 1]);
				var pr   = transform.transformProjectiveVector([u4, vmid, 1]);

				// Subdivide.
				limit--;
				divide.call(this, u1,   v1, umid, vmid,   p1,   pt,   pl, pmid, limit, attr);
				divide.call(this, umid,   v1,   u4, vmid,   pt,   p2, pmid,   pr, limit, attr);
				divide.call(this, u1,  vmid, umid,   v4,   pl, pmid,   p3,   pb, limit, attr);
				divide.call(this, umid, vmid,   u4,   v4, pmid,   pr,   pb,   p4, limit, attr);
				return;
			}
		}

		var ctx = attr.ctx;

		// Get patch edge vectors.
		var d12 = [p2[0] - p1[0], p2[1] - p1[1]];
		var d24 = [p4[0] - p2[0], p4[1] - p2[1]];
		var d43 = [p3[0] - p4[0], p3[1] - p4[1]];
		var d31 = [p1[0] - p3[0], p1[1] - p3[1]];

		// Find the corner that encloses the most area
		var a1 = Math.abs(d12[0] * d31[1] - d12[1] * d31[0]);
		var a2 = Math.abs(d24[0] * d12[1] - d24[1] * d12[0]);
		var a4 = Math.abs(d43[0] * d24[1] - d43[1] * d24[0]);
		var a3 = Math.abs(d31[0] * d43[1] - d31[1] * d43[0]);
		var amax = Math.max(Math.max(a1, a2), Math.max(a3, a4));
		var dx = 0, dy = 0, padx = 0, pady = 0;

		// Align the transform along this corner.
		// Calculate 1.05 pixel padding on vector basis.
		if (amax === a1) {
				ctx.setTransform(d12[0], d12[1], -d31[0], -d31[1], p1[0] + attr.deltaX, p1[1] + attr.deltaY);
				if (u4 !== 1) { padx = 1.05 / Math.sqrt(d12[0] * d12[0] + d12[1] * d12[1]); }
				if (v4 !== 1) { pady = 1.05 / Math.sqrt(d31[0] * d31[0] + d31[1] * d31[1]); }
		} else if (amax === a2) {
				ctx.setTransform(d12[0], d12[1],  d24[0],  d24[1], p2[0] + attr.deltaX, p2[1] + attr.deltaY);
				if (u4 !== 1) { padx = 1.05 / Math.sqrt(d12[0] * d12[0] + d12[1] * d12[1]); }
				if (v4 !== 1) { pady = 1.05 / Math.sqrt(d24[0] * d24[0] + d24[1] * d24[1]); }
				dx = -1;
		} else if (amax === a4) {
				ctx.setTransform(-d43[0], -d43[1], d24[0], d24[1], p4[0] + attr.deltaX, p4[1] + attr.deltaY);
				if (u4 !== 1) { padx = 1.05 / Math.sqrt(d43[0] * d43[0] + d43[1] * d43[1]); }
				if (v4 !== 1) { pady = 1.05 / Math.sqrt(d24[0] * d24[0] + d24[1] * d24[1]); }
				dx = -1;
				dy = -1;
		} else if (amax === a3) {
				ctx.setTransform(-d43[0], -d43[1], -d31[0], -d31[1], p3[0] + attr.deltaX, p3[1] + attr.deltaY);
				if (u4 !== 1) { padx = 1.05 / Math.sqrt(d43[0] * d43[0] + d43[1] * d43[1]); }
				if (v4 !== 1) { pady = 1.05 / Math.sqrt(d31[0] * d31[0] + d31[1] * d31[1]); }
				dy = -1;
		}

		// Calculate image padding to match.
		var du = (u4 - u1);
		var dv = (v4 - v1);
		padx++;
		pady++;

        var iw = attr.imageObj.width,
            ih = attr.imageObj.height,
            sx = Math.floor(u1 * iw),
            sy = Math.floor(v1 * ih),
            sw = Math.floor(Math.min(padx * du, 1) * iw),
            sh = Math.floor(Math.min(pady * dv, 1) * ih);

		cnt++;
        ctx.drawImage(
            attr.imageObj,
            sx, sy,
            sw, sh,
            dx, dy,
            padx, pady
        );
	};

	this.getCanvas = function (attr) {
		cnt = 0;
		transform = getProjectiveTransform(attr.points);
		// Begin subdivision process.

		var ptl = transform.transformProjectiveVector([0, 0, 1]),
            ptr = transform.transformProjectiveVector([1, 0, 1]),
            pbl = transform.transformProjectiveVector([0, 1, 1]),
            pbr = transform.transformProjectiveVector([1, 1, 1]);

		var canvas = document.createElement('canvas');
		canvas.width = canvas.height = 256;
		attr.canvas = canvas;
		attr.ctx = canvas.getContext('2d');

		var	boundsP = gmxAPIutils.bounds([ptl, ptr, pbr, pbl]),
            maxSize = Math.max(boundsP.max.x - boundsP.min.x, boundsP.max.y - boundsP.min.y);

		limit = 'limit' in attr ? attr.limit : (maxSize < 200 ? 1 : 4);
		patchSize = 'patchSize' in attr ? attr.patchSize : maxSize / 8;

		try {
			divide(0, 0, 1, 1, ptl, ptr, pbl, pbr, limit, attr);
		} catch (e) {
			console.log('Error: ProjectiveImage event:', e);
			canvas = null;
		}
		return {
			canvas: canvas,
			ptl: ptl,
			ptr: ptr,
			pbl: pbl,
			pbr: pbr,
			cnt: cnt
		};
	};
};
L.gmx.projectiveImage = function() {
    return new ProjectiveImage();
};
})();


// https://github.com/bbecquet/Leaflet.PolylineDecorator/blob/master/src/L.RotatedMarker.js

L.RotatedMarker = L.Marker.extend({
    options: {
        angle: 0
    },

    statics: {
        TRANSFORM_ORIGIN: L.DomUtil.testProp(
            ['transformOrigin', 'WebkitTransformOrigin', 'OTransformOrigin', 'MozTransformOrigin', 'msTransformOrigin'])
    },

    _initIcon: function() {
        L.Marker.prototype._initIcon.call(this);

        this._icon.style[L.RotatedMarker.TRANSFORM_ORIGIN] = this._getTransformOrigin();
    },

    _getTransformOrigin: function() {
        var iconAnchor = this.options.icon.options.iconAnchor;

        if (!iconAnchor) {
            return '50% 50%';
        }

        return iconAnchor[0] + 'px ' + iconAnchor[1] + 'px';
    },

    _setPos: function(pos) {
        L.Marker.prototype._setPos.call(this, pos);

        if (L.DomUtil.TRANSFORM) {
            // use the CSS transform rule if available
            this._icon.style[L.DomUtil.TRANSFORM] += ' rotate(' + this.options.angle + 'deg)';
        } else if (L.Browser.ie) {
            // fallback for IE6, IE7, IE8
            var rad = this.options.angle * (Math.PI / 180),
                costheta = Math.cos(rad),
                sintheta = Math.sin(rad);
            this._icon.style.filter += ' progid:DXImageTransform.Microsoft.Matrix(sizingMethod=\'auto expand\', M11=' +
                costheta + ', M12=' + (-sintheta) + ', M21=' + sintheta + ', M22=' + costheta + ')';
        }
    },

    setAngle: function(ang) {
        this.options.angle = ang;
    }
});

L.rotatedMarker = function(pos, options) {
    return new L.RotatedMarker(pos, options);
};


L.gmx.ExternalLayer = L.Class.extend({
    createExternalLayer: function () {          // extend: must return <ILayer> or null = this.externalLayer
        return null;
    },

    isExternalVisible: function (/*zoom*/) {    // extend: return true view this.externalLayer, return false view this.parentLayer
        return true;
    },

    updateData: function (/*data*/) {           // extend: for data update in this.externalLayer
    },

    setDateInterval: function () {
        if (this._observer) {
            var gmx = this.parentLayer._gmx;
            this._observer.setDateInterval(gmx.beginDate, gmx.endDate);
        }
    },

    options: {
        useDataManager: true,
        observerOptions: {
			delta: 0,
            filters: ['clipFilter', 'userFilter', 'clipPointsFilter']
        }
    },

    initialize: function (options, layer) {
        L.setOptions(this, options);
        this.parentLayer = layer;
        layer
            .on('add', this._addEvent, this)
            .on('dateIntervalChanged', this.setDateInterval, this);

        if (this.options.useDataManager) {
            this._addObserver(this.options.observerOptions);
        }

        this.externalLayer = this.createExternalLayer();

        if (layer._map) {
            this._addEvent({target:{_map: layer._map}});
            this._updateBbox();
        }
    },

    _addObserver: function (opt) {
        this._items = {};
        this._observer = this.parentLayer.addObserver(
            L.extend({
                bbox: gmxAPIutils.bounds([[Number.MAX_VALUE, Number.MAX_VALUE]]),
                callback: L.bind(this.updateData, this)
            }, opt)
        ).deactivate();
    },

    unbindLayer: function () {
        this.parentLayer
            .off('add', this._addEvent, this)
            .off('dateIntervalChanged', this.setDateInterval, this);

        if (this._observer) { delete this.parentLayer.repaintObservers[this._observer.id]; }
        var map = this._map || this.parentLayer._map;
        this._onRemove(!map);
        this._removeMapHandlers();
    },

    _addMapHandlers: function (map) {
        this._map = map;
        this._map.on({
            moveend: this._updateBbox,
            zoomend: this._chkZoom,
            layeradd: this._layeradd,
            layerremove: this._layerremove
        }, this);
    },

    _removeMapHandlers: function () {
        if (this._map) {
            this._map.off({
                moveend: this._updateBbox,
                zoomend: this._chkZoom,
                layeradd: this._layeradd,
                layerremove: this._layerremove
            }, this);
        }
        this._map = null;
    },

    _addEvent: function (ev) {
        this._addMapHandlers(ev.target._map);
        this._updateBbox();
        this._chkZoom();
    },

    _isParentLayer: function (ev) {
        var layer = ev.layer;
        return layer._gmx && layer._gmx.layerID === this.parentLayer.options.layerID;
    },

    _layeradd: function (ev) {
        if (this._isParentLayer(ev)) {
            this._chkZoom();
        }
    },

    _layerremove: function (ev) {
        if (this._isParentLayer(ev)) {
            this._onRemove(true);
            this._removeMapHandlers();
        }
    },

    _onRemove: function (fromMapFlag) {    // remove external layer from parent layer
        if (this._observer) {
            this._observer.deactivate();
        }
        var map = this._map;
        if (map) {
            if (map.hasLayer(this.externalLayer)) {
                this._chkZoom();
                map.removeLayer(this.externalLayer);
            }
            if (!fromMapFlag) {
                this.parentLayer.onAdd(map);
            }
        }
    },

    _chkZoom: function () {
        if (!this._map) { return; }

        var layer = this.parentLayer,
            observer = this._observer,
            map = this._map,
            isExtLayerOnMap = map.hasLayer(this.externalLayer);

        layer.setCurrentZoom(map);
        if (!this.isExternalVisible(map.getZoom())) {
            if (observer) { observer.deactivate(); }
            if (!layer._map) {
                if (isExtLayerOnMap) {
                    map.removeLayer(this.externalLayer);
                }
                layer.onAdd(map);
            }
            layer.enablePopup();
        } else if (layer._map) {
            layer.onRemove(map);
            if (!isExtLayerOnMap) {
                map.addLayer(this.externalLayer);
            }
            this.setDateInterval();
            if (observer) {
                layer.getIcons(function () {
                    observer.activate();
                }.bind(this));
            }
            layer.disablePopup();
        }
    },


    _updateBbox: function () {
        if (!this._map || !this._observer) { return; }

        var map = this._map,
			screenBounds = map.getBounds(),
            p1 = screenBounds.getNorthWest(),
            p2 = screenBounds.getSouthEast(),
            bbox = L.gmxUtil.bounds([[p1.lng, p1.lat], [p2.lng, p2.lat]]),
			delta = this.options.observerOptions.delta,
			buffer = delta ? delta * L.gmxUtil.tileSizes[map.getZoom()] / 256 : 0;
        this._observer.setBounds(bbox, buffer);
    }
});


(function() {
    'use strict';
    var BindWMS = L.gmx.ExternalLayer.extend({
        options: {
            minZoom: 1,
            maxZoom: 6,
            useDataManager: false,
            format: 'png',
            transparent: true
        },

        createExternalLayer: function () {
            var poptions = this.parentLayer.options,
                opt = {
                    map: poptions.mapID,
                    layers: poptions.layerID,
                    format: this.options.format,
                    transparent: this.options.transparent
                },
                rawProperties = this.parentLayer.getGmxProperties();

            if (rawProperties && rawProperties.Temporal) { this._extendOptionsByDateInterval(opt); }
            if (this.options.apikey) { opt.apikey = this.options.apikey; }
            return L.tileLayer.wms(L.gmxUtil.protocol + '//' + poptions.hostName + '/TileService.ashx', opt);
        },

        _extendOptionsByDateInterval: function (options) {
            var dateInterval = this.parentLayer.getDateInterval(),
                beginDate = dateInterval.beginDate,
                endDate = dateInterval.endDate;
            L.extend(options, {
                StartDate: beginDate && beginDate.toLocaleDateString(),
                EndDate: endDate && endDate.toLocaleDateString()
            });
        },

        setDateInterval: function () {
            this._extendOptionsByDateInterval(this.externalLayer.wmsParams);
            this.externalLayer.redraw();
        },

        isExternalVisible: function (zoom) {
            return !(zoom < this.options.minZoom || zoom > this.options.maxZoom);
        }
    });

    L.gmx.VectorLayer.include({
        bindWMS: function (options) {
            if (this._layerWMS) {
                this._layerWMS.unbindLayer();
            }
            this._layerWMS = new BindWMS(options, this);
            this.isExternalVisible = this._layerWMS.isExternalVisible;
            return this;
        },

        unbindWMS: function () {
            if (this._layerWMS) {
                this._layerWMS.unbindLayer();
                this._layerWMS = null;
                this.isExternalVisible = null;
                this.enablePopup();
            }
            return this;
        }
    });
})();


(function() {
    'use strict';
    var GmxHeatMap = L.gmx.ExternalLayer.extend({
        options: {
            minHeatMapZoom: 1,
            maxHeatMapZoom: 6,
            intensityField: '',
            intensityScale: 1,
            observerOptions: {
                type: 'resend'
            }
        },

        createExternalLayer: function () {
            return L.heatLayer([], L.extend({
                 // minOpacity: 0.05,
                 // maxZoom: 18,
                 // radius: 25,
                 // blur: 15,
                 // max: 1.0
            }, this.options));
        },

        isExternalVisible: function (zoom) {
            return !(zoom < this.options.minHeatMapZoom || zoom > this.options.maxHeatMapZoom);
        },

        updateData: function (data) {
            if (data.added) {
                var latlngs = [],
                    indexes = this.parentLayer.getTileAttributeIndexes(),
                    altIndex = null,
                    intensityField = this.options.intensityField || '',
                    intensityScale = this.options.intensityScale || 1;

                if (intensityField && intensityField in indexes) {
                    altIndex = indexes[intensityField];
                }
                for (var i = 0, len = data.added.length; i < len; i++) {
                    var it = data.added[i].properties,
                        alt = altIndex !== null ? it[altIndex] : 1,
                        geo = it[it.length - 1],
                        coord = geo.coordinates,
                        point = L.Projection.Mercator.unproject({x: coord[0], y: coord[1]});

                    latlngs.push([point.lat, point.lng, typeof intensityScale === 'function' ? intensityScale(alt) : intensityScale * alt]);
                }
                this.externalLayer.setLatLngs(latlngs);
            }
        }
    });


    L.gmx.VectorLayer.include({
        bindHeatMap: function (options) {
            if (L.heatLayer) {
                if (this._heatmap) {
                    this._heatmap.unbindLayer();
                }
                this._heatmap = new GmxHeatMap(options, this);
            }
            return this;
        },

        unbindHeatMap: function () {
            if (L.heatLayer) {
                if (this._heatmap) {
                    this._heatmap.unbindLayer();
                    this._heatmap = null;
                    this.enablePopup();
                }
            }
            return this;
        }
    });
})();


(function() {
    'use strict';
    var _DEFAULTS = {
        radiusFunc: function (count) {
            var r = Math.floor(count / 15);
            if (r > 40) {
                r = 40;
            } else if (r < 20) {
                r = 20;
            }
            return r;
        },
        text: {
            stroke: 'black',
            'stroke-width': 1,
            'text-anchor': 'middle',
            fill: 'white'
        }
    };
    var GmxMarkerCluster = L.gmx.ExternalLayer.extend({
        options: {
            observerOptions: {
				delta: 256,
                filters: ['clipFilter', 'styleFilter', 'userFilter', 'clipPointsFilter']
            },
            spiderfyOnMaxZoom: true,
            minZoom: 1,
            maxZoom: 6
        },

        createExternalLayer: function () {
            var mOptions = L.extend({
                showCoverageOnHover: false,
                disableClusteringAtZoom: 1 + Number(this.options.maxZoom)
            }, this.options);

            if ('clusterIconOptions' in this.options) {
                var opt = this.options.clusterIconOptions;
                if ('radialGradient' in opt) {
                    var radialGradient = opt.radialGradient,
                        text = opt.text || _DEFAULTS.text;
                    mOptions.iconCreateFunction = function (cluster) {
                        var childCount = cluster.getChildCount();

                        text.count = childCount;
                        return  L.gmxUtil.getSVGIcon({
                            type: 'circle',
                            iconSize: 2 * (radialGradient.radiusFunc || _DEFAULTS.radiusFunc)(childCount),
                            text: text,
                            fillRadialGradient: radialGradient
                        });
                    };
                }
            }

            if (this.options.clusterclick) {
                mOptions.clusterclick = this.options.clusterclick;
                if (mOptions.clusterclick === true) { mOptions.zoomToBoundsOnClick = false; }
            }

            this._popup = new L.Popup({maxWidth: 10000, className: 'gmxPopup'});
            var markers = new L.MarkerClusterGroup(mOptions);

            // текущий развёрнутый кластер
            var currentSpiderfiedCluster = null;

            markers
                .on('click', function (ev) {
                    var propsArr = ev.layer.options.properties,
                        properties = this.parentLayer.getItemProperties(propsArr),
                        geometry = [propsArr[propsArr.length - 1]],
                        id = propsArr[0];

                    if (currentSpiderfiedCluster && !(currentSpiderfiedCluster.getAllChildMarkers().indexOf(ev.layer) + 1)) {
                        currentSpiderfiedCluster.unspiderfy();
                        markers.once('unspiderfied', function () {
                            this._openPopup(propsArr, ev.latlng);
                        }, this);
                    } else {
                        this._openPopup(propsArr, ev.latlng);
                    }

                    this.parentLayer.fire('click', L.extend(ev, {
                        eventFrom: 'markerClusters',
                        originalEventType: 'click',
                        gmx: {
                            id: id,
                            layer: this.parentLayer,
                            properties: properties,
                            target: {
                                id: id,
                                properties: propsArr,
                                geometry: geometry
                            }
                        }
                    }));
                }, this)
                .on('animationend', function () {
                    if (this._popup && this._popup._map) {
                        this._popup._map.removeLayer(this._popup);
                    }
                }, this)
                .on('clusterclick', function (ev) {
                    this.parentLayer.fire('clusterclick', L.extend(ev, {
                        eventFrom: 'markerClusters',
                        originalEventType: 'clusterclick'
                    }));
                }, this)
                .on('spiderfied', function (ev) {
                    currentSpiderfiedCluster = ev.cluster;
                }, this)
                .on('unspiderfied', function () {
                    currentSpiderfiedCluster = null;
                }, this);

            if (mOptions.clusterclick) {
                markers.on('clusterclick', mOptions.clusterclick instanceof Function ? mOptions.clusterclick : function (a) {
                    a.layer.spiderfy();
                });
            }

            return markers;
        },

        isExternalVisible: function (zoom) {
            return !(zoom < this.options.minZoom || zoom > this.options.maxZoom);
        },

        updateData: function (data) {
            var arr = [],
                i, len, vectorTileItem, id, marker;
            if (data.removed) {
                for (i = 0, len = data.removed.length; i < len; i++) {
                    vectorTileItem = data.removed[i];
                    id = vectorTileItem.id;
                    marker = this._items[id];
                    if (marker) {
                        arr.push(marker);
                    }
                    delete this._items[id];
                }
                this.externalLayer.removeLayers(arr);
                arr = [];
            }
            if (data.added) {
                for (i = 0, len = data.added.length; i < len; i++) {
                    vectorTileItem = data.added[i];
                    id = vectorTileItem.id;
                    marker = this._items[id];
                    var item = vectorTileItem.properties;
                    if (marker && item.processing) {
                        this.externalLayer.removeLayer(marker);
                        marker = null;
                    }
                    if (!marker) {
                        if (!vectorTileItem.item.parsedStyleKeys) {
                            vectorTileItem.item.parsedStyleKeys = this.parentLayer.getItemStyle(id);
                        }
                        var geo = item[item.length - 1],
                            parsedStyle = vectorTileItem.item.parsedStyleKeys,
                            p = geo.coordinates,
                            latlng = L.Projection.Mercator.unproject({x: p[0], y: p[1]}),
                            opt = {
                                properties: vectorTileItem.properties,
                                mPoint: p
                            };

                        if (this.options.notClusteredIcon) {
                            var icon = this.options.notClusteredIcon;
                            if (icon instanceof L.Icon) {
                                opt.icon = icon;
                            } else {
                                opt.icon = L.icon(icon);
                            }
                        } else if (parsedStyle) {
                            if (parsedStyle.iconUrl) {
                                var iconAnchor = parsedStyle.iconAnchor;
                                if (!iconAnchor) {
                                    var style = this.parentLayer.getItemStyle(id);
                                    iconAnchor = style.image ? [style.sx / 2, style.sy / 2] : [8, 10];
                                }
                                opt.icon = L.icon({
                                    iconAnchor: iconAnchor,
                                    iconUrl: parsedStyle.iconUrl
                                });
                            } else {
                                opt.icon = L.gmxUtil.getSVGIcon(parsedStyle);
                            }
                        }
                        if (parsedStyle.rotate) {
                            marker = L.rotatedMarker(latlng, L.extend(opt, {
                                angle: parsedStyle.rotate
                            }));
                        } else {
                            marker = L.marker(latlng, L.extend(opt, {
                                angle: parsedStyle.rotate
                            }));
                        }
                        this._items[id] = marker;
                    }
                    arr.push(marker);
                }
                this.externalLayer.addLayers(arr);
            }
        },

        _openPopup: function (propsArr, latlng) {
            var gmx = this.parentLayer._gmx,
                id = propsArr[0],
                balloonData = gmx.styleManager.getItemBalloon(id),
                properties = this.parentLayer.getItemProperties(propsArr),
                geometry = [propsArr[propsArr.length - 1]];

            if (balloonData && !balloonData.DisableBalloonOnClick) {
                var style = this.parentLayer.getItemStyle(id);
                if (style && style.iconAnchor) {
                    var protoOffset = L.Popup.prototype.options.offset;
                    this._popup.options.offset = [-protoOffset[0] - style.iconAnchor[0] + style.sx / 2,
                        protoOffset[1] - style.iconAnchor[1] + style.sy / 2
                    ];
                }
                this._popup
                    .setLatLng(latlng)
                    .setContent(L.gmxUtil.parseBalloonTemplate(balloonData.templateBalloon, {
                        properties: properties,
                        tileAttributeTypes: gmx.tileAttributeTypes,
                        unitOptions: this._map.options || {},
                        geometries: geometry
                    }))
                    .openOn(this._map);
            }
        }
    });

    L.gmx.VectorLayer.include({
        bindClusters: function (options) {
            if (L.MarkerClusterGroup) {
                if (this._clusters) {
                    this._clusters.unbindLayer();
                }
                this._clusters = new GmxMarkerCluster(options, this);
            }
            return this;
        },

        unbindClusters: function () {
            if (L.MarkerClusterGroup) {
                if (this._clusters) {
                    this._clusters.unbindLayer();
                    this._clusters = null;
                    this.enablePopup();
                }
            }
            return this;
        }
    });
})();


L.gmx = L.gmx || {};

var DEFAULT_HOSTNAME = 'maps.kosmosnimki.ru';
var DEFAULT_VECTOR_LAYER_ZINDEXOFFSET = 2000000;

//Build in layer classes
L.gmx._layerClasses = {
    'Raster': L.gmx.RasterLayer,
    'Vector': L.gmx.VectorLayer,
    'VectorView': L.gmx.DummyLayer
};

L.gmx._loadingLayerClasses = {};

L.gmx.addLayerClass = function(type, layerClass) {
    L.gmx._layerClasses[type] = layerClass;
};

L.gmx._layerClassLoaders = [];

L.gmx.addLayerClassLoader = function(layerClassLoader) {
    L.gmx._layerClassLoaders.push(layerClassLoader);

    //delete all loading promises to ensure that new loader will be invoked
    L.gmx._loadingLayerClasses = {};
};

L.gmx._loadLayerClass = function(type) {
    if (!L.gmx._loadingLayerClasses[type]) {
        var promise = new L.gmx.Deferred();
        promise.resolve();

        L.gmx._layerClassLoaders.forEach(function(loader) {
            promise = promise.then(function(layerClass) {
                if (layerClass) {
                    L.gmx._layerClasses[type] = layerClass;
                    return layerClass;
                }

                return loader(type);
            },
            function(){
                //just skip loader errors
            });
        });

        promise = promise.then(function(layerClass) {
            if (layerClass) {
                L.gmx._layerClasses[type] = layerClass;
                return layerClass;
            }
        }, function(){
            //just skip loader errors
        });

        L.gmx._loadingLayerClasses[type] = promise;
    }

    return L.gmx._loadingLayerClasses[type];
};

L.gmx.loadLayer = function(mapID, layerID, options) {

    var promise = new L.gmx.Deferred(),
        layerParams = {
            mapID: mapID,
            layerID: layerID
        };

    options = options || {};

    for (var p in options) {
        layerParams[p] = options[p];
    }

    var hostName = gmxAPIutils.normalizeHostname(options.hostName || DEFAULT_HOSTNAME);
    layerParams.hostName = hostName;

    gmxMapManager.loadMapProperties({
			srs: options.srs,
			hostName: hostName,
			apiKey: options.apiKey,
			mapName: mapID,
			skipTiles: options.skipTiles
		}).then(function() {
            var layerInfo = gmxMapManager.findLayerInfo(hostName, mapID, layerID);

            if (!layerInfo) {
                promise.reject('There is no layer ' + layerID + ' in map ' + mapID);
                return;
            }

            //to know from what host the layer was loaded
            layerInfo.properties.hostName = hostName;

            var type = layerInfo.properties.ContentID || layerInfo.properties.type;

            var doCreateLayer = function() {
                var layer = L.gmx.createLayer(layerInfo, layerParams);
                if (layer) {
                    promise.resolve(layer);
                } else {
                    promise.reject('Unknown type of layer ' + layerID);
                }
            };

            if (type in L.gmx._layerClasses) {
                doCreateLayer();
            } else {
                L.gmx._loadLayerClass(type).then(doCreateLayer);
            }
        },
        function(response) {
            promise.reject('Can\'t load layer ' + layerID + ' from map ' + mapID + ': ' + response.error);
        }
    );

    return promise;
};

L.gmx.loadLayers = function(layers, globalOptions) {
    var defs = layers.map(function(layerInfo) {
        var options = L.extend({}, globalOptions, layerInfo.options);
        return L.gmx.loadLayer(layerInfo.mapID, layerInfo.layerID, options);
    });

    return L.gmx.Deferred.all.apply(null, defs);
};

L.gmx.loadMap = function(mapID, options) {
    options = L.extend({}, options);
    options.hostName = gmxAPIutils.normalizeHostname(options.hostName || DEFAULT_HOSTNAME);
    options.mapName = mapID;

    var def = new L.gmx.Deferred();

    gmxMapManager.loadMapProperties(options).then(function(mapInfo) {
        var loadedMap = new L.gmx.gmxMap(mapInfo, options);

        loadedMap.layersCreated.then(function() {
            if (options.leafletMap || options.setZIndex) {
                var curZIndex = 0,
                    layer, rawProperties;

                for (var l = loadedMap.layers.length - 1; l >= 0; l--) {
                    layer = loadedMap.layers[l];
					rawProperties = layer.getGmxProperties();
					if (mapInfo.properties.LayerOrder === 'VectorOnTop' && layer.setZIndexOffset && rawProperties.type !== 'Raster') {
                        layer.setZIndexOffset(DEFAULT_VECTOR_LAYER_ZINDEXOFFSET);
                    }
                    if (options.setZIndex && layer.setZIndex) {
                        layer.setZIndex(++curZIndex);
                    }

                    if (options.leafletMap && rawProperties.visible) {
                        layer.addTo(options.leafletMap);
                    }
                }
            }
            def.resolve(loadedMap);
        });
    },
    function(response) {
        var errorMessage = (response && response.ErrorInfo && response.ErrorInfo.ErrorMessage) || 'Server error';
        def.reject('Can\'t load map ' + mapID + ' from ' + options.hostName + ': ' + errorMessage);
    });
    return def;
};

L.gmx.DummyLayer = function(props) {
    this.onAdd = this.onRemove = function() {};
    this.getGmxProperties = function() { return props; };
};

L.gmx.createLayer = function(layerInfo, options) {
    if (!layerInfo) { layerInfo = {}; }
    if (!layerInfo.properties) { layerInfo.properties = {type: 'Vector'}; }

    var type = layerInfo.properties.ContentID || layerInfo.properties.type || 'Vector',
        layer;

		if (type in L.gmx._layerClasses) {
        try {
            layer = new L.gmx._layerClasses[type](options);
            layer = layer.initFromDescription(layerInfo);
        } catch (e) {
            layer = new L.gmx.DummyLayer(layerInfo.properties);
        }
    } else {
        layer = new L.gmx.DummyLayer(layerInfo.properties);
    }

    return layer;
};


}());
L.Map.addInitHook(function () {
    var corners = this._controlCorners,
        parent = this._controlContainer,
        tb = 'leaflet-top leaflet-bottom',
        lr = 'leaflet-left leaflet-right',
        classNames = {
            bottom: 'leaflet-bottom ' + lr,
            gmxbottomleft: 'leaflet-bottom leaflet-left',
            gmxbottomcenter: 'leaflet-bottom ' + lr,
            gmxbottomright: 'leaflet-bottom leaflet-right',
            center: tb + ' ' + lr,
            right:  'leaflet-right ' + tb,
            left:   'leaflet-left ' + tb,
            top:    'leaflet-top ' + lr
        };

    for (var key in classNames) {
        if (!corners[key]) {
            corners[key] = L.DomUtil.create('div', classNames[key], parent);
        }
    }
});

L.Map.addInitHook(function() {
    var map = this,
        hideControl = null,
        hiddenClass = 'leaflet-control-gmx-hidden',
		// defaultSvgSprites = ['http://www.kosmosnimki.ru/lib/geomixer/img/svg-symbols.svg'],
		defaultSvgSprites = ['img/svg-symbols.svg'],
        DEFAULT = ['gmxLoaderStatus', 'gmxHide', 'gmxZoom', 'gmxDrawing', 'gmxBottom', 'gmxLocation', 'gmxCopyright', 'gmxCenter', 'gmxLogo'];

    this.gmxControlsManager = {
        _controls: {},
        _svgLoaded: {},
        add: function(control) {
            var opt = control.options,
                id = opt.id;
            this._controls[id] = control;
            if (control instanceof L.Control.GmxHide) {
                hideControl = control;
            }
            if (hideControl && !hideControl.options.isActive
                && !opt.notHide && !control._parent
                && control._container
              ) {
                L.DomUtil.addClass(control._container, hiddenClass);
            }
            return this;
        },
        remove: function(control) {
            delete this._controls[control.options.id];
            return this;
        },
        get: function(id) {
            return this._controls[id];
        },
        getAll: function() {
            return this._controls;
        },
        init: function(options) {
            options = options || {};
            if (map.options.svgSprite !== false) {
				this.setSvgSprites(map.options.svgSprite);
            }
            if (map.zoomControl && !options.zoomControl) {
                map.removeControl(map.zoomControl);
            }
            if (map.attributionControl && !options.attributionControl) {
                map.removeControl(map.attributionControl);
            }
			DEFAULT.forEach(function(key) {
                if (!(key in options) || options[key] !== null) {
                    map.addControl(L.control[key](options[key]));
                }
			});
            return this;
        },
        setSvgSprites: function(arr) {
			arr = arr && arr !== true ? (L.Util.isArray(arr) ? arr : [arr]) : defaultSvgSprites;
			var _this = this;
			arr.forEach(function(url) {
				if (!_this._svgLoaded[url]) {
					_this._svgLoaded[url] = true;
					fetch(url, {mode: 'cors'}).then(function(resp) {
						return resp.text();
					}).then(function(txt) {
						var div = document.createElement('div');
						div.style.display = 'none';
						div.innerHTML = txt;
						document.body.insertBefore(div, document.body.childNodes[0]);
						map.fire('svgspriteloaded', {url: url});
					});
				}
			});
			map.options.svgSprite = arr;
            return this;
        }
    };
    this.gmxControlIconManager = this.gmxControlsManager;
});

L.Control.GmxIcon = L.Control.extend({
    includes: L.Mixin.Events,
    options: {
        position: 'topleft',
        id: 'defaultIcon',
        isActive: false
    },

    setActive: function (active, skipEvent) {
        var options = this.options,
            togglable = options.togglable || options.toggle;
        if (togglable) {
            var prev = options.isActive,
                prefix = this._prefix,
                className = prefix + '-' + options.id,
                container = this._container;

            options.isActive = active;

            if (this._img) {
                if (active && options.activeImageUrl) { this._img.src = options.activeImageUrl; }
                else if (!active && options.regularImageUrl) { this._img.src = options.regularImageUrl; }
            }
            if (active) {
                L.DomUtil.addClass(container, prefix + '-active');
                L.DomUtil.addClass(container, className + '-active');
                if (container.children.length) {
                    L.DomUtil.addClass(container, prefix + '-externalImage-active');
                }
                if (options.styleActive) { this.setStyle(options.styleActive); }
            } else {
                L.DomUtil.removeClass(container, prefix + '-active');
                L.DomUtil.removeClass(container, className + '-active');
                if (container.children.length) {
                    L.DomUtil.removeClass(container, prefix + '-externalImage-active');
                }
                if (options.style) { this.setStyle(options.style); }
            }
            if (!skipEvent && prev !== active) { this.fire('statechange'); }
        }
    },

    onAdd: function (map) {
        var img = null,
            span = null,
            options = this.options,
			svgSprite = options.svgSprite || map.options.svgSprite,
			prefix = 'leaflet-gmx-icon' + (svgSprite && !options.regularImageUrl && !options.text ? 'Svg' : ''),
            className = prefix + '-' + options.id;

		this._prefix = prefix;
        var container = L.DomUtil.create('div', prefix + ' ' + className);
        container._id = options.id;

        this._container = container;
        if (options.title) { container.title = options.title; }
        this.setStyle = function (style) {
            for (var key in style) {
                container.style[key] = style[key];
            }
        };
        if (options.className) {
            L.DomUtil.addClass(container, options.className);
        }
        if (options.regularImageUrl) {
            img = L.DomUtil.create('img', '', container);
            img.src = options.regularImageUrl;
            this._img = img;
            L.DomUtil.addClass(container, prefix + '-img');
            L.DomUtil.addClass(container, prefix + '-externalImage');
        } else if (options.text) {
            L.DomUtil.addClass(container, prefix + '-text');
            span = L.DomUtil.create('span', '', container);
            span.innerHTML = options.text;
        } else if (svgSprite) {
          L.DomUtil.addClass(container, 'svgIcon');
          var useHref = '#' + options.id.toLowerCase();
          container.innerHTML = '<svg role="img" class="svgIcon">\
              <use xlink:href="' + useHref + '"></use>\
            </svg>';
        } else {
            L.DomUtil.addClass(container, prefix + '-img ' +  prefix + '-sprite');
        }
        // if (container.children.length) {
            // L.DomUtil.addClass(container, prefix + '-externalImage');
        // }
        if (options.style) {
            this.setStyle(options.style);
        }

        this._iconClick = function () {
            if (container.parentNode) {
                this.setActive(!this.options.isActive);
                this.fire('click');
                if (this.options.stateChange) { this.options.stateChange(this); }
            }
        };
        var stop = L.DomEvent.stopPropagation;
        L.DomEvent
            .on(container, 'mousemove', stop)
            .on(container, 'touchstart', stop)
            .on(container, 'mousedown', stop)
            .on(container, 'dblclick', stop)
            .on(container, 'click', stop)
            .on(container, 'click', this._iconClick, this);
        if (options.onAdd) {
            options.onAdd(this);
        }
        this.fire('controladd');
        map.fire('controladd', this);

        if (options.notHide) {
            container._notHide = true;
        }
        if (map.gmxControlsManager) {
            map.gmxControlsManager.add(this);
        }
        return container;
    },

    onRemove: function (map) {
        if (map.gmxControlsManager) {
            map.gmxControlsManager.remove(this);
        }
        this.fire('controlremove');
        map.fire('controlremove', this);

        var container = this._container,
            stop = L.DomEvent.stopPropagation;

        L.DomEvent
            .off(container, 'mousemove', stop)
            .off(container, 'touchstart', stop)
            .off(container, 'mousedown', stop)
            .off(container, 'dblclick', stop)
            .off(container, 'click', stop)
            .off(container, 'click', this._iconClick, this);
    },

    addTo: function (map) {
        L.Control.prototype.addTo.call(this, map);
        if (this.options.addBefore) {
            this.addBefore(this.options.addBefore);
        }
        return this;
    },

    addBefore: function (id) {
        var parentNode = this._parent && this._parent._container;
        if (!parentNode) {
            parentNode = this._map && this._map._controlCorners[this.getPosition()];
        }
        if (!parentNode) {
            this.options.addBefore = id;
        } else {
            for (var i = 0, len = parentNode.childNodes.length; i < len; i++) {
                var it = parentNode.childNodes[i];
                if (id === it._id) {
                    parentNode.insertBefore(this._container, it);
                    break;
                }
            }
        }

        return this;
    }
});

L.Control.gmxIcon = L.Control.GmxIcon;
L.control.gmxIcon = function (options) {
  return new L.Control.GmxIcon(options);
};

(function() {
function isIE(v) {
  return RegExp('msie' + (!isNaN(v) ? ('\\s' + v) : ''), 'i').test(navigator.userAgent);
}
var ICONSIZE = 32;
L.Control.GmxIconGroup = L.Control.GmxIcon.extend({
    includes: L.Mixin.Events,
    options: {
        position: 'topleft',
        id: 'defaultIconGroup',
        isVertical: true,
        isCollapsible: true,
        isSortable: false,
        singleSelection: false
    },
    addIcon: function (gmxIcon) {
        this.items.push(gmxIcon);
        gmxIcon._parent = this;
        if (this._map) {
            this._container.appendChild(gmxIcon.onAdd(this._map));
            if (gmxIcon.options.addBefore) {
                gmxIcon.addBefore(gmxIcon.options.addBefore);
            }
        }

        gmxIcon.on('click', function () {
            this.setActiveIcon(gmxIcon);
        }, this);

        if (this.options.isCollapsible && !gmxIcon.options.skipCollapse) {
            gmxIcon.on('click', this._minimize, this);
        }
        return this;
    },
    removeIcon: function (gmxIcon) {
        for (var i = 0, len = this.items.length; i < len; i++) {
            if (gmxIcon === this.items[i]) {
                var cont = gmxIcon._container;
                if (cont.parentNode) {
                    cont.parentNode.removeChild(cont);
                }
                this.items.splice(i, 1);
                break;
            }
        }
        return this;
    },
    getIconById: function (id) {
        for (var i = 0, len = this.items.length; i < len; i++) {
            var it = this.items[i];
            if (it.options.id === id) { return it; }
        }
        return null;
    },
    setActiveIcon: function (gmxIcon, isActive) {
        this.activeIcon = '';
        var len = this.items.length;
        if (len) {
            if (this.options.singleSelection) {
                for (var i = 0; i < len; i++) {
                    var it = this.items[i],
                        flag = gmxIcon === it && (isActive || it.options.isActive);
                    it.setActive(flag);
                    if (flag) { this.activeIcon = it.options.id; }
                }
            }
            var cont = this._container;
            if (this.options.isSortable && gmxIcon && cont.firstChild) {
                cont.insertBefore(gmxIcon._container, cont.firstChild);
                if (gmxIcon.options.text) {
                    this._chkTriangleStyle(gmxIcon._container);
                }
            }
            if (this.triangle) {
                var icon = this.options.isSortable ? gmxIcon : this.items[0];
                if (icon && icon.options.isActive) {
                    L.DomUtil.addClass(this.triangle, 'triangle-active');
                } else {
                    L.DomUtil.removeClass(this.triangle, 'triangle-active');
                }
            }
            this.fire('activechange', this);
        }
        return this;
    },

    _chkTriangleStyle: function (first) {
        var cont = this._container;
        for (var i = 0, len = this.items.length; i < len; i++) {
            var it = this.items[i];
            if (it._container === first) {
                if (it.options.text) {
                    this.triangle.style.right = (cont.clientWidth - first.clientWidth - 5) + 'px';
                    this.triangle.style.left = 'inherit';
                }
                break;
            }
        }
    },

    _minimize: function () {
        var style = this._container.style;

        style.height = ICONSIZE + 'px';
        if (this.options.width !== 'auto') { style.width = (ICONSIZE + 4) + 'px'; }
        style.overflow = 'hidden';
        if (this.bg) { this.bg.height = ICONSIZE + 2; }

		L.DomUtil.removeClass(this._container, 'leaflet-gmx-icon-group-maximum');
        this.fire('collapse', this);
    },

    _maximize: function () {
        var style = this._container.style,
            options = this.options;

        var size = this.items.length === 1 ? ICONSIZE : (ICONSIZE + 4) * this.items.length;
        if (options.isVertical) {
            if (this.bg) { this.bg.height = size; }
            style.height = size + 'px';
            if (options.width !== 'auto') { style.width = (ICONSIZE + 4) + 'px'; }
        } else {
            style.height = ICONSIZE + 'px';
            style.width = size + 'px';
        }
        style.overflow = 'unset';
		L.DomUtil.addClass(this._container, 'leaflet-gmx-icon-group-maximum');
        this.fire('expand', this);
    },

    onAdd: function (map) {
        var options = this.options,
			svgSprite = options.svgSprite || map.options.svgSprite,
			prefix = 'leaflet-gmx-icon-group',
            className = prefix + '-' + options.id + (svgSprite ? ' ' + prefix + 'Svg' : '') + ' ' + prefix + (options.isVertical ? '-vertical' : '-horizontal'),
            container = L.DomUtil.create('div', prefix + ' ' + className);

		if (options.isVertical) {
            if (isIE(10) || isIE(9)) {
                var vertical = L.DomUtil.create('span', 'icons-vertical',  container);
                var bg = L.DomUtil.create('img', '',  vertical);
                bg.width = bg.height = ICONSIZE;
                bg.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABBJREFUeNpi+P//PwNAgAEACPwC/tuiTRYAAAAASUVORK5CYII=';
                this.bg = bg;
                setTimeout(function() { bg.width = container.clientWidth; }, 0);
            }
            if (options.isCollapsible) {
				if (svgSprite) {
					this.triangle = L.DomUtil.create('div', 'triangleSvg',  container);
					this.triangle.innerHTML = '<svg role="img" class="svgIcon">\
						<use xlink:href="#arrow-down"></use>\
						</svg>';
				} else {
					this.triangle = L.DomUtil.create('div', 'triangle leaflet-gmx-icon-sprite',  container);
					this.triangle.width = this.triangle.height = ICONSIZE;
				}
            }
        }

        this._map = map;
        this._container = container;
        container._id = options.id;
        if (options.isCollapsible) {
            L.DomEvent
                .on(container, 'mousemove', L.DomEvent.stopPropagation)
                .on(container, 'mouseout', function(event) {
                    var parent = event.toElement;
                    while (parent) {
                        if (parent === container) { return; }
                        parent = parent.parentNode;
                    }
                    this._minimize();
                }, this)
                .on(container, 'mouseover', function(event) {
                    var parent = event.fromElement;
                    while (parent) {
                        if (parent === container) { return; }
                        parent = parent.parentNode;
                    }
                    this._maximize();
                }, this);

            this._minimize();
        }

        this.items = [];
        options.items.map(this.addIcon, this);
        if (options.onAdd) { options.onAdd(this); }
        this.fire('controladd');
        map.fire('controladd', this);

        if (options.isVertical) { container.style.marginLeft = 0; }
        if (options.notHide) {
            container._notHide = true;
        }
        if (map.gmxControlsManager) {
            map.gmxControlsManager.add(this);
        }
        if (this.items.length) {
            var first = this.items[0],
                _this = this;
            if (first.options.text) {
                setTimeout(function() { _this._chkTriangleStyle(first._container); }, 0);
            }
        }
        return container;
    },

    onRemove: function (map) {
        if (map.gmxControlsManager) {
            map.gmxControlsManager.remove(this);
        }
        this.fire('controlremove');
        map.fire('controlremove', this);
    }
});
L.Control.gmxIconGroup = L.Control.GmxIconGroup;
L.control.gmxIconGroup = function (options) {
  return new L.Control.GmxIconGroup(options);
};

})();

(function () {
var drawingIcons = ['Point', 'Polygon', 'Polyline', 'Rectangle'];
L.Control.GmxDrawing = L.Control.GmxIconGroup.extend({
    options: {
        position: 'topleft',
        singleSelection: true,
        isSortable: true,
        id: 'drawing',
        items: null
    },

    onAdd: function (map) {
        var _this = this;
        this.setActive = function (key) {
            if (map.gmxDrawing) {
                map.gmxDrawing.bringToFront();
                map.gmxDrawing.create(key, _this.options.drawOptions);
            }
        };
        this.on('activechange', function (ev) {
            var activeIcon = ev.activeIcon;
            for (var i = 0, len = drawingIcons.length; i < len; i++) {
                if (activeIcon === drawingIcons[i]) {
                    return;
                }
            }
            _this.setActive();
        });

        if (map.gmxDrawing) {
            map.gmxDrawing.on('drawstop', function (ev) {
                var opt = ev.object._obj.options || {};
                if (!opt.ctrlKey && !opt.shiftKey) {
                    _this.setActiveIcon();
                } else {
                    _this.setActive(ev.object.options.type);
                }
            }, this);
        }
        var addIcon = function (key) {
            return L.control.gmxIcon({
                id: key,
                //className: 'leaflet-gmx-icon-sprite',
                title: _this._locale && 'getText' in _this._locale ? _this._locale.getText(key) : key,
                togglable: true
              })
              .on('statechange', function (ev) {
                var opt = ev.target.options,
                    id = opt.id;

                if (id === _this.activeIcon) {
                    _this.setActive();
                } else if (opt.isActive) {
                    _this.setActive(id);
                }
            });
        };
        var defaultIcons = this.options.items || drawingIcons;
        this.options.items = [];
        defaultIcons.forEach(function (it) {
            _this.options.items.push(it instanceof L.Control.GmxIcon ? it : addIcon(it));
        });
        return L.Control.GmxIconGroup.prototype.onAdd.call(this, map);
    }
});

L.Control.gmxDrawing = L.Control.GmxDrawing;
L.control.gmxDrawing = function (options) {
  return new L.Control.GmxDrawing(options);
};

L.Control.GmxDrawing.locale = {};
L.Control.GmxDrawing.addInitHook(function () {
    this._locale = L.Control.GmxDrawing.locale;
    L.extend(this._locale, L.gmxLocaleMixin);
});
})();

L.extend(L.Control.GmxDrawing.locale, {
    rus: {
        'Point': 'Маркер',
        'Polygon': 'Многоугольник',
        'Polyline': 'Линия',
        'Rectangle': 'Прямоугольник'
    }
});

L.extend(L.Control.GmxDrawing.locale, {
    eng: {
        'Point': 'Point',
        'Polygon': 'Polygon',
        'Polyline': 'Polyline',
        'Rectangle': 'Rectangle'
    }
});

L.Control.GmxCenter = L.Control.extend({
    options: {
        position: 'center',
        id: 'center',
        notHide: true,
        color: '#216b9c'
    },

    onRemove: function (map) {
        if (map.gmxControlsManager) {
            map.gmxControlsManager.remove(this);
        }
        map.fire('controlremove', this);
    },

    onAdd: function (map) {
        var className = 'leaflet-gmx-center',
            container = L.DomUtil.create('div', className),
            div = L.DomUtil.create('div', className),
            svg = L.Path.prototype._createElement('svg'),
            g = document.createElementNS(L.Path.SVG_NS, 'g'),
            path = document.createElementNS(L.Path.SVG_NS, 'path');

        this._container = container;
        container._id = this.options.id;
        if (this.options.notHide) { container._notHide = true; }

		path.setAttribute('stroke-width', 1);
		path.setAttribute('stroke-opacity', 1);
		path.setAttribute('d', 'M6 0L6 12M0 6L12 6');
        this._path = path;
		g.appendChild(path);
		svg.appendChild(g);
        svg.setAttribute('width', 12);
        svg.setAttribute('height', 12);
        div.appendChild(svg);
        container.appendChild(div);

        this.setColor(this.options.color);
        map.fire('controladd', this);
        if (map.gmxControlsManager) {
            map.gmxControlsManager.add(this);
        }
        return container;
    },

    setColor: function (color) {
        this.options.color = color;
        if (this._map) { this._path.setAttribute('stroke', color); }
        return this;
    }
});

L.Control.gmxCenter = L.Control.GmxCenter;
L.control.gmxCenter = function (options) {
  return new L.Control.GmxCenter(options);
};

L.Control.GmxHide = L.Control.GmxIcon.extend({
    options: {
        id: 'hide',
        isActive: true,
        togglable: true,
        notHide: true,
        position: 'topleft'
    },

    setActive: function (active, flagAll) {
        if (this._map) {
            var corners = this._map._controlContainer,
                hiddenClass = 'leaflet-control-gmx-hidden',
                func = active ? L.DomUtil.removeClass : L.DomUtil.addClass;

            for (var i = 0, len = corners.children.length; i < len; i++) {
                for (var j = 0, arr = corners.children[i].children, len1 = arr.length; j < len1; j++) {
                    var node = arr[j];
                    if (!node._notHide || flagAll) {
                        func(node, hiddenClass);
                    }
                }
            }
            this.options.isActive = !this.options.isActive;
			var use = this._container.getElementsByTagName('use');
			if (use && use.length) {
				var zn = (use[0].getAttribute('xlink:href') || '').replace(/-off$/, '');
				if (!this.options.isActive) { zn += '-off'; }
				use[0].setAttribute('href', zn);
			}
            this.fire('statechange');
        }
    },

    onAdd: function (map) {
        var container = L.Control.GmxIcon.prototype.onAdd.call(this, map),
            txt = 'Hide/Show';

        if (L.gmxLocale) {
            txt = L.gmxLocale.addText({
                'eng': {hide: txt},
                'rus': {hide: 'Скрыть/Показать'}
            }).getText('hide');
        }
        container._id = this.options.id;
        container.title = txt;
        container._notHide = this.options.notHide;
        //L.DomUtil.addClass(container, 'leaflet-gmx-icon-sprite');
        return container;
    }
});
L.Control.gmxHide = L.Control.GmxHide;
L.control.gmxHide = function (options) {
  return new L.Control.GmxHide(options);
};

L.Control.GmxLayers = L.Control.Layers.extend({
    options: {
        collapsed: false,
        autoZIndex: false,
        id: 'layers'
    },

    initialize: function (gmxBaseLayersManager, options) {
        L.setOptions(this, options);

        this._layers = {};
        this._lastZIndex = 0;
        this._handlingClick = false;

        this._blm = gmxBaseLayersManager;

        L.extend(this, {
            _onBaseLayerActiveIDs: function(ev) {
                var i, len;
                for (i in this._layers) {
                    if (!this._layers[i].overlay) { delete this._layers[i]; }
                }
                for (i = 0, len = ev.activeIDs.length; i < len; i++) {
                    this._addBaseLayer(this._blm.get(ev.activeIDs[i]), true);
                }
                this._update();
                return true;
            },

            _onBaseLayerChange: function(ev) {
                if (ev.baseLayer) { this.setActiveBaseLayer(ev.baseLayer.id); }
            },

            _onBaseLayerOptionsChange: function(ev) {
                this._addBaseLayer(ev.baseLayer);
            }
        });
    },

    addBaseLayer: function () {
        console.log('Warning: Use `gmxBaseLayersManager.add` instead `addBaseLayer`!');
        return this;
    },

    _addBaseLayer: function (baseLayer, notUpdate) {
        if (baseLayer) {
            this._addLayer(baseLayer, baseLayer.options[L.gmxLocale.getLanguage()] || baseLayer.id);
            if (!notUpdate) { this._update(); }
        }
        return this;
    },

    _addItemObject: function (obj) {
        var label = this._addItem(obj);
        if (obj.layer && obj.layer._gmx && obj.layer._gmx.layerID) {
            label.className = '_' + obj.layer._gmx.layerID;
        }
    },

    _update: function () {
        if (!this._container) {
            return;
        }

        this._baseLayersList.innerHTML = '';
        this._overlaysList.innerHTML = '';

        var baseLayersPresent = false,
            overlaysPresent = false,
            activeIDs = this._blm.getActiveIDs(),
            activeIDsHash = {},
            i, len, obj;

        for (i in this._layers) {
            obj = this._layers[i];
            if (obj.overlay) {
                this._addItemObject(obj);
                overlaysPresent = true;
            } else {
                activeIDsHash[obj.layer.id] = obj;
                baseLayersPresent = true;
            }
        }
        for (i = 0, len = activeIDs.length; i < len; i++) {
            if (activeIDsHash[activeIDs[i]]) { this._addItemObject(activeIDsHash[activeIDs[i]]); }
        }

        if (this.options.hideBaseLayers) {
            baseLayersPresent = false;
            this._baseLayersList.style.display = 'none';
        }
        this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
        this._container.style.display = overlaysPresent || baseLayersPresent ? '' : 'none';
    },

    onAdd: function (map) {
        var cont = L.Control.Layers.prototype.onAdd.call(this, map);
        this._container = cont;
        cont.id = this.options.id;
        if (!('activeBaseLayerInput' in this)) {
            this.activeBaseLayerInput = this.getActiveBaseLayer(true);
        }
        L.DomEvent
            .on(cont, 'mousemove', L.DomEvent.stopPropagation);
        map.gmxLayersControl = this;
        map.fire('controladd', this);

        this._blm
            .on('baselayeroptionschange baselayeradd', this._onBaseLayerOptionsChange, this)
            .on('baselayeractiveids', this._onBaseLayerActiveIDs, this)
            .on('baselayerchange', this._onBaseLayerChange, this);

        var _this = this;
        this._blm.getActiveIDs().map(function(id) {
            _this._addBaseLayer(_this._blm.get(id));
        });
        var currentID = this._blm.getCurrentID();
        if (currentID) { this.setActiveBaseLayer(currentID); }

        if (map.gmxControlsManager) {
            map.gmxControlsManager.add(this);
        }
        return cont;
    },

    onRemove: function (map) {
        if (map.gmxControlsManager) {
            map.gmxControlsManager.remove(this);
        }
        L.Control.Layers.prototype.onRemove.call(this, map);
        this._blm
            .off('baselayeroptionschange baselayeradd', this._onBaseLayerOptionsChange, this)
            .off('baselayeractiveids', this._onBaseLayerActiveIDs, this)
            .off('baselayerchange', this._onBaseLayerChange, this);

        map.fire('controlremove', this);
    },

    unSetActiveBaseLayer: function (name) {
        this._toogleActiveBaseLayer(name, false);
    },

    setActiveBaseLayer: function (name) {
        this._toogleActiveBaseLayer(name, true);
    },

    _toogleActiveBaseLayer: function (name, flag) {
        var active = null,
            inputs = this._form.getElementsByTagName('input'),
            targetInput = null,
            blayer = this._getLayerByName(name),
            tid = blayer && blayer.layer._leaflet_id,
            targetIsOverlay = blayer && blayer.overlay;

        for (var i = 0, len = inputs.length; i < len; i++) {
            var input = inputs[i],
                id = input.layerId,
                obj = this._layers[id],
                layer = obj.layer,
                isHasLayer = this._map.hasLayer(layer),
                isOverlay = obj.overlay || false;

            if (isOverlay) {
                if (tid === id) {
                    if (flag) {
                        if (!isHasLayer) { this._map.addLayer(layer); }
                    } else if (isHasLayer) {
                        this._map.removeLayer(layer);
                    }
                    return this;
                }
            } else if (!targetIsOverlay) {
                if (tid === id) {
                    if (flag) {
                        active = input;
                    } else if (isHasLayer) {
                        input.checked = false;
                        active = null;
                        this._map.removeLayer(layer);
                    }
                    targetInput = input;
                }
            }
        }
        if (active && targetInput) {
            this._map.addLayer(this._layers[targetInput.layerId].layer);
            targetInput.checked = true;
        }
        this.activeBaseLayerInput = active;
        return this;
    },

    getActiveBaseLayer: function (inputFlag) {
        var inputs = this._form.getElementsByTagName('input');
        for (var i = 0, len = inputs.length; i < len; i++) {
            var input = inputs[i];
            if (input.checked) {
                if (inputFlag) { return input; }
                var id = input.layerId,
                    obj = this._layers[id];
                if (!obj.overlay) {
                    return obj.name;
                }
            }
        }
        return null;
    },

    _getLayerByName: function (name) {
        for (var id in this._layers) {
            var blayer = this._layers[id];
            if (name === blayer.name || name === blayer.layer.id) { return blayer; }
        }
        return null;
    },

    _onInputClick: function (ev) {
        if (ev) {
            var target = ev.target,
                name = this._layers[target.layerId].name,
                blayer = this._getLayerByName(name),
                flag = this.activeBaseLayerInput && target.layerId === this.activeBaseLayerInput.layerId ? false : target.checked;
            this._handlingClick = true;
            if (flag && blayer && !blayer.overlay) { this._blm.setCurrentID(blayer.layer.id); }
            else { this._toogleActiveBaseLayer(name, flag); }
            this._handlingClick = false;

            this._refocusOnMap();
        }
    }
});

L.Control.gmxLayers = L.Control.GmxLayers;
L.control.gmxLayers = function (gmxBaseLayersManager, options) {
  return new L.Control.GmxLayers(gmxBaseLayersManager, options);
};

(function () {
var _localeJson = {
    eng: {
        gmxLocation: {
            locationChange: 'Сhange the map center:',
            locationTxt: 'Current center coordinates',
            coordFormatChange: 'Toggle coordinates format',
            scaleBarChange: 'Toggle scale bar format'
        }
    },
    rus: {
        gmxLocation: {
            locationChange: 'Переместить центр карты:',
            locationTxt: 'Текущие координаты центра карты',
            coordFormatChange: 'Сменить формат координат',
            scaleBarChange: 'Сменить формат масштаба'
        }
    }
};

var _gtxt = function (key) {
    var res = '';
    if (L.gmxLocale) { res = L.gmxLocale.getText(key); }
    else {
        var arr = key.split('.');
        res = _localeJson.eng.gmxLocation[arr[arr.length - 1]]
    }
    return res || '';
};
var _mzoom = [
    'M 1:500 000 000',  //  0   156543.03392804
    'M 1:300 000 000',  //  1   78271.51696402
    'M 1:150 000 000',  //  2   39135.75848201
    'M 1:80 000 000',   //  3   19567.879241005
    'M 1:40 000 000',   //  4   9783.9396205025
    'M 1:20 000 000',   //  5   4891.96981025125
    'M 1:10 000 000',   //  6   2445.98490512563
    'M 1:5 000 000',    //  7   1222.99245256281
    'M 1:2500 000',     //  8   611.496226281406
    'M 1:1 000 000',    //  9   305.748113140703
    'M 1:500 000',      //  10  152.874056570352
    'M 1:300 000',      //  11  76.437028285176
    'M 1:150 000',      //  12  38.218514142588
    'M 1:80 000',       //  13  19.109257071294
    'M 1:40 000',       //  14  9.554628535647
    'M 1:20 000',       //  15  4.777314267823
    'M 1:10 000',       //  16  2.388657133912
    'M 1:5 000',        //  17  1.194328566956
    'M 1:2 500',        //  18  0.597164283478
    'M 1:1 250',        //  19  0.298582141739
    'M 1:625'           //  20  0.149291070869
];
var coordFormats = [
    '',
    '',
    ' (EPSG:3395)',
    ' (EPSG:3857)'
];
L.Control.GmxLocation = L.Control.extend({
    includes: L.Mixin.Events,
    options: {
        position: 'gmxbottomright',
        id: 'location',
        gmxPopup: 'internal',
        notHide: true,
        coordinatesFormat: 0,
        scaleFormat: 'bar'  // or text
    },

    setScaleFormat: function (type) {
        this.options.scaleFormat = type === 'bar' ? 'bar' : 'text';
        this.scaleBar.style.visibility = type === 'bar' ? 'visible' : 'hidden';
        this._checkPositionChanged();
    },

    onAdd: function (map) {
        var className = 'leaflet-gmx-location',
            container = L.DomUtil.create('div', className),
            utils = L.Control.GmxLocation.Utils,
            my = this;

        this._container = container;
        container._id = this.options.id;
        if (this.options.notHide) {
            container._notHide = true;
        }
        if (L.gmxLocale) {
            L.gmxLocale.addText(_localeJson);
        }
        this.prevCoordinates = '';

		var corner = map._controlCorners[this.options.position];
		if (corner) {
			this._window = L.DomUtil.create('div', 'leaflet-gmx-location-window', container);
			this._window.style.display = 'none';
			var closeButton = L.DomUtil.create('div', 'closeButton', this._window);
			closeButton.innerHTML = '&#215;';
			L.DomEvent.disableClickPropagation(this._window);
			L.DomEvent.on(this._window, 'contextmenu', L.DomEvent._fakeStop);

			L.DomEvent.on(closeButton, 'click', function () {
				var style = my._window.style;
				style.display = style.display === 'none' ? 'block' : 'none';
			}, this);
			map.on('click', function () {
				my._window.style.display = 'none';
			}, this);
			this._windowContent = L.DomUtil.create('div', 'windowContent', this._window);
		}

        this.locationTxt = L.DomUtil.create('span', 'leaflet-gmx-locationTxt', container);
        this.locationTxt.title = _gtxt('gmxLocation.locationTxt');
        this.coordFormatChange = L.DomUtil.create('span', 'leaflet-gmx-coordFormatChange', container);
        this.coordFormatChange.title = _gtxt('gmxLocation.coordFormatChange');
        this.scaleBar = L.DomUtil.create('span', 'leaflet-gmx-scaleBar', container);
        this.scaleBarTxt = L.DomUtil.create('span', 'leaflet-gmx-scaleBarTxt', container);
        this.scaleBarTxt.title = this.scaleBar.title = _gtxt('gmxLocation.scaleBarChange');
        this._map = map;

        var util = {
            coordFormat: this.options.coordinatesFormat || 0,
            len: coordFormats.length,
            setCoordinatesFormat: function(num) {
                num = num || this.coordFormat || 0;
                if (num < 0) {
                    num = util.len - 1;
                } else if (num >= util.len) {
                    num = 0;
                }
                this.coordFormat = num;
                var res = utils.getCoordinatesString(my._map.getCenter(), this.coordFormat);
                if (res && my.prevCoordinates !== res) { my.locationTxt.innerHTML = res; }
                my.prevCoordinates = res;
                if (this._redrawTimer) { clearTimeout(this._redrawTimer); }
                this._redrawTimer = setTimeout(function() {
                    if (my._map) { my._map.fire('onChangeLocationSize', {locationSize: container.clientWidth}); }
                }, 100);
                my.fire('coordinatesformatchange', {coordinatesFormat: this.coordFormat});
            },
            goTo: function(value) {
				var coord = L.Control.gmxLocation.Utils.parseCoordinates(value);
				my._map.panTo(coord);
            },
            showCoordinates: function(ev) {        //окошко с координатами
                var oldText = utils.getCoordinatesString(my._map.getCenter(), this.coordFormat);
                if (my.options.onCoordinatesClick) {
                    my.options.onCoordinatesClick(oldText, ev);
                } else if (L.control.gmxPopup) {
                    var div = L.DomUtil.create('div', 'gmxLocation-popup'),
                        span = L.DomUtil.create('div', '', div),
                        input = L.DomUtil.create('input', 'gmxLocation-input', div),
                        button = L.DomUtil.create('button', '', div);

                    button.innerHTML = 'Ok';
                    L.DomEvent.on(button, 'click', function () {
                        util.goTo(input.value);
                    });
                    span.innerHTML = _gtxt('gmxLocation.locationChange');
                    input.value = oldText;
                    L.DomEvent.on(input, 'keydown', function (ev) {
                        if (ev.which === 13) { util.goTo(this.value); }
                    });
					if (my.options.gmxPopup === 'internal' && my._window) {
						my._windowContent.innerHTML = '';
						my._windowContent.appendChild(div);
						var style = my._window.style;
						style.display = style.display === 'none' ? 'block' : 'none';
                    } else {
						var opt = {};
						if (my.options.gmxPopup === 'tip') {
							var pos = my._map.mouseEventToContainerPoint(ev);
							opt = {
								tip: true,
								anchor: new L.Point(pos.x, pos.y - 5)
							};
						}
						L.control.gmxPopup(opt).setContent(div).openOn(my._map);
					}
                } else {
                    //if (this.coordFormat > 2) { return; } // только для стандартных форматов.
                    var text = window.prompt(my.locationTxt.title + ':', oldText);
                    if (text && text !== oldText) {
                        var point = utils.parseCoordinates(text);
                        if (point) { my._map.panTo(point); }
                    }
                }
            },
            nextCoordinatesFormat: function() {
                this.coordFormat += 1;
                this.setCoordinatesFormat(this.coordFormat || 0);
            }
        };
        this.getCoordinatesFormat = function() {
			return util.coordFormat;
		};

        this._checkPositionChanged = function () {
            var z = map.getZoom();

            if (z) {
                var attr = {txt: _mzoom[z], width: 0};
                if (this.options.scaleFormat === 'bar') {
                    attr = utils.getScaleBarDistance(z, map.getCenter());
                }

                if (!attr || (attr.txt === my._scaleBarText && attr.width === my._scaleBarWidth)) { return; }
                my._scaleBarText = attr.txt;
                my._scaleBarWidth = attr.width;
                if (my._scaleBarText) {
                    my.scaleBar.style.width = my._scaleBarWidth + 'px';//, 4);
                    my.scaleBarTxt.innerHTML = my._scaleBarText;
                }

                util.setCoordinatesFormat(util.coordFormat || 0);
            }
        };
        this._setCoordinatesFormat = function () {
            util.setCoordinatesFormat(util.coordFormat || 0);
        };

        this.setCoordinatesFormat = function (nm) {
            if (nm === 0) { util.coordFormat = 0; }
            util.setCoordinatesFormat(nm);
        };

        var toggleScaleFormat = function () {
            this.setScaleFormat(this.options.scaleFormat === 'bar' ? 'text' : 'bar');
        };
        this._toggleHandlers = function (flag) {
            var op = flag ? 'on' : 'off',
                func = L.DomEvent[op],
                stop = L.DomEvent.stopPropagation;

            func(container, 'mousemove', stop);
            func(this.coordFormatChange, 'click', stop);
            func(this.coordFormatChange, 'click', util.nextCoordinatesFormat, util);
            func(this.locationTxt, 'click', stop);
            func(this.locationTxt, 'click', util.showCoordinates, util);
            func(this.scaleBarTxt, 'click', stop);
            func(this.scaleBarTxt, 'click', toggleScaleFormat, this);
            func(this.scaleBar, 'click', stop);
            func(this.scaleBar, 'click', toggleScaleFormat, this);
            if (!L.Browser.mobile && !L.Browser.ie) {
                func(this.coordFormatChange, 'dblclick', stop);
                func(this.scaleBarTxt, 'dblclick', stop);
                func(this.scaleBar, 'dblclick', stop);
            }

            map[op]('moveend', this._checkPositionChanged, this);
            map[op]('move', this._setCoordinatesFormat, this);
        };
        this._toggleHandlers(true);
        this.setScaleFormat(this.options.scaleFormat);
        this._checkPositionChanged();
        map.fire('controladd', this);
        if (map.gmxControlsManager) {
            map.gmxControlsManager.add(this);
        }
        return container;
    },
    onRemove: function (map) {
        if (map.gmxControlsManager) {
            map.gmxControlsManager.remove(this);
        }
        map.fire('controlremove', this);
        this.prevCoordinates = this._scaleBarText = null;
        this._toggleHandlers(false);
    }
});

var utils = {
    getScaleBarDistance: function(z, pos) {
        var merc = L.Projection.Mercator.project(pos),
            pos1 = L.Projection.Mercator.unproject(new L.Point(merc.x + 40, merc.y + 30)),
            metersPerPixel = Math.pow(2, -z) * 156543.033928041 * this.distVincenty(pos.lng, pos.lat, pos1.lng, pos1.lat) / 50;

        for (var i = 0; i < 30; i++) {
            var distance = [1, 2, 5][i % 3] * Math.pow(10, Math.floor(i / 3)),
                w = Math.floor(distance / metersPerPixel);
            if (w > 50) {
                return {txt: this.prettifyDistance(distance), width: w};
            }
        }
        return null;
    }
};
if (L.gmxUtil) {
    utils.getCoordinatesString = L.gmxUtil.getCoordinatesString;
    utils.prettifyDistance = L.gmxUtil.prettifyDistance;
    utils.formatDegrees = L.gmxUtil.formatDegrees;
    utils.pad2 = L.gmxUtil.pad2;
    utils.trunc = L.gmxUtil.trunc;
    utils.latLonFormatCoordinates = L.gmxUtil.latLonFormatCoordinates;
    utils.latLonFormatCoordinates2 = L.gmxUtil.latLonFormatCoordinates2;
    utils.degRad = L.gmxUtil.degRad;
    utils.distVincenty = L.gmxUtil.distVincenty;
    utils.parseCoordinates = L.gmxUtil.parseCoordinates;
} else {
    utils.prettifyDistance = function(length) {
        var type = '', //map.DistanceUnit
            txt = _gtxt('units.km') || 'km',
            km = ' ' + txt;
        if (type === 'km') {
            return (Math.round(length) / 1000) + km;
        } else if (length < 2000 || type === 'm') {
            txt = _gtxt('units.m') || 'm';
            return Math.round(length) + ' ' + txt;
        } else if (length < 200000) {
            return (Math.round(length / 10) / 100) + km;
        }
        return Math.round(length / 1000) + km;
    };
    utils.formatDegrees = function(angle) {
        angle = Math.round(10000000 * angle) / 10000000 + 0.00000001;
        var a1 = Math.floor(angle),
            a2 = Math.floor(60 * (angle - a1)),
            a3 = this.pad2(3600 * (angle - a1 - a2 / 60)).substring(0, 2);
        return this.pad2(a1) + '°' + this.pad2(a2) + '\'' + a3 + '"';
    };
    utils.pad2 = function(t) {
        return (t < 10) ? ('0' + t) : ('' + t);
    };
    utils.trunc = function(x) {
        return ('' + (Math.round(10000000 * x) / 10000000 + 0.00000001)).substring(0, 9);
    };
    utils.latLonFormatCoordinates = function(x, y) {
        return  this.formatDegrees(Math.abs(y)) + (y > 0 ? ' N, ' : ' S, ') +
            this.formatDegrees(Math.abs(x)) + (x > 0 ? ' E' : ' W');
    };
    utils.latLonFormatCoordinates2 = function(x, y) {
        return  this.trunc(Math.abs(y)) + (y > 0 ? ' N, ' : ' S, ') +
            this.trunc(Math.abs(x)) + (x > 0 ? ' E' : ' W');
    };
    utils.degRad = function(ang) {
        return ang * (Math.PI / 180.0);
    };

    utils.distVincenty =  function(lon1, lat1, lon2, lat2) {
        var p1 = {};
        var p2 = {};

        p1.lon =  this.degRad(lon1);
        p1.lat =  this.degRad(lat1);
        p2.lon =  this.degRad(lon2);
        p2.lat =  this.degRad(lat2);

        var a = 6378137, b = 6356752.3142,  f = 1 / 298.257223563;  // WGS-84 ellipsiod
        var L = p2.lon - p1.lon;
        var U1 = Math.atan((1 - f) * Math.tan(p1.lat));
        var U2 = Math.atan((1 - f) * Math.tan(p2.lat));
        var sinU1 = Math.sin(U1), cosU1 = Math.cos(U1);
        var sinU2 = Math.sin(U2), cosU2 = Math.cos(U2);

        var lambda = L, lambdaP = 2 * Math.PI;
        var iterLimit = 20;
        while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0) {
                var sinLambda = Math.sin(lambda), cosLambda = Math.cos(lambda);
                var sinSigma = Math.sqrt((cosU2 * sinLambda) * (cosU2 * sinLambda) +
                    (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
                if (sinSigma === 0) { return 0; }
                var cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
                var sigma = Math.atan2(sinSigma, cosSigma);
                var sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;
                var cosSqAlpha = 1 - sinAlpha * sinAlpha;
                var cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;
                if (isNaN(cos2SigmaM)) { cos2SigmaM = 0; }
                var C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));
                lambdaP = lambda;
                lambda = L + (1 - C) * f * sinAlpha *
                    (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
        }
        if (iterLimit === 0) { return NaN; }

        var uSq = cosSqAlpha * (a * a - b * b) / (b * b);
        var A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
        var B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
        var deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) -
                B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
        var s = b * A * (sigma - deltaSigma);

        s = s.toFixed(3);
        return s;
    };

    utils.parseCoordinates = function(text) {
        // should understand the following formats:
        // 55.74312, 37.61558
        // 55°44'35" N, 37°36'56" E
        // 4187347, 7472103
        // 4219783, 7407468 (EPSG:3395)
        // 4219783, 7442673 (EPSG:3857)

        var crs = null,
            regex = /\(EPSG:(\d+)\)/g,
            t = regex.exec(text);

        if (t) {
            crs = t[1];
            text = text.replace(regex, '');
        }

        if (text.match(/[йцукенгшщзхъфывапролджэячсмитьбюЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮqrtyuiopadfghjklzxcvbmQRTYUIOPADFGHJKLZXCVBM_:]/)) {
            return null;
        }

        //there should be a separator in the string (exclude strings like "11E11")
        if (text.indexOf(' ') === -1 && text.indexOf(',') === -1) {
            return null;
        }

        if (text.indexOf(' ') !== -1) {
            text = text.replace(/,/g, '.');
        }
        var results = [];
        regex = /(-?\d+(\.\d+)?)([^\d\-]*)/g;
        t = regex.exec(text);
        while (t) {
            results.push(t[1]);
            t = regex.exec(text);
        }
        if (results.length < 2) {
            return null;
        }
        var ii = Math.floor(results.length / 2),
            y = 0,
            mul = 1,
            i;
        for (i = 0; i < ii; i++) {
            y += parseFloat(results[i]) * mul;
            mul /= 60;
        }
        var x = 0;
        mul = 1;
        for (i = ii; i < results.length; i++) {
            x += parseFloat(results[i]) * mul;
            mul /= 60;
        }

        if (Math.max(text.indexOf('N'), text.indexOf('S')) > Math.max(text.indexOf('E'), text.indexOf('W'))) {
            t = x;
            x = y;
            y = t;
        }

        var pos;
        if (crs === '3857') {
            pos = L.Projection.SphericalMercator.unproject(new L.Point(y, x)._divideBy(6378137));
            x = pos.lng;
            y = pos.lat;
        }
        if (Math.abs(x) > 180 || Math.abs(y) > 180) {
            pos = L.Projection.Mercator.unproject(new L.Point(y, x));
            x = pos.lng;
            y = pos.lat;
        }

        if (text.indexOf('W') !== -1) {
            x = -x;
        }

        if (text.indexOf('S') !== -1) {
            y = -y;
        }
        return [y, x];
    };

    utils.getCoordinatesString = function(latlng, num) {
        var x = latlng.lng,
            y = latlng.lat,
            formats = coordFormats,
            len = formats.length,
            merc,
            out = '';
        num = num || 0;
        if (x > 180) { x -= 360; }
        if (x < -180) { x += 360; }
        if (num % len === 0) {
            out = utils.latLonFormatCoordinates2(x, y);
        } else if (num % len === 1) {
            out = utils.latLonFormatCoordinates(x, y);
        } else if (num % len === 2) {
            merc = L.Projection.Mercator.project(new L.LatLng(y, x));
            out = '' + Math.round(merc.x) + ', ' + Math.round(merc.y) + formats[2];
        } else {
            merc = L.CRS.EPSG3857.project(new L.LatLng(y, x));
            out = '' + Math.round(merc.x) + ', ' + Math.round(merc.y) + formats[3];
        }
        return out;
    };
}
L.Control.GmxLocation.Utils = utils;

L.Control.gmxLocation = L.Control.GmxLocation;
L.control.gmxLocation = function (options) {
  return new L.Control.GmxLocation(options);
};
})();

L.Control.GmxPopup = L.Control.extend({
    options: {
        position: 'center',
        id: 'gmxPopup',
        className: 'gmxControlPopup',
        draggable: true
    },

    onAdd: function (map) {
        this._map = map;
		if (!this._container) {
			this._initLayout();
		}
        map.on('click', this.remove, this);
        return this._container;
    },

    openOn: function (map) {
        map.addControl(this);
		this.update();
		return this;
    },

    remove: function () {
		if (this._map) {
            this._map.off('click', this.remove, this);
            this._map.removeControl(this);
        }
		return this;
    },

	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	update: function () {
		if (!this._container) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';
		return this;
	},

	_updateContent: function () {
		if (!this._content) { return; }

		if (typeof this._content === 'string') {
			this._contentNode.innerHTML = this._content;
		} else {
			while (this._contentNode.hasChildNodes()) {
				this._contentNode.removeChild(this._contentNode.firstChild);
			}
			this._contentNode.appendChild(this._content);
		}
	},

	_updateLayout: function () {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			L.DomUtil.addClass(container, scrolledClass);
		} else {
			L.DomUtil.removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var offset = new L.Point(this._container.clientWidth, this._container.clientHeight),
            anchor = this.options.anchor && this.options.anchor._subtract(L.point(10, this._container.clientHeight)) || this._map.getSize()._divideBy(2),
            pos = anchor._subtract(offset._divideBy(2));

        L.DomUtil.setPosition(this._container, pos);
	},

	_initLayout: function () {
		var container = this._container = L.DomUtil.create('div', this.options.className),
			closeButton = L.DomUtil.create('div', 'closeButton', container);

        closeButton.innerHTML = '&#215;';
        L.DomEvent.disableClickPropagation(closeButton);
        L.DomEvent.disableClickPropagation(container);

        L.DomEvent.on(closeButton, 'click', this.remove, this);
        if (this.options.draggable) {
            new L.Draggable(container).enable();
            container.style.cursor = 'move';
        }

		var wrapper = L.DomUtil.create('div', 'content-wrapper', container);
		L.DomEvent.disableClickPropagation(wrapper);

		this._contentNode = L.DomUtil.create('div', 'content', wrapper);

		L.DomEvent.disableScrollPropagation(this._contentNode);
		L.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

        if (this.options.tip) {
            this._tipContainer = L.DomUtil.create('div', 'tip-container', container);
            this._tip = L.DomUtil.create('div', 'tip', this._tipContainer);
        }
	}
});

L.control.gmxPopup = function (options) {
  return new L.Control.GmxPopup(options);
};

(function () {

var _gtxt = function (key) {
    var res = L.gmxLocale ? L.gmxLocale.getText(key) : null;
    return res || '';
};

L.Control.GmxCopyright = L.Control.extend({
    options: {
        position: 'gmxbottomleft',
        type: 'window', // 'window' or 'line'
        closeButton: false,
        notHide: true,
		cursorPosition: false,
        mapCopyright: '',
        scanexCopyright: '<a target="_blank" href="http://kosmosnimki.ru/terms.html">&copy; 2007-' + (new Date().getUTCFullYear()) + ' RDC ScanEx</a> - Terms of Service',
        leafletCopyright: '<a target="_blank" href="http://leafletjs.com">&copy; Leaflet</a>',
        id: 'copyright'
    },

    onAdd: function (map) {
        if (L.gmxLocale) {
            L.gmxLocale.addText({
                eng: {
                    gmxCopyright: {
                        showHide: 'Show/Hide copyrights'
                    }
                },
                rus: {
                    gmxCopyright: {
                        showHide: 'Показать/Скрыть копирайты'
                    }
                }
            });
        }
        this._currentText = '';

        this._container = L.DomUtil.create('span', 'leaflet-gmx-copyright');
        if (this.options.notHide) { this._container._notHide = true; }
        this._container._id = this.options.id;

        this._window = L.DomUtil.create('div', 'leaflet-gmx-copyright-window', this._container);
		if (this.options.closeButton) {
			var closeButton = L.DomUtil.create('div', 'closeButton', this._window);
			closeButton.innerHTML = '&#215;';
			L.DomEvent.on(closeButton, 'click', this.toggleWindow, this);
		}

		this._windowContent = L.DomUtil.create('div', 'windowContent', this._window);
		L.DomEvent.on(this._window, 'contextmenu', L.DomEvent._fakeStop);

        this._copyrights = L.DomUtil.create('span', 'leaflet-gmx-copyrights', this._container);

        if (this.options.cursorPosition) {
			var utils = L.gmxUtil || (L.Control.GmxLocation ? L.Control.GmxLocation.Utils : null),
				gmxLocation = map.gmxControlsManager.get('location') || null;

			if (utils) {
				var cursorPositionContainer = L.DomUtil.create('span', 'leaflet-gmx-cursorposition', this._container);
				this.lastLatLng = L.latLng(0, 0);
				this.cursorPosition = function (ev) {
					var latlng = ev.latlng,
						mouseDown = L.Browser.webkit ? ev.originalEvent.which : ev.originalEvent.buttons;
					if (!mouseDown && !latlng.equals(this.lastLatLng)) {
						this.lastLatLng = latlng;
						cursorPositionContainer.innerHTML = utils.getCoordinatesString(latlng, gmxLocation ? gmxLocation.getCoordinatesFormat() : 0);
					}
				};
				map.on('mousemove', this.cursorPosition, this);
			}
		}
        this.setFormat = function (type) {
            if (type === 'window') {
                this._copyrights.title = _gtxt('gmxCopyright.showHide');
                this._copyrights.innerHTML = '© Copyrights';
                this._container.style.width = 'auto';
            } else {
                this._copyrights.title = '';
            }
            this.options.type = type;
            this.toggleWindow();
            this._window.style.display = 'none';
        };

        this.setFormat(this.options.type);
        var stop = L.DomEvent.stopPropagation;
        L.DomEvent
            .on(this._window, 'dblclick', stop)
            .on(this._window, 'click', stop)
            .on(this._container, 'mousemove', stop)
            .on(this._copyrights, 'dblclick', stop)
            .on(this._copyrights, 'click', stop)
            .on(this._copyrights, 'click', this.toggleWindow, this);
        map
            .on('click', this.closeWindow, this)
            .on('onChangeLocationSize', this._chkWidth, this)
            .on('moveend', this._redraw, this)
            .on('layeradd', this._redraw, this)
            .on('layerremove', this._redraw, this);
        this._redraw();
        map.fire('controladd', this);
        if (map.gmxControlsManager) {
            map.gmxControlsManager.add(this);
        }
        return this._container;
    },

    onRemove: function (map) {
        if (map.gmxControlsManager) {
            map.gmxControlsManager.remove(this);
        }
        map.fire('controlremove', this);
        var stop = L.DomEvent.stopPropagation;
        L.DomEvent
            .off(this._window, 'dblclick', stop)
            .off(this._window, 'click', stop)
            .off(this._container, 'mousemove', stop)
            .off(this._copyrights, 'dblclick', stop)
            .off(this._copyrights, 'click', stop)
            .off(this._copyrights, 'click', this.toggleWindow, this);
        map
            .off('click', this.closeWindow, this)
            .off('onChangeLocationSize', this._chkWidth, this)
            .off('moveend', this._redraw, this)
            .off('layeradd', this._redraw, this)
            .off('layerremove', this._redraw, this);

        if (this.cursorPosition) {
			map.off('mousemove', this.cursorPosition, this);
		}
    },

    toggleWindow: function() {
		this.setWindowVisible(this._window.style.display === 'none' ? true : false);
    },

    closeWindow: function() {
		this.setWindowVisible(false);
    },

    setWindowVisible: function(flag) {
		if (this.options.type === 'window') {
			var style = this._window.style;
			style.display = flag ? 'block' : 'none';
			this._currentText = '';
			this._redraw();
		}
    },

    _chkWidth: function(ev) {
        if (this.options.type !== 'window') {
            var width = this._map._size.x - ev.locationSize - 25;
            this._container.style.width = (width > 0 ? width : 0) + 'px';
        }
    },

    setMapCopyright: function(copyright) {
        this.options.mapCopyright = copyright || '';
        this._redraw();
    },

    _redrawItems: function() {
        var prefix = '<a target="_blank"',
            texts = [],
            _layers = this._map._layers,
            _zoom = this._map._zoom,
            _bounds = this._map.getBounds(),
            arr = [],
            chkExists = {};

        if (this.options.scanexCopyright) { texts.push(this.options.scanexCopyright); }
        if (this.options.mapCopyright) { texts.push(this.options.mapCopyright); }
        for (var id in _layers) {
            if (_layers[id].options) { arr.push(_layers[id].options); }
        }
        arr = arr.sort(function(a, b) { return a.zIndex - b.zIndex; });

        arr.forEach(function(item) {
            var attribution = item.attribution;
            if (attribution && !chkExists[attribution]) {
                chkExists[attribution] = true;
                texts.push(attribution.split('<a').join(prefix));
            }

            if (item.gmxCopyright) {
                item.gmxCopyright.forEach(function(item1) {
                    var copyright = item1.attribution;
                    if (chkExists[copyright] || _zoom < item1.minZoom || _zoom > item1.maxZoom) { return; }
                    if (item1.bounds) {
                        if (!(item1.bounds instanceof L.LatLngBounds)) {
                            item1.bounds = L.latLngBounds(item1.bounds);
                        }
                        if (!_bounds.intersects(item1.bounds)) { return; }
                    }
                    chkExists[copyright] = true;
                    texts.push(copyright.split('<a').join(prefix));
                });
            }
        });
        if (this.options.leafletCopyright) { texts.push(this.options.leafletCopyright); }

        var text = texts.join(' ');

        if (this._currentText !== text) {
            this._currentText = text;
            if (this.options.type === 'window') {
                this._windowContent.innerHTML = texts.join('<br>');
            } else {
                this._copyrights.innerHTML = text;
            }

        }
    },

    _redraw: function () {
        var my = this;
        if (this._redrawTimer) { clearTimeout(this._redrawTimer); }
        this._redrawTimer = setTimeout(function() {
            my._redrawTimer = null;
            if (my._map) { my._redrawItems(); }
        }, 100);
    }
});

L.Control.gmxCopyright = L.Control.GmxCopyright;
L.control.gmxCopyright = function (options) {
  return new L.Control.GmxCopyright(options);
};
})();

L.Control.GmxZoom = L.Control.Zoom.extend({
    options: {
        position: 'topleft',
        id: 'zoom',
        zoomslider: true
    },
    _stepY: 7,  // slider step
    _minY: 9,   // slider min Y position
    _maxY: 9,   // slider max Y position

    onAdd: function (map) {
        var classPrefix = 'leaflet-gmx',
            container = L.DomUtil.create('div', classPrefix + '-zoomParent'),
            options = this.options,
			svgSprite = options.svgSprite || map.options.svgSprite;

        this._container = container;
        container._id = options.id;
        container._isZoomControl = true;
        this._map = map;
        this._zoomPlaque = L.DomUtil.create('div', classPrefix + '-zoomPlaque', container);
        var zoomIn = 'Zoom in',
            zoomOut = 'Zoom out';
        if (L.gmxLocale) {
            L.gmxLocale.addText({
                'eng': {
                    'Zoom in': 'Zoom in',
                    'Zoom out': 'Zoom out'
                },
                'rus': {
                    'Zoom in': 'Увеличить',
                    'Zoom out': 'Уменьшить'
                }
            });
            zoomIn = L.gmxLocale.getText('Zoom in');
            zoomOut = L.gmxLocale.getText('Zoom out');
        }
        var gmxIconClass = svgSprite ?
			classPrefix + '-iconSvg'
			:
			classPrefix + '-icon ' + classPrefix + '-icon-img ' + classPrefix + '-icon-sprite';

        this._zoomInButton  = this._createDiv(container,
            classPrefix + (svgSprite ? 'Svg' : '') + '-zoom-in ' + gmxIconClass, zoomIn, this._zoomIn, this);
        this._zoomOutButton = this._createDiv(container,
            classPrefix + (svgSprite ? 'Svg' : '') + '-zoom-out ' + gmxIconClass, zoomOut, this._zoomOut, this);

		if (svgSprite) {
          L.DomUtil.addClass(this._zoomInButton, 'svgIcon');
          this._zoomInButton.innerHTML = '<svg role="img" class="svgIcon"><use xlink:href="#zoom-in"></use></svg>';
          L.DomUtil.addClass(this._zoomOutButton, 'svgIcon');
          this._zoomOutButton.innerHTML = '<svg role="img" class="svgIcon"><use xlink:href="#zoom-out"></use></svg>';
        }

        map.on('zoomend zoomlevelschange', this._updateDisabled, this);
        if (options.zoomslider) {
            this._chkZoomLevelsChange(container);
        }
        map.fire('controladd', this);
        if (map.gmxControlsManager) {
            map.gmxControlsManager.add(this);
        }
        return container;
    },

    onRemove: function (map) {
        if (map.gmxControlsManager) {
            map.gmxControlsManager.remove(this);
        }
        map.fire('controlremove', this);
        L.Control.Zoom.prototype.onRemove.call(this, map);
    },

    _createDiv: function (container, className, title, fn, context) {
        var link = L.DomUtil.create('div', className, container);
        if (title) { link.title = title; }

        var stop = L.DomEvent.stopPropagation;

        L.DomEvent
            //.on(container, 'mousemove', stop)
            .on(link, 'click', stop)
            .on(link, 'mousedown', stop)
            .on(link, 'dblclick', stop)
            .on(link, 'click', L.DomEvent.preventDefault)
            .on(link, 'click', fn || stop, context);

        return link;
    },

    _setPosition: function () {
        if (this._zoomVal) {
            var MinZoom = this._map.getMinZoom(),
                y = this._maxY - (this._zoom - MinZoom) * this._stepY;

            this._zoomVal.innerHTML = this._zoom;
            L.DomUtil.setPosition(this._zoomPointer, L.point(4, y));
        }
    },

    _getZoomByY: function (y) {
        if (y < this._minY) { y = this._minY; }
        else if (y > this._maxY) { y = this._maxY; }
        return Math.floor((this._maxY - y) / this._stepY);
    },

    _setSliderSize: function () {
        var map = this._map,
            height = this._stepY * (map.getMaxZoom() - map.getMinZoom() + 1);
        this._maxY = height + 3;
        this._zoomSliderBG.style.height = height + 'px';
        height += 72;
        if (this._zoomSliderCont.style.display !== 'block') {
            this._zoomPlaque.style.display = 'none';
            height = 68;
        } else {
            this._zoomPlaque.style.display = 'block';
        }
        this._zoomPlaque.style.height = height + 'px';
    },

    _chkZoomLevelsChange: function (container) {
        var my = this,
            map = this._map,
            classPrefix = 'leaflet-gmx',
            MinZoom = map.getMinZoom(),
            MaxZoom = map.getMaxZoom();

        if (MinZoom !== this._MinZoom || MaxZoom !== this._MaxZoom) {
            var delta = MaxZoom - MinZoom;
            if (MaxZoom < 100 && delta >= 0) {
                if (!this._zoomSliderCont) {
                    this._zoomSliderCont  = this._createDiv(container, classPrefix + '-sliderCont');
                    this._zoomSliderBG  = this._createDiv(this._zoomSliderCont, classPrefix + '-sliderBG');
                    L.DomEvent.on(this._zoomSliderBG, 'click', function (ev) {
                        this._zoom = this._getZoomByY(ev.layerY) + map.getMinZoom();
                        this._map.setZoom(this._zoom);
                        this._zoomPointer.style.display = this._zoom === map._limitZoom(this._zoom) ? 'block' : 'none';
                    }, this);
                    this._zoomPointer  = this._createDiv(this._zoomSliderCont, classPrefix + '-zoomPointer ');
                    this._zoomVal  = this._createDiv(this._zoomPointer, classPrefix + '-zoomVal ' + classPrefix + '-icon-sprite');
                    L.DomEvent.on(container, 'mouseover', function () {
                        var zoom = map.getZoom();
                        this._zoomPointer.style.display = zoom === map._limitZoom(zoom) ? 'block' : 'none';
                        if (map.getMaxZoom() !== Infinity) {
                            this._zoomSliderCont.style.display = 'block';
                            this._setSliderSize();
                        }
                    }, this);
                    var mouseout = function () {
                        my._zoomSliderCont.style.display = 'none';
                        my._setSliderSize();
                    };
                    L.DomEvent.on(container, 'mouseout', function () {
                        if (this._draggable._moving) { return; }
                        mouseout();
                    }, this);
                    var draggable = new L.Draggable(this._zoomPointer);
                    draggable.on('dragstart', function () {
                    }, this);
                    draggable.on('drag', function (ev) {
                        var pos = ev.target._newPos;
                        this._zoom = this._getZoomByY(pos.y) + map.getMinZoom();
                        this._setPosition();
                    }, this);
                    draggable.on('dragend', function () {
                        this._map.setZoom(this._zoom);
                        mouseout();
                    }, this);
                    draggable.enable();
                    this._draggable = draggable;
                }
                this._setSliderSize();
            }
            this._MinZoom = MinZoom;
            this._MaxZoom = MaxZoom;
        }
        this._zoom = map._zoom;
        this._setPosition();
    },

    _updateDisabled: function (ev) {
        L.Control.Zoom.prototype._updateDisabled.call(this, ev);
        this._zoom = this._map._zoom;
        if (this.options.zoomslider) {
            if (ev.type === 'zoomlevelschange') {
                this._chkZoomLevelsChange(this._container);
            }
            this._setPosition();
        }
    },

    setVisible: function(isVisible) {
        if (this._container) {
            this._container.style.display = isVisible ? 'block' : 'none';
        }
    }
});

L.Control.gmxZoom = L.Control.GmxZoom;
L.control.gmxZoom = function (options) {
  return new L.Control.GmxZoom(options);
};

L.Control.GmxBottom = L.Control.extend({
    options: {
        position: 'bottom',
        notHide: true,
        id: 'bottom'
    },

    onRemove: function (map) {
        if (map.gmxControlsManager) {
            map.gmxControlsManager.remove(this);
        }
        map.fire('controlremove', this);
        var corners = map._controlCorners;
        ['bottomleft', 'bottomright', 'right', 'left'].map(function (it) {
            if (corners[it]) {
                L.DomUtil.removeClass(corners[it], 'gmx-bottom-shift');
            }
        });
    },

    onAdd: function (map) {
        var className = 'leaflet-gmx-copyright-location',
            container = L.DomUtil.create('div', className);

        this._container = container;
        container._id = this.options.id;
        if (this.options.notHide) { container._notHide = true; }
        L.DomEvent
            .on(container, 'mousemove', L.DomEvent.stopPropagation)
            .on(this._map._controlContainer, 'dblclick', L.DomEvent.stopPropagation);
        L.DomUtil.create('div', className + '-bg', container);
        map.fire('controladd', this);

        var corners = map._controlCorners;
        ['bottomleft', 'bottomright', 'right', 'left'].map(function (it) {
            if (corners[it]) {
                L.DomUtil.addClass(corners[it], 'gmx-bottom-shift');
            }
        });
        if (map.gmxControlsManager) {
            map.gmxControlsManager.add(this);
        }
        return container;
    }
});

L.Control.gmxBottom = L.Control.GmxBottom;
L.control.gmxBottom = function (options) {
  return new L.Control.GmxBottom(options);
};

L.Control.GmxLogo = L.Control.extend({
    options: {
        position: 'gmxbottomcenter',
        notHide: true,
        id: 'logo'
    },

    onAdd: function (map) {
        var container = L.DomUtil.create('a', '');
        this._container = container;
        if (this.options.notHide) { container._notHide = true; }
        container.id = this.options.id;
        container.setAttribute('href', 'http://geomixer.ru');
        container.setAttribute('target', '_blank');

        this._logoPrefix = 'leaflet-gmx-logo' + (this.options.type ? '-' + this.options.type : '');
        var shiftClass = this._logoPrefix + '-shift';
        this._shift = false;
        this._updatePosition = function (ev) {
            if (container.parentNode) {
                var shift = (container.clientWidth - container.parentNode.clientWidth) / 2 + ev.locationSize > 0 ? true : false;
                if (this._shift !== shift) {
                    this._shift = shift;
                    if (shift) {
                        L.DomUtil.addClass(container, shiftClass);
                    } else {
                        L.DomUtil.removeClass(container, shiftClass);
                    }
                }
            }
        };
        map.fire('controladd', this);
        if (map.gmxControlsManager) {
            map.gmxControlsManager.add(this);
        }
        return container;
    },

    onRemove: function (map) {
        if (map.gmxControlsManager) {
            map.gmxControlsManager.remove(this);
        }
        map.fire('controlremove', this);
        map.off('onChangeLocationSize', this._updatePosition, this);
    },

    addTo: function (map) {
        L.Control.prototype.addTo.call(this, map);
        L.DomUtil.addClass(this._container, this._logoPrefix);
        map.on('onChangeLocationSize', this._updatePosition, this);
        return this;
    }
});

L.Control.gmxLogo = L.Control.GmxLogo;
L.control.gmxLogo = function (options) {
  return new L.Control.GmxLogo(options);
};

L.Map.addInitHook(function () {
    if (!this._controlCorners.bottom) {
        this._controlCorners.bottom = L.DomUtil.create(
            'div',
            'leaflet-bottom leaflet-left leaflet-right',
            this._controlContainer
        );
    }
});

L.Control.GmxSidebar = L.Control.extend({
    options: {
        id: 'defaultSidebar',
        position: 'right'
    },
    onAdd: function(map) {
        var container = document.createElement('div');
        this._container = container;
        container._id = this.options.id;
        container.className = 'leaflet-gmx-sidebar';
        if (typeof this.options.width === 'number') {
            container.setAttribute('style', 'width: ' + this.options.width + 'px');
        }
        if (typeof this.options.className === 'string') {
            L.DomUtil.addClass(container, this.options.className);
        }
        L.DomEvent
            .on(container, 'mousemove', L.DomEvent.stopPropagation)
            .on(container, 'dblclick', L.DomEvent.stopPropagation);

        if (map.gmxControlsManager) {
            map.gmxControlsManager.add(this);
        }
        return container;
    },

    onRemove: function (map) {
        if (map.gmxControlsManager) {
            map.gmxControlsManager.remove(this);
        }
        map.fire('controlremove', this);
    },
    expand: function() {
        L.DomUtil.addClass(this._container, 'leaflet-gmx-sidebar_expanded');
    },
    collapse: function() {
        L.DomUtil.removeClass(this._container, 'leaflet-gmx-sidebar_expanded');
    },
    isExpanded: function() {
        return L.DomUtil.hasClass(this._container, 'leaflet-gmx-sidebar_expanded');
    },
    getContentContainer: function() {
        return this.getContainer();
    },
    setWidth: function(w) {
        if (typeof w === 'number') {
            this._container.setAttribute('style', 'width: ' + w + 'px');
        }
    }
});

L.Control.gmxSidebar = L.Control.GmxSidebar;
L.control.gmxSidebar = function(options) {
    return new L.Control.GmxSidebar(options);
};

L.Control.GmxLoaderStatus = L.Control.extend({
    options: {
        id: 'loaderStatus',
        position: 'topleft',
        type: 'gif' // 'gif' 'font'
    },
    _items: {},
    _text: 'Loader status',

    addItem: function (id, type) {
        var itemId = id || L.gmxUtil.newId(),
            item = this._items[itemId],
            className = this.options.type === 'gif' ? 'icon-refresh-gif' : 'animate-spin icon-refresh';
        className += (type ? ' leaflet-gmx-loaderStatus-' + type : '');

        this._div.className = className;
        L.DomUtil.removeClass(this._container, 'leaflet-gmx-visibility-hidden');
        if (item) {
            item++;
        } else {
            this._items[itemId] = 1;
        }
		this._container.title = this._text + ': ' + Object.keys(this._items).length;

        return itemId;
    },

    removeItem: function (id) {
        var item = this._items[id];
        if (item > 1) {
            this._items[id]--;
        } else {
            delete this._items[id];
        }
        if (Object.keys(this._items).length === 0) {
            if (this.options.type !== 'gif') { L.DomUtil.removeClass(this._div, 'animate-spin'); }
            L.DomUtil.addClass(this._container, 'leaflet-gmx-visibility-hidden');
        }
		this._container.title = this._text + ': ' + Object.keys(this._items).length;
    },

    onRemove: function (map) {
        if (map.gmxControlsManager) {
            map.gmxControlsManager.remove(this);
        }
        map.fire('controlremove', this);
        delete L.gmx.loaderStatus;
    },

    onAdd: function (map) {
        var options = this.options,
            className = 'leaflet-gmx-visibility-hidden leaflet-gmx-' + options.id,
            container = L.DomUtil.create('div', className),
            div = L.DomUtil.create('div', options.type === 'gif' ? 'icon-refresh-gif' : 'animate-spin icon-refresh', container),
            txt = 'Loader status';

        if (L.gmxLocale) {
            txt = L.gmxLocale.addText({
                'eng': {hide: txt},
                'rus': {hide: 'Статус загрузки'}
            }).getText('hide');
        }

        container._id = this.options.id;
        container.title = this._text = txt;

        this._container = container;
        this._div = div;
        this._items = {};

        map.fire('controladd', this);
        if (map.gmxControlsManager) {
            map.gmxControlsManager.add(this);
        }
        var _this = this;
        if (!L.gmxUtil) { L.gmxUtil = {}; }
        L.gmxUtil.loaderStatus = function(id, removeFlag, type) {
            return _this[removeFlag ? 'removeItem' : 'addItem'].apply(_this, [id, type]);
        };
		L.DomEvent
			.on(container, 'click', L.DomEvent.stopPropagation)
			.on(container, 'click', function() {
				var arr = Object.keys(this._items);
				console.info('Запросов в очереди на загрузку:', arr.length, arr);
			}, this);
        return container;
    }
});

L.Control.gmxLoaderStatus = L.Control.GmxLoaderStatus;
L.control.gmxLoaderStatus = function (options) {
  return new L.Control.GmxLoaderStatus(options);
};

(function () {

var rectDelta = 0.0000001;
var stateVersion = '1.0.0';

L.GmxDrawing = L.Class.extend({
    options: {
        type: ''
    },
    includes: [L.Mixin.Events],

    initialize: function (map) {
        this._map = map;
        this.items = [];
        this.current = null;
        this.contextmenu = new L.GmxDrawingContextMenu({
			points: [], // [{text: 'Remove point'}, {text: 'Delete feature'}],
			lines: []
		});

        if (L.gmxUtil && L.gmxUtil.prettifyDistance) {
            var tooltip = document.createElementNS(L.Path.SVG_NS, 'g');
            L.DomUtil.addClass(tooltip, 'gmxTooltip');
            var bg = document.createElementNS(L.Path.SVG_NS, 'rect');
            bg.setAttributeNS(null, 'rx', 4);
            bg.setAttributeNS(null, 'ry', 4);
            bg.setAttributeNS(null, 'height', 16);
            L.DomUtil.addClass(bg, 'gmxTooltipBG');

            var text = document.createElementNS(L.Path.SVG_NS, 'text');
            var userSelectProperty = L.DomUtil.testProp(
                ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);
            text.style[userSelectProperty] = 'none';
            tooltip.appendChild(bg);
            tooltip.appendChild(text);

            this.hideTooltip = function() {
                tooltip.setAttributeNS(null, 'visibility', 'hidden');
            };
            this.showTooltip = function(point, mouseovertext) {
                var x = point.x + 11,
                    y = point.y - 14;
                text.setAttributeNS(null, 'x', x);
                text.setAttributeNS(null, 'y', y);
                text.textContent = mouseovertext;
                if (tooltip.getAttributeNS(null, 'visibility') !== 'visible') {
                    this._map._pathRoot.appendChild(tooltip);
                    tooltip.setAttributeNS(null, 'visibility', 'visible');
                }
                var length = text.getComputedTextLength();
                bg.setAttributeNS(null, 'width', length + 8);
                bg.setAttributeNS(null, 'x', x - 4);
                bg.setAttributeNS(null, 'y', y - 12);
            };
        }
        var refreshMode = function (ev) {
            this._drawMode = ev.mode;
        };
        this.on('drawstop drawstart', refreshMode);
    },

    bringToFront: function () {
        for (var i = 0, len = this.items.length; i < len; i++) {
            var item = this.items[i];
            if (item._map && 'bringToFront' in item) { item.bringToFront(); }
        }
    },

    addGeoJSON: function (obj, options) {
        var arr = [],
            isLGeoJSON = obj instanceof L.GeoJSON;
        if (!isLGeoJSON) {
            obj = L.geoJson(obj, options);
        }
        if (obj instanceof L.GeoJSON) {
            var layers = obj.getLayers();
            if (layers) {
                var parseLayer = function (it) {
                    var _originalStyle = null;
                    if (it.setStyle && options && options.lineStyle) {
                        _originalStyle = {};
                        for (var key in options.lineStyle) {
                            _originalStyle[key] = options.lineStyle[key];
                        }
                        it.setStyle(options.lineStyle);
                    }
                    var f = this.add(it, options);
                    f._originalStyle = _originalStyle;
                    arr.push(f);
                };
                for (var i = 0, len = layers.length; i < len; i++) {
                    var layer = layers[i];

                    if (layer.feature.geometry.type !== 'GeometryCollection') {
                        layer = L.layerGroup([layer]);
                    }
                    layer.eachLayer(parseLayer, this);
                }
            }
        }
        return arr;
    },

    add: function (obj, options) {
        var item = null;
        if (obj) {
            if (obj instanceof L.GmxDrawing.Feature) {
                item = obj;
            } else {
                var calcOptions = {};
                if (!options || !('editable' in options)) { calcOptions.editable = true; }
                if (obj.geometry)     { calcOptions.type = obj.geometry.type; }
                else if (obj instanceof L.Rectangle)     { calcOptions.type = 'Rectangle'; }
                else if (obj instanceof L.Polygon)  { calcOptions.type = 'Polygon'; }
                else if (obj instanceof L.MultiPolygon)  { calcOptions.type = 'MultiPolygon'; }
                else if (obj instanceof L.Polyline) { calcOptions.type = 'Polyline'; }
                else if (obj instanceof L.MultiPolyline) { calcOptions.type = 'MultiPolyline'; }
                else if (obj instanceof L.Marker) {
                    calcOptions.type = 'Point'; calcOptions.editable = false;
                    obj.options.draggable = true;
                }
                options = this._chkDrawOptions(calcOptions.type, options);
                L.extend(options, calcOptions);
                if (obj.geometry) {
                    var iconStyle = options.markerStyle && options.markerStyle.iconStyle;
                    if (options.type === 'Point' &&
                        !options.pointToLayer &&
                        iconStyle
                    ) {
                        options.icon = L.icon(iconStyle);
                        options.pointToLayer = function (geojson, latlng) {
                             return new L.Marker(latlng, options);
                        };
                    }
                    return this.addGeoJSON(obj, options);
                }
                item = new L.GmxDrawing.Feature(this, obj, options);
            }
            if (!('map' in options)) { options.map = true; }
            if (options.map && !item._map) { this._map.addLayer(item); }
            else { this._addItem(item); }
            //if (!item._map) this._map.addLayer(item);
            //if (item.points) item.points._path.setAttribute('fill-rule', 'inherit');
            if ('setEditMode' in item) { item.setEditMode(); }
        }
        return item;
    },

    _disableDrag: function () {
        this._map.dragging.disable();
        L.DomUtil.disableTextSelection();
        L.DomUtil.disableImageDrag();
		this._map.doubleClickZoom.removeHooks();
    },

    _enableDrag: function () {
        this._map.dragging.enable();
        L.DomUtil.enableTextSelection();
        L.DomUtil.enableImageDrag();
		this._map.doubleClickZoom.addHooks();
    },

    _clearCreate: function () {
        if (this._createKey) {
            if (this._createKey.type === 'Rectangle' && L.Browser.mobile) {
                L.DomEvent.off(this._map._container, 'touchstart', this._createKey.fn, this);
            } else {
                this._map.off(this._createKey.eventName, this._createKey.fn, this);
            }
            this._enableDrag();
        }
        this._createKey = null;
    },

    _chkDrawOptions: function (type, drawOptions) {
        var defaultStyles = L.GmxDrawing.utils.defaultStyles,
            resultStyles = {};
        if (!drawOptions) {
            drawOptions = L.extend({}, defaultStyles);
        }
        if (type === 'Point') {
            L.extend(resultStyles, defaultStyles.markerStyle.options.icon, drawOptions);
        } else {
            L.extend(resultStyles, drawOptions);
            resultStyles.lineStyle = L.extend({}, defaultStyles.lineStyle, drawOptions.lineStyle);
            resultStyles.pointStyle = L.extend({}, defaultStyles.pointStyle, drawOptions.pointStyle);
            resultStyles.holeStyle = L.extend({}, defaultStyles.holeStyle, drawOptions.holeStyle);
        }

        if (resultStyles.iconUrl) {
            var iconStyle = {
                iconUrl: resultStyles.iconUrl
            };
            delete resultStyles.iconUrl;
            if (resultStyles.iconAnchor) {
                iconStyle.iconAnchor = resultStyles.iconAnchor;
                delete resultStyles.iconAnchor;
            }
            if (resultStyles.iconSize) {
                iconStyle.iconSize = resultStyles.iconSize;
                delete resultStyles.iconSize;
            }
            if (resultStyles.popupAnchor) {
                iconStyle.popupAnchor = resultStyles.popupAnchor;
                delete resultStyles.popupAnchor;
            }
            if (resultStyles.shadowSize) {
                iconStyle.shadowSize = resultStyles.shadowSize;
                delete resultStyles.shadowSize;
            }
            resultStyles.markerStyle = {
                iconStyle: iconStyle
            };
        }
        return resultStyles;
    },

    create: function (type, options) {
        this._clearCreate(null);
        if (type) {
            var map = this._map,
                drawOptions = this._chkDrawOptions(type, options),
                my = this;

            if (type === 'Rectangle') {
                map._initPathRoot();
                map.dragging.disable();
            }

            this._createKey = {
                type: type,
                eventName: type === 'Rectangle' ? (L.Browser.mobile ? 'touchstart' : 'mousedown') : 'click',
                fn: function (ev) {
                    my._createType = '';
                    var obj, key,
                        opt = {},
                        latlng = ev.latlng;

                    for (key in drawOptions) {
                        if (!(key in L.GmxDrawing.utils.defaultStyles)) {
                            opt[key] = drawOptions[key];
                        }
                    }
                    if (type === 'Point') {
                        var markerStyle = drawOptions.markerStyle || {},
                            markerOpt = {
                                draggable: true
                            };
                        if (ev && ev.originalEvent) {
                            markerOpt.ctrlKey = ev.originalEvent.ctrlKey;
                            markerOpt.shiftKey = ev.originalEvent.shiftKey;
                            markerOpt.altKey = ev.originalEvent.altKey;
                        }
                        if (markerStyle.iconStyle) {
                            markerOpt.icon = L.icon(markerStyle.iconStyle);
                        }
                        obj = my.add(L.marker(latlng, markerOpt), opt);
                    } else {
                        if (drawOptions.pointStyle) { opt.pointStyle = drawOptions.pointStyle; }
                        if (drawOptions.lineStyle) { opt.lineStyle = drawOptions.lineStyle; }
                        if (type === 'Rectangle') {
                            // if (L.Browser.mobile) {
                                // var downAttr = L.GmxDrawing.utils.getDownType.call(my, ev, my._map);
                                // latlng = downAttr.latlng;
                            // }
                            opt.mode = 'edit';
                            obj = my.add(
                                L.rectangle(L.latLngBounds(L.latLng(latlng.lat + rectDelta, latlng.lng - rectDelta), latlng))
                            , opt);
                            if (L.Browser.mobile) { obj._startTouchMove(ev, true); }
                            else { obj._pointDown(ev); }

                            obj.rings[0].ring._drawstop = true;
                        } else if (type === 'Polygon') {
                            opt.mode = 'add';
                            obj = my.add(L.polygon([latlng]), opt);
                            obj.setAddMode();
                        } else if (type === 'Polyline') {
                            opt.mode = 'add';
                            obj = my.add(L.polyline([latlng]), opt).setAddMode();
                        }
                    }
                    my._clearCreate();
                }
            };
            if (type === 'Rectangle' && L.Browser.mobile) {
                L.DomEvent.on(map._container, 'touchstart', this._createKey.fn, this);
            } else {
                map.on(this._createKey.eventName, this._createKey.fn, this);
            }
            this._createType = type;
            L.DomUtil.addClass(map._mapPane, 'leaflet-clickable');
            this.fire('drawstart', {mode: type});
        }
        this.options.type = type;
    },

    extendDefaultStyles: function (drawOptions) {
        var defaultStyles = L.GmxDrawing.utils.defaultStyles;
        drawOptions = drawOptions || {};
        if (drawOptions.iconUrl) {
            var iconStyle = defaultStyles.markerStyle.options.icon;
            iconStyle.iconUrl = drawOptions.iconUrl;
            delete drawOptions.iconUrl;
            if (drawOptions.iconAnchor) {
                iconStyle.iconAnchor = drawOptions.iconAnchor;
                delete drawOptions.iconAnchor;
            }
            if (drawOptions.iconSize) {
                iconStyle.iconSize = drawOptions.iconSize;
                delete drawOptions.iconSize;
            }
            if (drawOptions.popupAnchor) {
                iconStyle.popupAnchor = drawOptions.popupAnchor;
                delete drawOptions.popupAnchor;
            }
            if (drawOptions.shadowSize) {
                iconStyle.shadowSize = drawOptions.shadowSize;
                delete drawOptions.shadowSize;
            }
        }
        if (drawOptions.lineStyle) {
            L.extend(defaultStyles.lineStyle, drawOptions.lineStyle);
            delete drawOptions.lineStyle;
        }
        if (drawOptions.pointStyle) {
            L.extend(defaultStyles.pointStyle, drawOptions.pointStyle);
            delete drawOptions.pointStyle;
        }
        if (drawOptions.holeStyle) {
            L.extend(defaultStyles.holeStyle, drawOptions.holeStyle);
            delete drawOptions.holeStyle;
        }
        L.extend(defaultStyles, drawOptions);
        return this;
    },

    getFeatures: function () {
        var out = [];
        for (var i = 0, len = this.items.length; i < len; i++) {
            out.push(this.items[i]);
        }
        return out;
    },

    loadState: function (data) {
        //if (data.version !== stateVersion) return;

        var _this = this,
            featureCollection = data.featureCollection;
        L.geoJson(featureCollection, {
            onEachFeature: function (feature, layer) {
                var options = feature.properties,
                    popupOpened = options.popupOpened;
                if (options.type === 'Rectangle') {
                    layer = L.rectangle(layer.getBounds());
                } else if (options.type === 'Point') {
                    options = options.options;
                    var icon = options.icon;
                    if (icon) {
                        delete options.icon;
                        if (icon.iconUrl) { options.icon = L.icon(icon); }
                    }
                    layer = L.marker(layer.getLatLng(), options);
                }
                if (layer.setStyle && options && options.lineStyle) {
                    layer.setStyle(options.lineStyle);
                }
                _this.add(layer, options);
                if (popupOpened) {
                    layer.openPopup();
                }
            }
        });
    },

    saveState: function () {
        var featureGroup = L.featureGroup();
        var points = [];
        for (var i = 0, len = this.items.length; i < len; i++) {
            var it = this.items[i];
            if (it.options.type === 'Point') {
                var geojson = it.toGeoJSON();
                geojson.properties = L.GmxDrawing.utils.getNotDefaults(it.options, L.GmxDrawing.utils.defaultStyles.markerStyle);
                if (!it._map) { geojson.properties.map = false; }
                else if (it._map.hasLayer(it.getPopup())) {
                    geojson.properties.popupOpened = true;
                }
                var res = L.GmxDrawing.utils.getNotDefaults(it._obj.options, L.GmxDrawing.utils.defaultStyles.markerStyle.options);
                if (Object.keys(res).length) { geojson.properties.options = res; }
                res = L.GmxDrawing.utils.getNotDefaults(it._obj.options.icon.options, L.GmxDrawing.utils.defaultStyles.markerStyle.options.icon);
                if (Object.keys(res).length) {
                    if (!geojson.properties.options) { geojson.properties.options = {}; }
                    geojson.properties.options.icon = res;
                }
                points.push(geojson);
            } else {
                featureGroup.addLayer(it);
            }
        }
        var featureCollection = featureGroup.toGeoJSON();
        featureCollection.features = featureCollection.features.concat(points);
        return {
            version: stateVersion,
            featureCollection: featureCollection
        };
    },

    _addItem: function (item) {
        var addFlag = true;
        for (var i = 0, len = this.items.length; i < len; i++) {
            var it = this.items[i];
            if (it === item) {
                addFlag = false;
                break;
            }
        }
        if (addFlag) { this.items.push(item); }
        this.fire('add', {mode: item.mode, object: item});
    },

    _removeItem: function (obj, remove) {
        for (var i = 0, len = this.items.length; i < len; i++) {
            var item = this.items[i];
            if (item === obj) {
                if (remove) {
                    this.items.splice(i, 1);
                    var ev = {type: item.options.type, mode: item.mode, object: item};
                    this.fire('remove', ev);
                    item.fire('remove', ev);
                }
                return item;
            }
        }
        return null;
    },

    clear: function () {
        for (var i = 0, len = this.items.length; i < len; i++) {
            var item = this.items[i];
            if (item && item._map) {
                item._map.removeLayer(item);
            }
            var ev = {type: item.options.type, mode: item.mode, object: item};
            this.fire('remove', ev);
            item.fire('remove', ev);
        }
        this.items = [];
        return this;
    },

    remove: function (obj) {
        var item = this._removeItem(obj, true);
        if (item && item._map) {
            item._map.removeLayer(item);
        }
        return item;
    }
});

L.Map.addInitHook(function () {
    this.gmxDrawing = new L.GmxDrawing(this);
});
})();


L.GmxDrawing.Feature = L.LayerGroup.extend({
    options: {
        mode: '' // add, edit
    },
    includes: [L.Mixin.Events],

    simplify: function () {
        var i, j, len, len1, hole;
        for (i = 0, len = this.rings.length; i < len; i++) {
            var it = this.rings[i],
                ring = it.ring;
            ring.setLatLngs(ring.points.getPathLatLngs());
            for (j = 0, len1 = it.holes.length; j < len1; j++) {
                hole = it.holes[j];
                hole.setLatLngs(hole.points.getPathLatLngs());
            }
        }
        return this;
    },

    bringToFront: function () {
        return this.invoke('bringToFront');
    },

    bringToBack: function () {
        return this.invoke('bringToBack');
    },

    onAdd: function (map) {
        L.LayerGroup.prototype.onAdd.call(this, map);
        this._parent._addItem(this);
        if (this.options.type === 'Point') {
            map.addLayer(this._obj);
            var _this = this;
            setTimeout(function () {
                _this._fireEvent('drawstop', _this._obj.options);
            }, 0);
        }
        this._fireEvent('addtomap');
    },

    onRemove: function (map) {
        if ('hideTooltip' in this) { this.hideTooltip(); }
        L.LayerGroup.prototype.onRemove.call(this, map);

        if (this.options.type === 'Point') {
            map.removeLayer(this._obj);
        }
        this._fireEvent('removefrommap');
    },

    remove: function (ring) {
        if (ring) {
            var i, j, len, len1, hole;
            for (i = 0, len = this.rings.length; i < len; i++) {
                if (ring.options.hole) {
                    for (j = 0, len1 = this.rings[i].holes.length; j < len1; j++) {
                        hole = this.rings[i].holes[j];
                        if (ring === hole) {
                            this.rings[i].holes.splice(j, 1);
                            if (hole._map) {
                                hole._map.removeLayer(hole);
                            }
                            break;
                        }
                    }
                    if (!ring._map) {
                        break;
                    }
                } else if (ring === this.rings[i].ring) {
                    for (j = 0, len1 = this.rings[i].holes.length; j < len1; j++) {
                        hole = this.rings[i].holes[j];
                        if (hole._map) {
                            hole._map.removeLayer(hole);
                        }
                    }
                    this.rings.splice(i, 1);
                    if (ring._map) {
                        ring._map.removeLayer(ring);
                    }
                    break;
                }
            }
        } else {
            this.rings = [];
        }
        if (this.rings.length < 1) {
            if (this._originalStyle) {
                this._obj.setStyle(this._originalStyle);
            }
            this._parent.remove(this);
        }
        return this;
    },

    _fireEvent: function (name) {
        //console.log('_fireEvent', name);
        if (name === 'removefrommap' && this.rings.length > 1) {
            return;
        }
        var event = {mode: this.mode || '', object: this};
        this.fire(name, event);
        this._parent.fire(name, event);
        if (name === 'drawstop' && this._map) {
            L.DomUtil.removeClass(this._map._mapPane, 'leaflet-clickable');
        }
    },

    getStyle: function () {
        var resultStyles = L.extend({}, this._drawOptions);
        delete resultStyles.holeStyle;
        if (resultStyles.type === 'Point') {
            L.extend(resultStyles, resultStyles.markerStyle.iconStyle);
            delete resultStyles.markerStyle;
        }
        return resultStyles;
    },

    setOptions: function (options) {
        if (options.lineStyle) {
            this._setStyleOptions(options.lineStyle, 'lines');
        }
        if (options.pointStyle) {
            this._setStyleOptions(options.pointStyle, 'points');
        }
        if ('editable' in options) {
            if (options.editable) { this.enableEdit(); }
            else { this.disableEdit(); }
        }
        L.setOptions(this, options);

        this._fireEvent('optionschange');
        return this;
    },

    _setStyleOptions: function (options, type) {
        for (var i = 0, len = this.rings.length; i < len; i++) {
            var it = this.rings[i].ring[type];
            it.setStyle(options);
            it.redraw();
            for (var j = 0, len1 = this.rings[i].holes.length; j < len1; j++) {
                it = this.rings[i].holes[j][type];
                it.setStyle(options);
                it.redraw();
            }
        }
        this._fireEvent('stylechange');
    },

    _setLinesStyle: function (options) {
        this._setStyleOptions(options, 'lines');
    },

    _setPointsStyle: function (options) {
        this._setStyleOptions(options, 'points');
    },

    getOptions: function () {
        var options = this.options,
            data = L.extend({}, options);

        data.lineStyle = options.lineStyle;
        data.pointStyle = options.pointStyle;

        var res = L.GmxDrawing.utils.getNotDefaults(data, L.GmxDrawing.utils.defaultStyles);
        if (!Object.keys(res.lineStyle).length) { delete res.lineStyle; }
        if (!Object.keys(res.pointStyle).length) { delete res.pointStyle; }
        if (!this._map) { res.map = false; }

        if (options.type === 'Point') {
            var opt = L.GmxDrawing.utils.getNotDefaults(this._obj.options, L.GmxDrawing.utils.defaultStyles.markerStyle.options);
            if (Object.keys(opt).length) { res.options = opt; }
            opt = L.GmxDrawing.utils.getNotDefaults(this._obj.options.icon.options, L.GmxDrawing.utils.defaultStyles.markerStyle.options.icon);
            if (Object.keys(opt).length) {
                res.options.icon = opt;
            }
        }

        return res;
    },

    _latLngsToCoords: function (latlngs, closed) {
        var coords = L.GeoJSON.latLngsToCoords(latlngs);
        if (closed) {
            var lastCoord = coords[coords.length - 1];
            if (lastCoord[0] !== coords[0][0] || lastCoord[1] !== coords[0][1]) {
                coords.push(coords[0]);
            }
        }
        return coords;
    },

    _latlngsAddShift: function (latlngs, shiftPixel) {
        var arr = [];
        for (var i = 0, len = latlngs.length; i < len; i++) {
            arr.push(L.GmxDrawing.utils.getShiftLatlng(latlngs[i], this._map, shiftPixel));
        }
        return arr;
    },

    getPixelOffset: function () {
        var p = this.shiftPixel;
        if (!p && this._map) {
            var mInPixel = 256 / L.gmxUtil.tileSizes[this._map._zoom];
            p = this.shiftPixel = new L.Point(Math.floor(mInPixel * this._dx), -Math.floor(mInPixel * this._dy));
        }
        return p || new L.Point(0, 0);
    },

    setOffsetToGeometry: function (dx, dy) {
        var i, len, j, len1, ring, latlngs,
            mInPixel = 256 / L.gmxUtil.tileSizes[this._map._zoom],
            shiftPixel = new L.Point(mInPixel * (this._dx || dx || 0), -mInPixel * (this._dy || dy || 0));

        for (i = 0, len = this.rings.length; i < len; i++) {
            var it = this.rings[i];
            ring = it.ring;
            latlngs = ring.points.getLatLngs();
            ring.setLatLngs(this._latlngsAddShift(latlngs, shiftPixel));

            if (it.holes && it.holes.length) {
                for (j = 0, len1 = it.holes.length; j < len1; j++) {
                    ring = it.holes[j].ring;
                    latlngs = ring.points.getLatLngs();
                    ring.setLatLngs(this._latlngsAddShift(latlngs, shiftPixel));
                }
            }
        }
        this.setPositionOffset();
        return this;
    },

    setPositionOffset: function (mercX, mercY) {
        this._dx = mercX || 0;
        this._dy = mercY || 0;
        if (this._map) {
            this.shiftPixel = null;
            var p = this.getPixelOffset();
            for (var i = 0, len = this.rings.length; i < len; i++) {
                this.rings[i].ring.setPositionOffset(p);
                for (var j = 0, len1 = this.rings[i].holes.length; j < len1; j++) {
                    this.rings[i].holes[j].setPositionOffset(p);
                }
            }
        }
    },

    _getCoords: function (withoutShift) {
        var type = this.options.type,
            closed = (type === 'Polygon' || type === 'Rectangle' || type === 'MultiPolygon'),
            shiftPixel = withoutShift ? null : this.shiftPixel,
            coords = [];
        for (var i = 0, len = this.rings.length; i < len; i++) {
            var it = this.rings[i],
                arr = this._latLngsToCoords(it.ring.points.getLatLngs(), closed, shiftPixel);

            if (closed) { arr = [arr]; }
            if (it.holes && it.holes.length) {
                for (var j = 0, len1 = it.holes.length; j < len1; j++) {
                    arr.push(this._latLngsToCoords(it.holes[j].points.getLatLngs(), closed, shiftPixel));
                }
            }
            coords.push(arr);
        }
        if (type === 'Polyline' || (closed && type !== 'MultiPolygon')) { coords = coords[0]; }
        return coords;
    },

    toGeoJSON: function () {
        return this._toGeoJSON(true);
    },

    _toGeoJSON: function (withoutShift) {
        var type = this.options.type,
            properties = this.getOptions(),
            coords;

        delete properties.mode;

        if (!this.options.editable || type === 'Point') {
            var obj = this._obj;
            if (obj instanceof L.GeoJSON) {
                obj = L.GmxDrawing.utils._getLastObject(obj).getLayers()[0];
            }
            var geojson = obj.toGeoJSON();
            geojson.properties = properties;
            return geojson;
        } else if (this.rings) {
            coords = this._getCoords(withoutShift);
            if (type === 'Rectangle') { type = 'Polygon'; }
            else if (type === 'Polyline') { type = 'LineString'; }
            else if (type === 'MultiPolyline') { type = 'MultiLineString'; }
        }

        return L.GeoJSON.getFeature({
            feature: {
                type: 'Feature',
                properties: properties
            }
        }, {
            type: type,
            coordinates: coords
        });
    },

    getType: function () {
        return this.options.type;
    },

    hideFill: function () {
        if (this._fill._map) {
             this._map.removeLayer(this._fill);
        }
    },

    showFill: function () {
        var geoJSON = this.toGeoJSON(),
            obj = L.GeoJSON.geometryToLayer(geoJSON, null, null, {weight: 0});

        this._fill.clearLayers();
        if (obj instanceof L.LayerGroup) {
            obj.eachLayer(function (layer) {
                this._fill.addLayer(layer);
            }, this);
        } else {
            obj.setStyle({weight: 0, fill: true, fillColor: '#0033ff'});
            this._fill.addLayer(obj);
        }
        if (!this._fill._map) {
            this._map.addLayer(this._fill);
            this._fill.bringToBack();
        }
        return this;
    },

    getBounds: function() {
        var bounds = new L.LatLngBounds();
        if (this.options.type === 'Point') {
            var latLng = this._obj.getLatLng();
            bounds.extend(latLng);
        } else {
            bounds = this._getBounds();
        }
        return bounds;
    },

    _getBounds: function(item) {
        var layer = item || this,
            bounds = new L.LatLngBounds(),
            latLng;
        if (layer instanceof L.LayerGroup) {
            layer.eachLayer(function (it) {
                latLng = this._getBounds(it);
                bounds.extend(latLng);
            }, this);
            return bounds;
        } else if (layer instanceof L.Marker) {
            latLng = layer.getLatLng();
        } else {
            latLng = layer.getBounds();
        }
        bounds.extend(latLng);
        return bounds;
    },

    initialize: function (parent, obj, options) {
        options = options || {};

        this.contextmenu = new L.GmxDrawingContextMenu();
        options.mode = '';
        this._drawOptions = L.extend({}, options);
        var type = options.type;
        if (type === 'Point') {
            delete options.pointStyle;
            delete options.lineStyle;
        } else {
            delete options.iconUrl;
            delete options.iconAnchor;
            delete options.iconSize;
            delete options.popupAnchor;
            delete options.shadowSize;
            delete options.markerStyle;
        }
        delete options.holeStyle;

        L.setOptions(this, options);

        this._layers = {};
        this._obj = obj;
        this._parent = parent;
        this._dx = 0;
        this._dy = 0;

        this._initialize(parent, obj);
    },

    enableEdit: function() {
        this.options.mode = 'edit';
        var type = this.options.type;
        if (type !== 'Point') {
            for (var i = 0, len = this.rings.length; i < len; i++) {
                var it = this.rings[i];
                it.ring.options.editable = this.options.editable;
                it.ring.setEditMode();
                for (var j = 0, len1 = it.holes.length; j < len1; j++) {
                    var hole = it.holes[j];
                    hole.options.editable = this.options.editable;
                    hole.setEditMode();
                }
            }
            var geojson = L.geoJson(this.toGeoJSON());
            this.options.editable = true;
            this._initialize(this._parent, geojson);
        }
        return this;
    },

    disableEdit: function() {
        var type = this.options.type;
        if (type !== 'Point') {
			this._originalStyle = this.options.lineStyle;
            var geojson = L.geoJson(this.toGeoJSON().geometry, this._originalStyle).getLayers()[0];
            for (var i = 0, len = this.rings.length; i < len; i++) {
                var it = this.rings[i];
                it.ring.removeEditMode();
                it.ring.options.editable = false;
                for (var j = 0, len1 = it.holes.length; j < len1; j++) {
                    var hole = it.holes[j];
                    hole.removeEditMode();
                    hole.options.editable = false;
                }
            }
            this._obj = geojson;
            this.options.editable = false;
            this._initialize(this._parent, this._obj);
        }
        return this;
    },

    getArea: function () {
        var out = 0;
        if (L.gmxUtil.geoJSONGetArea) {
            out = L.gmxUtil.geoJSONGetArea(this.toGeoJSON());
        }
        return out;
    },

    getLength: function () {
        var out = 0;
        if (L.gmxUtil.geoJSONGetLength) {
            out = L.gmxUtil.geoJSONGetLength(this.toGeoJSON());
        }
        return out;
    },

    getSummary: function () {
        var str = '',
            mapOpt = this._map.options || {},
            type = this.options.type;

        if (type === 'Polyline' || type === 'MultiPolyline') {
            str = L.gmxUtil.prettifyDistance(this.getLength(), mapOpt.distanceUnit);
        } else if (type === 'Polygon' || type === 'MultiPolygon' || type === 'Rectangle') {
            str = L.gmxUtil.prettifyArea(this.getArea(), mapOpt.squareUnit);
        } else if (type === 'Point') {
            var latLng = this._obj.getLatLng();
            str = L.gmxUtil.formatCoordinates(latLng);
        }
        return str;
    },

    _initialize: function (parent, obj) {
        this.clearLayers();
        this.rings = [];
        this.mode = '';
        this._fill = L.featureGroup();

        if (this.options.editable) {
            var arr = obj.getLayers ? L.GmxDrawing.utils._getLastObject(obj).getLayers() : [obj];
            for (var i = 0, len = arr.length; i < len; i++) {
                var it = arr[i],
                    holes = [],
                    ring = new L.GmxDrawing.Ring(this, it._latlngs, {ring: true, editable: this.options.editable});

                this.addLayer(ring);
                if (it._holes) {
                    for (var j = 0, len1 = it._holes.length; j < len1; j++) {
                        var hole = new L.GmxDrawing.Ring(this, it._holes[j], {hole: true, editable: this.options.editable});
                        this.addLayer(hole);
                        holes.push(hole);
                    }
                }
                this.rings.push({ring: ring, holes: holes});
            }

            if (L.gmxUtil && L.gmxUtil.prettifyDistance && !this._showTooltip) {
                var _gtxt = L.GmxDrawing.utils.getLocale;
                var my = this;
                this._showTooltip = function (type, ev) {
                    var ring = ev.ring,
                        originalEvent = ev.originalEvent,
                        down = originalEvent.buttons || originalEvent.button;

                    if (ring && (ring.downObject || !down)) {
                        var mapOpt = my._map.options || {},
                            distanceUnit = mapOpt.distanceUnit,
                            squareUnit = mapOpt.squareUnit,
                            str = '';

                        if (type === 'Area') {
                            if (!L.gmxUtil.getArea) { return; }
                            if (ev.originalEvent.ctrlKey) {
                                str = _gtxt('Perimeter') + ': ' + L.gmxUtil.prettifyDistance(my.getLength(), distanceUnit);
                            } else {
                                str = _gtxt(type) + ': ' + L.gmxUtil.prettifyArea(my.getArea(), squareUnit);
                            }
                            my._parent.showTooltip(ev.layerPoint, str);
                        } else if (type === 'Length') {
                            var downAttr = L.GmxDrawing.utils.getDownType.call(my, ev, my._map, my),
                                length = ring.getLength(downAttr),
                                titleName = (downAttr.mode === 'edit' || downAttr.num > 1 ? downAttr.type : '') + type,
                                title = _gtxt(titleName);
                            str = (title === titleName ? _gtxt(type) : title) + ': ' + L.gmxUtil.prettifyDistance(length, distanceUnit);
                            my._parent.showTooltip(ev.layerPoint, str);
                        }
                        my._fireEvent('onMouseOver');
                    }
                };
                this.hideTooltip = function() {
                    this._parent.hideTooltip();
                    this._fireEvent('onMouseOut');
                };
                this.getTitle = _gtxt;
            }
        } else if (this.options.type === 'Point') {
            this._setMarker(obj);
        } else {
            this.addLayer(obj);
        }
    },

    _enableDrag: function () {
        this._parent._enableDrag();
    },

    _disableDrag: function () {
        this._parent._disableDrag();
    },

    _setMarker: function (marker) {
        var _this = this,
            _parent = this._parent;

        marker
            .bindPopup(null, {maxWidth: 1000, closeOnClick: _parent._map.options.maxPopupCount > 1 ? false : true})
            .on('dblclick', function() {
                this._map.removeLayer(this);
                _this.remove();
                //_parent.remove(this);
            })
            .on('dragstart', function() {
                _this._fireEvent('dragstart');
            })
            .on('drag', function() {
                _this._fireEvent('drag');
                _this._fireEvent('edit');
            })
            .on('dragend', function() {
                _this._fireEvent('dragend');
            })
            .on('popupopen', function(ev) {
                var popup = ev.popup;
                if (!popup._input) {
                    popup._input = L.DomUtil.create('textarea', 'leaflet-gmx-popup-textarea', popup._contentNode);
                    // popup._input.placeholder = _this.options.title || marker.options.title || '';
                    popup._input.value = _this.options.title || marker.options.title || '';
                    popup._contentNode.style.width = 'auto';
                }
                L.DomEvent.on(popup._input, 'keyup', function() {
                    var rows = this.value.split('\n'),
                        cols = this.cols || 0;

                    rows.forEach(function(str) {
                        if (str.length > cols) { cols = str.length; }
                    });
                    this.rows = rows.length;
                    if (cols) { this.cols = cols; }
                    popup.update();
                    _this.options.title = marker.options.title = this.value;
                    this.focus();
                }, popup._input);
                popup.update();
            });
        _parent._map.addLayer(marker);

        _this.openPopup = marker.openPopup = function () {
            if (marker._popup && marker._map && !marker._map.hasLayer(marker._popup)) {
                marker._popup.setLatLng(marker._latlng);
                var gmxDrawing = marker._map.gmxDrawing;
                if (gmxDrawing._drawMode) {
                    marker._map.fire(gmxDrawing._createType ? 'click' : 'mouseup', {latlng: marker._latlng, delta: 1});
                } else {
                    marker._popup.addTo(marker._map);
                    marker._popup._isOpen = true;
                }
            }
            return marker;
        };
    },

    setAddMode: function () {
        if (this.rings.length) {
            this.rings[0].ring.setAddMode();
        }
		return this;
    },

    _pointDown: function (ev) {
        if (this.rings.length) {
            this.rings[0].ring._pointDown(ev);
        }
    },

    getPopup: function() {
        if (this.options.type === 'Point') {
            return this._obj.getPopup();
        }
    }
});


L.GmxDrawing.Ring = L.LayerGroup.extend({
    options: {
        className: 'leaflet-drawing-ring',
        //noClip: true,
        //smoothFactor: 0,
        opacity: 1,
        shape: 'circle',
        fill: true,
        fillColor: '#ffffff',
        fillOpacity: 1,
        size: L.Browser.mobile ? 40 : 8,
        weight: 2
    },
    includes: [L.Mixin.Events],

    initialize: function (parent, coords, options) {
        options = options || {};

        this.contextmenu = new L.GmxDrawingContextMenu();
        options.mode = '';
        this._activeZIndex = options.activeZIndex || 7;
        this._notActiveZIndex = options.notActiveZIndex || 6;
        this.options = L.extend({}, parent.getStyle(), options);

        this._layers = {};
        this._coords = coords;
        this._legLength = [];
        this._parent = parent;

        this._initialize(parent, coords);
    },

    _initialize: function (parent, coords) {
        this.clearLayers();
        delete this.lines;
        delete this.fill;
        delete this.points;

        this.downObject = false;
        this.mode = '';
        this.lineType = this.options.type.indexOf('Polyline') !== -1;

        var pointStyle = this.options.pointStyle;
        var lineStyle = {opacity:1, weight:2, noClip: true, clickable: false, className: 'leaflet-drawing-lines'};
        if (!this.lineType) {
            lineStyle.fill = 'fill' in this.options ? this.options.fill : true;
        }
        if (this.options.lineStyle) {
            for (var key in this.options.lineStyle) {
                if (key !== 'fill' || !this.lineType) {
                    lineStyle[key] = this.options.lineStyle[key];
                }
            }
        }
        if (this.options.hole) {
            lineStyle = L.extend({}, lineStyle, L.GmxDrawing.utils.defaultStyles.holeStyle);
            pointStyle = L.extend({}, pointStyle, L.GmxDrawing.utils.defaultStyles.holeStyle);
        }

        var latlngs = coords,
            _this = this,
            mode = this.options.mode || (latlngs.length ? 'edit' : 'add');

        this.lines = new L.Polyline(latlngs, lineStyle);
        this.addLayer(this.lines);
        this.fill = new L.Polyline(latlngs, {
            className: 'leaflet-drawing-lines-fill',
            opacity: 0,
            fill: false,
            size: 10,
            weight: 10
        });

        this.addLayer(this.fill);
        if (!this.lineType && mode === 'edit') {
            this.lines.addLatLng(latlngs[0]);
            this.fill.addLatLng(latlngs[0]);
        }
        this.mode = mode;

        this.points = new L.GmxDrawing.PointMarkers(latlngs, pointStyle);
        this.points._parent = this;

        this.addLayer(this.points);
        this.points
            .on('mouseover mousemove', function (ev) {
                ev.ring = _this;
                if ('_showTooltip' in this) {
                    this._showTooltip(_this.lineType ? 'Length' : 'Area', ev);
                }
                if (ev.type === 'mouseover') {
                    _this._recheckContextItems('points', _this._map);
                }
            }, parent)
            .on('mouseout', function () {
                if ('hideTooltip' in this) { this.hideTooltip(); }
            }, parent);
        this.fill
            .on('mouseover mousemove', function (ev) {
                ev.ring = _this;
                if ('_showTooltip' in this) {
                    this._showTooltip('Length', ev);
                }
            }, parent)
            .on('mouseout', function () {
                if ('hideTooltip' in this) { this.hideTooltip(); }
            }, parent);

		if (this.points.bindContextMenu) {
			this.points.bindContextMenu({
				contextmenu: false,
				contextmenuInheritItems: false,
				contextmenuItems: []
			});
		}
    },

    _recheckContextItems: function (type, map) {
        var _this = this;
		this[type].options.contextmenuItems = map.gmxDrawing.contextmenu.getItems()[type]
			.concat(this._parent.contextmenu.getItems()[type])
			.concat(this.contextmenu.getItems()[type])
			.map(function(obj) {
				return {
					id: obj.text,
					text: L.GmxDrawing.utils.getLocale(obj.text),
					callback: obj.callback || function (ev) { _this._eventsCmd(obj, ev); }
				};
			});
    },

    _eventsCmd: function (obj, ev) {
		var ring = ev.relatedTarget._parent;
		var downAttr = L.GmxDrawing.utils.getDownType.call(ring, ev, ring._map, ring._parent);
		if (downAttr) {
			var type = obj.text;
			if (obj.callback) {
				obj.callback(downAttr);
			} else if (type === 'Remove point') {
				ring._removePoint(downAttr.num);
			} else if (type === 'Delete feature') {
                ring._parent.remove(ring);
			}
        }
    },

    getFeature: function () {
		return this._parent;
    },

    onAdd: function (map) {
        L.LayerGroup.prototype.onAdd.call(this, map);
        this.setEditMode();
    },

    onRemove: function (map) {
        if (this.points) {
            this._pointUp();
            this.removeAddMode();
            this.removeEditMode();

            if ('hideTooltip' in this._parent) { this._parent.hideTooltip(); }
        }
        L.LayerGroup.prototype.onRemove.call(this, map);
        if (this.options.type === 'Point') {
            map.removeLayer(this._obj);
        }
        this._fireEvent('removefrommap');
    },

    getLength: function (downAttr) {
        var length = 0,
            latlngs = this.points._latlngs,
            len = latlngs.length;

        if (len) {
            var beg = 1,
                prev = latlngs[0];
            if (downAttr) {
                if (downAttr.type === 'node') {
                    len = downAttr.num + 1;
                } else {
                    beg = downAttr.num;
                    if (beg === len) {
                        prev = latlngs[beg - 1];
                        beg = 0;
                    } else {
                        prev = latlngs[beg - 1];
                    }
                    len = beg + 1;
                }
            }
            for (var i = beg; i < len; i++) {
                var leg = this._legLength[i] || null;
                if (leg === null) {
                    leg = L.gmxUtil.distVincenty(prev.lng, prev.lat, latlngs[i].lng, latlngs[i].lat);
                    this._legLength[i] = leg;
                }
                prev = latlngs[i];
                length += leg;
            }
        }
        return length;
    },

    _setPoint: function (latlng, nm, type) {
        if (!this.points) { return; }
        var latlngs = this.points._latlngs;
        if (this.options.type === 'Rectangle') {
            if (type === 'edge') {
                nm--;
                if (nm === 0) { latlngs[0].lng = latlngs[1].lng = latlng.lng; }
                else if (nm === 1) { latlngs[1].lat = latlngs[2].lat = latlng.lat; }
                else if (nm === 2) { latlngs[2].lng = latlngs[3].lng = latlng.lng; }
                else if (nm === 3) { latlngs[0].lat = latlngs[3].lat = latlng.lat; }
            } else {
                latlngs[nm] = latlng;
                if (nm === 0) { latlngs[3].lat = latlng.lat; latlngs[1].lng = latlng.lng; }
                else if (nm === 1) { latlngs[2].lat = latlng.lat; latlngs[0].lng = latlng.lng; }
                else if (nm === 2) { latlngs[1].lat = latlng.lat; latlngs[3].lng = latlng.lng; }
                else if (nm === 3) { latlngs[0].lat = latlng.lat; latlngs[2].lng = latlng.lng; }
            }
            this._legLength = [];
        } else {
            latlngs[nm] = latlng;
            this._legLength[nm] = null;
            this._legLength[nm + 1] = null;
        }
        this.setLatLngs(latlngs);
    },

    addLatLng: function (point, delta) {
        this._legLength = [];
        if (this.points) {
            var points = this.points._latlngs,
                len = points.length,
                lastPoint = points[len - 2];
            if (!lastPoint || !lastPoint.equals(point)) {
                if (delta) { len -= delta; }    // reset existing point
                this._setPoint(point, len, 'node');
            }
        } else if ('addLatLng' in this._obj) {
            this._obj.addLatLng(point);
        }
    },

    setPositionOffset: function (p) {
        L.DomUtil.setPosition(this.points._container, p);
        L.DomUtil.setPosition(this.fill._container, p);
        L.DomUtil.setPosition(this.lines._container, p);
    },

    setLatLngs: function (latlngs) {
        if (this.points) {
            var points = this.points;
            this.fill.setLatLngs(latlngs);
            this.lines.setLatLngs(latlngs);
            if (!this.lineType && this.mode === 'edit' && latlngs.length > 2) {
                this.lines.addLatLng(latlngs[0]);
                this.fill.addLatLng(latlngs[0]);
            }
            points.setLatLngs(latlngs);
        } else if ('setLatLngs' in this._obj) {
            this._obj.setLatLngs(latlngs);
        }
        this._fireEvent('edit');
    },

    // edit mode
    _pointDown: function (ev) {
        if (L.Browser.ie || (L.gmxUtil && L.gmxUtil.gtIE11)) {
            this._map.dragging._draggable._onUp(); // error in IE
        }
        if (ev.originalEvent) {
            var originalEvent = ev.originalEvent;
            if (originalEvent.ctrlKey) {
                this._onDragStart(ev);
                return;
            } else if (originalEvent.which !== 1 && originalEvent.button !== 1) {
                return;
            }
        }
        this._parent._disableDrag();
        var downAttr = L.GmxDrawing.utils.getDownType.call(this, ev, this._map, this._parent),
            type = downAttr.type,
            opt = this.options;

        this._lastDownTime = Date.now() + 100;
        this.down = downAttr;
        if (type === 'edge' && opt.type !== 'Rectangle') {
            if (opt.disableAddPoints) { return; }
            this._legLength = [];
            var num = downAttr.num,
                points = this.points._latlngs;
            points.splice(num, 0, points[num]);
            this._setPoint(ev.latlng, num, type);
        }
        this.downObject = true;
        this._map
            .on('mousemove', this._pointMove, this)
            .on('mouseup', this._mouseupPoint, this);
    },

    _mouseupPoint: function (ev) {
		this._fireEvent('editstop');
		this._pointUp(ev);
    },

    _pointMove: function (ev) {
        if (this.down && this._lastDownTime < Date.now()) {
            if (!this.lineType) {
                this._parent.showFill();
            }
            this._clearLineAddPoint();
            this._moved = true;
            this._setPoint(ev.latlng, this.down.num, this.down.type);
            if ('_showTooltip' in this._parent) {
                this._parent._showTooltip(this.lineType ? 'Length' : 'Area', ev);
            }
        }
    },

    _pointUp: function (ev) {
        this.downObject = false;
        this._parent._enableDrag();
        if (!this.points) { return; }
        if (this._map) {
            this._map
                .off('mousemove', this._pointMove, this)
                .off('mouseup', this._mouseupPoint, this);

            var target = ev && ev.originalEvent ? ev.originalEvent.target : null;
            if (target && target._leaflet_pos && /leaflet-marker-icon/.test(target.className)) {
                var latlng = L.GmxDrawing.utils.getMarkerByPos(target._leaflet_pos, this._map.gmxDrawing.getFeatures());
                this._setPoint(latlng, this.down.num, this.down.type);
            }
            this._map._skipClick = true;    // for EventsManager
        }
        if (this._drawstop) {
            this._fireEvent('drawstop');
        }
        this._drawstop = false;
        this.down = null;
        var lineStyle = this.options.lineStyle || {};
        if (!lineStyle.fill && !this.lineType) {
            this._parent.hideFill();
        }
    },
    _lastPointClickTime: 0,  // Hack for emulate dblclick on Point

    _removePoint: function (num) {
        var points = this.points._latlngs;
        if (points.length > num) {
            this._legLength = [];
            points.splice(num, 1);
            if (this.options.type === 'Rectangle'
                || points.length < 2
                || (points.length < 3 && !this.lineType)
                ) {
                this._parent.remove(this);
            } else {
                this._setPoint(points[0], 0);
            }
        }
    },

    _clearLineAddPoint: function () {
        if (this._lineAddPointID) { clearTimeout(this._lineAddPointID); }
        this._lineAddPointID = null;
    },

    _pointDblClick: function (ev) {
        this._clearLineAddPoint();
        if (!this._lastAddTime || Date.now() > this._lastAddTime) {
            var downAttr = L.GmxDrawing.utils.getDownType.call(this, ev, this._map, this._parent);
            this._removePoint(downAttr.num);
        }
    },

    _pointClick: function (ev) {
        if (ev.originalEvent && ev.originalEvent.ctrlKey) { return; }
        var clickTime = Date.now(),
            prevClickTime = this._lastPointClickTime;

        this._lastPointClickTime = clickTime + 300;
        if (this._moved || clickTime < prevClickTime) { this._moved = false; return; }

        var downAttr = L.GmxDrawing.utils.getDownType.call(this, ev, this._map, this._parent),
            mode = this.mode;
        if (downAttr.type === 'node') {
            var num = downAttr.num;
            if (downAttr.end) {  // this is click on first or last Point
                if (mode === 'add') {
                    this._pointUp();
                    this.setEditMode();
                    if (this.lineType && num === 0) {
                        this._parent.options.type = this.options.type = 'Polygon';
                        this.lineType = false;
                        this._removePoint(this.points._latlngs.length - 1);
                    }
                    this._fireEvent('drawstop');
                    this._removePoint(num);
                } else if (this.lineType) {
                    var _this = this,
                        setLineAddPoint = function () {
                            _this._clearLineAddPoint();
                            if (num === 0) { _this.points._latlngs.reverse(); }
                            _this.points.addLatLng(downAttr.latlng);
                            _this.setAddMode();
                            _this._fireEvent('drawstop');
                        };
                    this._lineAddPointID = setTimeout(setLineAddPoint, 250);
                }
            } else if (mode === 'add') { // this is add pont
                this.addLatLng(ev.latlng);
            }
        }
    },

    _onDragEnd: function () {
        this._map
            .off('mouseup', this._onDragEnd, this)
            .off('mousemove', this._onDrag, this);

		this._parent._enableDrag();
        this._fireEvent('dragend');
    },

    _onDragStart: function (ev) {
        this._dragstartPoint = ev.latlng;
        this._map
            .on('mouseup', this._onDragEnd, this)
            .on('mousemove', this._onDrag, this);
        this._fireEvent('dragstart');
    },

    _onDrag: function (ev) {
        var lat = this._dragstartPoint.lat - ev.latlng.lat,
            lng = this._dragstartPoint.lng - ev.latlng.lng,
            points = this.points._latlngs;

        points.forEach(function (item) {
            item.lat -= lat;
            item.lng -= lng;
        });
        this._dragstartPoint = ev.latlng;

        this._legLength = [];
        this.setLatLngs(points);
        this._fireEvent('drag');
    },

    _fireEvent: function (name) {
        this._parent._fireEvent(name);
    },

    _startTouchMove: function (ev, drawstop) {
        var downAttr = L.GmxDrawing.utils.getDownType.call(this, ev, this._map, this._parent);
        if (downAttr.type === 'node') {
            this._parent._disableDrag();
            this.down = downAttr;
            //var num = downAttr.num;
            var my = this;
            var _touchmove = function (ev) {
                downAttr = L.GmxDrawing.utils.getDownType.call(my, ev, my._map, this._parent);
                    if (ev.touches.length === 1) { // Only deal with one finger
                        my._pointMove(downAttr);
                  }
            };
            var _touchend = function () {
                L.DomEvent
                    .off(my._map._container, 'touchmove', _touchmove, my)
                    .off(my._map._container, 'touchend', _touchend, my);
                my._parent._enableDrag();
                if (drawstop) {
                    my._parent.fire('drawstop', {mode: my.options.type, object: my});
                }
            };
            L.DomEvent
                .on(my._map._container, 'touchmove', _touchmove, my)
                .on(my._map._container, 'touchend', _touchend, my);
        }
    },

    _editHandlers: function (flag) {
        //if (!this.points) { return; }
        var stop = L.DomEvent.stopPropagation;
        //var prevent = L.DomEvent.preventDefault;
        if (this.touchstart) {
            L.DomEvent.off(this.points._container, 'touchstart', this.touchstart, this);
        }
        if (this.touchstartFill) {
            L.DomEvent.off(this.fill._container, 'touchstart', this.touchstartFill, this);
        }
        this.touchstart = null;
        this.touchstartFill = null;
        if (flag) {
            this.points
                .on('dblclick click', stop, this)
                .on('dblclick', this._pointDblClick, this)
                .on('click', this._pointClick, this);
            if (L.Browser.mobile) {
                if (this._EditOpacity) {
                    this._parent._setPointsStyle({fillOpacity: this._EditOpacity});
                }
                var my = this;
                this.touchstart = function (ev) {
                    my._startTouchMove(ev);
                };
                L.DomEvent.on(this.points._container, 'touchstart', this.touchstart, this);
                this.touchstartFill = function (ev) {
                    var downAttr = L.GmxDrawing.utils.getDownType.call(my, ev, my._map, this._parent);
                    if (downAttr.type === 'edge' && my.options.type !== 'Rectangle') {
                        var points = my.points._latlngs;
                        points.splice(downAttr.num, 0, points[downAttr.num]);
                        my._legLength = [];
                        my._setPoint(downAttr.latlng, downAttr.num, downAttr.type);
                    }
                };
                L.DomEvent.on(this.fill._container, 'touchstart', this.touchstartFill, this);
            } else {
                this.points
                    .on('mousemove', stop)
                    .on('mousedown', this._pointDown, this);
                this.fill
                    .on('dblclick click', stop, this)
                    .on('mousedown', this._pointDown, this);
                this._fireEvent('editmode');
            }
        } else {
            this._pointUp();
            this.points
                .off('dblclick click', stop, this)
                .off('dblclick', this._pointDblClick, this)
                .off('click', this._pointClick, this);
            if (!L.Browser.mobile) {
                this.points
                    .off('mousemove', stop)
                    .off('mousedown', this._pointDown, this);
                this.fill
                    .off('dblclick click', stop, this)
                    .off('mousedown', this._pointDown, this);
            }
        }
    },

    _createHandlers: function (flag) {
        if (!this.points) { return; }
        var stop = L.DomEvent.stopPropagation;
        if (flag) {
			if (this._map.contextmenu) {
				this._map.contextmenu.disable();
			}

            this._parent._enableDrag();
            this._map
                .on('dblclick', stop)
                .on('mousedown', this._mouseDown, this)
                .on('mouseup', this._mouseUp, this)
                .on('mousemove', this._moseMove, this);
            this.points
                .on('click', this._pointClick, this);
            this._fireEvent('addmode');
            if (!this.lineType) { this.lines.setStyle({fill: true}); }
        } else {
            if (this._map) {
                this._map
                    .off('dblclick', stop)
                    .off('mouseup', this._mouseUp, this)
                    .off('mousemove', this._moseMove, this);
                this.points
                    .off('click', this._pointClick, this);
            }
            var lineStyle = this.options.lineStyle || {};
            if (!this.lineType && !lineStyle.fill) {
                this.lines.setStyle({fill: false});
            }
        }
    },

    setEditMode: function () {
        if (this.options.editable) {
            this._editHandlers(false);
            this._createHandlers(false);
            this._editHandlers(true);
            this.mode = 'edit';
        }
        return this;
    },

    setAddMode: function () {
        if (this.options.editable) {
            this._editHandlers(false);
            this._createHandlers(false);
            this._createHandlers(true);
            this.mode = 'add';
        }
        return this;
    },

    removeAddMode: function () {
        this._createHandlers(false);
        this.mode = '';
    },

    removeEditMode: function () {
        this._editHandlers(false);
        this.mode = '';
    },

    // add mode
    _moseMove: function (ev) {
        if (this.points) {
            var points = this.points._latlngs;
            if (points.length === 1) { this._setPoint(ev.latlng, 1); }

            this._setPoint(ev.latlng, points.length - 1);
        }
    },

    _mouseDown: function () {
        this._lastMouseDownTime = Date.now() + 200;
    },

    _mouseUp: function (ev) {
        var timeStamp = Date.now();
        if (ev.delta || timeStamp < this._lastMouseDownTime) {
            this._lastAddTime = timeStamp + 1000;

			if (ev.originalEvent && ev.originalEvent.which === 3
				&& this.points && this.points._latlngs && this.points._latlngs.length) {	// for click right button

				this.setEditMode();
				this._removePoint(this.points._latlngs.length - 1);
				this._pointUp();
				this._fireEvent('drawstop');
				if (this._map && this._map.contextmenu) {
					setTimeout(this._map.contextmenu.enable.bind(this._map.contextmenu), 250);
				}
			} else {
				var latlng = ev._latlng || ev.latlng;
				if (ev.delta) { this.addLatLng(latlng, ev.delta); }    // for click on marker
				this.addLatLng(latlng);
			}
			this._parent._parent._clearCreate();
        }
    }
});


L.GmxDrawing.PointMarkers = L.Polygon.extend({
    options: {
        className: 'leaflet-drawing-points',
        //noClip: true,
        smoothFactor: 0,
        opacity: 1,
        shape: 'circle',
        fill: true,
        fillColor: '#ffffff',
        fillOpacity: 1,
        size: L.Browser.mobile ? 40 : 8,
        weight: 2
    },

    getRing: function () {
		return this._parent;
    },

    getFeature: function () {
		return this.getRing()._parent;
    },

    getPathLatLngs: function () {
        var out = [],
            size = this.options.size,
            points = this._parts[0],
            prev;

        for (var i = 0, len = points.length, p; i < len; i++) {
            p = points[i];
            if (i === 0 || Math.abs(prev.x - p.x) > size || Math.abs(prev.y - p.y) > size) {
                out.push(this._latlngs[i]);
                prev = p;
            }
        }
        return out;
    },

    _getPathPartStr: function (points) {
        var round = L.Path.VML,
            size = this.options.size / 2,
            skipLastPoint = this._parent.mode === 'add' && !L.Browser.mobile ? 1 : 0,
            radius = (this.options.shape === 'circle' ? true : false),
            prev;

        for (var j = 0, len2 = points.length - skipLastPoint, str = '', p; j < len2; j++) {
            p = points[j];
            if (round) { p._round(); }
            if (j === 0 || Math.abs(prev.x - p.x) > this.options.size || Math.abs(prev.y - p.y) > this.options.size) {
                if (radius) {
                    str += 'M' + p.x + ',' + (p.y - size) +
                           ' A' + size + ',' + size + ',0,1,1,' +
                           (p.x - 0.1) + ',' + (p.y - size) + ' ';
                } else {
                    var px = p.x, px1 = px - size, px2 = px + size,
                        py = p.y, py1 = py - size, py2 = py + size;
                    str += 'M' + px1 + ' ' + py1 + 'L' + px2 + ' ' + py1 + 'L' + px2 + ' ' + py2 + 'L' + px1 + ' ' + py2 + 'L' + px1 + ' ' + py1;
                }
                prev = p;
            }
        }
        return str;
    },

    _onMouseClick: function (e) {
        //if (this._map.dragging && this._map.dragging.moved()) { return; }

        this._fireMouseEvent(e);
    },

    _isPathChange: function () {
        this.projectLatlngs();
        var pathStr = this.getPathString();
        if (pathStr !== this._pathStr) {
            this._pathStr = pathStr;
            return true;
        }
        return false;
    },

    _updatePath: function () {
        if (!this._map) { return; }
        this._clipPoints();

        if (this._isPathChange()) {
            if (this._path.getAttribute('fill-rule') !== 'inherit') {
                this._path.setAttribute('fill-rule', 'inherit');
            }
            this._path.setAttribute('d', this._pathStr || 'M0 0');
            // L.Path.prototype._updatePath.call(this);
        }
    }
});


(function () {
	function GmxDrawingContextMenu(options) {
		this.options = options || {points: [], lines: []};
	}

	GmxDrawingContextMenu.prototype = {
		insertItem: function (obj, index, type) {
			var optKey = type || 'points';
			if (index === undefined) { index = this.options[optKey].length; }
			this.options[optKey].splice(index, 0, obj);
			return this;
		},

		removeItem: function (obj, type) {
			var optKey = type || 'points';
			for (var i = 0, len = this.options[optKey].length; i < len; i++) {
				if (this.options[optKey][i].callback === obj.callback) {
					this.options[optKey].splice(i, 1);
					break;
				}
			}
			return this;
		},

		removeAllItems: function (type) {
			if (!type) {
				this.options = {points: [], lines: []};
			} else if (type === 'lines') {
				this.options.lines = [];
			} else {
				this.options.points = [];
			}
			return this;
		},

		getItems: function () {
			return this.options;
		}
	};
	L.GmxDrawingContextMenu = GmxDrawingContextMenu;
})();


L.GmxDrawing.utils = {
    defaultStyles: {
        mode: '',
        map: true,
        editable: true,
        holeStyle: {
            opacity: 0.5,
            color: '#003311'
        },
        lineStyle: {
            opacity:1,
            weight:2,
            noClip: true,
            clickable: false,
            className: 'leaflet-drawing-lines',
            color: '#0033ff',
            dashArray: null,
            lineCap: null,
            lineJoin: null,
            fill: false,
            fillColor: null,
            fillOpacity: 0.2,
            smoothFactor: 1,
            stroke: true
        },
        pointStyle: {
            className: 'leaflet-drawing-points',
            noClip: true,
            smoothFactor: 0,
            opacity: 1,
            shape: 'circle',
            fill: true,
            fillColor: '#ffffff',
            fillOpacity: 1,
            size: L.Browser.mobile ? 40 : 8,
            weight: 2,
            clickable: true,
            color: '#0033ff',
            dashArray: null,
            lineCap: null,
            lineJoin: null,
            stroke: true
        },
        markerStyle: {
            mode: '',
            editable: false,
            title: 'Text example',
            options: {
                alt: '',
                //title: '',
                clickable: true,
                draggable: false,
                keyboard: true,
                opacity: 1,
                zIndexOffset: 0,
                riseOffset: 250,
                riseOnHover: false,
                icon: {
                    className: '',
                    iconUrl: '',
                    iconAnchor: [12, 41],
                    iconSize: [25, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                }
            }
        }
    },

    getNotDefaults: function(from, def) {
        var res = {};
        for (var key in from) {
            if (key === 'icon' || key === 'map') {
                continue;
            } else if (key === 'iconAnchor' || key === 'iconSize' || key === 'popupAnchor' || key === 'shadowSize') {
                if (!def[key]) { continue; }
                if (def[key][0] !== from[key][0] || def[key][1] !== from[key][1]) { res[key] = from[key]; }
            } else if (key === 'lineStyle' || key === 'pointStyle' || key === 'markerStyle') {
                res[key] = this.getNotDefaults(from[key], def[key]);
            } else if (!def || (def[key] !== from[key] || key === 'fill')) {
                res[key] = from[key];
            }
        }
        return res;
    },

    getShiftLatlng: function (latlng, map, shiftPixel) {
        if (shiftPixel && map) {
            var p = map.latLngToLayerPoint(latlng)._add(shiftPixel);
            latlng = map.layerPointToLatLng(p);
        }
        return latlng;
    },

    getDownType: function(ev, map, feature) {
        var layerPoint = ev.layerPoint,
            ctrlKey = false,
            latlng = ev.latlng;
        if (ev.originalEvent) {
            if (ev.originalEvent.ctrlKey) { ctrlKey = true; }
        }
        if (ev.touches && ev.touches.length === 1) {
            var first = ev.touches[0],
                containerPoint = map.mouseEventToContainerPoint(first);
            layerPoint = map.containerPointToLayerPoint(containerPoint);
            latlng = map.layerPointToLatLng(layerPoint);
        }
        var out = {type: '', latlng: latlng, ctrlKey: ctrlKey},
            ring = this.points ? this : (ev.ring || ev.relatedEvent),
            points = ring.points._originalPoints || [],
            len = points.length;

        if (len === 0) { return out; }

        var size = (ring.points.options.size || 10) / 2;
        size += 1 + (ring.points.options.weight || 2);

        var cursorBounds = new L.Bounds(
            L.point(layerPoint.x - size, layerPoint.y - size),
            L.point(layerPoint.x + size, layerPoint.y + size)
            ),
            prev = points[len - 1],
            lastIndex = len - (ring.mode === 'add' ? 2 : 1);

        out = {
            mode: ring.mode,
            layerPoint: ev.layerPoint,
            ctrlKey: ctrlKey,
            latlng: latlng
        };
        for (var i = 0; i < len; i++) {
            var point = points[i];
            if (feature.shiftPixel) { point = points[i].add(feature.shiftPixel); }
            if (cursorBounds.contains(point)) {
                out.type = 'node';
                out.num = i;
                out.end = (i === 0 || i === lastIndex ? true : false);
                break;
            }
            var dist = L.LineUtil.pointToSegmentDistance(layerPoint, prev, point);
            if (dist < size) {
                out.type = 'edge';
                out.num = (i === 0 ? len : i);
            }
            prev = point;
        }
        return out;
    },

    _getLastObject: function (obj) {
        if (obj.getLayers) {
            var layer = obj.getLayers().shift();
            return layer.getLayers ? this._getLastObject(layer) : obj;
        }
        return obj;
    },

    getMarkerByPos: function (pos, features) {
        for (var i = 0, len = features.length; i < len; i++) {
            var feature = features[i],
                fobj = feature._obj ? feature._obj : null,
                mpos = fobj && fobj._icon ? fobj._icon._leaflet_pos : null;
            if (mpos && mpos.x === pos.x && mpos.y === pos.y) {
                return fobj._latlng;
            }
        }
        return null;
    },

    getLocale: function (key) {
		var res = L.gmxLocale ? L.gmxLocale.getText(key) : null;
		return res || key;
    }
};



/** Загрузчик модулей ГеоМиксера
Позволяет загружать модули из разных файлов. 
Модуль - единица кода, имеющая уникальное имя и зависящая от других модулей и скриптов.
@namespace
*/

var gmxCore = function() 
{
    var _callbacks = [];
    var _modules = {}; //null - файл модуля уже загружается, но сам модуль пока не доступен
    var _globalNamespace = this;
	var _modulesDefaultHost = "";
	var _modulePathes = {/*#buildinclude<modules_path.txt>*/};
	var _moduleFiles = {/*#buildinclude<module_files.txt>*/};
    
    var getScriptURL = function(scriptName)
	{
        scriptName = scriptName.toLowerCase();
		var scripts1 = document.getElementsByTagName("script");
		for (var i = 0; i < scripts1.length; i++)
		{
			var src = scripts1[i].getAttribute("src");
			if (src && (src.toLowerCase().indexOf(scriptName) != -1))
				return src;
		}
		return false;
	}
    
    //производится регистронезависимое сравнение
	var getScriptBase = function(scriptName)
	{
        scriptName = scriptName.toLowerCase();
		var url = getScriptURL(scriptName);
		return url ? url.toLowerCase().substring(0, url.toLowerCase().indexOf(scriptName)) : "";
	}
    
    var invokeCallbacks = function()
    {
        for (var k = 0; k < _callbacks.length; k++)
        {
            var isAllModules = true;
            var curModules = _callbacks[k].modules;
			var modules = [];
            for (var m = 0; m < curModules.length; m++)
			{
                if ( !_modules[curModules[m]] )
                {
                    isAllModules = false;
                    break;
                }
				modules.push(_modules[curModules[m]]);
			}
                
            if (isAllModules)
            {
                var curCallback = _callbacks[k].callback;
                
                //first delete, then callback!
                _callbacks.splice(k, 1);
                k = k - 1;
                curCallback.apply(null, modules);
            }
        }
    }
    var LABjsDeferred = null;
    var lazyLoadLABjs = function()
    {
        if (!LABjsDeferred) {
            LABjsDeferred = $.Deferred();
            
            //load LAB.js (snippest from its website)
            (function(g,b,d){var c=b.head||b.getElementsByTagName("head"),D="readyState",E="onreadystatechange",F="DOMContentLoaded",G="addEventListener",H=setTimeout;
            H(function(){if("item"in c){if(!c[0]){H(arguments.callee,25);return}c=c[0]}var a=b.createElement("script"),e=false;a.onload=a[E]=function(){if((a[D]&&a[D]!=="complete"&&a[D]!=="loaded")||e){return false}a.onload=a[E]=null;e=true;LABjsDeferred.resolve()};

            a.src = ( getScriptBase('gmxcore.js') || window.gmxJSHost || "" ) + 'LAB.min.js';

            c.insertBefore(a,c.firstChild)},0);if(b[D]==null&&b[G]){b[D]="loading";b[G](F,d=function(){b.removeEventListener(F,d,false);b[D]="complete"},false)}})(this,document);
        
        }
        
        return LABjsDeferred.promise();
    }
    
    var cssLoader = null;
    
    var withCachePostfix = function(filename) {
        var sym = filename.indexOf('?') === -1 ? '?' : '&';
        if (window.gmxDropBrowserCache) {
            filename += sym + Math.random();
        } else if (window.nsGmx && nsGmx.buildGUID){
            filename += sym + nsGmx.buildGUID;
        }
        
        return filename;
    }
    
    var publicInterface = 
    /** @lends gmxCore */
    {
        /** Добавить новый модуль
        * @param {String} moduleName Уникальное имя модуля
        * @param {Object|Function} moduleObj Тело модуля или ф-ция, возвращающая тело. Аргумент ф-ции - путь к модулю. Будет вызвана после загрузки всех зависимостей.
        * @param {Object} [options] Дополнительные параметры модуля
        * @param {String[]} [options.require] Какие модули должны быть загрежены перед данным
        * @param {Function} [options.init] Ф-ция для инициализации модуля. Сигнатура: function (moduleObj, modulePath)->{void|{@link jQuery.Deferred}}. Если ф-ция возвращает {@link jQuery.Deferred}, загрузчик будет ждать его для окончания инициализации.
        * @param {String|String[]} [options.css] CSS файлы для загрузки. Пути к CSS указываются относительно файла текущего модуля.
        */
        addModule: function(moduleName, moduleObj, options)
        {
            var requiredModules = (options && 'require' in options) ? options.require : [];
            var initDeferred = null;
            var _this = this;
            
            for (var r = 0; r < requiredModules.length; r++)
                this.loadModule( requiredModules[r] );
                
            this.addModulesCallback( requiredModules, function()
            {

                if (options && 'init' in options)
				{
                    initDeferred = options.init(moduleObj, _modulePathes[moduleName]);
				}
                
                if (options && 'css' in options)
				{
                    var cssFiles = typeof options.css === 'string' ? [options.css] : options.css;
                    var path = _modulePathes[moduleName] || window.gmxJSHost || "";
                    
                    for (var iF = 0; iF < cssFiles.length; iF++)
                        _this.loadCSS(withCachePostfix(path + cssFiles[iF]));
				}

                var doAdd = function() {
                    if (typeof moduleObj === 'function') {
                        moduleObj = moduleObj( _modulePathes[moduleName] );
                    }
                    _modules[moduleName] = moduleObj;
                    invokeCallbacks();
                }
                
                if (initDeferred) {
                    initDeferred.done(doAdd);
                } else {
                    doAdd();
                }
            });
        },
        
        /** Загрузить модуль
        * @param { String } moduleName Имя модуля для загрузки
        * @param { String } [moduleSource] Имя файла, откуда загружать модуль. Если не указан, будет сформирован в виде (defaultHost + moduleName + '.js')
        * @param { Function } [callback] Ф-ция, которая будет вызвана после загрузки и инициализации. В ф-цию первым параметром передаётся тело модуля
        * @return { jQuery.Deferred } Promise, который будет resolve при загрузке модуля (параметр - модуль).
        */
        loadModule: function(moduleName, moduleSource, callback)
        {
            var def = $.Deferred();
            
            if (typeof moduleSource === 'function') {
                callback = moduleSource;
                moduleSource = undefined;
            }
            
            this.addModulesCallback([moduleName], function(module)
            {
                callback && callback(module);
                def.resolve(module);
            });
            
            if ( ! (moduleName in _modules) )
            {
                _modules[moduleName] = null;
                
                var headElem = document.getElementsByTagName("head")[0];
                var newScript = document.createElement('script');
                
                var path;
                if (typeof moduleSource != 'undefined')
                {
                    path = moduleSource.match(/^http:\/\//i) ? moduleSource : (window.gmxJSHost || "") + moduleSource;
                }
                else
                {
                    path = (moduleName in _moduleFiles) ? _moduleFiles[moduleName] : (_modulesDefaultHost || window.gmxJSHost || "") + moduleName + '.js';
                }

                var pathRegexp = /(.*)\/[^\/]+/;
                if ( typeof _modulePathes[moduleName] === 'undefined' )
                    _modulePathes[moduleName] = pathRegexp.test(path) ? path.match(pathRegexp)[1] + "/" : "";
				
                var pathPostfix = "";
                
                newScript.onerror = function() {
                    def.reject();
                }
                
                newScript.type = 'text/javascript';
                newScript.src = withCachePostfix(path);
                newScript.charset = "utf-8";
                headElem.appendChild(newScript);
            }
            
            return def;
        },
        
        /** Добавить callback, который будет вызван после загрузки моделей
        *
        * Если модули уже загружены, callback будет вызван сразу же
        *
        * @param {Array} moduleNames Массив имён модулей
        * @param {Function} callback Ф-ция, которую нужно вызвать после загрузки. В качестве аргументов в ф-цию передаются загруженные модули
        */
        addModulesCallback: function( moduleNames, callback )
        {
            _callbacks.push({modules: moduleNames, callback: callback});
            invokeCallbacks();
        },
        
        /** Получить модуль по имени.
        *
        * @param {String} moduleName Имя модуля
        * @return {Object} Тело модуля. Если модуль не загружен, вернётся null.
        */
        getModule: function(moduleName)
        {
            return _modules[moduleName] || null;
        },
		
        /** Установить дефольный путь к модулям. Используется если указан локальный файл модуля.
        * @param {String} defaultHost Дефолтный путь у модулям.
        */
		setDefaultModulesHost: function( defaultHost )
		{
			_modulesDefaultHost = defaultHost;
		},
        
        /** Явно задать полный путь к модулю
        * @param {String} moduleName Имя модуля
        * @param {String} defaultHost Путь к файлу модулю. При загрузке модуля будет загружен файл по указанному пути
        */
        setModuleFile: function(moduleName, moduleFile)
        {
            _moduleFiles[moduleName] = moduleFile;
        },
		
        pushModule2GlobalNamespace: function(moduleName)
        {
            if ( !_modules[moduleName] ) return;
            var module = _modules[moduleName];
            
            for (var p in module)
                _globalNamespace[p] = module[p];
        },
		
        /** Получить путь к директории, из которой был загружен модуль.
        * @param {String} moduleName Имя модуля
        * @returns {String} Путь к директории, из которой был загружен модуль. Для не загруженных модулей ничего не возвращает
        */
		getModulePath: function(moduleName)
		{
			return _modulePathes[moduleName];
		},
        
        /** Возвращает ф-цию, которая делает следующее:
        *
        *  - Если модуль moduleName не загружен, загружает его
        *  - Потом просто вызывает ф-цию с именем functionName из этого модуля, передав ей все свои параметры
        *
        *  - Возвращённая ф-ция при вызове возвращает jQuery.Promise, который будет resolve с параметрами, возвращёнными исходной ф-цией из модуля
        * @param {String} moduleName Имя модуля
        * @param {String} functionName Название ф-ции внутри модуля
        * @param {Function} callback Ф-ция, которая будет вызвана после того, как отработает ф-ция модуля. В callback будет передан ответ исходной ф-ции.
        */
        createDeferredFunction: function(moduleName, functionName, callback)
        {
            var _this = this;
            return function()
            {
                var deferred = $.Deferred();
                var args = arguments;
                _this.loadModule(moduleName).done(function(module)
                {
                    var res = module[functionName].apply(this, args);
                    callback && callback(res);
                    deferred.resolve(res);
                });
                
                return deferred.promise();
            }
        },
        
        /** Загружает скрипт после предвариетельной проверки условий.
        *
        * @param {Array} filesInfo Массив объектов со следующими свойствами:
        *
        *   * check: function() -> Bool. Если возвращает true, ни js ни css не будет загружены
        *   * script: String. Не обязательно. Скрипт для загрузки, если провалится проверка
        *   * css: String | String[]. Не обязательно. CSS файл(ы) для загрузки, если провалится проверка
        *   @returns {jQuery.Deferred} Deferred, который будет разрешён когда все скрипты выполнятся (окончание загрузки css не отслеживается)
        */
        loadScriptWithCheck: function(filesInfo)
        {
            var _this = this;
            var localFilesInfo = filesInfo.slice(0);
            var def = $.Deferred();
            
            var doLoad = function(info)
            {
                if (localFilesInfo.length > 0)
                {
                    var curInfo = localFilesInfo.shift();
                    if (curInfo.check())
                        doLoad()
                    else
                    {
                        var css = curInfo.css || [];
                        if (typeof css === 'string') {
                            css = [css];
                        }
                        css.forEach(_this.loadCSS);
                        
                        if (curInfo.script)
                            _this.loadScript(curInfo.script).then(doLoad);
                        else
                            doLoad();
                    }
                }
                else
                    def.resolve();
            }
            
            doLoad();
            return def.promise();
        },
        
        /**
        * Загружает отдельный скрипт
        * @param {String} fileName Имя файла скрипта
        * @param {function} [callback] Ф-ция, которая будет вызвана после загрузки
        * @param {String} [charset=utf-8] Кодировка загружаемого файла
        * @returns {jQuery.Deferred}
        */
        loadScript: function(fileName, callback, charset)
        {
            var def = $.Deferred();
            lazyLoadLABjs().done(function()
            {
                var descr = {src: withCachePostfix(fileName)};
                if (charset) {
                    descr.charset = charset;
                }
                
                $LAB.script(descr).wait(function()
                {
                    def.resolve();
                    callback && callback();
                })
            })
            return def.promise();
        }, 
        
        /** Загрузить отдельный css файл
        * @param {String} cssFilename Имя css файла.
        */
        loadCSS: function(cssFilename)
        {
            var doLoadCss = function()
            {
                $.getCSS(withCachePostfix(cssFilename));
            }
            
            if ('getCSS' in $)
            {
                doLoadCss()
            }
            else
            {
                if (!cssLoader)
                {
                    var path = getScriptBase('gmxcore.js') || window.gmxJSHost || "";
                    cssLoader = $.getScript(path + "jquery/jquery.getCSS.js");
                }
                
                cssLoader.done(doLoadCss);
            }
        }
    }
    
    return publicInterface;
}();
window.nsGmx = window.nsGmx || {};
nsGmx._defaultPlugins =
[
    {pluginName: 'Media Plugin',         file: 'plugins/external/GMXPluginMedia/MediaPlugin2.js',        module: 'MediaPlugin2',       mapPlugin: false, isPublic: true},
    // {pluginName: 'Fire Plugin',          file: 'plugins/FireMapplet_v2.js',                               module: 'FireMapplet',        mapPlugin: true,  isPublic: true},
    // {pluginName: 'Shift Rasters Plugin', file: 'plugins/shiftrasters/ShiftRasterPlugin.js',              module: 'ShiftRastersPlugin', mapPlugin: true,  isPublic: true},
    {pluginName: 'Cadastre',             file: 'plugins/external/GMXPluginCadastre/cadastre.js',         module: 'cadastre',           mapPlugin: true,  isPublic: true, params: {notHideDrawing: true}},
    // {pluginName: 'ScanEx catalog',       file: '../GeoMixerModules/catalog/CatalogPlugin.js',            module: 'Catalog',            mapPlugin: true,  isPublic: true},
    // {pluginName: 'GIBS Plugin',          file: 'plugins/gibs/GIBSPlugin.js',                             module: 'GIBSPlugin',         mapPlugin: true,  isPublic: true},
    {pluginName: 'BufferPlugin',         file: 'plugins/external/GMXPluginBuffer/BufferPlugin.js',       module: 'BufferPlugin',       mapPlugin: true,  isPublic: true},
    // {pluginName: 'Wind Plugin',       file: 'plugins/windplugin/WindPlugin.js',                 module: 'WindPlugin',      mapPlugin: true,  isPublic: true},
    {pluginName: 'Weather Grid Plugin',  file: 'plugins/weathergridplugin/WeatherGridPlugin.js',         module: 'WeatherGridPlugin',  mapPlugin: false,  isPublic: true},
    {pluginName: 'HelloWorld',            file: 'plugins/HelloWorld/HelloWorld.js', module: 'HelloWorld',    mapPlugin: true,  isPublic: true},
    {pluginName: 'Wikimapia',            file: 'plugins/external/GMXPluginWikimapia/WikimapiaPlugin.js', module: 'WikimapiaPlugin',    mapPlugin: true,  isPublic: true,
        params: {key: "A132989D-3AE8D94D-5EEA7FC1-E4D5F8D9-4A59C8A4-7CF68948-338BD8A8-611ED12", proxyUrl:""}
    }
];

(function(){

//внутреннее представление плагина
var Plugin = function(moduleName, file, body, params, pluginName, mapPlugin, isPublic)
{
    var usageState = mapPlugin ? 'unknown' : 'used'; //used, notused, unknown
    var _this = this; 
    
    var doLoad = function()
    {
        if (_this.body || _this.isLoading)
            return;
            
        _this.isLoading = true;
        gmxCore.loadModule(moduleName, file).then(function()
        {
            _this.body = gmxCore.getModule(moduleName);
            _this.isLoading = false;
            _this.pluginName = _this.pluginName || _this.body.pluginName;
            _this.def.resolve();
        }, function() {
            _this.isLoading = false;
            _this.def.reject();
        });
    }
    
    this.body = body;
    this.moduleName = moduleName;
    this.params = params || {};
    this.def = $.Deferred(); //будет resolve когда плагин загрузится
    this.isLoading = false;
    this.mapPlugin = mapPlugin || (body && body.pluginName);
    this.pluginName = pluginName || (this.body && this.body.pluginName);
    this.isPublic = isPublic;
    this.file = file;
    
    if (this.body)
        this.def.resolve();
        
    //мы не будем пока загружать плагин только если он не глобальный и имеет имя
    if (!mapPlugin || !pluginName) {
        doLoad();
    }
    
    this.setUsage = function(usage)
    {
        usageState = usage;
        if (usageState === 'used') {
            doLoad();
        }
    }
    
    this.isUsed = function()
    {
        return usageState === 'used';
    }
    
    this.updateParams = function (newParams) {
        $.extend(true, _this.params, newParams);
    }
}

/**
  @name IGeomixerPlugin
  @desc Интерфейс плагинов ГеоМиксера
  @class
  @abstract
  @property {String} pluginName Имя плагина для списка плагинов
*/

/**
  @memberOf IGeomixerPlugin.prototype
  @method
  @name beforeMap
  @desc Вызывется сразу после загрузки всех модулей ядра вьюера (до инициализации карты, проверки пользователя и т.п.).
        Ещё нет информации о пользователе, но пока можно сменить карту для загрузки.
  @param {Object} params Параметры плагина
*/

/**
  @memberOf IGeomixerPlugin.prototype
  @method
  @name preloadMap
  @desc Вызывется непосредственно перед началом создания слоёв по загруженной информации о карте.
        Карту сменить уже нельзя, но можно как-нибудь повлиять на процесс создания слоёв (например, добавить новые классы слоёв)
  @param {Object} params Параметры плагина
*/

/**
  @memberOf IGeomixerPlugin.prototype
  @method
  @name beforeViewer
  @desc вызовется до начала инициализации ГеоМиксера, но сразу после инициализации карты
  @param {Object} params Параметры плагина
  @param {gmxAPI.Map} map Основная карта
*/

/**
  @memberOf IGeomixerPlugin.prototype
  @method
  @name afterViewer
  @desc вызовется после окончания инициализации ГеоМиксера
  @param {Object} params Параметры плагина
  @param {gmxAPI.Map} map Основная карта
*/

/** Менеджер плагинов. Загружает плагины из конфигурационного файла
*
* Загрузка плагинов происходит из массива window.gmxPlugins. 
*
* Каждый элемент этого массива - объект со следующими свойствами:
*
*   * module (имя модуля)
*   * file (из какого файла подгружать модуль, может отсутствовать). Только если указано module
*   * plugin (сам плагин). Если указано, плагин подгружается в явном виде, иначе используется module (и file)
*   * params - объект параметров, будет передаваться в методы модуля
*   * pluginName - имя плагина. Должно быть уникальным. Заменяет IGeomixerPlugin.pluginName. Не рекомендуется использовать без особых причин
*   * mapPlugin {bool, default: true} - является ли плагин плагином карт. Если является, то не будет грузиться по умолчанию.
*   * isPublic {bool, default: false} - нужно ли показывать плагин в списках плагинов (для некоторых плагинов хочется иметь возможность подключать их к картам, но не показывать всем пользователям)
*
* Если очередной элемент массива просто строка (например, "name"), то это эквивалентно {module: "name", file: "plugins/name.js"}
*
* Каждый плагин хранится в отдельном модуле (через свойство module) или подгружается в явном виде (через свойство plugin). Модуль должен реализовывать интерфейс IGeomixerPlugin.
*  @class PluginsManager
*/
var PluginsManager = function()
{
    var _plugins = [];
    var _pluginsWithName = {};
    
    var joinedPluginInfo = {};
    
    //сначала загружаем инфу о плагинах из переменной nsGmx._defaultPlugins - плагины по умолчанию
    window.nsGmx && nsGmx._defaultPlugins && $.each(nsGmx._defaultPlugins, function(i, info) {
        if (typeof info === 'string') {
            info = { module: info, file: 'plugins/' + info + '.js' };
        }
        joinedPluginInfo[info.module] = info;
    })
    
    //дополняем её инфой из window.gmxPlugins с возможностью перезаписать
    window.gmxPlugins && $.each(window.gmxPlugins, function(i, info) {
        if (typeof info === 'string') {
            info = { module: info, file: 'plugins/' + info + '.js' };
        }
        joinedPluginInfo[info.module] = $.extend(true, joinedPluginInfo[info.module], info);
    })
    
    $.each(joinedPluginInfo, function(key, info) {
        if (typeof info === 'string')
            info = { module: info, file: 'plugins/' + info + '.js' };
        
        var plugin = new Plugin(
            info.module, 
            info.file,
            info.plugin,
            info.params,
            info.pluginName,
            info.mapPlugin,
            info.isPublic || false
        );
        
        _plugins.push(plugin);
        
        if (plugin.pluginName) {
            _pluginsWithName[ plugin.pluginName ] = plugin;
        }
        else
        {
            plugin.def.done(function()
            {
                if (plugin.pluginName) {
                    _pluginsWithName[ plugin.pluginName ] = plugin;
                }
            })
        }
    })
    
    var _genIterativeFunction = function(funcName)
    {
        return function(map)
        {
            for (var p = 0; p < _plugins.length; p++)
                if ( _plugins[p].isUsed() && _plugins[p].body && _plugins[p].body[funcName]) {
                    //передаём в плагин deep clone параметров, чтобы плагин не мог их менять in-place
                    var params = $.extend(true, {}, _plugins[p].params);
                    try {
                        _plugins[p].body[funcName]( params, map || nsGmx.leafletMap );
                    } catch (e) {
                        console && console.error('Error in function ' + funcName + '() of plugin ' + _plugins[p].moduleName + ': ' + e);
                        console && console.error(e.stack);
                    }
                }
        }
    }
    
    //public interface
    
    /**
    Вызывет callback когда будут загружены все плагины, загружаемые в данный момент
    @memberOf PluginsManager
     @name done
     @method
     @param {Function} callback Ф-ция, которую нужно будет вызвать
    */
    
    this.done = function(f) {
        //не можем использовать $.when, так как при первой ошибке результирующий promise сразу же reject'ится, а нам нужно дождаться загрузки всех плагинов
        var loadingPlugins = _.where(_plugins, {isLoading: true}),
            count = loadingPlugins.length;
        
        count || f();
        
        loadingPlugins.forEach(function(plugin) {
            plugin.def.always(function() {
                --count || f();
            })
        })
    }
    
    /**
     Вызывает beforeMap() у всех плагинов
     @memberOf PluginsManager
     @name beforeMap
     @method
    */
    this.beforeMap = _genIterativeFunction('beforeMap');
    
    /**
     Вызывает preloadMap() у всех плагинов
     @memberOf PluginsManager
     @name preloadMap
     @method
    */
    this.preloadMap = _genIterativeFunction('preloadMap');
    
    /**
     Вызывает beforeViewer() у всех плагинов
     @memberOf PluginsManager
     @name beforeViewer
     @method
    */
    this.beforeViewer = _genIterativeFunction('beforeViewer');
    
    /**
     Вызывает afterViewer() у всех плагинов
     @memberOf PluginsManager
     @name afterViewer
     @method
    */
    this.afterViewer = _genIterativeFunction('afterViewer');
    
    /**
     Добавляет пункты меню всех плагинов к меню upMenu
     Устарело! Используйте непосредственное добавление элемента к меню из afterViewer()
     @method
     @ignore
    */
    this.addMenuItems = function( upMenu )
    {
        for (var p = 0; p < _plugins.length; p++) {
            if ( _plugins[p].isUsed() && _plugins[p].body && _plugins[p].body.addMenuItems) {
                var menuItems = _plugins[p].body.addMenuItems();
                for (var i = 0; i < menuItems.length; i++)
                    upMenu.addChildItem(menuItems[i].item, menuItems[i].parentID);
            }
        }
    };
    
    /**
     Вызывает callback(plugin) для каждого плагина
     @memberOf PluginsManager
     @name forEachPlugin
     @method
     @param {Function} callback Ф-ция для итерирования. Первый аргумент ф-ции - модуль плагина.
    */
    this.forEachPlugin = function(callback)
    {
        //if (!_initDone) return;
        for (var p = 0; p < _plugins.length; p++)
            callback(_plugins[p]);
    }
    
    /**
     Задаёт, нужно ли в дальнейшем использовать данный плагин
     @memberOf PluginsManager
     @name setUsePlugin
     @method
     @param {String} pluginName Имя плагина
     @param {Bool} isInUse Использовать ли его для карты
    */
    this.setUsePlugin = function(pluginName, isInUse)
    {
        if (pluginName in _pluginsWithName)
            _pluginsWithName[pluginName].setUsage(isInUse ? 'used' : 'notused');
    }
    
    /**
     Получить плагин по имени
     @memberOf PluginsManager
     @name getPluginByName
     @method
     @param {String} pluginName Имя плагина
     @returns {IGeomixerPlugin} Модуль плагина, ничего не возвращает, если плагина нет
    */
    this.getPluginByName = function(pluginName)
    {
        return _pluginsWithName[pluginName];
    }
    
    /**
     Проверка публичности плагина (можно ли его показывать в различных списках с перечислением подключенных плагинов)
     @memberOf PluginsManager
     @name isPublic
     @method
     @param {String} pluginName Имя плагина
     @returns {Bool} Является ли плагин публичным
    */
    this.isPublic = function(pluginName)
    {
        return _pluginsWithName[pluginName] && _pluginsWithName[pluginName].isPublic;
    }
    
    /**
     Обновление параметров плагина
     @memberOf PluginsManager
     @name updateParams
     @method
     @param {String} pluginName Имя плагина
     @param {Object} newParams Новые параметры плагина. Параметры с совпадающими именами будут перезатёрты
    */
    this.updateParams = function(pluginName, newParams) {
        _pluginsWithName[pluginName] && _pluginsWithName[pluginName].updateParams(newParams);
    }
}

var publicInterface = {PluginsManager : PluginsManager};
gmxCore.addModule('PluginsManager', publicInterface);

})();
!function(){
var translationsHash = function()
{
	this.hash = {};
	
	this.flags = {};
	
	this.titles = {};
    
    this._errorHandlers = [];
}

var DEFAULT_LANGUAGE = 'rus';

//Для запоминания выбора языка пользователем используются куки. 
//Запоминается выбор для каждого pathname, а не только для домена целиком
//Формат куки: pathname1=lang1&pathname2=lang2&...
var _parseLanguageCookie = function()
{
    var text = readCookie("language");
    
    if (!text) 
        return {};
    
    var items = text.split('&');

    //поддержка старого формата кук (просто названия взыка для всех pathname)
    if (items % 2) items = [];
    
    var langs = {};
    for (var i = 0; i < items.length; i++)
    {
        var elems = items[i].split('=');
        langs[decodeURIComponent(elems[0])] = decodeURIComponent(elems[1]);
    }
    
    return langs;
}

var _saveLanguageCookie = function(langs)
{
    var cookies = [];
    
    for (var h in langs)
    {
        cookies.push(encodeURIComponent(h) + '=' + encodeURIComponent(langs[h]));
    }
    
    eraseCookie("language");
    createCookie("language", cookies.join('&'));
}

var TranslationsManager = function() {
    this.flags = {};
    this.titles = {};
    this.hash = {};
    this._errorHandlers = [];
}

TranslationsManager.prototype._language = null;

TranslationsManager.prototype._addTextWithPrefix = function(prefix, lang, newHash) {
    var res = true,
        hash = this.hash;

    if (!(lang in hash)) {
        hash[lang] = {};
    }

    for (var k in newHash) {
        var fullKey = prefix + k;
        if (fullKey in hash[lang]) {
            res = false;
        } else {
            if (typeof newHash[k] === 'string') {
                hash[lang][fullKey] = newHash[k];
            } else {
                this._addTextWithPrefix(fullKey + '.', lang, newHash[k]);
            }
        }
    }

    return res;
}

/** Добавить строки в словарь локализации
 @func addText
 @memberOf nsGmx.Translations
 @param {String} lang Язык, к которому добавляются строки
 @param {Object} strings Список добавляемых строк. Должен быть объектом, в котором атрибуты являются ключами перевода.
                 Если значение атрибута - строка, то она записывается как результат локализации данного ключа.
                 Если значение атрибута - другой объект, то название текущего атрибута будет добавлено с точкой 
                 к названию атрибутов в этом объекте. Например: {a: {b: 'бэ', c: 'це'}} сформируют ключи локализации 'a.b' и 'a.c'.
*/
TranslationsManager.prototype.addText = function(lang, newHash) {
    this._addTextWithPrefix('', lang, newHash);
}

/** Получить локализованный текст по ключу для текущего языка
 @func getText
 @memberOf nsGmx.Translations
 @param {String} key Ключ локализации
 @return {String} Локализованный текст
*/
TranslationsManager.prototype.getText = function(dictKey) {
    var lang = this.getLanguage(),
        args = arguments,
        getArg = function(i) {
            return args[i + 1] || '';
        };

    if (!this.hash[lang] || !this.hash[lang][dictKey]) {
        this._errorHandlers.forEach(function(handler) {handler(dictKey, lang);});
        return '';
    } else {
        return this.hash[lang][dictKey].replace(/\[value(\d)\]/g, function(match, argIndex) {
            return getArg(Number(argIndex))
        })
    }
}

/** Установить текущий язык
 @func setLanguage
 @memberOf nsGmx.Translations
 @param {String} lang Текущий язык (eng/rus/...)
*/
TranslationsManager.prototype.setLanguage = function(lang) {
    TranslationsManager.prototype._language = lang;
}

/** Получить текущий язык локализации
 @func getLanguage
 @memberOf nsGmx.Translations
 @return {String} Текущий язык (eng/rus/...)
*/
TranslationsManager.prototype.getLanguage = function() {
    return TranslationsManager.prototype._language || 
           (typeof window !== 'undefined' && window.language) || 
           DEFAULT_LANGUAGE;
}

/** Добавить обработчик ошибок локализации. 
    При возникновении ошибок (не определён язык, не найден перевод) будет вызываться каждый из обработчиков
 @func addErrorHandler
 @memberOf nsGmx.Translations
 @param {function(text, lang)} Обработчик ошибки. В ф-цию передаётся текст и язык
*/
TranslationsManager.prototype.addErrorHandler = function(handler) {
    this._errorHandlers.push(handler);
}

/** Считать из кук текущий язык локализации.
 * В куках отдельно записываются языки для каждого pathname, а не только для домена целиком
 @func getLanguageFromCookies
 @memberOf nsGmx.Translations
 @param {String} [pathname] Идентификатор проекта, для которого нужно запомнить куку. По умолчанию `window.location.pathname`.
 @return {String} Язык, записанный в куках для данного pathname
*/
TranslationsManager.prototype.getLanguageFromCookies = function(pathname) {
    return _parseLanguageCookie()[pathname || window.location.pathname];
}

/** Записать в куки текущий язык локализации.
 * В куках отдельно записываются языки для каждого pathname, а не только для домена целиком
 @func updateLanguageCookies
 @memberOf nsGmx.Translations
 @param {String} lang Язык, который нужно записать в куку
 @param {String} [pathname] Идентификатор проекта, для которого нужно запомнить куку. По умолчанию `window.location.pathname`.
*/
TranslationsManager.prototype.updateLanguageCookies = function(lang, pathname) {
    var langs = _parseLanguageCookie();
    langs[pathname || window.location.pathname] = lang;
    _saveLanguageCookie(langs);
}

/** Ф-ции для локализации пользовательского интерфейса
 @namespace nsGmx.Translations
*/

var commonTranslationsManager = new TranslationsManager();
TranslationsManager.commonManager = commonTranslationsManager;

//хелпер для вставки локализованных констант в шаблоны. Например: {{i "layerEditor.dialogTitle"}}
var addHanlebarsHelper = function(Handlebars) {
    Handlebars && Handlebars.registerHelper('i', function(dictKey) {
        return commonTranslationsManager.getText(dictKey);
    });
}

if (typeof define === 'function' && define.amd) {
    define(['handlebars'], function(Handlebars) {
        addHanlebarsHelper(Handlebars);
        return TranslationsManager;
    });
} else {
    addHanlebarsHelper(window.Handlebars);
}

window.nsGmx = window.nsGmx || {};
window.nsGmx.Translations = commonTranslationsManager;

//Поддерживаем обратную совместимость - глобальные объекты _gtxt, _translationsHash, translationsHash
var prev_gtxt = window._gtxt,
    prev_translationsHash = window._translationsHash,
    prevTranslationsHash = window.translationsHash;
    
/** Убирает из глобальной видимости все объекты и ф-ции, связанные с локализацией
 @name noConflicts
 @memberOf nsGmx.Translations
*/
TranslationsManager.prototype.noConflicts = function() {
    window._gtxt = prev_gtxt;
    window._translationsHash = prev_translationsHash;
    window.translationsHash = prevTranslationsHash;
}

//Явно добавляем объекты в глобальную видимость
var DumpClass = function(){};
DumpClass.prototype = commonTranslationsManager;

window._translationsHash = new DumpClass();
_translationsHash.gettext = commonTranslationsManager.getText.bind(commonTranslationsManager),
_translationsHash.addtext = commonTranslationsManager.addText.bind(commonTranslationsManager),
_translationsHash.showLanguages = function() {
    var langCanvas = _div(null, [['dir','className','floatRight'],['css','margin',' 7px 10px 0px 0px']]);
    
    for (var lang in this.hash)
    {
        if (lang != window.language)
        {
            var button = makeLinkButton(_translationsHash.titles[lang]);
            
            button.style.marginLeft = '5px';
            button.style.fontSize = '11px';

            button.onclick = function(lang) {
                window.translationsHash.updateLanguageCookies(lang);

                if (window.nsGmx && window.nsGmx.GeomixerFramework) {
                    window.language = lang;
                    _mapHelper.reloadMap();
                } else {
                    window.location.reload();
                }
            }.bind(null, lang);
            
            _title(button, this.titles[lang]);
            
            langCanvas.appendChild(button);
        }
        else 
        {
            langCanvas.appendChild(_span([_t(_translationsHash.titles[lang])], [['css','marginLeft','5px'], ['css','color','#fc830b']]));
        }
    }

    document.getElementById("headerLinks").appendChild(langCanvas);
}

window._gtxt = function() {
    return commonTranslationsManager.getText.apply(commonTranslationsManager, arguments);
};

window.translationsHash = {
    getLanguageFromCookies: commonTranslationsManager.getLanguageFromCookies.bind(commonTranslationsManager),
    updateLanguageCookies: commonTranslationsManager.updateLanguageCookies.bind(commonTranslationsManager)
};

window.gmxCore && gmxCore.addModule('translations',
{
    _translationsHash: window._translationsHash
})

}();

_translationsHash.flags["rus"] = "img/flag_ru.png";

_translationsHash.titles["rus"] = "Русский";

_translationsHash.hash["rus"] = {
	"Да": "Да",
	"Нет": "Нет",
	"Карта" : "Карта",
	"Создать" : "Создать",
	"Создать карту" : "Создать карту",
	"Сохранить" : "Сохранить",
	"Сохранить как" : "Сохранить как",
	"Сохранить карту как" : "Сохранить карту как",
	"Сохранить карту" : "Сохранить карту",
	"Экспорт" : "Экспорт",

    "Карта пожаров": "Карта пожаров",
    "Поиск снимков": "Поиск снимков",
    "Платформа Геомиксер": "Веб-ГИС GeoMixer",
    "http://fires.ru": "http://fires.ru",
    "http://search.kosmosnimki.ru": "http://search.kosmosnimki.ru",

    "Данные": "Данные",
    "Сервисы": "Сервисы",
    "Поделиться": "Поделиться",
    "Открыть слой": "Открыть слой",
    "Создать слой": "Создать слой",
    "Растровый": "Растровый",
    "Векторный": "Векторный",
    "Создать группу": "Создать группу",
    "Базовые слои": "Базовые слои",
    "Подключить WMS": "Подключить WMS",
    "Подключить WFS": "Подключить WFS",
    "Объекты": "Объекты",
    "Результаты поиска": "Результаты поиска",
    "Буфер": "Буфер",
    "Ручная привязка растров": "Ручная привязка растров",
    "Поиск слоев на карте": "Поиск слоев на карте",
    "Краудсорсинг данных": "Краудсорсинг данных",
    "Пакетный геокодинг": "Пакетный геокодинг",
    "Маршруты": "Маршруты",
    "Кадастр Росреестра": "Кадастр Росреестра",
    "Выбрать кадастровый объект": "Выбрать кадастровый объект",
    "Викимапиа": "Викимапиа",
    "Каталог СКАНЭКС": "Поиск снимков",
    "Космоснимки-пожары": "Космоснимки-пожары",
    "GIBS NASA": "Съёмка MODIS (NASA)",
    "Руководство пользователя": "Документация",
    "GeoMixer API": "GeoMixer API",
    "Использование плагинов": "Использование плагинов",
	"копия": "копия",
	
	"Открыть" : "Открыть",
	"Слой" : "Слой",
	"Создать векторный слой" : "Создать векторный слой",
	"Создать растровый слой" : "Создать растровый слой",
	"Создать мультислой" : "Создать мультислой",
	"Вид" : "Вид",
	"Дерево слоев" : "Дерево слоев",
	"Объекты на карте" : "Объекты на карте",
	"Результаты поиска" : "Результаты поиска",
	"Координатная сетка" : "Координатная сетка",
	"Индексная сетка" : "Индексная сетка",
	"Сервисы" : "Сервисы",
	"Загрузить объекты" : "Загрузить объекты",
	"Загрузить фотографии" : "Загрузить фотографии",
	"Загрузить данные" : "Загрузить данные",
		"WFS сервер" : "WFS сервер",
		"WMS сервер" : "WMS сервер",
		"Кадастровые данные" : "Кадастровые данные",
	"Ссылка на карту" : "Ссылка на карту",
	"Код для вставки" : "Код для вставки карты",
	"Печать" : "Печать",
	"Привязать изображение" : "Привязать изображение",
	"Сообщить об ошибке на карте" : "Сообщить об ошибке на карте",
	"Справка" : "Справка",
	"Использование" : "Использование",
	"Сервисы" : "Сервисы",
	"О проекте" : "О проекте/Контакты",
	"$$phrase$$_1" : "Укажите карту в параметре defaultMapID в файле config.js",
	"У вас нет прав на просмотр данной карты" : "У вас нет прав на просмотр данной карты",
	"Access error" : "У вас нет прав на просмотр данной карты",
	"Map not found" : "Данная карта не существует",
	"Unable to locate EXIF content" : "отсутствуют координаты в EXIF",
	"Развернуть карту" : "Развернуть карту",
	"Свернуть карту" : "Свернуть карту",
	"Точки на изображении:" : "Точки на изображении:",
	"Точки на карте:" : "Точки на карте:",
	"Координаты" : "Координаты",
	"Нарисовать" : "Нарисовать",
	"Восстановить" : "Восстановить",
	"Прозрачность" : "Прозрачность",
	"Видимость" : "Видимость",
	"Привязка изображения" : "Привязка изображения",
	"$$phrase$$_2" : "Точка [value0] находится за пределами изображения",
	"$$phrase$$_3" : "Не задана точка [value0] на карте",
	"Соответствие точек" : "Соответствие точек",
	"$$phrase$$_4" : "Точки 1 и 2 на изображении совпадают",
	"$$phrase$$_5" : "Точки 1 и 3 на изображении совпадают",
	"$$phrase$$_6" : "Точки 2 и 3 на изображении совпадают",
	"$$phrase$$_7" : "Точки 1 и 2 на карте совпадают",
	"$$phrase$$_8" : "Точки 1 и 3 на карте совпадают",
	"$$phrase$$_9" : "Точки 2 и 3 на карте совпадают",
	"$$phrase$$_10" : "Точки на изображении лежат на одной прямой",
	"Создать экскурсию" : "Создать экскурсию",
	"Чтобы пользоваться этим сайтом, установите Flash Player" : "Чтобы пользоваться этим сайтом, установите Flash Player",
	"из Интернет" : "из Интернет",
	"или с локального диска " : "или с локального диска ",
	"для Internet Explorer" : "для Internet Explorer",
	" или " : " или ",
	"для Internet Firefox" : "для Internet Firefox",
	"Скачать shp-файл" : "Скачать shp-файл",
	"shp-файл" : "shp-файл",
	"gpx-файл" : "gpx-файл",
	"Скачать фрагмент растра" : "Скачать фрагмент растра",
	"Очистить" : "Очистить",
	"точка" : "точка",
	"линия" : "линия",
	"прямоугольник" : "прямоугольник",
	"многоугольник" : "многоугольник",
	"Скачать" : "Скачать",
	"Введите имя файла для скачивания" : "Введите имя файла для скачивания",
	"Выберите область рамкой на карте" : "Выберите область рамкой на карте",
	"Вырезать фрагмент растра" : "Вырезать фрагмент растра",
	"К прямоугольнику не подходит ни одного растрового слоя" : "К прямоугольнику не подходит ни одного растрового слоя",
	"Загруженный shp-файл пуст" : "Загруженный shp-файл пуст",
	"Ошибка скачивания" : "Ошибка скачивания",
	"Обновить" : "Обновить",
	"Домашняя директория" : "Директория проекта",
	"Имя папки" : "Имя папки",
	"Имя" : "Имя",
	"Тип" : "Тип",
	"Размер" : "Размер",
	"Дата" : "Дата",
    "Дата создания": "Дата создания",
	"Снять выделение" : "Снять выделение",
	"Скопировать" : "Скопировать",
	"Удалить" : "Удалить",
	"Извлечь" : "Извлечь",
	"Упаковать" : "Упаковать",
	"Загрузить" : "Загрузить",
    "Параметр" : "Параметр",
    "Значение" : "Значение",
    "Метаданные": "Метаданные",
    "Поля": "Поля",
    "Редактировать поля": "Редактировать поля",
	"URL сервера" : "URL сервера",
	"Формат изображения" : "Формат изображения",
	"Введите имя gml-файла для скачивания:" : "Введите имя gml-файла для скачивания:",
	"точки" : "точки",
	"линии" : "линии",
	"полигоны" : "полигоны",
	"(ссылка)" : "(ссылка)",
	"Сохранить состояние карты" : "Сохранить состояние карты",
	"Ссылка на текущее состояние карты" : "Ссылка на текущее состояние карты",
	"Добавить стиль" : "Добавить стиль",
	"Атрибут >" : "Атрибут >",
	"Значение >" : "Значение >",
	"Операция >" : "Операция >",
	"Накладываемое изображение" : "Накладываемое изображение",
	"Цвет" : "Цвет",
	"Прозрачность" : "Прозрачность",
	"Авторизуйтесь для редактирования фильтров" : "Авторизуйтесь для редактирования фильтров",
	"Имя фильтра" : "Имя фильтра",
	"Переместить фильтр вверх" : "Переместить фильтр вверх",
	"Переместить фильтр вниз" : "Переместить фильтр вниз",
	"Удалить фильтр" : "Удалить фильтр",
	"Размер шрифта" : "Размер шрифта",
	"Смещение" : "Смещение",
	"Смещение по x" : "Смещение по x",
	"Смещение по y" : "Смещение по y",
	"Имя атрибута" : "Имя атрибута",
	"Граница обрезки" : "Граница обрезки",
	"Граница" : "Граница",
	"Толщина линии" : "Толщина линии",
	"Заливка" : "Заливка",
    "Заливка цветом": "Заливка цветом",
    "Заливка штриховкой": "Заливка штриховкой",
    "Заливка рисунком": "Заливка рисунком",
    "Ширина паттерна": "Ширина паттерна",
    "Ширина отступа": "Ширина отступа",
    "URL рисунка": "URL рисунка",
	"Маркер URL" : "Маркер URL",
	"URL изображения" : "URL изображения",
    "Изображение" : "Изображение",
	"Размер точек" : "Размер точек",
	"Редактировать стили" : "Редактировать стили",
	"Авторизуйтесь для редактирования настроек слоя" : "Авторизуйтесь для редактирования настроек слоя",
	"Недостаточно прав для редактирования настроек слоя" : "Недостаточно прав для редактирования настроек слоя",
	"Недостаточно прав для редактирования объектов слоя" : "Недостаточно прав для редактирования объектов слоя",
	"ID" : "ID",
	"Описание" : "Описание",
	"Файл" : "Файл",
	"Таблица" : "Таблица",
	"Каталог с тайлами" : "Каталог с тайлами",
	"Каталог растров" : "Каталог растров",
    "Источник": "Источник",
    "Данные с датой": "Разбить по датам",

    "Дополнительно": "Дополнительно",
    "Шаблон названий объектов": "Шаблон названий объектов",
	"Y (широта)" : "Y (широта)",
	"X (долгота)" : "X (долгота)",
	"Каталог" : "Каталог",
	"Изменить" : "Изменить",
	"Создать" : "Создать",
	"Вид вложенных элементов" : "Вид вложенных элементов",
	"Использовать KosmosnimkiAPI" : "Загрузить подложки Kosmosnimki",
	"Использовать OpenStreetMap" : "Использовать OpenStreetMap",
	"Язык по умолчанию" : "Язык по умолчанию",
    "Единицы длины": "Единицы длины",
    "Единицы площади": "Единицы площади",
	"Формат координат": "Формат координат",
    "units.auto": "авто",
    "units.m": "м",
    "units.km": "км",
    "units.nm": "м. мили",
    "units.m2": "м<sup>2",
    "units.ha": "га",
    "units.km2": "км<sup>2",
	"coords.dd" : "dd.dddd",
	"coords.dms" : "dd°mm′ss″",
	"Генерализация" : "Генерализация",
	"gereralization.on": "включить",
	"gereralization.off": "выключить",
	"gereralization.disable": "использовать настройки слоев",
	"Количество информационных окошек" : "Количество информационных окошек",
    "layerOrder.title": "Порядок слоёв",
    "layerOrder.native": "Стандартный",
    "layerOrder.vectorOnTop": "Вектора сверху",
	"Разрешить поиск в векторных слоях" : "Разрешить поиск в векторных слоях",
	"Начальная позиция" : "Начальная позиция",
	"Широта" : "Широта",
	"Долгота" : "Долгота",
	"placeholder degrees": "dd.dddd",
	"placeholder zoom": "1-21",
	"placeholder minZoom": "1",
	"placeholder maxZoom": "21",
	"Зум" : "Зум",
	"Ссылка (permalink)" : "Ссылка (permalink)",
	"Разрешить скачивание" : "Разрешить скачивание",
	"Векторных слоев" : "Векторных слоев",
	"Растровых слоев" : "Растровых слоев",
	"Масштабирование в миникарте" : "Масштабирование в миникарте",
	"Показывать всплывающие подсказки" : "Показывать всплывающие подсказки",
	"Свойства" : "Свойства",
	"Стили" : "Стили",
	"Изображение на карте" : "Изображение на карте",
	"Слой [value0]" : "Слой [value0]",
    "Стили слоя [value0]" : "Стили слоя [value0]",
	"Мультислой [value0]" : "Мультислой [value0]",
	"Группа [value0]" : "Группа [value0]",
	"Карта [value0]" : "Карта [value0]",
	"Редактировать стиль" : "Редактировать стиль",
	"Редактирование стилей объекта" : "Редактирование стилей объекта",
	"Стили слоя" : "Стили слоя",
	"Навигация по карте и инструменты" : "Навигация по карте и инструменты",
	"Список слоев" : "Список слоев",
	"Стиль векторного слоя" : "Стиль векторного слоя",
	"Управление содержанием карты" : "Управление содержанием карты",
	"Пользовательские инструменты" : "Пользовательские инструменты",
	"$$help$$_1" : "Держите нажатой левую клавишу мыши – перетаскивайте карту курсором. Для приближения и удаления используйте колесико мыши (карта зуммируется к точке под курсором). Для перецентровки по координатам – введите их в строке поиска.",
	"$$help$$_2" : "В левой панели отображается список слоев в виде дерева. Для перецентровки карты по экстенту слоя – кликните по его названию в списке. Если данная опция включена администратором карты, вы можете скачивать векторные слои и вырезать и скачивать фрагменты растровых слоев.",
	"$$help$$_3" : "Для редактирования стиля векторного слоя кликните на иконку перед названием слоя.",
	"$$help$$_4" : "Карта представляет собой набор слоев, отображение которого задается с помощью списка слоев. Чтобы иметь возможность редактировать набор слоев (создавать группы, изменять порядок отображения и т.д.) и сохранять изменения – необходимо авторизоваться. Более подробно см ",
	" - Руководство пользователя" : " - Руководство пользователя",
	"$$help$$_5" : "Пользовательские инструменты одновременно служат для создания объектов на карте, которые затем можно сохранять через «ссылку на карту», и для выполнения простых аналитических функций. ",
	"В режиме маркеров: " : "В режиме маркеров: ",
	"$$help$$_6" : "одиночный клик - добавить маркер. Двойной клик по маркеру - удалить. Клик на маркер – открыть всплывающее окошко (балун), клик по балуну – добавить надпись.",
	"В режиме линейка/измерения расстояния, полигон/измерение площади: " : "В режиме линейка/измерения расстояния, полигон/измерение площади: ",
	"$$help$$_7" : "одиночный клик - добавить вершину. Двойной клик - завершить фигуру. Клик на линию - добавить вершину. Двойной клик по вершине - удалить.",
	"$$help$$_8" : "Кликните по объекту в списке «объектов на карте», чтобы перецентровать карту на него. Вы можете скачать контуры объектов в shp/tab/kml формате.",
	"$$about$$_1" : "это веб-приложение для интерактивного просмотра геоданных и доступа к источникам базовых геоданных в интернете, таким как: ",
	"$$about$$_2" : "С помощью GeoMixer можно публиковать собственные геоданные во внутренней сети предприятий или в интернет, накладывать их поверх базовых источников и предоставлять к ним доступ для совместной работы сколь угодно большому числу пользователей, разграничивая права доступа.",
	"$$about$$_3" : "GeoMixer также включает компонент API, который позволяет встраивать созданные проекты в сторонние веб-сайты и приложения и программно управлять фукционалом интерактивной карты.",
	" - Общее описание" : " - Общее описание",
	" - Руководство разработчика" : " - Руководство разработчика",
	"Создать" : "Создать",
	"Получить API-ключ" : "Получить API-ключ",
	"Введите API-ключ" : "Введите API-ключ",
	"Печать карты" : "Печать карты",
	"$$serviceHelp$$_1" : "Позволяет на лету загрузить shp/tab/kml файл небольшого размера в виде пользовательских объектов. После загрузки пользователь может редактировать геометрию объектов и скачивать объекты в том же наборе форматов.",
	"$$serviceHelp$$_2" : "По ссылке запоминается текущее положение карты, а так же пользовательские объекты и надписи.",
	"$$serviceHelp$$_3" : "Отправляет на печать текущий фрагмент карты.",
	"Редактировать" : "Редактировать",
    "Удалить объект?": "Удалить объект?",
    "Удалить отмеченные объекты?": "Удалить отмеченные объекты?",
	"Координаты" : "Координаты",
	"Длина" : "Длина",
	"Площадь" : "Площадь",
	"Добавить подгруппу" : "Добавить группу",
	"Введите имя группы" : "Создание новой группы",
	"Имя группы" : "Имя группы",
	"Включая вложенные слои" : "Включая вложенные слои",
	"Удаление группы [value0]" : "Удаление группы [value0]",
	"Сохранено" : "Сохранено",
	"Прозрачность выбранного слоя/группы/карты" : "Прозрачность выбранного слоя/группы/карты",
	"$$updateInfo$$_1" : "Для отображения нового слоя необходимо сохранить и перезагрузить карту",
	"Любой" : "Любой",
	"Векторный" : "Векторный",
	"Растровый" : "Растровый",
	"Название" : "Название",
	"Владелец" : "Владелец",
	"Последнее изменение": "Последнее изменение",
	"Список слоев" : "Список слоев",
	"Вы действительно хотите удалить этот слой?" : "Вы действительно хотите удалить этот слой?",
	"Ошибка!" : "Ошибка!",
	"Список карт" : "Список карт",
	"Показать" : "Показать",
	"загрузка..." : "загрузка...",
	"удаление..." : "удаление...",
	"Вы действительно хотите удалить эту карту?" : "Вы действительно хотите удалить эту карту?",
    "maplist.hint": "Группы и слои можно перетащить в текущую карту",
	"Слоя нет в базе" : "Слоя нет в базе",
	"ScanEx Web Geomixer - просмотр карты" : "ScanEx Web Geomixer - просмотр карты",
	"Изменить параметры поиска" : "Изменить параметры поиска",
	"$$search$$_1" : "Поиск по векторным слоям и адресной базе",
	"$$search$$_2" : "Поиск по адресной базе",
	"Поиск не дал результатов" : "Поиск не дал результатов",
	"Очистить" : "Очистить",
	"Регистрация" : "Регистрация",
	"Восстановление пароля" : "Восстановление пароля",
	"Вход" : "Вход",
	"Выход" : "Выход",
	"Логин" : "Логин",
	"Пароль" : "Пароль",
	"пароль" : "пароль",
    "Псевдоним": "Псевдоним",
    "Полное имя": "Полное имя",
	"Пожалуйста, авторизуйтесь" : "Пожалуйста, авторизуйтесь",
    "адрес электронной почты": "адрес электронной почты",
	"Ошибка сервера" : "Ошибка сервера",
	"Папка" : "Папка",
	" и " : " и ",
	"Название" : "Название",
	"Рейтинг" : "Рейтинг",
	"Автор" : "Автор",
	"Тематика" : "Тематика",
	"Развлекательная" : "Развлекательная",
	"Спортивная" : "Спортивная",
	"Историческая" : "Историческая",
	"Экологическая" : "Экологическая",
	"Любая" : "Любая",
	"Создать новую тему" : "Создать новую тему",
	"Начало периода" : "Начало периода",
	"Окончание периода" : "Окончание периода",
	"Накладываемые тайлы" : "Накладываемые тайлы",
	"Отображать с зума" : "Отображать с зума",
	"По" : "по",
	"Фильтр" : "Фильтр",
	"Подпись" : "Подпись",
	"Балун" : "Подсказка при наведении и клике",
	"По умолчанию" : "По умолчанию",
	"Показывать при клике": "Показывать при клике",
	"Показывать при наведении": "Показывать при наведении",
	"Символика" : "Символика",
    "Библиотека стилей": "Библиотека стилей",
    "Настройка стилей": "Настройка стилей",
	"скопировать": "скопировать",
	"применить везде": "применить везде",
	"Кластеризация" : "Кластеризация",
	"Минимальный" : "Минимальный",
	"Максимальный" : "Максимальный",
	"Мин. зум" : "Мин. зум",
	"Макс. зум" : "Макс. зум",
	"Тип" : "Тип",
	"Пешеходная" : "Пешеходная",
	"Велосипедная" : "Велосипедная",
	"Автомобильная" : "Автомобильная",
	"Речная" : "Речная",
	"Места" : "Места",
	"Маршрут" : "Маршрут",
	"Редактировать экскурсию" : "Редактировать экскурсию",
	"Добавьте маршрут" : "Добавьте маршрут",
	"Выберете темы на пути следования" : "Выберете темы на пути следования",
	"$$phrase$$_11" : "Добавьте маршрут при помощи инструмента \"Линия\" на панели инструментов",
	"$$phrase$$_12" : "Нет подходящих объектов на карте",
	"Выбор маршрута" : "Выбор маршрута",
	"Выбор мест" : "Выбор мест",
	"$$phrase$$_13" : "У вас нет опубликованных тем на карте. Вы можете добавить тему в разделе Вид-Обсуждения",
	"Обсуждения" : "Обсуждения",
	"Экскурсии" : "Экскурсии",
	"$$phrase$$_14" : "Невозможно удалить карту, использующуюся в качестве карты по умолчанию",
	"$$phrase$$_15" : "Невозможно удалить загруженную карту",
	"Назад" : "Назад",
	"Вперед" : "Вперед",
	"$$phrase$$_16" : "Альбома с указанным ID изображения не существует",
	"Редактировать альбом" : "Редактировать альбом",
	"Оценить" : "Оценить",
	"Поставьте маркер" : "Поставьте маркер",
	"на карту и переместите его в нужное место." : "на карту и переместите его в нужное место.",
	"Недостаточно прав для совершения операции" : "Недостаточно прав для совершения операции",
	"Новая папка" : "Новая папка",
	"Выбрать" : "Выбрать",
	"Добавить" : "Добавить",
	"$$serviceHelp$$_4" : "Пользователь может встроить созданную карту в другой сайт, скопировав код и вставив его внутрь HTML. Требуется указать api-ключ для сайта, на котором будет использоваться данный код.",
	"Масштаб" : "Масштаб",
	"Угол поворота" : "Угол поворота",
	"Диаграммы" : "Диаграммы",
	"График по времени" : "График по времени",
	"Круговая" : "Круговая",
	"Маска атрибутов" : "Маска атрибутов",
	"Закладки" : "Закладки",
	"Добавить закладку" : "Добавить закладку",
	"Имя закладки" : "Имя закладки",
	"Дерево" : "Дерево",
	"Поиск слоев" : "Поиск слоев",
	"Пример выражения": "[Атрибут1]\n[Атрибут2]\nпроизвольный текст",
	"Шкала прозрачности" : "Шкала прозрачности",
	"Цвет заливки" : "Цвет заливки",
	"Цвет обводки" : "Цвет обводки",
	"Цвет шрифта" : "Цвет шрифта",
	"Легенда" : "Легенда",
	"Событие загрузки карты" : "Событие загрузки карты",
	"Мин" : "Мин",
	"Макс" : "Макс",
	"График" : "График",
	"Гистограмма" : "Гистограмма",
	"Столбчатая" : "Столбчатая",
	"Временная" : "Временная",
	"Круговая" : "Круговая",
	"Копировать стиль" : "Копировать стиль",
	"Применить стиль" : "Применить стиль",
	"Не выбран стиль" : "Не выбран стиль",
	"Невозможно применить стиль к другому типу геометрии" : "Невозможно применить стиль к другому типу геометрии",
	"Общие" : "Общие",
	"Доступ" : "Доступ",
	"Окно карты" : "Окно карты",
	"Загрузка" : "Загрузка",
	"Копирайт" : "Копирайт",
	"Инструменты" : "Инструменты",
	"Загрузить KML" : "Загрузить KML",
	"URL файла" : "URL файла",
	"Поиск" : "Поиск",
    "Подложки": "Подложки",
    "Доступные подложки": "Доступные подложки",
    "Подложки карты": "Подложки карты",
    "Выберите слои для поиска по атрибутам": "Выберите слои для поиска по атрибутам",
	"Включить синхронизацию слоев": "Включить синхронизацию слоев",
	"Выключить синхронизацию слоев": "Выключить синхронизацию слоев",

	"Редактирование прав доступа карты [value0]" : "Редактирование прав доступа карты [value0]",
	"Редактирование прав доступа слоя [value0]" : "Редактирование прав доступа слоя [value0]",
	"Редактирование прав доступа слоев карты [value0]" : "Редактирование прав доступа слоев карты [value0]",
	"Состав группы [value0]" : "Состав группы [value0]",
	"Роль" : "Роль",
	"Добавить пользователя" : "Добавить пользователя",
	"Права доступа" : "Права доступа",
	"Права доступа к слоям" : "Права доступа к слоям",
	"Пользователи без прав доступа:" : "Пользователи без прав доступа:",
	"Пользователи с правами доступа:" : "Пользователи с правами доступа:",
	"Выберите нового владельца" : "Выберите нового владельца",
	"Сменить владельца" : "Сменить владельца",

	"Объекты RuMap" : "Данные RuMap",
	"Объекты пользователей" : "Данные пользователей",


	"Контакты" : "Контакты",
	"Фотографии" : "Фотографии",
	"Момент съемки" : "Момент съемки",
	"Видео" : "Видео",
	"Сообщения" : "Сообщения",
	"Ссылка на место" : "Ссылка на место",
	"Ссылка на экскурсию" : "Ссылка на экскурсию",
	"Ссылка на событие" : "Ссылка на событие",
	"Создать новое событие" : "Создать новое событие",
	"События" : "События",
	"Календарь" : "Календарь",
	"Новости" : "Новости",
	"Мероприятия" : "Мероприятия",
	"Отмена" : "Отмена",
	"Пропустить" : "Пропустить",
	"Время" : "Время",
	"Альбом OpenPhotoVR" : "Фотоальбом",
	"Встраиваемый код" : "Встраиваемое видео",

	"Объекты экологического риска" : "Объекты экологического риска",
		"Санкционированные свалки" : "Санкционированные свалки",
		"Несанкционированные свалки" : "Несанкционированные свалки",
		"Полигоны отходов" : "Полигоны отходов",
		"Предприятия переработки отходов" : "Предприятия переработки отходов",
		"Факельные установки, ТЭЦ, трубы" : "Факельные установки, ТЭЦ, трубы",
		"Закрытые свалки" : "Закрытые свалки",
		"Пункты приема отходов" : "Пункты приема отходов",
		"Оползни" : "Оползни",
		"Карстовые явления" : "Карстовые явления",
		"Суффозионные явления" : "Суффозионные явления",

	"Государство и общество" : "Государство и общество",
		"Радио" : "Радиостанции",
		"Правительственные учреждения" : "Правительственные учреждения",
		"Оптики" : "Оптики",
		"Охранные агенства" : "Охранные агенства",
		"Травмпункты" : "Травмпункты",
		"Таможня" : "Таможня",
		"Ветеринарные клиники" : "Ветеринарные клиники",
		"ЗАГС" : "ЗАГС",
		"Больницы" : "Больницы",
		"Аптеки" : "Аптеки",
		"Поликлиники" : "Поликлиники",
		"Колледжи" : "Колледжи",
		"Университеты" : "Университеты",
		"ОВИР" : "ОВИР",
		"Посольства" : "Посольства",
		"Почтовые отделения" : "Почтовые отделения",
		"Суды" : "Суды",
		"Банки" : "Банки",
		"Родильные дома" : "Родильные дома",
		"Дома престарелых" : "Дома престарелых",
		"Детские сады" : "Детские сады",
		"Школы" : "Школы",
		"Инспекции" : "Инспекции",
		"Адвокаты" : "Адвокаты",
		"МЧС" : "МЧС",
		"Муниципальные учреждения" : "Муниципальные учреждения",
		"Администрация" : "Администрация",

	"Культура и отдых" : "Культура и отдых",
		"Боулинг" : "Боулинг",
		"Аквапарки" : "Аквапарки",
		"Парки развлечений" : "Парки развлечений",
		"Библиотеки" : "Библиотеки",
		"Памятники" : "Памятники",
		"Лагери отдыха" : "Лагери отдыха",
		"Кинотеатры" : "Кинотеатры",
		"Цирки" : "Цирки",
		"Галереи" : "Галереи",
		"Отели" : "Отели",
		"Мотели" : "Мотели",
		"Музеи" : "Музеи",
		"Концертные залы" : "Концертные залы",
		"Ночные клубы" : "Ночные клубы",
		"Театры" : "Театры",
		"Санатории" : "Санатории",
		"Зоопарки" : "Зоопарки",

	"Общественное питание" : "Общественное питание",
		"Кафе" : "Кафе",
		"Фастфуды" : "Фастфуды",
		"Рестораны" : "Рестораны",
		"Кафе-мороженое" : "Кафе-мороженое",
		"Столовые" : "Столовые",

	"Природные достопримечательности" : "Природные достопримечательности",
		"Ботанический сад" : "Ботанические сады",
		"Пещеры" : "Пещеры",
		"Водопады" : "Водопады",
		"Парки" : "Парки",
		"Источники" : "Источники",
		"Заповедники" : "Заповедники",
		"Прочие архитектурные и природные достопримечательности" : "Архитектурные достопримечательности",

	"Религия" : "Религия",
		"Культовые сооружения" : "Культовые сооружения",
		"Мечети" : "Мечети",
		"Монастыри" : "Монастыри",
		"Церкви других христианских конфессий" : "Церкви других христианских конфессий",
		"Православные церкви" : "Православные церкви",
		"Синагоги" : "Синагоги",

	"Спорт" : "Спорт",
		"Стадионы" : "Стадионы",
		"Теннисные корты" : "Теннисные корты",
		"Катки" : "Катки",
		"Ипподромы" : "Ипподромы",
		"Фитнес" : "Фитнес",
		"Бассейны" : "Бассейны",
		"Прокат спортинвентаря" : "Прокат спортинвентаря",

	"Торговля и услуги" : "Торговля и услуги",
		"Солярии" : "Солярии",
		"Интернет-кафе" : "Интернет-кафе",
		"Рынки" : "Рынки",
		"Стоматологические клиники" : "Стоматологические клиники",
		"Магазины одежды" : "Магазины одежды",
		"Парикмахерские" : "Парикмахерские",
		"Бани" : "Бани",
		"Магазины обуви" : "Магазины обуви",
		"Магазины" : "Магазины",
		"Ателье" : "Ателье",
		"Такси" : "Такси",
		"Туризм" : "Туризм",

	"Транспорт и услуги" : "Транспорт и услуги",
		"Аэропорты" : "Аэропорты",
		"Автосервисы" : "Автосервисы",
		"Автовокзалы" : "Автовокзалы",
		"ДПС" : "ДПС",
		"ГИБДД" : "ГИБДД",
		"Шиномонтаж" : "Шиномонтаж",
		"Парковки бесплатные" : "Парковки бесплатные",
		"Парковки платные" : "Парковки платные",
		"АЗС" : "АЗС",
		"Автомойки" : "Автомойки",

	"Экстренные службы" : "Экстренные службы",
		"Пожарные/спасатели" : "Пожарные/спасатели",
		"Милиция" : "Милиция",
		"Скорая помощь" : "Скорая помощь",

	"Другие темы" : "Другие темы",
		"Разное" : "Разное",

	"Изменение пароля" : "Изменение пароля",
	"Новый пароль" : "Новый пароль",
	"Старый пароль" : "Старый пароль",
	"Подтвердите пароль" : "Подтвердите пароль",
	"Контур" : "Контур",
	"$$phrase$$_17" : "Добавьте контур при помощи инструмента \"Полигон\" на панели инструментов",
	"Выбор контура" : "Выбор контура",
	"Таблица атрибутов слоя [value0]" : "Таблица атрибутов слоя [value0]",
	"Показать параметры поиска" : "Показать параметры поиска",
	"Скрыть параметры поиска" : "Скрыть параметры поиска",
	"SQL-условие WHERE" : "SQL-условие WHERE",
    "Искать внутри полигона" : "Искать внутри полигона",
	"Показывать столбцы" : "Показывать столбцы",
	"Найти" : "Найти",
	"Нет полей" : "Нет полей",
	"Нет данных" : "Нет данных",
	"Таблица атрибутов" : "Таблица атрибутов",
	"Разрешить поиск" : "Разрешить поиск",
	"Произвольный" : "Произвольный",
	"День" : "День",
	"Неделя" : "Неделя",
	"Месяц" : "Месяц",
	"Год" : "Год",
	"Ежегодно" : "Ежегодно",
	"Облачность" : "Облачность",
	"Период" : "Период",
	"Спутниковые покрытия" : "Спутниковые покрытия",
	"Редактировать объект слоя [value0]" : "Редактировать объект слоя [value0]",
	"Создать объект слоя [value0]" : "Создать объект слоя [value0]",
	"Геометрия" : "Геометрия",
	"Добавить объект" : "Добавить объект",
	"Очистить поиск" : "Очистить поиск",
    "Скачать shp": "Скачать shp",
    "Скачать gpx": "Скачать gpx",
    "Скачать csv": "Скачать csv",
    "Скачать geojson": "Скачать geojson",
    "Рассчитать площадь": "Суммарная площадь",
	"Создать столбец" : "Создать столбец",
	"Мультислой" : "Мультислой",
	"В дереве слоев остались несохраненные изменения!" : "В дереве слоев остались несохраненные изменения!",
	"файл версии отсутствует" : "файл версии отсутствует",
	"Хост" : "Хост",
	"Дополнительные карты" : "Дополнительные карты",
	"Добавить карту" : "Добавить карту",
	"Невозможно загрузить карту [value0] с домена [value1]" : "Невозможно загрузить карту [value0] с домена [value1]",
	"Показывать" : "Показывать",
	"Поиск снимков" : "Поиск снимков",
	"Принудительно обновить тайлы" : "Принудительно обновить тайлы",
	"Обводка" : "Обводка",
	"Карта имеет более новую версию. Сохранить?" : "Карта имеет более новую версию. Сохранить?",
	"Кодировка": "Кодировка",
	"helpPostfix": "_rus.html",
	"Показывать чекбокс видимости": "Чекбокс видимости",
	"Разворачивать автоматически": "Разворачивать автоматически",
	"Другая": "Другая",
	"Временнóй слой": "Мультивременнóй слой",
	"Колонка даты": "Колонка даты",
	"Минимальный период": "Мин. период (дни)",
	"Максимальный период": "Макс. период (дни)",
    "Отсутствует временной атрибут": "Отсутствует атрибут типа 'Дата'",
    "Период 1 день": "Период 1 день",
    "Показывать на карте данные за": "Показывать на карте данные за",
    "1 день": "1 день",
    "произвольный период" : "произвольный период",
	"По границе экрана": "По границе экрана",
	"По центру экрана": "По центру экрана",
	"Пересечение": "Пересечение",
	"Пролистывать слои": "Пролистывать слои",
	"Следующий слой": "Следующий слой",
	"Предыдущий слой": "Предыдущий слой",
    "Геометрия не сохранена. Эта возможность будет реализована в будущих версиях Геомиксера.": "Геометрия не сохранена. Эта возможность будет реализована в будущих версиях Геомиксера.",
    "WMS доступ": "WMS/WFS доступ",
    "ссылка": "ссылка",
    "Слой '[value0]' уже есть в карте": "Слой '[value0]' уже есть в карте",
    "Группа '[value0]' уже есть в карте": "Группа '[value0]' уже есть в карте",
    "Плагины": "Плагины",
    "Вручную": "Вручную",
    "Добавить атрибут": "Добавить поле",
    "Проекция": "Проекция",
    "Широта/Долгота (EPSG:4326)": "Широта/Долгота (EPSG:4326)",
    "Меркатор (EPSG:3395)": "Меркатор (EPSG:3395)",
    "Из файла": "Из файла",
    "Мультиполигон": "Мультиполигон",
    "Мультилиния": "Мультилиния",
    "Мультиточка": "Мультиточка",
    "Администрирование": "Администрирование",
    "Системные настройки": "Системные настройки",
    "Управление группами": "Управление группами",
    "Управление группами пользователей": "Управление группами пользователей",
    "Добавить снимки": "Добавить растры",
    "Существующие слои": "Существующие слои",
    "Слои из карты": "Слои из карты",
    "Слои из КР": "Слои из КР",
    "Новый слой": "Новый слой",
    "С экрана": "С экрана",
    "Добавлен растр": "Добавлен растр",
    "Добавлены растры": "Добавлены растры",
    "Выбранный объект не имеет растра": "Выбранный объект не имеет растра",
    "Этот растр уже был выбран": "Этот растр уже был выбран",
    "Каталог Растров": "Каталог растров",
    "Растр": "Растр",
    "Добавить выбранные растры": "Добавить выбранные растры",
    "EditObject.menuTitle" : "Добавить объект",
    "FileBrowser.ExceedLimitMessage" : "Размер файла превышает 500 Мб. Используйте GeoMixerFileBrowser для загрузки больших файлов.",
    "FileBrowser.DropInfo" : "Перетащите файлы сюда",
    "EditObject.drawingMenuTitle" : "Добавить объект в активный слой",
    "Поставить маркер": "Поставить маркер",
    "Центрировать": "Центрировать",
    "Пароль изменён": "Пароль изменён",
	"портретная": "портретная",
	"альбомная": "альбомная"
};


_translationsHash.flags["eng"] = "img/flag_en.png";

_translationsHash.titles["eng"] = "English";

_translationsHash.hash["eng"] = {
	"Да": "Yes",
	"Нет": "No",
	"Карта" : "Map",
	"Создать" : "Create",
	"Создать карту" : "Create map",
	"Сохранить" : "Save",
	"Сохранить как" : "Save as",
	"Сохранить карту как" : "Save map as",
	"Сохранить карту" : "Save map",
	"Экспорт" : "Export",

    "Карта пожаров": "Fires map",
    "Поиск снимков": "Search Imagery",
    "Платформа Геомиксер": "GeoMixer Web-GIS",
    "http://fires.ru": "http://fires-map.com",
    "http://search.kosmosnimki.ru": "http://search.kosmosnimki.ru/index_eng.html",

    "Данные": "Datasets",
    "Сервисы": "Services",
    "Поделиться": "Share",
    "Открыть слой": "Open layer",
    "Создать слой": "Create layer",
    "Растровый": "Raster",
    "Векторный": "Vector",
    "Создать группу": "Create group",
    "Базовые слои": "Base layers",
    "Подключить WMS": "Add WMS",
    "Подключить WFS": "Add WFS",
    "Объекты": "User objects",
    "Результаты поиска": "Search results",
    "Буфер": "Buffer",
    "Ручная привязка растров": "Manual rasters shift",
    "Поиск слоев на карте": "Search layers on map",
    "Краудсорсинг данных": "Crowdsourcing",
    "Пакетный геокодинг": "Batch geocode",
    "Маршруты": "Directions",
    "Кадастр Росреестра": "Cadastre data of Rosreestr",
    "Выбрать кадастровый объект": "Select Cadastre item",
    "Викимапиа": "Wikimapia",
    "Каталог СКАНЭКС": "Search imagery",
    "Космоснимки-пожары": "Kosmosnimki-fires",
    "GIBS NASA": "MODIS Images (NASA)",
    "Руководство пользователя": "Documentation",
    "GeoMixer API": "GeoMixer API",
    "Использование плагинов": "Plugins usage",
	"копия": "копия",

	"Открыть" : "Open",
	"Слой" : "Layer",
	"Создать векторный слой" : "Create vector layer",
	"Создать растровый слой" : "Create raster layer",
    "Создать мультислой" : "Create multilayer",
	"Вид" : "View",
	"Дерево слоев" : "Layers tree",
	"Объекты на карте" : "Objects on map",
	"Результаты поиска" : "Search results",
	"Координатная сетка" : "Coordinate grid",
	"Индексная сетка" : "Index grid",
	"Сервисы" : "Services",
	"Загрузить объекты" : "Upload objects",
	"Загрузить фотографии" : "Upload photos",
	"Загрузить данные" : "Load data",
		"WFS сервер" : "WFS server",
		"WMS сервер" : "WMS server",
		"Кадастровые данные" : "Cadastre data",
	"Ссылка на карту" : "Link to the map",
	"Код для вставки" : "Embed code",
	"Печать" : "Print",
	"Привязать изображение" : "Bind image",
	"Сообщить об ошибке на карте" : "Report a map error",
	"Справка" : "Help",
	"Использование" : "Usage",
	"Сервисы" : "Services",
	"О проекте" : "About/Contacts",
	"$$phrase$$_1" : "Choose parameter defaultMapID in config.js file",
	"У вас нет прав на просмотр данной карты" : "Sorry, you don’t have permission to view this map",
	"Access error" : "Sorry, you don’t have permission to view this map",
	"Map not found" : "Sorry, this map not found",
	"Unable to locate EXIF content" : "Unable to locate EXIF content",
	"Развернуть карту" : "Unfold map",
	"Свернуть карту" : "Fold map",
	"Точки на изображении:" : "Points on image:",
	"Точки на карте:" : "Points on map:",
	"Координаты" : "Coordinates",
	"Нарисовать" : "Draw",
	"Восстановить" : "Restore",
	"Прозрачность" : "Transparency",
	"Видимость" : "Visibility",
	"Привязка изображения" : "Image binding",
	"$$phrase$$_2" : "Point [value0] is outside the limits of image",
	"$$phrase$$_3" : "Point [value0] is not specified on a map",
	"Соответствие точек" : "Point correspondence",
	"$$phrase$$_4" : "Points 1 and 2 coincide at the image",
	"$$phrase$$_5" : "Points 1 and 3 coincide at the image",
	"$$phrase$$_6" : "Points 2 and 3 coincide at the image",
	"$$phrase$$_7" : "Points 1 and 2 coincide at the map",
	"$$phrase$$_8" : "Points 1 and 3 coincide at the map ",
	"$$phrase$$_9" : "Points 2 and 3 coincide at the map ",
	"$$phrase$$_10" : "Points lie on a straight line at the image ",
	"Создать экскурсию" : "Create guide",
	"Чтобы пользоваться этим сайтом, установите Flash Player" : "To use this web site, please, install Flash Player",
	"из Интернет" : "from Internet",
	"или с локального диска " : "or from local disc",
	"для Internet Explorer" : "for Internet Explorer",
	" или " : " or ",
	"для Firefox" : "for Firefox",
	"Скачать shp-файл" : "Download shp-file",
	"shp-файл" : "shp-file",
	"gpx-файл" : "gpx-file",
	"Скачать фрагмент растра" : "Download fragment of raster",
	"Очистить" : "Delete",
	"точка" : "point",
	"линия" : "line",
	"прямоугольник" : "rectangle",
	"многоугольник" : "polygon",
	"Скачать" : "Download",
	"Введите имя файла для скачивания" : "Enter file name to download",
	"Выберите область рамкой на карте" : "Select region using frame",
	"Вырезать фрагмент растра" : "Cut fragment of raster",
	"К прямоугольнику не подходит ни одного растрового слоя" : "No one raster layer fit the rectangle",
	"Загруженный shp-файл пуст" : "The uploaded shp-file is empty",
	"Ошибка скачивания" : "Download error",
	"Обновить" : "Update",
	"Домашняя директория" : "Project directory",
	"Имя папки" : "Folder name",
	"Имя" : "Name",
	"Тип" : "Type",
	"Размер" : "Size",
	"Дата" : "Date",
    "Дата создания": "Дата создания",
	"Снять выделение" : "Clear selection",
	"Скопировать" : "Copy",
	"Удалить" : "Delete",
	"Извлечь" : "Extract",
	"Упаковать" : "Add to archive",
	"Загрузить" : "Download",
    "Параметр" : "Parameter",
    "Значение" : "Value",
    "Метаданные": "Metadata",
    "Поля": "Attributes",
    "Редактировать поля": "Edit attributes",
	"URL сервера" : "Server URL",
	"Формат изображения" : "Image format",
	"Введите имя gml-файла для скачивания:" : "Enter gml-file name to download:",
	"точки" : "points",
	"линии" : "lines",
	"полигоны" : "polygons",
	"(ссылка)" : "(link)",
	"Сохранить состояние карты" : "Save map state",
	"Ссылка на текущее состояние карты" : "Link to the map",
	"Добавить стиль" : "Add style",
	"Атрибут >" : "Attribute >",
	"Значение >" : "Value >",
	"Операция >" : "Operation >",
	"Накладываемое изображение" : "Ground overlay",
	"Цвет" : "Color",
	"Авторизуйтесь для редактирования фильтров" : "Authorize to edit filters",
	"Имя фильтра" : "Filter name",
	"Переместить фильтр вверх" : "Move filter up",
	"Переместить фильтр вниз" : "Move filter down",
	"Удалить фильтр" : "Delete filter",
	"Размер шрифта" : "Typesize",
	"Смещение" : "Shift",
	"Смещение по x" : "X shift",
	"Смещение по y" : "Y shift",
	"Имя атрибута" : "Attribute name",
	"Граница обрезки" : "Clip region",
	"Граница" : "Outline",
	"Толщина линии" : "Line thickness",
	"Заливка" : "Fill",
    "Заливка цветом": "Color fill",
    "Заливка штриховкой": "Pattern fill",
    "Заливка рисунком": "Image fill",
    "Ширина паттерна": "Pattern width",
    "Ширина отступа": "Indent width",
    "URL рисунка": "Image URL",
	"Маркер URL" : "Icon URL ",
	"URL изображения" : "Image URL",
    "Изображение" : "Image",
	"Размер точек" : "Point size",
	"Редактировать стили" : "Edit styles",
	"Авторизуйтесь для редактирования настроек слоя" : " Authorize to edit layer properties",
	"Недостаточно прав для редактирования настроек слоя" : "You have not enough permission to edit layer properties ",
	"Недостаточно прав для редактирования объектов слоя" : "You have not enough permission to edit layer objects ",
	"ID" : "ID",
	"Описание" : "Description",
	"Файл" : "File",
	"Таблица" : "Table",
	"Каталог с тайлами" : "Tile catalogue",
    "Каталог растров" : "Raster catalogue",
    "Данные с датой": "Split through time",
    "Источник": "Source",
    "Дополнительно": "Advanced options",
    "Шаблон названий объектов": "Objects title template",
	"Y (широта)" : "Y (latitude)",
	"X (долгота)" : "X (longitude)",
	"Каталог" : "Catalogue",
	"Изменить" : "Change",
	"Вид вложенных элементов" : "Form of attached elements",
	"Использовать KosmosnimkiAPI" : "Load Kosmosnimki base layers",
	"Использовать OpenStreetMap" : "Use OpenStreetMap",
	"Язык по умолчанию" : "Default language",
    "Единицы длины": "Distance unit",
    "Единицы площади": "Square unit",
	"Формат координат": "Coordinates format",
    "units.auto": "auto",
    "units.m": "m",
    "units.km": "km",
    "units.nm": "nmi",
    "units.m2": "m<sup>2</sup>",
    "units.ha": "ha",
    "units.km2": "km<sup>2</sup>",
	"coords.dd" : "dd.dddd",
	"coords.dms" : "dd°mm′ss″",
	"Генерализация" : "Generalization",
	"gereralization.on": "on",
	"gereralization.off": "off",
	"gereralization.disable": "use layers settings",
	"Количество информационных окошек" : "Max popup count",
    "layerOrder.title": "Layers order",
    "layerOrder.native": "Native",
    "layerOrder.vectorOnTop": "Vector on top",
	"Разрешить поиск в векторных слоях" : "Allow search vector layers",
	"Начальная позиция" : "Start position",
	"Широта" : "Latitude",
	"Долгота" : "Longitude",
	"placeholder degrees": "dd.dddd",
	"placeholder zoom": "1-21",
	"placeholder minZoom": "1",
	"placeholder maxZoom": "21",
	"Зум" : "Zoom",
	"Ссылка (permalink)" : "Permalink",
	"Разрешить скачивание" : "Allow to download",
	"Векторных слоев" : "Vector layers",
	"Растровых слоев" : "Raster layers",
	"Масштабирование в миникарте" : "Minimap zoom delta",
	"Показывать всплывающие подсказки" : "Show tooltips",
	"Свойства" : "Properties",
	"Стили" : "Styles",
	"Изображение на карте" : "Ground overlay",
	"Слой [value0]" : "Layer [value0]",
	"Стили слоя [value0]" : "Styles of layer [value0]",
	"Мультислой [value0]" : "Multilayer [value0]",
	"Группа [value0]" : "Group [value0]",
	"Карта [value0]" : "Map [value0]",
	"Редактировать стиль" : "Edit style",
	"Редактирование стилей объекта" : "Object styles editing",
	"Стили слоя" : "Layer styles",
	"Навигация по карте и инструменты" : "Map navigation and tools",
	"Список слоев" : "List of layers",
	"Стиль векторного слоя" : "Vector layer style",
	"Управление содержанием карты" : "Map content management",
	"Пользовательские инструменты" : "Users tools",
	"$$help$$_1" : "Hold mouse left button – move map with cursor. To zoom in or out use mouse wheel (or map zoom slider to zoom to the cursor position). In order to move map center to specified coordinates – enter coordinates in search line.",
	"$$help$$_2" : "Layer tree is represented in the left panel. To change map center according to layer extent – click its title in the list. If this option was activated by map administrator, you can download vector layers and cut and download raster layers fragments.",
	"$$help$$_3" : "To edit vector layer style click icon near layer name.",
	"$$help$$_4" : "Map is a collection of layers, which is displayed using layer tree. It is necessary to authorize to be able to edit the collection of layers (create groups, change display order etc.) and save changes. For more information see ",
	" - Руководство пользователя" : " – User guide",
	"$$help$$_5" : "User tools serve the purpose of creation of objects on map, which can be saved via «save link to the map», and, at the same time, simple analytic functions fulfillment.",
	"В режиме маркеров: " : "Creating markers: ",
	"$$help$$_6" : "single click – add marker. Double click on marker – delete. Click on marker – open pop-up window (balloon), click on balloon – add text.",
	"В режиме линейка/измерения расстояния, полигон/измерение площади: " : "Drawing lines/distance measurement, polygon/area measurement: ",
	"$$help$$_7" : "single click – add vertex. Double click – complete figure. Click on line – add vertex. Double click on vertex – delete.",
	"$$help$$_8" : "Click on object in list of «objects on map» to move map center to it. You can download object in shp/tab/kml format.",
	"$$about$$_1" : "this web application for interactive geodata view and access to basic data sources in the Internet, such as: ",
	"$$about$$_2" : " Using GeoMixer you can publish own geodata in intranet or in the Internet, put them over basic data coverages and give access to them for however large number of users, changing access permissions.",
	"$$about$$_3" : "GeoMixer also includes API component, which enables integrating the created projects into other web sites and applications and carry out program control over interactive map functional.",
	" - Общее описание" : " – General manual",
	" - Руководство разработчика" : " – Developer’s gudie",
	"Получить API-ключ" : "Get API-key",
	"Введите API-ключ" : "Enter API-key",
	"$$serviceHelp$$_1" : "Allows to upload small shp/tab/kml file on the fly in the form of user objects. After uploading user can edit geometry of objects and download objects in the same format kit.",
	"$$serviceHelp$$_2" : "Link saves current map state, and also user objects and texts.",
	"$$serviceHelp$$_3" : "Print current map fragment.",
	"Редактировать" : "Edit",
    "Удалить объект?": "Delete object?",
    "Удалить отмеченные объекты?": "Delete selected objects?",
	"Длина" : "Length",
	"Площадь" : "Area",
	"Добавить подгруппу" : "Create group",
	"Введите имя группы" : "New group creation",
	"Имя группы" : "Group name",
	"Включая вложенные слои" : "Including attached layers",
	"Удаление группы [value0]" : "Delete group [value0]",
	"Сохранено" : "Saved",
	"Прозрачность выбранного слоя/группы/карты" : "Transparency of the selected layer/group/map",
	"$$updateInfo$$_1" : "To display new layer it is necessary to save and reload map",
	"Любой" : "Any",
	"Векторный" : "Vector",
	"Растровый" : "Raster",
	"Название" : "Name",
	"Владелец" : "Owner",
	"Последнее изменение": "Last modification",
	"Список слоев" : "Layers list",
	"Вы действительно хотите удалить этот слой?" : "Do you really want to delete the selected layer?",
	"Ошибка!" : "Error!",
	"Список карт" : "Maps list",
	"Показать" : "Show",
	"загрузка..." : "loading...",
	"удаление..." : "deleting...",
	"Вы действительно хотите удалить эту карту?" : " Do you really want to delete the selected map?",
    "maplist.hint": "You can drag layers and folders from here to current map",
	"Слоя нет в базе" : "Layer is not in base",
	"ScanEx Web Geomixer - просмотр карты" : "ScanEx Web Geomixer – map view",
	"Изменить параметры поиска" : "Change search parameters",
	"$$search$$_1" : "Search vector layers and address base",
	"$$search$$_2" : "Search address base",
	"Поиск не дал результатов" : "There are no search results",
	"Регистрация" : "Registration",
	"Восстановление пароля" : "Restore password",
	"Вход" : "Login",
	"Выход" : "Logout",
	"Логин" : "User name",
	"Пароль" : "Password",
	"пароль" : "password",
    "Псевдоним": "Nickname",
    "Полное имя": "Full name",
	"Пожалуйста, авторизуйтесь" : "Please, authorize",
    "адрес электронной почты": "enter your e-mail",
	"Ошибка сервера" : "Server error",
	"Папка" : "Folder",
	" и " : " and ",
	"Название" : "Title",
	"Рейтинг" : "Rating",
	"Автор" : "Author",
	"Тематика" : "Theme",
	"Развлекательная" : "Fun",
	"Спортивная" : "Sport",
	"Историческая" : "History",
	"Экологическая" : "Ecology",
	"Любая" : "All",
	"Создать новую тему" : "Create topic",
	"Начало периода" : "Since",
	"Окончание периода" : "Till",
	"Накладываемые тайлы" : "Ground tiles",
	"Отображать с зума" : "Show with zoom",
	"По" : "to",
	"Фильтр" : "Filter",
	"Подпись" : "Label",
	"Балун" : "Balloon",
	"По умолчанию" : "Default",
	"Показывать при клике": "Show on click",
	"Показывать при наведении": "Show on mouse over",
	"Символика" : "Shown style",
    "Библиотека стилей": "Style library",
    "Настройка стилей": "Style settings",
	"скопировать": "copy style",
	"применить везде": "apply to all",
    "Кластеризация" : "Clustering",
	"Минимальный" : "Mininmal",
	"Максимальный" : "Maximal",
	"Мин. зум" : "Min. zoom",
	"Макс. зум" : "Max. zoom",
	"Пешеходная" : "Footpath",
	"Велосипедная" : "Bicycle",
	"Автомобильная" : "Automobile",
	"Места" : "Places",
	"Маршрут" : "Route",
	"Редактировать экскурсию" : "Edit excursion",
	"Добавьте маршрут" : "Add route",
	"Выберете темы на пути следования" : "Choose places throughout the journey",
	"$$phrase$$_11" : "Add route by clicking \"Line\" tool on toolbar",
	"$$phrase$$_12" : "There are no corresponding objects on the map",
	"Выбор маршрута" : "Routes choice",
	"Выбор мест" : "Places choice",
	"$$phrase$$_13" : "You haven't places om map. You can add place in View-Forum tab",
	"Обсуждения" : "Forum",
	"Экскурсии" : "Excursions",
	"$$phrase$$_14" : "Unable to delete default map",
	"$$phrase$$_15" : "Unable to delete current map",
	"Назад" : "Back",
	"Вперед" : "Forward",
	"$$phrase$$_16" : "There is no album with given image ID",
	"Редактировать альбом" : "Edit album",
	"Оценить" : "Vote",
	"Поставьте маркер" : "Add marker",
	"на карту и переместите его в нужное место." : "to map and move it to choosen place.",
	"Недостаточно прав для совершения операции" : "Insufficient rights to perform operation",
	"Новая папка" : "New folder",
	"Выбрать" : "Choose",
	"Добавить" : "Add",
	"$$serviceHelp$$_4" : "Embedding the map: the user can embed a map window into their site by copying and pasting an HTML snippet. An API key for the site's domain is required.",
	"Масштаб" : "Scale",
	"Угол поворота" : "Angle",
	"Диаграммы" : "Charts",
	"График по времени" : "Time chart",
	"Круговая" : "Pie chart",
	"Маска атрибутов" : "Attributes mask",
	"Закладки" : "Bookmarks",
	"Добавить закладку" : "Add bookmark",
	"Имя закладки" : "Bookmark name",
	"Дерево" : "Tree view",
	"Поиск слоев" : "Layers search",
	"Пример выражения": "[Field1]\n[Field2]\nsimple text",
	"Шкала прозрачности" : "Transparency bar",
	"Цвет заливки" : "Fill color",
	"Цвет обводки" : "Outline color",
	"Цвет шрифта" : "Font color",
	"Легенда" : "Legend",
	"Событие загрузки карты" : "Событие загрузки карты",
	"Мин" : "Min",
	"Макс" : "Max",
	"График" : "График",
	"Гистограмма" : "Гистограмма",
	"Столбчатая" : "Столбчатая",
	"Временная" : "Временная",
	"Круговая" : "Круговая",
	"Копировать стиль" : "Copy style",
	"Применить стиль" : "Apply style",
	"Не выбран стиль" : "There is no copied style",
	"Невозможно применить стиль к другому типу геометрии" : "Can't apply style to different geometry type",
	"Общие" : "Common",
	"Доступ" : "Policy",
	"Окно карты" : "View",
	"Загрузка" : "Onload",
	"Копирайт" : "Copyright",
	"Инструменты" : "Tools",
	"Загрузить KML" : "Load KML",
	"URL файла" : "File URL",
    "Поиск" : "Search",
    "Подложки": "Base Layers",
    "Доступные подложки": "Available base layers",
    "Подложки карты": "Base layers on map",
    "Выберите слои для поиска по атрибутам": "Select layers for attributes search",
	"Включить синхронизацию слоев": "Enable sync layers",
	"Выключить синхронизацию слоев": "Disable sync layers",

	"Редактирование прав доступа карты [value0]" : "Map [value0] access editor",
	"Редактирование прав доступа слоя [value0]" : "Layer [value0] access editor",
	"Редактирование прав доступа слоев карты [value0]" : "Map [value0] layers access editor",
	"Состав группы [value0]" : "Users of group [value0]",
	"Роль" : "Role",
	"Добавить пользователя" : "Add user",
	"Права доступа" : "Access permissions",
	"Права доступа к слоям" : "Layers access permissions",
	"Пользователи без прав доступа:" : "Users wihout access:",
	"Пользователи с правами доступа:" : "Users with access:",
	"Выберите нового владельца" : "Select new owner",
	"Сменить владельца" : "Change owner",

	"Объекты RuMap" : "RuMap objects",
	"Объекты пользователей" : "User objects",

	"Контакты" : "Contacts",
	"Фотографии" : "Photo",
	"Момент съемки" : "Image date",
	"Видео" : "Video",
	"Сообщения" : "Messages",
	"Ссылка на место" : "Ссылка на место",
	"Ссылка на экскурсию" : "Ссылка на экскурсию",
	"Ссылка на событие" : "Ссылка на событие",
	"Создать новое событие" : "Создать новое событие",
	"События" : "События",
	"Календарь" : "Календарь",
	"Новости" : "Новости",
	"Мероприятия" : "Мероприятия",
	"Отмена" : "Отмена",
	"Пропустить" : "Skip",
	"Время" : "Время",
	"Альбом OpenPhotoVR" : "Фотоальбом",
	"Встраиваемый код" : "Embed video",

	"Объекты экологического риска" : "Объекты экологического риска",
		"Санкционированные свалки" : "Санкционированные свалки",
		"Несанкционированные свалки" : "Несанкционированные свалки",
		"Полигоны отходов" : "Полигоны отходов",
		"Предприятия переработки отходов" : "Предприятия переработки отходов",
		"Факельные установки, ТЭЦ, трубы" : "Факельные установки, ТЭЦ, трубы",
		"Закрытые свалки" : "Закрытые свалки",
		"Пункты приема отходов" : "Пункты приема отходов",
		"Оползни" : "Оползни",
		"Карстовые явления" : "Карстовые явления",
		"Суффозионные явления" : "Суффозионные явления",

	"Государство и общество" : "Государство и общество",
		"Радио" : "Радио",
		"Правительственные учреждения" : "Правительственные учреждения",
		"Оптики" : "Оптики",
		"Охранные агенства" : "Охранные агенства",
		"Травмпункты" : "Травмпункты",
		"Таможня" : "Таможня",
		"Ветеринарные клиники" : "Ветеринарные клиники",
		"ЗАГС" : "ЗАГС",
		"Больницы" : "Больницы",
		"Аптеки" : "Аптеки",
		"Поликлиники" : "Поликлиники",
		"Колледжи" : "Колледжи",
		"Университеты" : "Университеты",
		"ОВИР" : "ОВИР",
		"Посольства" : "Посольства",
		"Почтовые отделения" : "Почтовые отделения",
		"Суды" : "Суды",
		"Банки" : "Банки",
		"Родильные дома" : "Родильные дома",
		"Дома престарелых" : "Дома престарелых",
		"Детские сады" : "Детские сады",
		"Школы" : "Школы",
		"Инспекции" : "Инспекции",
		"Адвокаты" : "Адвокаты",
		"МЧС" : "МЧС",
		"Муниципальные учреждения" : "Муниципальные учреждения",
		"Администрация" : "Администрация",

	"Культура и отдых" : "Культура и отдых",
		"Боулинг" : "Боулинг",
		"Аквапарки" : "Аквапарки",
		"Парки развлечений" : "Парки развлечений",
		"Библиотеки" : "Библиотеки",
		"Памятники" : "Памятники",
		"Лагери отдыха" : "Лагери отдыха",
		"Кинотеатры" : "Кинотеатры",
		"Цирки" : "Цирки",
		"Галереи" : "Галереи",
		"Отели" : "Отели",
		"Мотели" : "Мотели",
		"Музеи" : "Музеи",
		"Концертные залы" : "Концертные залы",
		"Ночные клубы" : "Ночные клубы",
		"Театры" : "Театры",
		"Санатории" : "Санатории",
		"Зоопарки" : "Зоопарки",

	"Общественное питание" : "Общественное питание",
		"Кафе" : "Кафе",
		"Фастфуды" : "Фастфуды",
		"Рестораны" : "Рестораны",
		"Кафе-мороженое" : "Кафе-мороженое",
		"Столовые" : "Столовые",

	"Природные достопримечательности" : "Природные достопримечательности",
		"Ботанический сад" : "Ботанические сады",
		"Пещеры" : "Пещеры",
		"Водопады" : "Водопады",
		"Парки" : "Парки",
		"Источники" : "Источники",
		"Заповедники" : "Заповедники",
		"Прочие архитектурные и природные достопримечательности" : "Архитектурные достопримечательности",

	"Религия" : "Религия",
		"Культовые сооружения" : "Культовые сооружения",
		"Мечети" : "Мечети",
		"Монастыри" : "Монастыри",
		"Церкви других христианских конфессий" : "Церкви других христианских конфессий",
		"Православные церкви" : "Православные церкви",
		"Синагоги" : "Синагоги",

	"Спорт" : "Спорт",
		"Стадионы" : "Стадионы",
		"Теннисные корты" : "Теннисные корты",
		"Катки" : "Катки",
		"Ипподромы" : "Ипподромы",
		"Фитнес" : "Фитнес",
		"Бассейны" : "Бассейны",
		"Прокат спортинвентаря" : "Прокат спортинвентаря",

	"Торговля и услуги" : "Торговля и услуги",
		"Солярии" : "Солярии",
		"Интернет-кафе" : "Интернет-кафе",
		"Рынки" : "Рынки",
		"Стоматологические клиники" : "Стоматологические клиники",
		"Магазины одежды" : "Магазины одежды",
		"Парикмахерские" : "Парикмахерские",
		"Бани" : "Бани",
		"Магазины обуви" : "Магазины обуви",
		"Магазины" : "Магазины",
		"Ателье" : "Ателье",
		"Такси" : "Такси",
		"Туризм" : "Туризм",

	"Транспорт и услуги" : "Транспорт и услуги",
		"Аэропорты" : "Аэропорты",
		"Автосервисы" : "Автосервисы",
		"Автовокзалы" : "Автовокзалы",
		"ДПС" : "ДПС",
		"ГИБДД" : "ГИБДД",
		"Шиномонтаж" : "Шиномонтаж",
		"Парковки бесплатные" : "Парковки бесплатные",
		"Парковки платные" : "Парковки платные",
		"АЗС" : "АЗС",
		"Автомойки" : "Автомойки",

	"Экстренные службы" : "Экстренные службы",
		"Пожарные/спасатели" : "Пожарные/спасатели",
		"Милиция" : "Милиция",
		"Скорая помощь" : "Скорая помощь",

	"Другие темы" : "Другие темы",
		"Разное" : "Разное",

	"Изменение пароля" : "Password change",
	"Новый пароль" : "New password",
	"Старый пароль" : "Old password",
	"Подтвердите пароль" : "Confirm password",
	"Контур" : "Border",
	"$$phrase$$_17" : "Add border by clicking \"Polygon\" tool on toolbar",
	"Выбор контура" : "Border select",
	"Таблица атрибутов слоя [value0]" : "[value0] attributes table",
	"Показать параметры поиска" : "Show search params",
	"Скрыть параметры поиска" : "Hide search params",
	"Искать внутри полигона" : "Search inside polygon",
	"SQL-условие WHERE" : "WHERE SQL expression",
	"Показывать столбцы" : "Show columns",
	"Найти" : "Search",
	"Нет полей" : "Empty fields",
	"Нет данных" : "Empty data",
	"Таблица атрибутов" : "Attributes table",
	"Разрешить поиск" : "Allow search",
	"Произвольный" : "Any",
	"День" : "Day",
	"Неделя" : "Week",
	"Месяц" : "Month",
	"Год" : "Year",
	"Ежегодно" : "Every year",
	"Облачность" : "Clouds",
	"Период" : "Period",
	"Спутниковые покрытия" : "Satellite cover",
	"Редактировать объект слоя [value0]" : "Edit layer [value0] object",
	"Создать объект слоя [value0]" : "Add layer [value0] object",
	"Геометрия" : "Geometry",
	"Добавить объект" : "Add object",
	"Очистить поиск" : "Clean search",
    "Скачать shp": "Download shp",
    "Скачать gpx": "Download gpx",
    "Скачать csv": "Download csv",
    "Скачать geojson": "Download geojson",
    "Рассчитать площадь": "Total square",
	"Создать столбец" : "Create column",
	"Мультислой" : "Multilayer",
	"В дереве слоев остались несохраненные изменения!" : "There are unsaved changes on layers tree!",
	"файл версии отсутствует" : "version file doesn't exists",
	"Хост" : "Host",
	"Дополнительные карты" : "Additional maps",
	"Добавить карту" : "Add map",
	"Невозможно загрузить карту [value0] с домена [value1]" : "Unable to load map [value0] from domain [value1]",
	"Показывать" : "Show",
	"Поиск снимков" : "Search imagery",
	"Принудительно обновить тайлы" : "Forced retiling",
	"Обводка" : "Outline",
	"Карта имеет более новую версию. Сохранить?" : "The map has a newer version. Save anyway?",
	"Кодировка": "Encoding",
	"helpPostfix": "_eng.html",
	"Показывать чекбокс видимости": "Visibility checkbox",
	"Разворачивать автоматически": "Expand automatically",
	"Другая": "Another",
	"Временнóй слой": "Multitemporal layer",
	"Колонка даты": "Date column",
	"Минимальный период": "Min. period (days)",
	"Максимальный период": "Max. period (days)",
    "Отсутствует временной атрибут": "Missing attribute with type 'Date'",
    "Период 1 день": "Period 1 day",
    "Показывать на карте данные за": "Show data on map within",
    "1 день": "single day",
    "произвольный период" : "arbitrary period",
	"По границе экрана": "Screen border",
	"По центру экрана": "Screen center",
	"Пересечение": "Intersection",
	"Пролистывать слои": "Scroll layers",
	"Следующий слой": "Next layer",
	"Предыдущий слой": "Previous layer",
    "Геометрия не сохранена. Эта возможность будет реализована в будущих версиях Геомиксера.": "Geometry is not saved. This feature will be implemented in future Geomixer versions",
    "WMS доступ": "WMS/WFS access",
    "ссылка": "link",
    "Слой '[value0]' уже есть в карте": "Layer '[value0]' already exists in this map",
    "Группа '[value0]' уже есть в карте": "Group '[value0]' already exists in this map",
    "Плагины": "Plugins",
    "Вручную": "Manually",
    "Добавить атрибут": "Add attribute",
    "Проекция": "Projection",
    "Широта/Долгота (EPSG:4326)": "Lat/Lon (EPSG:4326)",
    "Меркатор (EPSG:3395)": "Mercator (EPSG:3395)",
    "Из файла": "From file",
    "Мультиполигон": "Multipolygon",
    "Мультилиния": "Multipolyline",
    "Мультиточка": "Multipoint",
    "Администрирование": "Administration",
    "Системные настройки": "System settings",
    "Управление группами": "User group management",
    "Управление группами пользователей": "User group management",
    "Добавить снимки": "Add rasters",
    "Существующие слои": "Existing layers",
    "Слои из карты": "Layers from map",
    "Слои из КР": "Layers from RC",
    "Новый слой": "New layer",
    "С экрана": "Select on map",
    "Добавлен растр": "Raster is added",
    "Добавлены растры": "Rasters are added",
    "Выбранный объект не имеет растра": "Selected object has no raster",
    "Этот растр уже был выбран": "This raster is already selected",
    "Каталог Растров": "Raster catalog",
    "Растр": "Raster",
    "Добавить выбранные растры": "Add selected rasters",
    "EditObject.menuTitle" : "Add object",
    "FileBrowser.ExceedLimitMessage" : "File size exceeds 500 Mb. Use GeoMixerFileBrowser tool to upload large files.",
    "FileBrowser.DropInfo" : "Drop files here",
    "EditObject.drawingMenuTitle" : "Add object to active layer",
    "Поставить маркер": "Add marker",
    "Центрировать": "Set center",
    "Пароль изменён": "Password has been changed",
	"портретная": "portrait view",
	"альбомная": "layout view"
};

var nsGmx = nsGmx || {};
nsGmx.Utils = nsGmx.Utils || {};

(function()
{
    var domManipulation = {
        // _el(nodeName, [childs], [attrs])
        _el: function(str, childs, attributes)
        {
            var el = document.createElement(str),
                children = childs,
                attrs = attributes;

            if (children)
                domManipulation._childs(el, children)

            if (attrs && attrs.length)
                domManipulation._attr(el, attrs)

            return el;
        },
        // _t("some text")
        _t: function(str)
        {
            return document.createTextNode(String(str));
        },
        // children - всегда массив
        _childs: function(el, children)
        {
            for (var i = 0; i < children.length; ++i)
                el.appendChild(children[i]);
        },
        //[['css','width','100%']]
        //[['dir','className','name']]
        //[['attr','colSpan',2]]
        _attr: function(el, attrs)
        {
            for (var i = 0; i < attrs.length; ++i)
            {
                var atr = attrs[i],
                    type = atr[0];

                switch(type)
                {
                    case 'css':
                        (el.style[atr[1]] = atr[2]);
                        break;
                    case 'dir':
                        el[atr[1]] = atr[2];
                        break;
                    case 'attr':
                        el.setAttribute(atr[1], atr[2]);
                        break;
                }
            }
        },
        _table: function(children,attrs){return _el('TABLE',children,attrs)},
        _caption: function(children,attrs){return _el('CAPTION',children,attrs)},
        _thead: function(children,attrs){return _el('THEAD',children,attrs)},
        _tbody: function(children,attrs){return _el('TBODY',children,attrs)},
        _tfoot: function(children,attrs){return _el('TFOOT',children,attrs)},
        _textarea: function(children,attrs){return _el('TEXTAREA',children,attrs)},
        _th: function(children,attrs){return _el('TH',children,attrs);} ,
        _tr: function(children,attrs){return _el('TR',children,attrs);},
        _td: function(children,attrs){return _el('TD',children,attrs);},
        _span: function(children,attrs){return _el('SPAN',children,attrs);},
        _label: function(children,attrs){return _el('LABEL',children,attrs);},
        _li: function(children,attrs){return _el('LI',children,attrs);},
        _ul: function(children,attrs){return _el('UL',children,attrs);},
        _div: function(children,attrs){return _el('DIV',children,attrs);},
        _radio: function(attrs){return _el('INPUT',null,(attrs&&attrs.concat([['attr','type','radio']]))||[['attr','type','radio']])},
        _button: function(children,attrs){return _el('BUTTON',children,attrs)},
        _a: function(children,attrs){return _el('A',children,attrs)},
        _select: function(children,attrs){return _el('SELECT',children,attrs)},
        _option: function(children,attrs){return _el('OPTION',children,attrs);},
        _form: function(children,attrs){return _el('FORM',children,attrs)},
        _iframe: function(children,attrs){return _el('IFRAME',children,attrs)},
        _image: function(children,attrs){return _el('IMG',children,attrs)},
        _img: function(children,attrs){return _el('IMG',children,attrs)},
        _br: function(){return _el('BR')},
        _hr: function(){return _el('HR')},
        _p: function(children,attrs){return _el('P',children,attrs)},
        _b: function(children,attrs){return _el('B',children,attrs)},
        _i: function(children,attrs){return _el('I',children,attrs)},
        _input: function(children,attrs){return _el('INPUT',children,attrs)}
    }

    var _el = domManipulation._el;

    // _(elem, [childs], [attrs])
    var _ = function(ent,childs,attributes)
    {
        var el = ent,
            children = childs,
            attrs = attributes;

        if (children)
            domManipulation._childs(el, children)

        if (attrs && attrs.length)
            domManipulation._attr(el, attrs)

        return el;
    };

    var prevGlobals = {};
    for (var k in domManipulation) {
        prevGlobals[k] = window[k];
    }

    /** Удаляет из глобальной видимости часть методов, записанных туда при загрузке utilities.js
    * @memberOf nsGmx.Utils
    */
    nsGmx.Utils.noConflicts = function() {
        for (var k in domManipulation) {
            window[k] = prevGlobals[k];
        }
        return nsGmx.Utils;
    }

    jQuery.extend(window, domManipulation);      //для обратной совместимости
    jQuery.extend(nsGmx.Utils, domManipulation);
    nsGmx.Utils._ = _;
})();

if (window.Node && window.Node.prototype)
{
	Node.prototype.removeNode = function()
	{
		var parent = this.parentNode;
		parent && parent.removeChild(this);
	}
}

function getkey(e)
{
	if (window.event)
		return window.event.keyCode;
	else if (e)
		return e.which;
	else
		return null;
}

function show(elem)
{
	elem.style.display = '';
}
function hide(elem)
{
	elem.style.display = 'none';
}
function hidden(elem)
{
	elem.style.visibility = 'hidden';
}
function visible(elem)
{
	elem.style.visibility = 'visible';
}
function switchSelect(sel, value)
{
	if (!sel.options || !sel.options.length)
		return sel;

	for (var i = 0; i < sel.options.length; i++)
	{
		if (value == sel.options[i].value)
		{
			sel.options[i].selected = true;

			sel.selectedIndex = i;

			break;
		}
	}

	return sel;
}
function objLength(obj)
{
	var cnt = 0;
	for (var field in obj) cnt++;

	return cnt;
}
function valueInArray(arr, value)
{
	for (var i = 0; i < arr.length; i++)
		if (arr[i] == value)
			return true;

	return false;
}
function getOffsetRect(elem)
{
    var box = elem.getBoundingClientRect(),
    	body = document.body,
    	docElem = document.documentElement,
    	scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
    	scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
    	clientTop = docElem.clientTop || body.clientTop || 0,
    	clientLeft = docElem.clientLeft || body.clientLeft || 0,
    	top  = box.top +  scrollTop - clientTop,
    	left = box.left + scrollLeft - clientLeft;

    return { top: Math.round(top), left: Math.round(left) }
}
function attachEffects(elem, className)
{
	elem.onmouseover = function()
	{
		jQuery(this).addClass(className)
	}
	elem.onmouseout = function(e)
	{
		var evt = e || window.event,
			target = evt.srcElement || evt.target,
			relTarget = evt.relatedTarget || evt.toElement;

		try
		{
			while (relTarget)
			{
				if (relTarget == elem)
					return;
				relTarget = relTarget.parentNode;
			}

			jQuery(elem).removeClass(className)
		}
		catch (e)
		{
			jQuery(elem).removeClass(className)
		}
	}
}
function makeButton(value, id)
{
	var inp = _input(null, [['dir','className','btn'],['attr','type','submit'],['attr','value',value]]);
	if (typeof id != 'undefined' && id != null)
		inp.id = id;

	inp.style.padding = '0px 5px';

	return inp;
}
function makeImageButton(url, urlHover)
{
	var btn = _img();
	btn.setAttribute('src',url)
	btn.style.cursor = 'pointer';
	btn.style.border = 'none';

	if (urlHover)
	{
		btn.onmouseover = function()
		{
			this.setAttribute('src', urlHover);
		}
		btn.onmouseout = function()
		{
			this.setAttribute('src', url);
		}
	}

	return btn;
}
function makeLinkButton(text)
{
	var span = _span([_t(String(text))],[['dir','className','buttonLink']]);

	attachEffects(span, 'buttonLinkHover')

	return span;
}
function makeHelpButton(helpText){
	var btn = makeImageButton(getAPIHostRoot() + 'api/img/help.gif');
	btn.setAttribute('title', helpText)
	btn.onclick = function(){
		showDialog('', _t(helpText), 300, 150);
	}
	return btn;
}

function getOwnChildNumber(elem)
{
	for (var i = 0; i < elem.parentNode.childNodes.length; i++)
		if (elem == elem.parentNode.childNodes[i])
			return i;
}
function stopEvent(e)
{
	if(!e) var e = window.event;

	//e.cancelBubble is supported by IE - this will kill the bubbling process.
	e.cancelBubble = true;
	e.returnValue = false;

	//e.stopPropagation works only in Firefox.
	if (e.stopPropagation)
	{
		e.stopPropagation();
		e.preventDefault();
	}
	return false;
}

//Показывает диалог (на основе jQuery UI dialog)
//Параметры можно передавать явно и в виде объекта params:
//1. showDialog(title, content, width, height, ?posX, ?posY, ?resizeFunc, ?closeFunc)
//2. showDialog(title, content, params)
//Параметры:
// - title {string} Заголовок диалога
// - content {HTMLDomElement} контент диалога
// - width, height {int} высота и ширина диалога (обязательные параметры!)
// - posX, posY {int} положение диалога относительно экрана. Если не задано - по центру
// - resizeFunc {function} будет вызываться при изменении размера диалога. Аргумент ф-ции - объект с атриубтами width и height
// - closeFunc {function} будет вызываться при закрытии диалога
// - setMinSize {bool} если true (по умолчанию), будут заданы минимальная ширина и высота, равные начальным размерам (width, height)
function showDialog(title, content, width, height, posX, posY, resizeFunc, closeFunc)
{
    var params = null;
    if (arguments.length == 3)
    {
        params = $.extend({
            posX: false,
            posY: false,
            setMinSize: true
        }, width);
    }
    else
    {
        params = {
            width: width,
            height: height,
            posX: posX,
            posY: posY,
            resizeFunc: resizeFunc,
            closeFunc: closeFunc,
            setMinSize: true
        }
    }
	var canvas = _div([content]);

	document.body.appendChild(canvas);

	var dialogParams = {
        width: params.width,
        height: params.height,
        title: title,
        position: params.posX == false ? 'center' : [params.posX, params.posY],
        resizable: true,
        resize: function(event, ui)
        {
            params.resizeFunc && params.resizeFunc(ui.size);
        },
        close: function(ev, ui)
        {
            if (params.closeFunc && params.closeFunc())
                return;

            removeDialog(canvas);
        },
        open: function (ev, ui) {
        },
        closeText: null
    };

    if (params.setMinSize)
    {
        dialogParams.minWidth = params.width;
        dialogParams.minHeight = params.height;
    }

    jQuery(canvas).dialog(dialogParams);

	var dialog = canvas.parentNode;
	dialog.style.overflow = '';

    $(dialog).focusout(function (event) {

        event.stopImmediatePropagation();
        event.stopPropagation();
        event.preventDefault();
        jQuery.support.focusinBubbles = false;
        var ui = $('.ui-dialog-content', this);
            ui.context.st = $(ui).scrollTop();

    });

    $(dialog).focusin(function() {
        var uis = $('.ui-dialog-content');

        $(uis).each(function(index) {
            var st = $(this).context.st;
            $(this).scrollTop(st);
        });

    });


	jQuery(dialog).children("div.ui-resizable-se").removeClass("ui-icon")
				.removeClass("ui-icon-gripsmall-diagonal-se")
				.removeClass("ui-icon-grip-diagonal-se");

	return canvas;
}

function removeDialog(canvas)
{
	jQuery(canvas).dialog('destroy').remove();
}

function showErrorMessage(message, removeFlag, title)
{
	var canvas = _div([_t(message)],[['dir','className','errorDialog']]);
        jQueryDiv = showDialog(title || "Ошибка!", canvas, {
            width: 250,
            height: 150,
            closeFunc: function(){
                canvas = null;
            }
        });

	if (removeFlag)
	{
		setTimeout(function()
		{
			if (canvas)
			{
                jQuery(jQueryDiv).dialog("destroy");
				jQuery(canvas.parentNode).remove();
			}
		}, 2500)
	}
}

function _checkbox(flag, type, name)
{
	var box = _input(null, [['attr','type',type]]);
    box.checked = flag;

    if (name)
        box.setAttribute('name', name);

	return box;
}

function insertAtCursor(myField, myValue, sel)
{
    if (myField.id && window.tinyMCE && tinyMCE.get(myField.id)) {
        tinyMCE.execInstanceCommand(myField.id, "mceInsertContent", false, myValue);
        return;
    }

	if (document.selection)
	{
		if (typeof sel != 'undefined')
			sel.text = myValue;
		else
		{
			myField.focus();
			var sel = document.selection.createRange();
			sel.text = myValue;
		}
	}
	else if (myField.selectionStart || myField.selectionStart == '0')
	{
		var startPos = myField.selectionStart,
			endPos = myField.selectionEnd;

		myField.value = myField.value.substring(0, startPos) + myValue + myField.value.substring(endPos, myField.value.length);
	}
	else
		myField.value += myValue;
}

/* ----------------------------- */
function sendRequest(url, callback, body)
{
	var xmlhttp;
	if (typeof XMLHttpRequest != 'undefined')
		xmlhttp = new XMLHttpRequest();
	else
		try { xmlhttp = new ActiveXObject("Msxml2.XMLHTTP"); }
		catch (e) { try {xmlhttp = new ActiveXObject("Microsoft.XMLHTTP"); } catch (E) {}}

	xmlhttp.open(body ? "POST" : "GET", url, true);
	if (body)
	{
		xmlhttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
		xmlhttp.setRequestHeader('Content-length', body.length);
	}
	xmlhttp.onreadystatechange = function() { if (xmlhttp.readyState == 4) callback(xmlhttp); }
	xmlhttp.send(body || "");
}

function sendJSONRequest(url, callback)
{
	sendRequest(url, function(xmlhttp)
	{
		var text = xmlhttp.responseText;
		callback(JSON.parse(text));
	});
}

nsGmx.Utils.uniqueGlobalName = (function()
{
    var freeid = 0;
    return function(thing)
    {
        var id = 'gmx_unique_' + freeid++;
        window[id] = thing;
        return id;
    }
})();

/** Посылает кросс-доменный GET запрос к серверу с использованием транспорта JSONP.
 *
 * @memberOf nsGmx.Utils
 * @param {String} url URL сервера.
 * @param {Function} callback Ф-ция, которая будет вызвана при получении от сервера результата.
 * @param {String} [callbackParamName=CallbackName] Имя параметра для задания имени ф-ции ответа.
 * @param {Function} [errorCallback] Ф-ция, которая будет вызвана в случае ошибки запроса к серверу
 */
function sendCrossDomainJSONRequest(url, callback, callbackParamName, errorCallback)
{
	callbackParamName = callbackParamName || 'CallbackName';

    var script = document.createElement("script");
	script.setAttribute("charset", "UTF-8");
	var callbackName = nsGmx.Utils.uniqueGlobalName(function(obj)
	{
		callback && callback(obj);
		window[callbackName] = false;
		document.getElementsByTagName("head").item(0).removeChild(script);
	});

    var sepSym = url.indexOf('?') == -1 ? '?' : '&';

    if (errorCallback) {
        script.onerror = errorCallback;
    }

	script.setAttribute("src", url + sepSym + callbackParamName + "=" + callbackName + "&" + Math.random());
	document.getElementsByTagName("head").item(0).appendChild(script);
}
nsGmx.Utils.sendCrossDomainJSONRequest = sendCrossDomainJSONRequest;

function createCookie(name, value, days)
{
	if (days)
	{
		var date = new Date();
		date.setTime(date.getTime() + (days*24*60*60*1000));
		var expires = "; expires=" + date.toGMTString();
	}
	else
		var expires = "";
	document.cookie = name + "=" + value + expires + "; path=/";
}

function readCookie(name)
{
	var nameEQ = name + "=";
	var ca = document.cookie.split(';');
	for(var i = 0; i < ca.length; i++)
	{
		var c = ca[i];
		while (c.charAt(0)==' ')
			c = c.substring(1, c.length);
		if (c.indexOf(nameEQ) == 0)
			return c.substring(nameEQ.length, c.length);
	}
	return null;
}

function eraseCookie(name)
{
	createCookie(name, "", -1);
}

function getWindowWidth()
{
	var myWidth = 0;

	if (typeof (window.innerWidth) == 'number')
		myWidth = window.innerWidth;
	else if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight))
		myWidth = document.documentElement.clientWidth;
	else if (document.body && (document.body.clientWidth || document.body.clientHeight))
	{
		myWidth = document.body.clientWidth;
	}

	return myWidth;
}

function getWindowHeight()
{
	var myHeight = 0;

	if (typeof (window.innerWidth) == 'number' )
		myHeight = window.innerHeight;
	else if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight))
		myHeight = document.documentElement.clientHeight;
	else if (document.body && (document.body.clientWidth || document.body.clientHeight))
		myHeight = document.body.clientHeight;

	return myHeight;
}

function strip(s)
{
	return s.replace(/^\s*/, "").replace(/\s*$/, "");
}

(function() {
    var replacements = {};
    for (var rus in (temp = {
        "qwertyuiopasdfghjklzxcvbnm_1234567890" :
        "qwertyuiopasdfghjklzxcvbnm_1234567890",
        "абвгдезийклмнопрстуфыэ ":
        "abvgdeziyklmnoprstufye_",
        "ёжчхцшщюя":
        "yozhchkhtsshshyuya",
        "ьъ":
        "",
        ".":
        "."
    }))
    {
        var eng = temp[rus],
            k = eng.length/rus.length;
        for (var i = 0; i < rus.length; i++)
        {
            var r = rus.substring(i, i + 1),
                e = eng.substring(i*k, (i + 1)*k);
            replacements[r] = e;
            replacements[r.toUpperCase()] = e.toUpperCase();
        }
    }

    nsGmx.Utils.translit = function(name)
    {
        var result = "";
        for (var i = 0; i < name.length; i++)
            result += (replacements[name.substring(i, i + 1)] || "");

        return result;
    }
})();

function loadFunc(iframe, callback)
{
	var win = iframe.contentWindow;

    //skip first onload in safari
    if ( jQuery.browser.safari && !iframe.safariSkipped)
    {
        iframe.safariSkipped = true;
        return;
    }

	if (iframe.loaded)
	{
		var data = decodeURIComponent(win.name.replace(/\n/g,'\n\\'));
        jQuery(iframe).remove();

		var parsedData;
		try
		{
			parsedData = JSON.parse(data)
		}
		catch(e)
		{
			parsedData = {Status:"error",ErrorInfo: {ErrorMessage: "JSON.parse exeption", ExceptionType:"JSON.parse", StackTrace: data}}
		}

		callback && callback(parsedData);
	}
	else
	{
		win.location = 'about:blank';
        iframe.loaded = true;
	}

}

function createPostIframe(id, callback)
{
	var userAgent = navigator.userAgent.toLowerCase(),
		callbackName = nsGmx.Utils.uniqueGlobalName(function()
		{
			loadFunc(iframe, callback);
		}),
		iframe;

	try {
		iframe = document.createElement('<iframe style="display:none" onload="' + callbackName + '()" src="javascript:true" id="' + id + '" name="' + id + '"></iframe>');
    }
	catch(e)
	{
		iframe = document.createElement("iframe");
		iframe.style.display = 'none';
		iframe.setAttribute('id', id);
		iframe.setAttribute('name', id);
		iframe.src = 'javascript:true';
		iframe.onload = window[callbackName];
	}

	return iframe;
}

!function() {
    var requests = {},
        lastRequestId = 0,
        uniquePrefix = 'id' + Math.random();

    var processMessage = function(e) {
        if (!(e.origin in requests)) {
            return;
        }

        var dataStr = decodeURIComponent(e.data.replace(/\n/g,'\n\\'));
        try {
            var dataObj = JSON.parse(dataStr);
        } catch (e) {
            request.callback && request.callback({Status:"error", ErrorInfo: {ErrorMessage: "JSON.parse exeption", ExceptionType: "JSON.parse", StackTrace: dataStr}});
        }

        // console.log(dataObj);
        var request = requests[e.origin][dataObj.CallbackName];
        if(!request) return;    // message от других запросов

        delete requests[e.origin][dataObj.CallbackName];
        delete dataObj.CallbackName;

        request.iframe.parentNode.removeChild(request.iframe);
        request.callback && request.callback(dataObj);
    }

    //совместимость с IE8
    if (window.addEventListener) {
        window.addEventListener('message', processMessage);
    } else {
        window.attachEvent('onmessage', processMessage);
    }

    //скопирована из API для обеспечения независимости от него
    var parseUri = function (str) {
        var	o   = parseUri.options,
            m   = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str),
            uri = {},
            i   = 14;

        while (i--) {
            uri[o.key[i]] = m[i] || '';
        }

        uri[o.q.name] = {};
        uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
            if ($1) { uri[o.q.name][$1] = $2; }
        });

        uri.hostOnly = uri.host;
        uri.host = uri.authority; // HACK

        return uri;
    };

    parseUri.options = {
        strictMode: false,
        key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
        q:   {
            name:   'queryKey',
            parser: /(?:^|&)([^&=]*)=?([^&]*)/g
        },
        parser: {
            strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
            loose:  /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
        }
    };

    function createPostIframe2(id, callback, url)
    {
        var uniqueId = uniquePrefix + (lastRequestId++);

        iframe = document.createElement("iframe");
        iframe.style.display = 'none';
        iframe.setAttribute('id', id);
        iframe.setAttribute('name', id);
        iframe.src = 'javascript:true';
        iframe.callbackName = uniqueId;
        //iframe.onload = window[callbackName];

        var parsedURL = parseUri(url);
        var origin = (parsedURL.protocol ? (parsedURL.protocol + ':') : window.location.protocol) + '//' + (parsedURL.host || window.location.host);

        requests[origin] = requests[origin] || {};
        requests[origin][uniqueId] = {callback: callback, iframe: iframe};

        return iframe;
    }

    window.createPostIframe2 = createPostIframe2;

}();

/** Посылает кроссдоменный POST запрос
*
* @memberOf nsGmx.Utils
* @param {String} url URL запроса
* @param {Object} params Хэш параметров-запросов
* @param {Function} [callback] Callback, который вызывается при приходе ответа с сервера. Единственный параметр ф-ции - собственно данные
* @param {DOMElement} [baseForm] базовая форма запроса. Используется, когда нужно отправить на сервер файл.
*                                В функции эта форма будет модифицироваться, но после отправления запроса будет приведена к исходному виду.
*/
function sendCrossDomainPostRequest(url, params, callback, baseForm)
{
	var form,
		rnd = String(Math.random()),
		id = '$$iframe_' + url + rnd;

	var iframe = createPostIframe2(id, callback, url),
        originalFormAction;

	if (baseForm)
	{
		form = baseForm;
        originalFormAction = form.getAttribute('action');
		form.setAttribute('action', url);
		form.target = id;

	}
	else
	{
		try {
			form = document.createElement('<form id=' + id + '" enctype="multipart/form-data" style="display:none" target="' + id + '" action="' + url + '" method="post"></form>');
        }
		catch (e)
		{
			form = document.createElement("form");
			form.style.display = 'none';
			form.setAttribute('enctype', 'multipart/form-data');
			form.target = id;
			form.setAttribute('method', 'POST');
			form.setAttribute('action', url);
			form.id = id;
		}
	}

    var hiddenParamsDiv = document.createElement("div");
    hiddenParamsDiv.style.display = 'none';

    if (params.WrapStyle === 'window') {
        params.WrapStyle = 'message';
    }

    if (params.WrapStyle === 'message') {
        params.CallbackName = iframe.callbackName;
    }

	for (var paramName in params)
	{
		var input = document.createElement("input");

        var value = typeof params[paramName] !== 'undefined' ? params[paramName] : '';

		input.setAttribute('type', 'hidden');
		input.setAttribute('name', paramName);
		input.setAttribute('value', value);

		hiddenParamsDiv.appendChild(input)
	}

    form.appendChild(hiddenParamsDiv);

	if (!baseForm)
		document.body.appendChild(form);

	document.body.appendChild(iframe);

	form.submit();

    if (baseForm)
    {
        form.removeChild(hiddenParamsDiv);
        if (originalFormAction !== null)
            form.setAttribute('action', originalFormAction);
        else
            form.removeAttribute('action');
    }
    else
    {
        form.parentNode.removeChild(form);
    }
}

(function() {

    var hooks = {};

    /** Добавляет "хук", который будет вызван при ответе сервера соответвующего типа
    * @param type {object} - тип хука (соответствует полю "Status" ответа сервера) или '*' - добавить к любому ответу
    * @param hookFunction {function(response, customErrorDescriptions)} - собственно хук
    */
    window.addParseResponseHook = function(type, hookFunction) {
        hooks[type] = hooks[type] || [];
        hooks[type].push(hookFunction);
    }

    /** Обрабатывает результат выполнения серверного скрипта.
    * Для выполнения действий вызывает "хуки" соответствующиего типа, добавленные через addParseResponseHook()
    * @function
    * @global
    * @param {object} response JSON, вернувшийся с сервера
    * @param {object} customErrorDescriptions хэш "тип ошибки" -> "кастомное сообщение пользователям".
    * @return true, если статус ответа "ok", иначе false
    */
    window.parseResponse = function(response, customErrorDescriptions)
    {
        var responseHooks = (hooks[response.Status] || []).concat(hooks['*'] || []);
        for (var h = 0; h < responseHooks.length; h++)
            responseHooks[h](response, customErrorDescriptions);

        return response.Status == 'ok';
    }

})();

function _title(elem, title)
{
	elem.setAttribute('title', title);
}

function parseXML(str)
{
	var xmlDoc;
	try
	{
		if (window.DOMParser)
		{
			parser = new DOMParser();
			xmlDoc = parser.parseFromString(str,"text/xml");
		}
		else // Internet Explorer
		{
			xmlDoc = new ActiveXObject("MSXML2.DOMDocument.3.0");
			xmlDoc.validateOnParse = false;
			xmlDoc.async = false;
			xmlDoc.loadXML(str);
		}
	}
	catch(e)
	{
		alert(e)
	}

	return xmlDoc;
}

function disableSelection(target)
{
	if (typeof target.onselectstart != "undefined")
	    target.onselectstart = function(){return false}
	else if (typeof target.style.MozUserSelect != "undefined")
	    target.style.MozUserSelect = "none"
	else
	    target.onmousedown = function(){return false}
}

function parsePropertiesDate(str)
{
	if (str == null || str == "")
		return 0;

	var dateParts = str.split('.');

	if (dateParts.length != 3)
		return 0;

	return new Date(dateParts[2], dateParts[1] - 1, dateParts[0]).valueOf();
}

function stringDate(msec, isUtc)
{
	var date = new Date(msec);
		excDate = isUtc ? date.getUTCDate() : date.getDate(),
		excMonth = (isUtc ? date.getUTCMonth() : date.getMonth()) + 1,
		excYear = isUtc ? date.getUTCFullYear() : date.getFullYear();

	return (excDate < 10 ? '0' + excDate : excDate) + '.' + (excMonth < 10 ? '0' + excMonth : excMonth) + '.' + excYear;
}

function stringTime(msec, isUtc)
{
	var date = new Date(msec);
		excHour = isUtc ? date.getUTCHours() : date.getHours(),
		excMin = isUtc ? date.getUTCMinutes() : date.getMinutes(),
		excSec = isUtc ? date.getUTCSeconds() : date.getSeconds();

	return (excHour < 10 ? '0' + excHour : excHour) + ':' + (excMin < 10 ? '0' + excMin : excMin) + ':' + (excSec < 10 ? '0' + excSec : excSec);
}

function stringDateTime(msec, isUtc)
{
	return stringDate(msec, isUtc) + ' ' + stringTime(msec, isUtc);
}

/** Подсвечивает красным input, убирает подсветку через некоторое время
*
* @param {HTMLDOMElement|Array<HTMLDOMElement>} input - целевой input-элемент или массив таких элементов
* @param {integer} delay - время подсвечивания ошибки в миллисекундах
*/
function inputError(input, delay)
{
    delay = delay || 1000;
    if (!jQuery.isArray(input))
        input = [input];

    for (var k = 0; k < input.length; k++)
        jQuery(input[k]).addClass('error');

	setTimeout(function()
	{
        for (var k = 0; k < input.length; k++)
            if (input[k])
                jQuery(input[k]).removeClass('error');
	}, delay)
}

function equals(x, y)
{
	for(p in y)
	{
	    if(typeof(x[p])=='undefined') {return false;}
	}

	for(p in y)
	{
	    if (y[p])
	    {
	        switch(typeof(y[p]))
	        {
	                case 'object':
	                        if (!equals(x[p], y[p])) { return false }; break;
	                case 'function':
	                        if (typeof(x[p])=='undefined' || (p != 'equals' && y[p].toString() != x[p].toString())) { return false; }; break;
	                default:
	                        if (y[p] != x[p]) { return false; }
	        }
	    }
	    else
	    {
	        if (x[p])
	        {
	            return false;
	        }
	    }
	}

	for(p in x)
	{
	    if(typeof(y[p])=='undefined') {return false;}
	}

	return true;
}

/**
    @namespace nsGmx.Utils
    @description Разнообразные вспомогательные ф-ции
*/
$.extend(nsGmx.Utils, {

    /**
        Возвращает уникальную строку (16 символов из букв и латинских цифр)
        @function
        @memberOf nsGmx.Utils
    */
    generateUniqueID: function()
    {
        var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz",
            randomstring = '';

        for (var i = 0; i < 16; i++)
        {
            var rnum = Math.floor(Math.random() * chars.length);
            randomstring += chars.charAt(rnum);
        }

        return randomstring;
    },
    /**
        Преобразует цвет, заданный в виде числа (0xaabbcc) в строку вида #aabbcc
        @function
        @memberOf nsGmx.Utils
    */
    convertColor: function(intColor)
    {
        var r,g,b;

        b = (intColor % 256).toString(16);
        if (b.length == 1)
            b = '0' + b;

        intColor = Math.floor(intColor / 256);
        g = (intColor % 256).toString(16);
        if (g.length == 1)
            g = '0' + g;

        intColor = Math.floor(intColor / 256);
        r = (intColor % 256).toString(16);
        if (r.length == 1)
            r = '0' + r;

        return '#' + r + g + b;
    },
    /**
        Преобразует цвет, заданный в виде строки rgb(255, 255, 255) в строку вида #aabbcc
        @function
        @memberOf nsGmx.Utils
    */
    rgb2hex: function(intColor)
    {
        var str,
            arr = intColor.substring(4, intColor.length-1).split(', ');

        arr = arr.map(function(c){
            var hex = Number(c).toString(16);
            return hex.length == 1 ? "0" + hex : hex;
        });

        str = "#" + arr.join('');

        return str;
    },

    checkForNumber: function (number) {
        return !(isNaN(number) || typeof(number) === 'undefined' || number === null || number === '');
    },

    isJSON: function(str) {
        try {
            JSON.parse(str);
        } catch (e) {
            return false;
        }
        if (str === '' || str === 'null' || str === 'undefined' || typeof(str) === 'Number') {
            return false;
        } else {
            return true;
        }
    },

	/** Возвращает позицию окна такую, чтобы окно не мешало текущему элементу
        @memberOf nsGmx.Utils
    */
	getDialogPos: function(div, offsetFlag, height)
	{
		var pos = getOffsetRect(div),
			left = pos.left + 30,
			top = pos.top - 10,
			windowHeight = getWindowHeight();

		if (offsetFlag)
		{
			$(div).children('div,img').each(function()
			{
				if (!this.getAttribute('multiStyle'))
					left += this.offsetWidth;
			})
		}

		if (top + 15 + height > windowHeight)
			top -= (top + 15 + height - windowHeight);

		return {left: left, top: top}
	},

	/** Устанавливает обычный стиль и генерит похожий стиль при наведении мышки
    @memberOf nsGmx.Utils
	@param layer {L.gmxVectorLayer} Слой
	@param styleIndex {Number} Номер стиля слоя
	@param templateStyle {Style} Стиль, похожий на который надо установить*/
	setMapObjectStyle: function(layer, styleIndex, templateStyle)
	{
        var hoverStyle = $.extend(true, {}, templateStyle);
        var style = layer.getStyle(styleIndex);

        if (templateStyle.outline && typeof templateStyle.outline.thickness != 'undefined')
            hoverStyle.outline.thickness = Number(templateStyle.outline.thickness) + 1;

        if (templateStyle.fill && typeof templateStyle.fill.opacity != 'undefined' && templateStyle.fill.opacity > 0)
            hoverStyle.fill.opacity = Math.min(Number(templateStyle.fill.opacity + 20), 100);

        var newStyle = $.extend(true, {}, style);
        newStyle.RenderStyle = L.gmxUtil.fromServerStyle(templateStyle);
        newStyle.HoverStyle = L.gmxUtil.fromServerStyle(hoverStyle);

        if (templateStyle.labelTemplate) {
          newStyle.RenderStyle.labelTemplate = templateStyle.labelTemplate;
        }
        if (hoverStyle.labelTemplate) {
          newStyle.HoverStyle.labelTemplate = hoverStyle.labelTemplate;
        }

        if (templateStyle.labelAnchor) {
          newStyle.RenderStyle.labelAnchor = templateStyle.labelAnchor;
        }
        if (hoverStyle.labelAnchor) {
          newStyle.HoverStyle.labelAnchor = hoverStyle.labelAnchor;
        }
        layer.setStyle(newStyle, styleIndex);
	},

    // берёт стиль в формате сервера, добавляет в него hover-подсветку
    // и возвращает этот стиль в новом формате Leafelt-Geomixer
    prepareGmxLayerStyle: function(style)
	{
        var templateStyle = style.RenderStyle,
            newStyle = $.extend(true, {}, style),
            hoverStyle = $.extend(true, {}, templateStyle);


        if (templateStyle.outline && typeof templateStyle.outline.thickness != 'undefined')
            hoverStyle.outline.thickness = Number(templateStyle.outline.thickness) + 1;

        if (templateStyle.fill && typeof templateStyle.fill.opacity != 'undefined' && templateStyle.fill.opacity > 0)
            hoverStyle.fill.opacity = Math.min(Number(templateStyle.fill.opacity + 20), 100);

        newStyle.RenderStyle = L.gmxUtil.fromServerStyle(templateStyle);
        newStyle.HoverStyle = L.gmxUtil.fromServerStyle(hoverStyle);

        return newStyle;
	},
    /** Конвертация данных между форматами сервера и клиента. Используется в тегах слоёв и в атрибутах объектов векторных слоёв.
    *
    * Форматы сервера:
    *
    *  * datetime - unix timestamp
    *  * date - unix timestamp, кратный 24*3600 секунд
    *  * time - кол-во секунд с полуночи
    *
    * Форматы клиента:
    *
    *  * все числа превращаются в строки
    *  * дата - строка в формате dd.mm.yy
    *  * время - строка в формате hh:mm:ss
    *  * дата-время - dd.mm.yy hh:mm:ss
    *
    * @memberOf nsGmx.Utils
    */
    convertFromServer: function(type, value)
    {
        //if (value === null) return "null";

        if (!type) {
            return value;
        }

        var lowerCaseType = type.toLowerCase();

        if (lowerCaseType == 'string')
        {
            return value !== null ? value : ''; //все null интерпретируем как пустые строки!
        }
        else if (lowerCaseType == 'integer' || lowerCaseType == 'float' || lowerCaseType == 'number')
        {
            return value !== null ? String(value) : '';
        }
        else if (lowerCaseType == 'date')
        {
            if (value === null) return '';

            return stringDate(value*1000, true);
        }
        else if (lowerCaseType == 'time')
        {
            if (value === null) return '';
            return stringTime(value*1000, true);
        }
        else if (lowerCaseType == 'datetime')
        {
            if (value === null) return '';
            return stringDateTime(value*1000, true);
        }

        return value;
    },

    /** Конвертация данных между форматами сервера и клиента. Используется в тегах слоёв и в атрибутах объектов векторных слоёв.
    * Описание форматов см. в {@link nsGmx.Utils.convertFromServer}
    * Если конвертация невозможна для данного типа, возвращает null
    * @memberOf nsGmx.Utils
    */
    convertToServer: function(type, value)
    {
        if (!type) {
            return value;
        }

        var lowerCaseType = type.toLowerCase();

        if (lowerCaseType == 'string')
        {
            return value;
        }
        else if (lowerCaseType == 'integer' || lowerCaseType == 'float' || lowerCaseType == 'number')
        {
            if (value === '') return null;
            var num = Number(value);
            return isNaN(num) ? null : num;
        }
        else if (lowerCaseType == 'date')
        {
            var localDateValue = $.datepicker.parseDate('dd.mm.yy', value);
            if (localDateValue === null) return null;

            var localValue = localDateValue.valueOf()/1000;
            var timeOffset = (new Date(localValue*1000)).getTimezoneOffset()*60;
            return localValue - timeOffset;
        }
        else if (lowerCaseType == 'time')
        {
            var resTime = $.datepicker.parseTime('HH:mm:ss', value);
            if (!resTime) return null;

            return resTime.hour*3600 + resTime.minute*60 + resTime.second;
        }
        else if (lowerCaseType == 'datetime')
        {
            var localDateValue = $.datepicker.parseDateTime('dd.mm.yy', 'HH:mm:ss', value);
            if (localDateValue === null) return null;

            var localValue = localDateValue.valueOf()/1000;
            var timeOffset = (new Date(localValue*1000)).getTimezoneOffset()*60;
            return localValue - timeOffset;
        }

        return value;
    },


	login: function(redirect_uri, authServerBase, callback, authServer, isHidden){
		var oAuthServer = authServer || 'MyKosmosnimki';
		window.gmxGetServerBase = function(){
			return authServerBase
		}
		var redirectUri = redirect_uri + (redirect_uri.indexOf('?')>0 ? '&' : '?') + 'authServer=' + oAuthServer;
		window.gmxProcessAuthentication = function(userInfo){
			callback && callback(userInfo);
		}
		var features, w = 600, h = 350, l, t;
		var handlerName = 'LoginDialog';
		if (oAuthServer != 'MyKosmosnimki') {
			handlerName += oAuthServer;
			h = 400;
		}
		var url = authServerBase + handlerName + '.ashx?redirect_uri=' + escape(redirectUri);

		if (!isHidden){
			var top = (screen.height - h)/2, left = (screen.width - w)/2;
			features = 'location=0,menubar=0,resizable=0,status=0,toolbar=0,width='+w+',height='+h+',left='+left+',top='+top ;

			window.open(url, '_blank', features);
		}else{
			$('<iframe />', {
				 'src': url
				,'style': 'display: block !important; position: absolute; left: -99999px;'
			}).appendTo('body'); //стиль такой кривой иначе будет бага в FF
		}
    },

    /** Загружает пользовательский shp файл.
    * Проверяет на ошибки, выводит предупреждения и ошибки в виде стандартных диалогов.
    * @memberof nsGmx.Utils
    * @function
    * @param {File|Form} shpSource Либо форма с полем file, в которой пользователь выбрал файл, либо HTML5 File. Форма должна иметь атрибуты method="post" и enctype="multipart/form-data"
    * @return {jQuery.Deferred} Возвращает promise (аргумент ф-ции - массив объектов из shp файла)
    */
    parseShpFile: (function() //приватные данные
    {
        var translationsAdded = false;
        var addTranslationsLazy = function()
        {
            if (translationsAdded) return;
            _translationsHash.addtext("rus", {
                                "loadShape.Errors.FileTooBigException" : "Файл слишком большой. Ограничение на размер файла 1000 Кб.",
                                "loadShape.Errors.ErrorUploadExeption" : "Произошла ошибка при попытке загрузить файл.",
                                "loadShape.Errors.NoGeometryFile"      : "Загруженный файл не содержит геометрических данных.",
                                "loadShape.Errors.ErrorUploadNoDependentFiles" : "Не найдено необходимых зависимых файлов. Запакуйте все файлы в ZIP архив и повторите загрузку."
                             });

            _translationsHash.addtext("eng", {
                                "loadShape.Errors.FileTooBigException" : "Too big file. File size limit is 1000 Kb.",
                                "loadShape.Errors.ErrorUploadExeption" : "Error during file uploading.",
                                "loadShape.Errors.NoGeometryFile"      : "There are no geometry in uploaded file.",
                                "loadShape.Errors.ErrorUploadNoDependentFiles" : "Not found the necessary dependent files. Add all files in a ZIP archive and upload it again."
                             });

            translationsAdded = true;
        }

        //непосредственно ф-ция
        return function(shpFileForm) {
            var def = $.Deferred();

            addTranslationsLazy();

            var errorMessages = {
                "CommonUtil.FileTooBigException" : _gtxt("loadShape.Errors.FileTooBigException"),
                "CommonUtil.ErrorUploadExeption" : _gtxt("loadShape.Errors.ErrorUploadExeption"),
                "CommonUtil.NoGeometryFile"      : _gtxt("loadShape.Errors.NoGeometryFile"),
                "CommonUtil.ErrorUploadNoDependentFiles": _gtxt("loadShape.Errors.ErrorUploadNoDependentFiles")
            };

            if (window.File && shpFileForm instanceof window.File) {
                if (!window.FormData) {
                    def.reject();
                    return false;
                }

                var formData = new FormData();
                formData.append('file', shpFileForm);
                var xhr = new XMLHttpRequest();
                xhr.open('POST', serverBase + 'ShapeLoader');
                xhr.onload = function () {
                    if (xhr.status === 200) {
                        response = JSON.parse(xhr.responseText.substr(1, xhr.responseText.length-2));

                        if (parseResponse(response, errorMessages)) {
                            def.resolve(response.Result);
                        } else {
                            def.reject(response);
                        }
                    }
                };

                xhr.send(formData);
            } else {
                sendCrossDomainPostRequest(serverBase + "ShapeLoader", {WrapStyle: "window"}, function(response)
                {
                    if (parseResponse(response, errorMessages))
                        def.resolve(response.Result);
                    else
                        def.reject(response);
                }, shpFileForm)
            }

            return def.promise();
        }

    })(),

    /** Позволяет скачать в браузере геометрию в одном из форматов (упакованный в zip архив).
    * @memberof nsGmx.Utils
    * @function
    * @param {Object[]} geoJSONFeatures Массив GeoJSON Features. К сожалению, другие типы GeoJSON объектов не поддерживаются.
    * @param {Object} [options] Доп. параметры
    * @param {String} [options.fileName=markers] Имя файла для скачивания
    * @param {String} [options.format=Shape] В каком формате скачать (Shape, Tab, gpx или несколько через запятую)
    */
    downloadGeometry: function(geoJSONFeatures, options) {
        var objectsByType = {},
            markerIdx = 1;

        options = $.extend({
            fileName: 'markers',
            format: 'Shape'
        }, options);

        geoJSONFeatures.forEach(function(item) {
            var geom = item.geometry,
                type = geom.type;

            objectsByType[type] = objectsByType[type] || [];

            var title = item.properties && item.properties.title || '';

            if (type == "Point" && !title) {
                title = "marker " + markerIdx++;
            }

            objectsByType[type].push({
                geometry: {
                    type: type.toUpperCase(),
                    coordinates: geom.coordinates
                },
                properties: {text: title}
            });
        });

        sendCrossDomainPostRequest(serverBase + "Shapefile", {
            name:     options.fileName,
            format:   options.format,
            points:   JSON.stringify(objectsByType["Point"] || []),
            lines:    JSON.stringify([].concat(objectsByType["LineString"] || [], objectsByType["MultiLineString"] || [])),
            polygons: JSON.stringify([].concat(objectsByType["Polygon"] || [], objectsByType["MultiPolygon"] || []))
        })
    },

    /** Объединяет массив полигонов/мультиполигонов в новый полигон/мультиполигон
    * @memberof nsGmx.Utils
    */
    joinPolygons: function(objs)
    {
        var polygonObjects = [];
        for (var i = 0; i < objs.length; i++)
        {
            var geom = objs[i];
            if (geom.type == 'POLYGON')
            {
                polygonObjects.push(geom.coordinates);
            }
            else if (geom.type == 'MULTIPOLYGON')
            {
                for (var iC = 0; iC < geom.coordinates.length; iC++)
                    polygonObjects.push(geom.coordinates[iC]);
            }
        }

        if (polygonObjects.length > 1)
            return {type: "MULTIPOLYGON", coordinates: polygonObjects}
        else if (polygonObjects.length == 1)
        {
            return {type: "POLYGON", coordinates: polygonObjects[0]}
        }
        else
            return null;
    },

    joinClippedPolygon: function(polygon) {

        if (polygon.type !== 'MULTIPOLYGON') {
            return polygon;
        }

        var origData = [],
            segmentsToJoin = [],
            joinedSegments = [],
            crossPoints = [],
            finalPolygon = [];

        var equal = function(a, b) {return Math.abs(a - b) < 1e-5;}

        var coords = polygon.coordinates;
        for (var c = 0; c < coords.length; c++) {
            for (var r = 0; r < coords[c].length; r++) {
                coords[c][r].length = coords[c][r].length - 1;
            }
        }

        var parseRing = function(origRing) {
            var segments = [],
                ring = origRing.coords,
                len = ring.length;

            var getNextSegment = function(i) {
                var il = (i - 1 + len) % len,
                    points = [];

                while (i != il) {
                    if (equal(Math.abs(ring[i][0]), 180) && equal(Math.abs(ring[(i+1)%len][0]), 180) ) {
                        return [i, points];
                    }

                    points.push(ring[i]);
                    i = (i + 1) % len;
                }

                return [i, points];
            }

            var segment = getNextSegment(0);

            var lastI = segment[0];

            if (!equal(Math.abs(ring[segment[0]][0]), 180)) {
                origRing.regularRing = ring;
                return;
            }

            do {
                startI = (segment[0] + 1) % len;
                segment = getNextSegment((startI + 1) % len);
                var nextSegment = {
                    points: [].concat([ring[startI]], segment[1], [ring[segment[0]]])
                }
                segmentsToJoin.push(nextSegment);
                origRing.segments.push(nextSegment);
            } while (segment[0] !== lastI);
        }

        var findSegment = function(y, joinedSeg) {
            for (var s = 0; s < segmentsToJoin.length; s++) {
                var seg = segmentsToJoin[s];
                if (equal(seg.points[0][1], y) || equal(seg.points[seg.points.length - 1][1], y)) {
                    segmentsToJoin.splice(s, 1);
                    seg.joinedSeg = joinedSeg;
                    var isReg = equal(seg.points[0][1], y);
                    return {
                        points: isReg ? seg.points.slice(1, seg.points.length - 1) : seg.points.slice(1, seg.points.length - 1).reverse(),
                        lastY: isReg ? seg.points[seg.points.length - 1][1] : seg.points[0][1]
                    };
                }
            }
        }

        var joinSegment = function(y0) {
            var res = {},
                seg = findSegment(y0, res),
                points = seg.points,
                crossPoints = [y0];

            while (seg.lastY !== y0) {
                crossPoints.push(seg.lastY);
                seg = findSegment(seg.lastY);
                points = points.concat(seg.points);
            };

            res.points = points,
            res.crossPoints = crossPoints,
            res.minCrossPoint = Math.min.apply(Math, crossPoints)

            return res;
        }

        var parseGeometry = function(geom) {
            for (var c = 0; c < geom.coordinates.length; c++) {
                var origComp = [];
                origData.push(origComp);
                var comp = geom.coordinates[c];
                for (var r = 0; r < comp.length; r++) {
                    var origRing = {
                        coords: comp[r],
                        segments: []
                    }
                    origComp.push(origRing);
                    parseRing(origRing);
                }
            }
        }

        parseGeometry(polygon);

        segmentsToJoin.forEach(function(segment) {
            if (segment.points[0][0] < 0) {
                segment.points = segment.points.map(function(c) { return [c[0] + 360, c[1]];});
            }
        })

        while (segmentsToJoin.length) {
            var y0 = segmentsToJoin[0].points[0][1];
            var joinedSeg = joinSegment(y0);
            joinedSegments.push(joinedSeg);
            crossPoints = crossPoints.concat(joinedSeg.crossPoints);
        }

        crossPoints = crossPoints.sort();

        joinedSegments = joinedSegments.sort(function(s1, s2) {
            return s1.minCrossPoint - s2.minCrossPoint;
        })

        joinedSegments.forEach(function(s, i) {
            s.isExternal = (crossPoints.indexOf(s.minCrossPoint) % 2) === 0;
        })

        //собираем объединённые сегменты в мультиполигон
        joinedSegments.forEach(function(s) {
            if (s.isExternal) {
                finalPolygon.push([s.points]);
            } else {
                finalPolygon[finalPolygon.length-1].push(s.points);
            }
            s.finalComponent = finalPolygon[finalPolygon.length-1];
        })

        //добавляем компоненты, которые не пересекались со 180 градусом
        for (var c = 0; c < origData.length; c++) {
            if (origData[c][0].regularRing) {
                console.log('external component', c)
                var geomToCopy = [];
                for (var r = 0; r < origData[c].length; r++) {
                    geomToCopy.push(origData[c][r].regularRing);
                }
                finalPolygon.push(geomToCopy);
                continue;
            }
            for (var r = 1; r < origData[c].length; r++) {
                if (origData[c][r].regularRing) {
                    console.log('internal component', c, r, origData[c][0].segments);
                    for (var s = 0; s < origData[c][0].segments.length; s++) {
                        var joinedSeg = origData[c][0].segments[s].joinedSeg;
                        if (joinedSeg.isExternal) {
                            joinedSeg.finalComponent.push(origData[c][r].regularRing);
                            break;
                        }
                    }
                }
            }
        }

        if (finalPolygon.length === 1) {
            return {type: 'POLYGON', coordinates: finalPolygon[0]};
        } else {
            return {type: 'MULTIPOLYGON', coordinates: finalPolygon};
        }
    },

    /** Методы для работы с сохранёнными на сервере данными.
    * Сервер позволяет сохранять произвольный текст на сервере и получить ID, по которому можно этот текст получить.
    * Используется для формирования пермалинков (сохранение состояния)
    * @namespace
    * @memberOf nsGmx.Utils
    */
    TinyReference: {
        /** Создать новую ссылку
        * @param {String} data Данные, которые нужно сохранить
        * @return {jQuery.Deferred} Промис, который будет resolve при сохранении данных. Параметр при ресолве: ID, по которому можно получить данные обратно
        */
        create: function(data, tempFlag) {
            var def = $.Deferred();
            sendCrossDomainPostRequest(serverBase + "TinyReference/Create.ashx", {
                WrapStyle: 'message',
                content: JSON.stringify(data),
                temp: tempFlag
            },
            function(response) {
                if (parseResponse(response)) {
                    def.resolve(response.Result);
                } else {
                    def.reject();
                }
            })

            return def.promise();
        },

        /** Получить ранее сохранённые данные по ID
        * @param {String} id полученный при сохранении ID данных
        * @return {jQuery.Deferred} Промис, который будет resolve при получении данных. Параметр при ресолве: данные с сервера
        */
        get: function(id) {
            var def = $.Deferred();
            sendCrossDomainJSONRequest(serverBase + "TinyReference/Get.ashx?id=" + id, function(response){
                //если пермалинк не найден, сервер не возвращает ошибку, а просто пустой результат
                if (parseResponse(response) && response.Result) {
                    def.resolve(JSON.parse(response.Result));
                } else {
                    def.reject();
                }
            });

            return def.promise();
        },

        /** Удалить данные по ID
        * @param {String} id полученный при сохранении ID данных
        * @return {jQuery.Deferred} Промис, который будет resolve при удалении данных
        */
        remove: function(id) {
            var def = $.Deferred();
            sendCrossDomainJSONRequest(serverBase + "TinyReference/Delete.ashx?id=" + id, function(response){
                if (parseResponse(response)) {
                    def.resolve();
                } else {
                    def.reject();
                }
            });

            return def.promise();
        }
    },
    isIpad: function() {
        return navigator.userAgent.match(/iPad/i) != null;
    },
    showDialog: showDialog,
	removeDialog: removeDialog,
    makeImageButton: makeImageButton,
	makeLinkButton: makeLinkButton,
	makeButton: makeButton,
	_title: _title,
	_checkbox: _checkbox
});

window.gmxCore && window.gmxCore.addModule('utilities', nsGmx.Utils);

/** Менеджер аудетификационной информации системы. Умеет запрашивать у сервера текущий статус пользователя,
 хранит информацию о ролях и допустимых действиях пользователей с этой ролью.
 @memberOf nsGmx
 @class
 @name AuthManager
*/
var nsGmx = nsGmx || {};
(function($)
{
    $.extend(nsGmx, {
        ROLE_ADMIN        : 'admin', 
        ROLE_USER         : 'user',
        ROLE_GUEST        : 'guest',
        ROLE_UNAUTHORIZED : 'none',
        
        ACTION_CREATE_LAYERS        : 'createData',      // Создавать новые слои (векторные и растровые)
        ACTION_CREATE_MAP           : 'createMap',       // Cоздавать новые карты
        ACTION_SAVE_MAP             : 'saveMap',         // Сохранять карту (нужны права редактирования на карту)
        ACTION_CHANGE_MAP_TYPE      : 'changeType',      // Менять тип карты (публичная/открытая/закрытая и т.п.)
        ACTION_SEE_OPEN_MAP_LIST    : 'openMap',         // Видеть список публичных карт
        ACTION_SEE_PRIVATE_MAP_LIST : 'privateMap',      // Видеть спискок всех карт
        ACTION_SEE_MAP_RIGHTS       : 'seeRights',       // Видеть и редактировать права пользователей (для объектов, владельцем которых является)
        ACTION_SEE_FILE_STRUCTURE   : 'seeFiles',        // Видеть всю файловую структуру сервера, а не только свою дом. директорию
        ACTION_SEE_ALL_USERS        : 'seeUsers',        // Видеть список всех пользователей
        ACTION_SEE_USER_FULLNAME    : 'seeUserFullname', // Видеть полные имена и логины пользователей (а не только псевдонимы)
        ACTION_UPLOAD_FILES         : 'uploadFiles'      // Загружать файлы на сервер через web-интерфейс
    });
    
    var _actions = {};
    _actions[nsGmx.ROLE_ADMIN] = {};    
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_CREATE_LAYERS       ] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_CREATE_MAP          ] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_SAVE_MAP            ] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_SEE_OPEN_MAP_LIST   ] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_SEE_PRIVATE_MAP_LIST] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_CHANGE_MAP_TYPE     ] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_SEE_MAP_RIGHTS      ] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_SEE_FILE_STRUCTURE  ] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_SEE_ALL_USERS       ] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_SEE_USER_FULLNAME   ] = true;
    _actions[nsGmx.ROLE_ADMIN][nsGmx.ACTION_UPLOAD_FILES        ] = true;
    
    _actions[nsGmx.ROLE_USER] = {};
    _actions[nsGmx.ROLE_USER][nsGmx.ACTION_CREATE_LAYERS     ] = true;
    _actions[nsGmx.ROLE_USER][nsGmx.ACTION_CREATE_MAP        ] = true;
    _actions[nsGmx.ROLE_USER][nsGmx.ACTION_SAVE_MAP          ] = true;
    _actions[nsGmx.ROLE_USER][nsGmx.ACTION_SEE_OPEN_MAP_LIST ] = true;
    _actions[nsGmx.ROLE_USER][nsGmx.ACTION_SEE_MAP_RIGHTS    ] = true;
    _actions[nsGmx.ROLE_USER][nsGmx.ACTION_UPLOAD_FILES      ] = true;
    
    _actions[nsGmx.ROLE_GUEST] = {}
    _actions[nsGmx.ROLE_GUEST][nsGmx.ACTION_SEE_OPEN_MAP_LIST ] = true;
    _actions[nsGmx.ROLE_GUEST][nsGmx.ACTION_SAVE_MAP          ] = true;
    
    nsGmx.AuthManager = new function()
    {
        var _userInfo = null;
        var _this = this;
        
        this.getLogin = function()
        {
            if (!_userInfo) return null;
            return _userInfo.Login || null;
        };
        
        this.getNickname = function()
        {
            if (!_userInfo) return null;
            return _userInfo.Nickname || null;
        };
        
        this.getFullname = function()
        {
            if (!_userInfo) return null;
            return _userInfo.FullName || null;
        };
        
        this.getUserFolder = function()
        {
            if (!_userInfo) return null;
            return _userInfo.Folder;
        };
        
        this.isRole = function(role)
        {
            return _userInfo && _userInfo.Role === role;
        };
        
        this.canDoAction = function(action)
        {
            return _userInfo && _userInfo.Role in _actions && action in _actions[_userInfo.Role];
        };
        
        this.isAccounts = function()
        {
            return _userInfo && _userInfo.IsAccounts;
        };
        
        this.isLogin = function()
        {
            return _userInfo && _userInfo.Login !== false && _userInfo.Role !== this.ROLE_UNAUTHORIZED;
        };
        
        this.setUserInfo = function(userInfo)
        {
            _userInfo = $.extend({}, {IsAccounts: false, Role: this.ROLE_UNAUTHORIZED}, userInfo);
            $(this).triggerHandler('change');
        };        
        
        this.checkUserInfo = function(callback, errorCallback)
        {
            //var isTokenUsed = false;
            var _processResponse = function( response )
            {
                var resOk = parseResponse(response);
                
                !resOk && errorCallback && errorCallback();
                    
                if (response.Result == null || !resOk)
                {
                    // юзер не авторизован
                    _this.setUserInfo({Login: false});
                }
                else
                {
                    _this.setUserInfo(response.Result);
                }
                
                resOk && callback && callback();
            }
            
            
            for (var iProvider = 0; iProvider < checkProviders.length; iProvider++)
            {
                if (checkProviders[iProvider].canAuth())
                {
                    checkProviders[iProvider].doAuth(callback, errorCallback);
                    return;
                }
            }
            
            sendCrossDomainJSONRequest(serverBase + 'User/GetUserInfo.ashx?WrapStyle=func', function(response) {
                if (response.Status === 'ok' && !response.Result && window.mapsSite && window.gmxAuthServer) {
                    var callbackPath = location.href.match(/(.*)\//)[0] + 'oAuthCallback.html';
                    nsGmx.Utils.login(callbackPath, serverBase + 'oAuth/', function(userInfo) {
                        _processResponse({Status: 'ok', Result: userInfo || null});
                    }, null, true);
                } else {
                    doAuthServerLogin(response.Result && response.Result.Token);
                    _processResponse(response);
                }
            })
        }
        
        this.login = function(login, password, callback, errorCallback)
        {
            sendCrossDomainPostRequest(serverBase + "Login.ashx", {WrapStyle: 'message', login: login, pass: password}, function(response)
            {
                if (response.Status == 'ok' && response.Result)
                {
                    _this.setUserInfo(response.Result);
                    
                    doAuthServerLogin(response.Result && response.Result.Token);
                    
                    callback && callback();
                }
                else
                {
                    if (response.Status === 'auth' && ('Result' in response) && (typeof(response.Result) === 'object') && ('ExceptionType' in response.Result) && response.Result.ExceptionType.indexOf('System.ArgumentException') == 0)
                    {
                        errorCallback && errorCallback({emailWarning: true, message: response.Result.Message})
                    }
                    errorCallback && errorCallback({emailWarning: false});
                }
            });
        }
        
        this.logout = function(callback)
        {
            sendCrossDomainJSONRequest(serverBase + "Logout.ashx?WrapStyle=func&WithoutRedirection=1", function(response)
            {
                if (!parseResponse(response))
                    return;
                    
                if (_this.isAccounts() && window.gmxAuthServer)
                {
                    sendCrossDomainJSONRequest(window.gmxAuthServer + "Handler/Logout", function(response)
                    {
                        //TODO: check result
                        _this.setUserInfo({Login: false});
                        callback && callback();
                    }, 'callback');
                }
                else
                {
                    _this.setUserInfo({Login: false});
                    callback && callback();
                }
            });
        }
        
        this.changePassword = function(oldPass, newPass, callback, errorCallback)
        {
            sendCrossDomainJSONRequest(serverBase + "ChangePassword.ashx?WrapStyle=func&old=" + encodeURIComponent(oldPass) + "&new=" + encodeURIComponent(newPass), function(response)
            {
                if (response.Status == 'ok' && response.Result)
                    callback && callback();
                else
                {
                    var msg = response.ErrorInfo && typeof response.ErrorInfo.ErrorMessage != 'undefined' ? response.ErrorInfo.ErrorMessage : null;
                    errorCallback && errorCallback(msg);
                }
            });
        }
    }
    
    var checkProviders = [];
    
    var doAuthServerLogin = function(token) {
        if (token && window.mapsSite && window.gmxAuthServer) {
            sendCrossDomainJSONRequest(gmxAuthServer + 'Handler/Me?token=' + encodeURIComponent(token), function(response) {
                //console.log(response);
            }, 'callback');
        }
    }
    
    //canAuth() -> bool
    //doAuth(callbackSuccess, callbackError)
    nsGmx.AuthManager.addCheckUserMethod = function(provider)
    {
        checkProviders.push(provider);
    }
})(jQuery);
/** Виджет для визуализации информации о текущем статусе пользователя.
* Показывает кнопки Вход/Выход, имя пользователя. Позволяет отослать логин/пароль на сервер, сменить пароль.
 @memberOf nsGmx
 @class
 @name GeoMixerAuthWidget
*/
var nsGmx = nsGmx || {};
(function($, _)
{
    var _dialogCanvas = null;

    function changePasswordDialog()
    {
        if ($('#changePasswordCanvas').length)
            return;

        var oldInput = _input(null, [['dir','className','inputStyle'],['css','width','160px'],['attr','type','password']]),
            newInput = _input(null, [['dir','className','inputStyle'],['css','width','160px'],['attr','type','password']]),
            confirmInput = _input(null, [['dir','className','inputStyle'],['css','width','160px'],['attr','type','password']]),
            changeButton = makeButton(_gtxt("Изменить")),
            canvas = _div([_div([_span([_t(_gtxt("Старый пароль"))]), _br(), oldInput, _br(),
                                _span([_t(_gtxt("Новый пароль"))]), _br(), newInput, _br(),
                                _span([_t(_gtxt("Подтвердите пароль"))]), _br(), confirmInput, _br()],[['css','textAlign','center']]),
                           _div([changeButton],[['css','textAlign','center'],['css','margin','5px']])],[['attr','id','changePasswordCanvas']]),
            checkPassw = function()
            {
                if (newInput.value != confirmInput.value)
                {
                    newInput.value = '';
                    confirmInput.value = '';

                    inputError([newInput, confirmInput], 2000);
                    newInput.focus();

                    return;
                }

                nsGmx.widgets.notifications.startAction('changePassword');
                nsGmx.AuthManager.changePassword(oldInput.value, newInput.value, function()
                {
                    jQuery(canvas.parentNode).dialog("destroy");
                    canvas.parentNode.removeNode(true);

                    nsGmx.widgets.notifications.stopAction('changePassword', 'success', _gtxt('Пароль изменён'));
                }, function( message )
                {
                    message && showErrorMessage(message, true);
                    nsGmx.widgets.notifications.stopAction('changePassword', 'failure');
                })

                oldInput.value = '';
                newInput.value = '';
                confirmInput.value = '';
            };

        showDialog(_gtxt("Изменение пароля"), canvas, 200, 200, false, false);
        canvas.parentNode.style.overflow = 'hidden';

        oldInput.focus();

        changeButton.onclick = function()
        {
            checkPassw();
        }

        $(confirmInput).on('keyup', function(e)
        {
            if (e.keyCode === 13)
            {
                checkPassw();

                return false;
            }

            return true;
        });
    }

    var loginDialogTemplate =
        '<div>' +
            '<div class = "loginMainDiv">' +
                '<form>' +
                    '<div>' +
                        '<span class="loginLabel">{{i "Логин"}}</span><br>' +
                        '<input name="login" class = "inputStyle inputLogin" placeholder = "{{i "адрес электронной почты"}}"><br>' +
                    '</div>' +
                    '<div>' +
                        '<span class="loginLabel">{{i "Пароль"}}</span><br>' +
                        '<input name="password" class = "inputStyle inputPass" type = "password" placeholder = "{{i "пароль"}}"><br>' +
                    '</div>' +
                    '<button class="loginButton">{{i "Вход"}}</button>' +
                '</form>' +
            '</div>' +
            '{{#isMapsSite}}' +
            '<div class="loginLinks">' +
                '<span class = "buttonLink registration">{{i "Регистрация"}}</span><br>' +
                '<span class = "buttonLink passRecovery">{{i "Восстановление пароля"}}</span>' +
            '</div>' +
            '{{/isMapsSite}}' +
        '</div>';

    nsGmx.GeoMixerAuthWidget = function( container, authManager, loginCallback, options )
    {
        var _container = container;
        var _authManager = authManager;
        var _this = this;

        _this.changePasswordDialog = changePasswordDialog;

        options = options || {};

        var _createLogin = function()
        {
            var span = makeLinkButton(_gtxt('Вход'));

            span.onclick = function()
            {
                _this.showLoginDialog( loginCallback );
            }
            _(_container, [_div([span], [['attr','id','log'],['dir','className','log']])]);
        }

        var _createLogout = function()
        {
            var logoutSpan = makeLinkButton(_gtxt('Выход'));

            logoutSpan.onclick = function()
            {
                _authManager.logout(function()
                {
                    if (nsGmx.GeomixerFramework)
                        _mapHelper.reloadMap();
                    else
                        window.location.replace(window.location.href.split("?")[0] + (defaultMapID == globalMapName ? "" : ("&" + globalMapName)));
                });
            }

            var userText = _authManager.getLogin();
            if (_authManager.getFullname() !== null && _authManager.getFullname() !== '')
                userText += ' (' + _authManager.getFullname() + ')';
            var userSpan = _span([_t(userText)], [['css','cursor','pointer']]);

            userSpan.onclick = function()
            {
                if ( _authManager.isAccounts() )
                {
                    if (window.gmxAuthServer)
                        window.open(  window.gmxAuthServer + "Account/ChangePassword", '_blank');
                }
                else
                    changePasswordDialog();
            }

            if ( _authManager.isAccounts() )
                $(userSpan).css('color', '#5555FF');

            _title(userSpan, _gtxt("Изменение пароля"))

            _(_container, [_table([_tr([
                _td([_div([userSpan], [['attr','id','user'],['dir','className','user']])]),
                _td([_div([logoutSpan], [['attr','id','log'],['dir','className','log']])])
            ])])]);
        }

        var _update = function()
        {
            if ( window.gmxViewerUI && window.gmxViewerUI.hideLogin )
                return;

            $(_container).empty();

            if (_authManager.isLogin())
            {
                _createLogout();
            }
            else
            {
                _createLogin();
            }
        }

        $(_authManager).change(_update);
        _update();

        //Показывает диалог с вводом логина/пароля, посылает запрос на сервер.
        this.showLoginDialog = function()
        {
            if (_dialogCanvas) {
                return;
            }

            var isMapsSite = !!window.mapsSite;
            var dialogHeight = isMapsSite ? 210 : 175;

            var canvas = $(Handlebars.compile(loginDialogTemplate)({isMapsSite: isMapsSite})),
                loginInput = canvas.find('.inputLogin')[0],
                passwordInput = canvas.find('.inputPass')[0],
                loginButton = canvas.find('.loginButton')[0];

            var checkLogin = function(){
                _authManager.login(loginInput.value, passwordInput.value, function()
                    { //всё хорошо
                        $(jQueryDialog).dialog("destroy")
                        jQueryDialog.removeNode(true);
                        _dialogCanvas = null;
                        loginCallback && loginCallback();
                    }, function(err)
                    { //ошибка
                        if (err.emailWarning)
                        {
                            var errorDiv = $("<div/>", {'class': 'EmailErrorMessage'}).text(err.message);
                            $(loginButton).after(errorDiv);
                            setTimeout(function(){
                                errorDiv.hide(500, function(){ errorDiv.remove(); });
                            }, 8000)
                        }
                        loginInput.value = '';
                        passwordInput.value = '';
                        inputError([loginInput, passwordInput], 2000);
                        loginInput.focus();
                    }
                );
            };

            _dialogCanvas = canvas;

            var jQueryDialog = showDialog(_gtxt("Пожалуйста, авторизуйтесь"), canvas[0], 248, dialogHeight, false, false, null, function()
            {
                _dialogCanvas = null;
            });

            loginInput.focus();

            loginButton.onclick = checkLogin;

            canvas.find('form').submit(function(e) {
                e.preventDefault();
            })

            canvas.find('.registration').click(options.registrationCallback || function(){
                window.open(window.gmxAuthServer + 'Account/Registration', '_blank');
            });

            canvas.find('.passRecovery').click(function(){
                window.open(window.gmxAuthServer + 'Account/Retrive', '_blank');
            });

            $(passwordInput).on('keyup', function(e)
            {
                if (e.keyCode === 13)
                {
                    checkLogin();

                    return false;
                }

                return true;
            });
        }

        this.getContainer = function()
        {
            return _container;
        }
    }

    // Обратная совместимость. Проверка нужна из-за возможного конфликта с одноимённым классом из общих компонент
    if (!nsGmx.AuthWidget) {
        nsGmx.AuthWidget = nsGmx.GeoMixerAuthWidget;
    }

})(jQuery, nsGmx.Utils._);

(function(){

var tasks = {};
var tasksByName = {};

var UPDATE_INTERVAL = 2000;

var sendGmxRequest = function(requestType, url, params) {
    var def = $.Deferred();
    
    var processResponse = function(response) {
        if (!response.Result || !response.Result.TaskID) {
            if (response.Status === 'ok' && !response.ErrorInfo) {
                def.resolve(response);
            } else {
                parseResponse(response);
                def.reject(response);
            }
            return;
        }
        
        def.notify(response.Result);
        
        var taskID = response.Result.TaskID;
        
        var interval = setInterval(function(){
            sendCrossDomainJSONRequest(serverBase + "AsyncTask.ashx?WrapStyle=func&TaskID=" + taskID, 
                function(response)
                {
                    var res = response.Result;
                    if (response.Status !== 'ok' || res.ErrorInfo)
                    {
                        res.Status = 'error';
                        parseResponse(res);
                        clearInterval(interval);
                        def.reject(res);
                    }
                    else if (res.Completed)
                    {
                        clearInterval(interval);
                        def.resolve(res);
                    }
                    else
                    {
                        def.notify(res);
                    }
                }, null, 
                function() {
                    clearInterval(interval);
                    def.reject();
                }
            );
        }, UPDATE_INTERVAL);
    }
    
    if (requestType === 'get') {
    
        params = params || {};
    
        var paramStrItems = [];
        
        for (var p in params) {
            paramStrItems.push(p + '=' + encodeURIComponent(params[p]));
        }
        
        var sepSym = url.indexOf('?') == -1 ? '?' : '&';
        
        
        sendCrossDomainJSONRequest(
            url + sepSym + paramStrItems.join('&'), 
            processResponse, null, def.reject.bind(def)
        );
    } else if (requestType === 'post') {
        var localParams = $.extend({WrapStyle: 'message'}, params);
        sendCrossDomainPostRequest(url, localParams, processResponse);
    } else {
        throw 'Wrong request type';
    }
    
    return def.promise();
}

nsGmx.asyncTaskManager = {
    sendGmxJSONPRequest: sendGmxRequest.bind(null, 'get'),
    sendGmxPostRequest: sendGmxRequest.bind(null, 'post')
}

})()
var nsGmx = nsGmx || {};

// Делегаты пользовательских объектов - классы, управляющие отображением и сериализацией пользовательских объектов
// Методы:
//   - isHidden(obj) -> Bool
//   - isSerializable(obj) -> Bool
nsGmx.DrawingObjectCustomControllers = (function()
{
	var _delegates = [];
	return {
		addDelegate: function(delegate)
		{
			_delegates.push(delegate);
		},
		
		isHidden: function(obj)
		{
			for (var d = 0; d < _delegates.length; d++)
				if ('isHidden' in _delegates[d] && _delegates[d].isHidden(obj))
					return true;
			return false;
		},
		
		isSerializable: function(obj)
		{
			for (var d = 0; d < _delegates.length; d++)
				if ('isSerializable' in _delegates[d] && !_delegates[d].isSerializable(obj))
					return false;
			return true;
		}
	}
})();
/**
  @class
  @virtual
  @name IMenuElem
  @desc Описание пункта верхнего меню ГеоМиксера
  @property {String} id Уникальный идентификатор элемента меню
  @property {String} title Tекст, который будет показываться пользователю
  @property {Function} func Ф-ция, которую нужно вызвать при клике
  @property {IMenuElem[]} childs Массив элементов подменю
*/

/**
    Верхнее меню ГеоМиксера. Может содержать до 3 уровней вложенности элементов.
    @class
*/
var UpMenu = function()
{

    this.submenus = [];
	this.currSel = null;
	this.currUnSel = null;
	this.refs = {};

	this.parent = null;
    this.loginContainer = null;
    this._isCreated = false;
    this.defaultHash = 'layers';
};

//предполагает, что если callback возвращает true, то итерирование можно прекратить
UpMenu.prototype._iterateMenus = function(elem, callback) {
    if (!elem.childs) {
        return;
    }

    for (var i = 0; i < elem.childs.length; i++) {
        if (elem.childs[i] && (callback(elem.childs[i]) || this._iterateMenus(elem.childs[i], callback))) {
            return true;
        }
    }
}

/** Добавляет к меню новый элемент верхнего уровня
*
* Если меню уже было нарисовано, вызов этой ф-ции приведёт к перерисовке
*
*    @param {IMenuElem} elem Элемент меню
*/
UpMenu.prototype.addItem = function(elem)
{
    this.submenus.push(elem)
    this._isCreated && this.draw();
}

/** Добавляет к меню новый элемент.
*
* Если меню уже было нарисовано, вызов этой ф-ции приведёт к перерисовке
*
*    @param {IMenuElem} newElem Вставляемый элемент меню
*    @param {String} parentID ID элемента меню, к которому добавляется новый элемент
*    @param {String} [insertBeforeID] ID элемента меню, перед которым нужно вставить пункт меню.
*                    Если не указан, пункт меню будет добавлен в конец списка.
*/
UpMenu.prototype.addChildItem = function(newElem, parentID, insertBeforeID)
{
    this._iterateMenus({childs: this.submenus}, function(elem) {
        if (elem.id && elem.id === parentID) {
            elem.childs = elem.childs || [];
            
            var index = elem.childs.length;
            elem.childs.forEach(function(childElem, i) {
                if (childElem.id === insertBeforeID) {
                    index = i;
                }
            })
            
            elem.childs.splice(index, 0, newElem);

            this._isCreated && this.draw();

            return true;
        }
    }.bind(this));
}

/** Задаёт родителя в DOM дереве для меню
* @param {DOMElement} parent Родительский элемент в DOM дереве
*/
UpMenu.prototype.setParent = function(parent)
{
	this.parent = parent;

	if (parent)
    {
		$(parent).empty();
        parent.appendChild(_span());
    }

	this.disabledTabs = {};
}

// Показывает элемент меню
UpMenu.prototype.showmenu = function(elem)
{
	elem.style.visibility = 'visible';
}
// Скрывает элемент меню
UpMenu.prototype.hidemenu = function(elem)
{
	elem.style.visibility = 'hidden';
}

UpMenu.prototype._template = Handlebars.compile(
'<div class="headerContainer">\
{{#childs}}{{#if id}}\
    <div class = "header1{{#unless childs}} menuClickable{{/unless}}" hash = "{{id}}">\
        <div class = "header1Internal">{{title}}</div>\
        {{#if childs}}\
            <ul class = "header2" id="{{id}}">\
            {{#childs}}{{#if id}}\
                <li class = "header2{{#unless childs}} menuClickable{{/unless}}" hash = "{{id}}">\
                    <div class = "header2{{#if disabled}} menuDisabled{{/if}}{{#delimiter}} menuDelimiter{{/delimiter}}">\
                        <div class = "menuMarkerLeft {{#if checked}} ui-icon ui-icon-check{{/if}}"></div>\
                        {{title}}\
                        {{#if childs}}\
                            <div class = "menuMarkerRight"></div>\
                        {{/if}}\
                    </div>\
                    {{#if childs}}\
                        <ul class = "header3" id="{{id}}">\
                        {{#childs}}{{#if id}}\
                            <li class = "header3 menuClickable" hash = "{{id}}">\
                                <div class = "header3{{#if disabled}} menuDisabled{{/if}}{{#delimiter}} menuDelimiter{{/delimiter}}">\
                                    <div class = "menuMarkerLeft {{#if checked}} ui-icon ui-icon-check{{/if}}"></div>\
                                    {{title}}\
                                </div>\
                            </li>\
                        {{/if}}{{/childs}}\
                        </ul>\
                    {{/if}}\
                </li>\
            {{/if}}{{/childs}}\
            </ul>\
        {{/if}}\
    </div>\
    {{/if}}{{/childs}}\
</div>');

/** Основная функция  - рисует меню по заданной структуре
*/
UpMenu.prototype.draw = function()
{
    var ui = $(this._template({
            childs: this.submenus
        })),
        _this = this;

    $(this.parent.firstChild).empty().append(ui);

    $(ui).find('.header1').each(function() {
        _this.attachEventOnMouseover(this, 'menuActive');
        _this.attachEventOnMouseout(this, 'menuActive');
        $(this).width($(this).width() + 10);
    });

    $(ui).find('li.header2').each(function() {
        _this.attachEventOnMouseover(this, 'menu2Active');
        _this.attachEventOnMouseout(this, 'menu2Active');
    });

    $(ui).find('li.header3').each(function() {
        attachEffects(this, 'menu3Active');
    });

    $(ui).find('.menuClickable').each(function() {
        var id = $(this).attr('hash');
        $(this).click(function() {
            _this.refs[id].disabled || _this.openTab(id);
        });
    });

    this._iterateMenus({childs: this.submenus}, function(elem) {
        _this.refs[elem.id] = elem;
    })

    //убираем все скрытые меню
    for (var d in this.disabledTabs)
        this.disableMenus([d]);

    this._isCreated = true;
}

UpMenu.prototype.checkItem = function(id, isChecked) {
    if (this.refs[id]) {
        this.refs[id].checked = isChecked;
        $(this.parent).find('li[hash=' + id + ']').find('.menuMarkerLeft').toggleClass('ui-icon ui-icon-check', isChecked);
    }
}

UpMenu.prototype.removeSelections = function(id)
{
	$('li.menu3Active').removeClass('menu3Active');
	$('li.menu2Active').removeClass('menu2Active');
	$('li.menuActive').removeClass('menuActive');
}
// Закрывает открытые меню
UpMenu.prototype.hideMenus = function()
{
	var _this = this;

	$('ul.header2').each(function()
	{
		_this.hidemenu(this);
	})
	$('ul.header3').each(function()
	{
		_this.hidemenu(this);
	})
}
// Открывает закладку
UpMenu.prototype.openRef = function(hash)
{
	_menuUp.removeSelections();
	_menuUp.hideMenus();
	_menuUp.openTab(hash);
}

UpMenu.prototype.attachEventOnMouseover = function(elem, className)
{
	var _this = this;
	elem.onmouseover = function(e)
	{
		$(this).addClass(className);

		if ($('#' + this.getAttribute('hash'))[0])
			_this.showmenu($('#' + this.getAttribute('hash'))[0]);
	}
}
UpMenu.prototype.attachEventOnMouseout = function(elem, className)
{
	var _this = this;
	elem.onmouseout = function(e)
	{
		var evt = e || window.event,
			target = evt.srcElement || evt.target,
			relTarget = evt.relatedTarget || evt.toElement,
			elem = this;

		try
		{
			while (relTarget)
			{
				if (relTarget == elem)
				{
					stopEvent(e);

					return false;
				}
				relTarget = relTarget.parentNode;
			}

			$(elem).removeClass(className)

			if ($('#' + elem.getAttribute('hash')).length)
				_this.hidemenu($('#' + elem.getAttribute('hash'))[0]);
		}
		catch (e)
		{
			$(elem).removeClass(className)

			if ($('#' + elem.getAttribute('hash')).length)
				_this.hidemenu($('#' + elem.getAttribute('hash'))[0]);
		}
	}
}

UpMenu.prototype.getNavigatePath = function(path) {
	for (var menuIdx = 0; menuIdx < this.submenus.length; menuIdx++)
	{
        var submenu = this.submenus[menuIdx];
        
        if (!submenu) {continue};

		if (path == submenu.id)
		{
            return [submenu.title];
		}

		if (submenu.childs)
		{
			var childsLevel2 = submenu.childs;
			for (var i = 0; i < childsLevel2.length; i++)
			{
                if (!childsLevel2[i]) {continue};
                
				if (childsLevel2[i].childs)
				{
					var childsLevel3 = childsLevel2[i].childs;
					// есть подменю, смотрим там
					for(var j = 0; j < childsLevel3.length; j++)
					{
                        if (!childsLevel3[j]) {continue};
                        
						if (path == childsLevel3[j].id)
						{
                            return [submenu.title, childsLevel2[i].title, childsLevel3[j].title];
						}
					}
				}
				if (path == childsLevel2[i].id)
				{
					// совпадение в меню 2го уровня
                    return [submenu.title, childsLevel2[i].title];
				}
			}
		}
	}

	return [];
}

/** Показывает все ранее скрытые элементы меню
*/
UpMenu.prototype.enableMenus = function()
{
	for (var name in this.disabledTabs)
	{
		$(this.parent).find("li[hash='" + name + "']").children('div').css('display','');

		delete this.disabledTabs[name];
	}
}
/** Скрывает заданные элементы меню
* @param {String[]} arr Массив ID элементов меню, которые нужно скрыть
*/
UpMenu.prototype.disableMenus = function(arr)
{
	for (var i = 0; i < arr.length; i++)
	{
		$(this.parent).find("li[hash='" + arr[i] + "']").children('div').css('display','none');

		this.disabledTabs[arr[i]] = true;
	}
}

UpMenu.prototype.checkView = function()
{
	if (!nsGmx.AuthManager.isLogin())
	{
		this.enableMenus();

		this.disableMenus(['mapCreate', 'mapSave', 'mapSaveAs', 'layersMenu', 'pictureBinding']);
	}
	else if (_queryMapLayers.currentMapRights() != "edit")
	{
		this.enableMenus();

		this.disableMenus(['mapSave', 'mapSaveAs', 'layersVector', 'layersRaster', 'layersMultiRaster']);
	}

    if (!nsGmx.AuthManager.isRole(nsGmx.ROLE_ADMIN)) {
        this.disableMenus(['stileLibrary']);
    }

    if (_queryMapLayers.currentMapRights() !== "edit") {
        this.disableMenus(['mapTabsNew']);
    }

	if (!nsGmx.AuthManager.canDoAction(nsGmx.ACTION_CREATE_LAYERS))
	{
            this.disableMenus(['layersVector', 'layersRaster', 'layersMultiRaster']);
	}

    if (!nsGmx.AuthManager.canDoAction(nsGmx.ACTION_CREATE_MAP))
	{
            this.disableMenus(['mapCreate']);
	}
}

UpMenu.prototype.go = function(container)
{
	this.setParent(container);

	this.createMenu();

	this.draw();

	this.checkView();

	if (window.location.hash)
	{
		this.currUnsel = function(){};
	}

	this.openTab(this.defaultHash);
}

UpMenu.prototype.openTab = function(id)
{
    if (this.disabledTabs[id] || !this.refs[id]) {
        return;
    }

    var item = this.refs[id];

    this.removeSelections();
	this.hideMenus();

    if (item.func) {
        item.func(id);
    } else {
        var func = item[item.checked ? 'onunsel' : 'onsel'];
        this.checkItem(id, !item.checked);
        func && func(id);
    }
}

/** Блок (контейнер с заголовком) левой панели
    @class
    @param {String} canvasID Уникальный идентификатор блока
    @param {Object} options Параметры
    @param {function} [options.closeFunc] Ф-ция, которая будет вызвана при нажатии на иконку закрытия блока. По умолчанию ничего не делается.
    @param {String[]} [options.path] Массив строк для формирования названия блока (см. метод setTitle()).
                      По умолчанию будет сформирован из верхнего меню ГеоМиксера по canvasID.
    @param {Boolean} [options.showCloseButton=true] Показывать ли кнопку закрытия блока
    @param {Boolean} [options.showMinimizeButton=true] Показывать ли кнопку сворачивания блока
*/
nsGmx.LeftPanelItem = function(canvasID, options) {
    /** Изменение видимости контента ("свёрнутости") панели
     * @event nsGmx.LeftPanelItem.changeVisibility
    */

    options = $.extend({
        closeFunc: function(){},
        showCloseButton: true,
        showMinimizeButton: true
    }, options);
    
    //по умолчанию оставляем только последний элемент списка
    if (!options.path) {
        var menuPath = _menuUp.getNavigatePath(canvasID);
        options.path = menuPath.length ? [menuPath[menuPath.length - 1]] : [];
    }

    var getPathHTML = function(path) {
        if (!path) return '';

        return Handlebars.compile(
            '<tr>' +
                '{{#path}}' +
                    '<td class="leftmenu-path-item {{#last}}menuNavigateCurrent{{/last}}">{{name}}</td>' +
                    '{{^last}}<td><div class="markerRight"></div></td>{{/last}}' +
                '{{/path}}' +
            '</tr>')(
            {
                path: path.map(function(item, index, arr) {
                    return {name: item, last: index === arr.length-1};
                })
            }
        );
    }

    var ui = Handlebars.compile(
        '<div class="leftmenu-canvas {{id}}" id="{{id}}">' +
            '{{#isTitle}}<div class="leftTitle">' +
                '{{#showMinimizeButton}}' + 
                    '<div class = "leftmenu-toggle-zone">' + 
                        '<div class="ui-helper-noselect leftmenu-toggle-icon leftmenu-down-icon"></div>' + 
                    '</div>' +
                '{{/showMinimizeButton}}' +
                '<table class="leftmenu-path ui-helper-noselect">{{{pathTR}}}</table>' +
                '{{#showCloseButton}}<div class="gmx-icon-close"></div>{{/showCloseButton}}' +
            '</div>{{/isTitle}}' +
            '<div class = "workCanvas"></div>' +
        '</div>');

    /**HTML элемент с блоком (содержит шапку и рабочую область)*/
    this.panelCanvas = $(ui({
        isTitle: !!(options.path.length || options.showCloseButton || options.showMinimizeButton),
        id: 'left_' + canvasID,
        pathTR: getPathHTML(options.path),
        showCloseButton: options.showCloseButton,
        showMinimizeButton: options.showMinimizeButton
    }))[0];

    /**Рабочая область блока*/
    this.workCanvas = $(this.panelCanvas).find('.workCanvas')[0];

    /** Программная имитация нажатия кнопки закрытия блока
        @function
    */
    this.close = options.closeFunc;

    var isUICollapsed = false,
        _this = this;
    
    var toggleContentVisibility = function(isCollapsed) {
        if (isUICollapsed !== isCollapsed) {
            isUICollapsed = !isUICollapsed;
            $(_this.workCanvas).toggle();
            $(_this.panelCanvas).find('.leftmenu-toggle-zone div').toggleClass('leftmenu-down-icon leftmenu-right-icon');
            $(_this).trigger('changeVisibility');
        }
    }

    $('.leftmenu-toggle-zone, .leftmenu-path', this.panelCanvas).click(function() {
        toggleContentVisibility(!isUICollapsed);
    });
    
    /** Свернуть панель
        @function
    */
    this.hide = toggleContentVisibility.bind(null, true);
    
    /** Развернуть панель
        @function
    */
    this.show = toggleContentVisibility.bind(null, false);
    
    /** Свёрнута ли панель */
    this.isCollapsed = function() {return isUICollapsed};

    $('.leftTitle .gmx-icon-close',  this.panelCanvas).click(options.closeFunc);

    /** Задать новый заголовок окна
     @param {String[]} [path] Массив строк для формирования названия блока.
                      Предполагается, что последний элемент является собственно названием, а предыдущие - названиями категорий.
    */
    this.setTitle = function(path) {
        $('.leftmenu-path', this.panelCanvas).html(getPathHTML(path));
    }
}

/** Основное меню ГеоМиксера
 * @global
 * @type {UpMenu}
 */
var _menuUp = new UpMenu();

// содержит ссылку на рабочую область для текущей вкладки
var leftMenu = function()
{
	this.workCanvas = null;
	this.parentWorkCanvas = null;
}

//варианты вызова:
//    function(canvasID, closeFunc, options) - для обратной совместимости
//    function(canvasID, options)
// options - те же, что и в LeftPanelItem
leftMenu.prototype.createWorkCanvas = function(canvasID, closeFunc, options)
{
    if (typeof closeFunc !== 'function') {
        options = closeFunc || {};
        closeFunc = options.closeFunc;
    } else {
        options = options || {};
    }

    options.closeFunc = function() {
        $(_this.parentWorkCanvas).hide();
        closeFunc && closeFunc();
    }

    var _this = this;
	if (!$('#left_' + canvasID).length)
	{
        var leftPanelItem = new nsGmx.LeftPanelItem(canvasID, options);
        this.parentWorkCanvas = leftPanelItem.panelCanvas;
        this.workCanvas = leftPanelItem.workCanvas;
        this.leftPanelItem = leftPanelItem;
        
        // так как мы используем dom элементы для поиска панелей после первого добавления
        // возможно, лучше сделать полноценный менеджер панелей левой вкладки
        this.parentWorkCanvas.leftPanelItem = leftPanelItem;

        $('#leftContentInner').prepend(this.parentWorkCanvas);

		return false;
	}
	else
	{
		this.parentWorkCanvas = $('#left_' + canvasID)[0];
		this.workCanvas = this.parentWorkCanvas.lastChild;
        this.leftPanelItem = this.parentWorkCanvas.leftPanelItem;
        this.leftPanelItem.close = options.closeFunc;

		$(this.parentWorkCanvas).show();
        
        $('#leftContentInner').prepend(this.parentWorkCanvas);

		return true;
	}
}
!(function($, _) {

var modulePath = "";

//TODO: вынести переключалку страниц в отдельный модуль
var appendTranslations = function()
{
    _translationsHash.addtext("rus", {
        "Следующие [value0] страниц" : "Следующие [value0] страниц",
        "Предыдущие [value0] страниц" : "Предыдущие [value0] страниц",
        "Первая страница" : "Первая страница",
        "Последняя страница" : "Последняя страница"
    });

    _translationsHash.addtext("eng", {
        "Следующие [value0] страниц" : "Next [value0] pages",
        "Предыдущие [value0] страниц" : "Previous [value0] pages",
        "Первая страница" : "First page",
        "Последняя страница" : "Last page"
    });
}

/** Интерфейс провайдера данных таблицы {@link nsGmx.ScrollTable}
 * @class nsGmx.ScrollTable.IDataProvider
 * @abstract
 */

/** Получить общее количество объектов
  @method nsGmx.ScrollTable.IDataProvider#getCount
  @param {function(Number)} callback Ф-ция, которую нужно вызвать с общим количеством объектов
*/
 
/** Это событие должно генерироваться при любом изменении набора данных. Приведёт к перерисовке таблицы
  @event nsGmx.ScrollTable.IDataProvider#change
*/

/** Получить массив объектов для отрисовки на странице
  @method nsGmx.ScrollTable.IDataProvider#getItems
  @param {Number} page Номер страницы (нумерация с нуля)
  @param {Number} pageSize Размер страницы
  @param {String} sortParam По какому атрибуту сортировать
  @param {Boolean} sortDec Направление сортировки (true - по убыванию)
  @param {function(Array)} callback Ф-ция, которую нужно вызвать с результирующим массивом объектов. Структура самих объектов определяется провайдером
*/

/** Получить массив объектов для отрисовки на страницы и общее количество данных за один запрос. 
    Альтернатива раздельным запросам getItems() и getCount(). Можно реализовать либо эту ф-цию, либо две другие
  @method nsGmx.ScrollTable.IDataProvider#getCountAndItems
  @param {Number} page Номер страницы (нумерация с нуля)
  @param {Number} pageSize Размер страницы
  @param {String} sortParam По какому атрибуту сортировать
  @param {Boolean} sortDec Направление сортировки (true - по убыванию)
  @param {function(count:Number, objs:Object[])} callback Ф-ция, которую нужно вызвать с полученным результатом. 
         Первый параметр - общее количество объектов, второй - массив объектов для данной страницы.
*/

/** Таблица с разбиением данных по страницам. Сильно кастомизируемый виджет. Поддерживает различные провайдеры данных и рендереры.
 * @class
 * @alias nsGmx.ScrollTable
 */
var scrollTable = function( params )
{
    /** Перед перерисовкой данных
     * @event nsGmx.ScrollTable#beforeRedraw
     */
     
    /** После перерисовки данных
     * @event nsGmx.ScrollTable#redraw
     */
     
    /** Изменились параметры сортировки
     * @event nsGmx.ScrollTable#sortChange
     */

    this._params = $.extend(
    {
        limit: 50,
        page: 0,
        pagesCount: 10,
        height: '',
        showFooter: true
    }, params);
    
	this.limit = this._params.limit;
	this.pagesCount = this._params.pagesCount;
	
	this.start = 0;
	this.reportStart = 0;
	
	this.drawFunc = null;
    
    this._requestID = 0;
    this._pageVals = [];
    this._currValsCount = 0;
    
    this._dataProvider = null;
	
	 // Переход на предыдущую страницу
	this.next = function()
	{
		var _this = this,
			button = makeImageButton(modulePath + 'img/next.png', modulePath + 'img/next_a.png');
		
		button.style.marginBottom = '-7px';
		
		button.onclick = function()
		{
			_this.start += _this.pagesCount;
			_this.reportStart = _this.start * _this.limit;

			_this._drawPagesRow();
			
			_this.tableBody.scrollTop = 0;
			_this.tableParent.scrollTop = 0;
		}
		
		_title(button, _gtxt('Следующие [value0] страниц', _this.pagesCount));

		return button;
	}
	
	// Переход на следующую страницу
	this.previous = function()
	{
		var _this = this,
			button = makeImageButton(modulePath + 'img/prev.png', modulePath + 'img/prev_a.png');
		
		button.style.marginBottom = '-7px';
		
		button.onclick = function()
		{
			_this.start -= _this.pagesCount;
			_this.reportStart = _this.start * _this.limit;

			_this._drawPagesRow();

			_this.tableBody.scrollTop = 0;
			_this.tableParent.scrollTop = 0;
		}							
		
		_title(button, _gtxt('Предыдущие [value0] страниц', _this.pagesCount));

		return button;
	}
	
	// Переход на первую страницу
	this.first = function()
	{
		var _this = this,
			button = makeImageButton(modulePath + 'img/first.png', modulePath + 'img/first_a.png');
		
		button.style.marginBottom = '-7px';
		
		button.onclick = function()
		{
			_this.start = 0;
			_this.reportStart = _this.start * _this.limit;

			_this._drawPagesRow();

			_this.tableBody.scrollTop = 0;
			_this.tableParent.scrollTop = 0;
		}
		
		_title(button, _gtxt('Первая страница'));

		return button;
	}
	
	// Переход на последнюю страницу
	this.last = function()
	{
		var _this = this,
			button = makeImageButton(modulePath + 'img/last.png', modulePath + 'img/last_a.png');
		
		button.style.marginBottom = '-7px';
		
		button.onclick = function()
		{
			_this.start = Math.floor(_this._currValsCount / (_this.pagesCount * _this.limit)) * _this.pagesCount;
			_this.reportStart = Math.floor(_this._currValsCount / _this.limit) * _this.limit;

			_this._drawPagesRow();

			_this.tableBody.scrollTop = 0;
			_this.tableParent.scrollTop = 0;
		}
		
		_title(button, _gtxt('Последняя страница'));
		
		return button;
	}
    
    var _this = this;
    this._status = {
        _state: false,
        start: function() {
            this._state = true;
            var me = this;
            setTimeout(function() {
                if (me._state) {
                    $(_this.statusContainer).siblings().hide();
                    $(_this.statusContainer).show();
                }
            }, 100);
        },
        stop: function() {
            $(_this.statusContainer).siblings().show();
            $(_this.statusContainer).hide();
            this._state = false;
        }
    }
	
	this.limitSel = nsGmx.Utils._select([_option([_t("10")], [['attr','value',10]]),
							 _option([_t("20")], [['attr','value',20]]),
							 _option([_t("50")], [['attr','value',50]]),
							 _option([_t("100")], [['attr','value',100]]),
							 _option([_t("200")], [['attr','value',200]]),
							 _option([_t("500")], [['attr','value',500]])], [['dir','className','selectStyle floatRight'], ['css','width','60px']])
}

/** Установка провайдера данных
 @param {nsGmx.ScrollTable.IDataProvider} dataProvider Провайдер данных
 */
scrollTable.prototype.setDataProvider = function( dataProvider )
{
    this._dataProvider = dataProvider;
    this._drawTable();
}

/** Получить текущий провайдер данных
 @return {nsGmx.ScrollTable.IDataProvider} Текущий провайдер данных
 */
scrollTable.prototype.getDataProvider = function()
{
    return this._dataProvider;
}

/** Изменить активность (видимость) колонки в таблице
  @param {String} name имя колонки
  @param {Boolean} isActive активность (видимость) колонки
*/
scrollTable.prototype.activateField = function(name, isActive)
{
    for (var f = 0; f < this._fields.length; f++)
        if (this._fields[f].title == name)
        {
            if (this._fields[f].isActive == isActive)
                return;
                
            this._fields[f].isActive = isActive;
            
            this._drawHeader();
            this._drawRows();
        }
}

scrollTable.prototype._getActiveFields = function()
{
    var res = [];
    for (var f = 0; f < this._fields.length; f++)
        if (this._fields[f].isActive)
            res.push(this._fields[f].title);
            
    return res;
}

scrollTable.prototype._drawRows = function()
{
	var trs = [],
        tr;
    
    $(this).triggerHandler('beforeRedraw');

	$(this.tableBody).empty();
    
    var activeFields = this._getActiveFields();
	
	for (var i = 0; i < this._pageVals.length; i++)
    {
        tr = this.drawFunc(this._pageVals[i], i, activeFields);
		tr && trs.push(tr);
    }
	
	_(this.tableBody, trs);
	
	if (this._pageVals.length == 0)
		_(this.tableBody, [_tr(null,[['css','height','1px'],['attr','empty', true]])])
	
	$(this.tableCount).empty();
    
    this.statusContainer = _div(null, [['dir', 'className', 'fileBrowser-progress'], ['css', 'display', 'none']]);
	
	if (this._currValsCount) {
		_(this.tableCount, [_span([
            _t((this.reportStart + 1) + '-' + (Math.min(this.reportStart + this.limit, this._currValsCount))),
            _span([_t(' ')],[['css','margin','0px 3px']]),
            _t("(" + this._currValsCount + ")")
        ]), this.statusContainer]);
    }
	else {
		_(this.tableCount, [_span([_t("0-0"), _span([_t(' ')],[['css','margin','0px 3px']]), _t("(0)")]), this.statusContainer]);
    }
        
    $(this).triggerHandler('redraw');
}

scrollTable.prototype._drawPages = function(end)
{
	var _this = this;
	for (var i = this.start + 1; i<= end; i++)
	{
		// текущий элемент
 		if (i - 1 == this.reportStart/this.limit)
 		{
		    var el = _span([_t(i.toString())]);
			_(_this.tablePages, [el]);
			$(el).addClass('page');
		}
		else
		{
			var link = makeLinkButton(i.toString());
			
			link.setAttribute('page', i - 1);
			link.style.margin = '0px 2px';
			
			_(_this.tablePages, [link]);
			
			link.onclick = function()
			{
				_this.reportStart = this.getAttribute('page') * _this.limit;
				
				_this._drawPagesRow();
				
				// мозилла
				_this.tableBody.scrollTop = 0;
				// ие
				_this.tableParent.scrollTop = 0;
			};
		}
	}
}

scrollTable.prototype._updatePageData = function(callback)
{
    var _this = this;
    
    if (this._dataProvider.getCountAndItems)
    {
        var requestID = this._requestID++;
        this._status.start();
        _this._dataProvider.getCountAndItems(
            _this.reportStart / _this.limit,
            _this.limit,
            _this.currentSortType, 
            _this.currentSortIndex[_this.currentSortType] == 1, 
            function(count, values)
            {
                if (requestID !== _this._requestID - 1) {
                    _this._status.stop();
                    return;
                }
                    
                _this._currValsCount = count;
                
                
                //если данных стало слишком мало, мы встанем на первую страницу и перезапросим данные ещё раз
                if (_this.reportStart > _this._currValsCount)
                {
                    requestID = _this._requestID++;
                    
                    _this.start = _this.reportStart = 0; //на первую страницу
                    
                    _this._dataProvider.getCountAndItems(
                        _this.reportStart / _this.limit,
                        _this.limit,
                        _this.currentSortType, 
                        _this.currentSortIndex[_this.currentSortType] == 1, 
                        function(count, values)
                        {
                            _this._status.stop();
                            if (requestID !== _this._requestID - 1)
                                return;
                        
                            _this._pageVals = values;
                            callback();
                        }
                    )
                }
                else
                {
                    _this._status.stop();
                    _this._pageVals = values;
                    callback();
                }
            }
        )
    }
    else
    {
        this._status.start();
        this._dataProvider.getCount(function(count)
        {
            _this._currValsCount = count;
            
            //вообще-то при обновлении данных мы не изменяем текущей страницы
            //однако если данных стало слишком мало, то текущую страницу сохранить нельзя,
            //и мы переключимся на первую
            if (_this.reportStart >= _this._currValsCount)
            {
                _this.start = _this.reportStart = 0;
            }
            
            _this._dataProvider.getItems(
                _this.reportStart / _this.limit,
                _this.limit,
                _this.currentSortType, 
                _this.currentSortIndex[_this.currentSortType] == 1, 
                function(values)
                {
                    _this._status.stop();
                    _this._pageVals = values;
                    callback();
                }
            )
        });
    }
}

scrollTable.prototype._drawPagesRow = function()
{
    var _this = this;
    this._updatePageData(function()
    {
        // перерисовывем номера страниц
        $(_this.tablePages).empty();
        
        if (_this._currValsCount > _this.limit)
        {
            var allPages = Math.ceil(_this._currValsCount / _this.limit);
            
            var end = (_this.start + _this.pagesCount <= allPages) ? _this.start + _this.pagesCount : allPages;
            
            if (_this.start - _this.pagesCount >= 0)
                _(_this.tablePages,[_this.first(), _this.previous()]);
            
            _this._drawPages(end);
            
            if (end + 1 <= allPages)
                _(_this.tablePages,[_this.next(), _this.last()]);
        }
        
        _this._drawRows();
    })
    
}

scrollTable.prototype._drawHeader = function()
{
    var tds = [],
        _this = this;
    
    var headerElemFactory = this._isWidthScroll ? _th : _td;
    
    this._fields.forEach(function(field) {
        if (!field.isActive)
            return;
            
        var title = field.title,
            button;
		
		if (title != '' && field.isSortable)
		{
			button = makeLinkButton(title);
			
			button.sortType = title;
		}
		else
			button = _t(title)
		
        var td = headerElemFactory([button], [['css','width',field.width]]);
        
        if (field.isSortable) {
            $(td).click(function() {
                _this.setSortParams(title, 1 - _this.currentSortIndex[title]);
            })
        }
        
		tds.push(td);
    })
    
    $(this._tableHeaderRow).empty();
    _(this._tableHeaderRow, tds);
}

//Если baseWidth == 0, таблица растягивается на весь контейнер по ширине

/** Нарисовать таблицу
* @param {Object} params
* @param {DOMElement} params.parent Контейнер для помещения результата отрисовки
* @param {String} params.name Уникальное имя таблицы
* @param {Number} [params.baseWidth] Какой ширины должна быть таблица. Если не указано, будет занимать 100% контейнера
* @param {String[]} params.fields массив имён колонок
* @param {String[]} params.fieldsWidths массив с описанием ширины колонок. Описание даётся в терминах css
* @param {function} params.drawFunc Ф-ция отрисовки одной строки таблицы. На вход - объект для отрисовки (полученный от провайдера). На выходе - "tr" элемент
* @param {Object} [params.sortableFields] Хеш для указания возможности сортировки колонок (будет включена для всех ключей хеша)
* @param {Boolean} [params.isWidthScroll] Трубется ли возможность прокрутки данных по горизонтали
*/
scrollTable.prototype.createTable = function(parent, name, baseWidth, fields, fieldsWidths, drawFunc, sortableFields, isWidthScroll)
{
    var params = null
    //передача параметров в виде структуры
    if (arguments.length === 1)
    {
        params = $.extend(true, {
            sortableFields: {}
        }, parent);
    }
    else
    {
        params = {
            parent: parent,
            name: name,
            baseWidth: baseWidth,
            fields: fields,
            fieldsWidths: fieldsWidths,
            drawFunc: drawFunc,
            sortableFields: sortableFields,
            isWidthScroll: isWidthScroll
        }
    }
    
    var name = params.name;
    
	var _this = this;
    this._isWidthScroll = params.isWidthScroll;
    
    this._fields = [];
    for (var f = 0; f < params.fields.length; f++)
        this._fields.push({
            title: params.fields[f],
            width: params.fieldsWidths[f],
            isSortable: params.fields[f] in params.sortableFields,
            isActive: true
        });
    
	
	this.limitSel = switchSelect(this.limitSel,  this.limit)
	
	this.limitSel.onchange = function()
	{
		_this.limit = Number(this.value);
		
		_this.start = 0;
		_this.reportStart = _this.start * _this.limit;
		
		_this._drawTable()
	}
	
	this.tableCount = _div();
	this.tableLimit = _div([this.limitSel]);
	this.tablePages = _div(null,[['dir','className','tablePages']]);

    this.tableBody = _tbody(null,[['attr','id',name + 'TableBody']]);
    
    
    this._tableHeaderRow = _tr();
    if (this._isWidthScroll)
    {
        this.tableHeader = _thead([this._tableHeaderRow], [['attr','id',name + 'TableHeader'], ['dir','className','tableHeader']]);
    }
    else
    {
        //как формировать фиксированный заголовок таблицы, зависит от того, будет ли у таблицы фиксированный размер или нет
        //TODO: убрать возможность задавать фиксированный размер
        if ( params.baseWidth )
            this.tableHeader = _tbody([this._tableHeaderRow],[['attr','id',name + 'TableHeader']]);
        else
            this.tableHeader = _tbody([_tr([_td([_table([_tbody([this._tableHeaderRow])])]), _td(null, [['css', 'width', '20px']])])], [['attr','id',name + 'TableHeader']]);
    }
    
    this._drawHeader();
    
    if (this._isWidthScroll)
    {
        this.tableParent = _div([_table([this.tableHeader, this.tableBody], [['css', 'width', '100%']])],
                                [['attr','id',name + 'TableParent'],['dir','className','scrollTable'],['css','width', baseWidth ? baseWidth + 'px' : "100%"], ['css', 'height', this._params.height], ['css', 'overflow', 'auto']]);
    }
    else
    {
        this.tableParent = _div([
                                _div([_table([this.tableHeader])],[['dir','className','tableHeader']]),
                                _div([_table([this.tableBody])],[['dir','className','tableBody'],['css', 'height', this._params.height ? (this._params.height - 20) + 'px' : ''], ['css','width', params.baseWidth ? params.baseWidth + 20 + 'px' : "100%"]])
                            ],[['attr','id',name + 'TableParent'],['dir','className','scrollTable'], ['css', 'height', this._params.height ? this._params.height + 'px' : ''], ['css','width', params.baseWidth ? params.baseWidth + 'px' : "100%"]])
    }
	
	_(params.parent, [this.tableParent])
    
    if (this._params.showFooter)
        _(params.parent, [_table([_tbody([_tr([_td([this.tableCount], [['css','width','20%']]), _td([this.tablePages]), _td([this.tableLimit], [['css','width','20%']])])])], [['css','width','100%']])]);
	
	
	this.drawFunc = params.drawFunc;
	this.start = 0;         //Первый номер страницы, показываемый на экране (это не текущая страница!)
	this.reportStart = 0;   //Первый номер элемента на текущей странице
	
	this.currentSortType = null;
	// сортировка по умолчанию	
	for (var name in params.sortableFields)
	{
		this.currentSortType = name;
		
		break;
	}
	
	this.currentSortIndex = {};
	for (var name in params.sortableFields)
	{
		this.currentSortIndex[name] = 0;
	}
    
    if (!this._dataProvider)
        this.setDataProvider(new scrollTable.StaticDataProvider());
    
    $(this._dataProvider).change(function()
    {
        _this._drawTable();
    });
    this._drawTable();
}

scrollTable.prototype.updateHeight = function( height )
{
    if (this._isWidthScroll)
    {
        this.tableParent.style.height = (height - 40) + 'px';
    }
    else
    {
        $(this.tableParent).find('.tableBody').height(height - 20);
        $(this.tableParent).height(height);
    }
}

scrollTable.prototype._drawTable = function()
{
    if (!this.tableBody) return; //ещё не создана таблица
    this._drawPagesRow();
}

/** Выбрать страницу для показа
@param {Number} page Номер страницы (нумерация с нуля)
*/
scrollTable.prototype.setPage = function(iPage)
{
	if (this.limit*iPage >= this._currValsCount || iPage < 0 || this.reportStart == iPage * this.limit) 
		return;
		
	this.reportStart = iPage * this.limit;
	this.start = Math.floor(iPage/this.pagesCount) * this.pagesCount;
	
	this._drawPagesRow();
	
	this.tableBody.scrollTop = 0;
	this.tableParent.scrollTop = 0;
}

/** Получить массив объектов, которые нарисованы в данный момент
 @return {Array} массив объектов в формате провайдера данных
*/
scrollTable.prototype.getVisibleItems = function()
{
    return this._pageVals;
}

/** Задать параметры сортровки
 @param {String} sortType Имя колонки для сортировки
 @param {Boolean} sortDirection Направление сортровки (false - по возрастанию, true - по убыванию)
*/
scrollTable.prototype.setSortParams = function(sortType, sortDirection)
{
    this.currentSortType = sortType;
    this.currentSortIndex[this.currentSortType] = sortDirection;
    
    this.start = 0;
    this.reportStart = this.start * this.limit;
    
    this._drawTable()
    
    $(this).triggerHandler('sortChange');
}

/** Получить текущее направление сортировки.
 @return {Boolean} false - по возрастанию, true - по убыванию
*/
scrollTable.prototype.getSortDirection = function()
{
    return this.currentSortIndex[this.currentSortType] == 1
}

/** Получить по какой колонке происходит сортровка
 @return Имя колонки
*/
scrollTable.prototype.getSortType = function()
{
    return this.currentSortType;
}

/** Перерисовать текущую страницу без перезапроса данных у провайдера */
scrollTable.prototype.repaint = function()
{
    this._drawRows();
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/** Провайдер данных для {@link nsGmx.ScrollTable}.
* Хранит статический массив данных, умеет их фильтровать и упорядочивать.
* @class
* @extends nsGmx.ScrollTable.IDataProvider
*/
scrollTable.StaticDataProvider = function( originalData )
{
    var _vals = originalData || []; //исходный список элементов
    var _filteredVals = []; //список элементов после фильтрации. Валиден только если _isFiltered == true
    
    var _isFiltered = false;
    var _predicate = {}; //фильтры. Ф-ции predicate(name, value, items)->filteredItems
    var _filterVals = {}; //значения фильтров
    
    var _sortFunctions = {};
    var _this = this;
    
    var _filter = function()
    {
        if (_isFiltered) return;
        
        _filteredVals = _vals;
        
        for (var filterElem in _filterVals)
        {
            _filteredVals = _predicate[filterElem](filterElem, _filterVals[filterElem], _filteredVals);
        }
        
        _isFiltered = true;
    }
    
    var _update = function()
    {
        _isFiltered = false;
        $(_this).change();
    }
    
    /** синхронный вариант getCount() */
    this.getCountDirect = function()
    {
        _filter();
        return _filteredVals.length;
    }
    
    /** синхронный вариант getItems() */
    this.getItemsDirect = function(page, pageSize, sortParam, sortDec)
    {
        var nMin = page*pageSize;
        var nMax = nMin + pageSize;
        _filter();
        var sortDirIndex = sortDec ? 1 : 0;
        var sortedVals;

        if (_sortFunctions[sortParam])
        {
            if (typeof _sortFunctions[sortParam] === 'function') //если нет ф-ции для сортировки в обратном порядке, инвертируем прямую ф-цию
                sortedVals = _filteredVals.sort(function(a, b) { return (1-2*sortDirIndex) * _sortFunctions[sortParam](a, b); });
            else 
                sortedVals = _filteredVals.sort(_sortFunctions[sortParam][sortDirIndex]);
        }
        else
            sortedVals = _filteredVals;
            
        nMin = Math.min(Math.max(nMin, 0), sortedVals.length);
        nMax = Math.min(Math.max(nMax, 0), sortedVals.length);
        return sortedVals.slice(nMin, nMax);
    }
    
    //IDataProvider interface
    this.getCount = function(callback)
    {
        callback(this.getCountDirect());
    }
    
    this.getItems = function(page, pageSize, sortParam, sortDec, callback)
    {
        callback(this.getItemsDirect(page, pageSize, sortParam, sortDec, callback));
    }
    
    /** задание исходных данных */
    this.setOriginalItems = function(items)
    {
        _vals = items;
        _update();
    }
    
    /** получение исходных данных */
    this.getOriginalItems = function()
    {
        return _vals;
    }
    
    /** Фильтруем исходные данные
    * @param {function(val:Object):Boolean} filterFunction ф-ция для фильтрации. На вход принимает элемент массива данных, возвращает false, если элемент отфильтровывается, иначе true
    */
    this.filterOriginalItems = function(filterFunction)
    {
        var newOrigData = [];
        for (var i = 0; i < _vals.length; i++)
            if (filterFunction(_vals[i]))
                newOrigData.push(_vals[i]);
                
        _vals = newOrigData;
        _update();
    }
    
    /** Добавляем новый элемент в исходные данные */
    this.addOriginalItem = function(item)
    {
        _vals.push(item);
        _update();
    }
    
    /** Добавляем массив элементов в исходные данные */
    this.addOriginalItems = function(itemArr)
    {
        _vals = _vals.concat(itemArr);
        _update();
    }
    
    //фильтрация
    this.attachFilterEvents = function(inputField, fieldName, predicate)
    {
        var _this = this;
        
        _predicate[fieldName] = predicate;

        $(inputField).bind('keyup', function()
        {
            if (_filterVals[fieldName] !== this.value)
            {
                _filterVals[fieldName] = this.value;
                _update();
            }
        })
        
        _filterVals[fieldName] = inputField.value;
        _update();
    }
    
    /** Добавить ф-цию фильтрации исходных данных
        @param {String} fieldName Имя фильтра
        @param {function} predicate Ф-ция фильтрации: predicate(name, value, items)->filteredItems
    */
    this.addFilter = function(fieldName, predicate)
    {
        _predicate[fieldName] = predicate;
    }
    
    /** Установить значение для фильтра
        @param {String} fieldName Имя фильтра
        @param {String} value Значение для фильтрации
    */
    this.setFilterValue = function(fieldName, value)
    {
        _filterVals[fieldName] = value;
        _update();
    }
    
    this.attachSelectFilterEvents = function(selectField, fieldName, predicate)
    {
        var _this = this;
        
        _predicate[fieldName] = predicate;

        selectField.onchange = function()
        {
            _filterVals[fieldName] = this.value;
            _update();
        }
        
        _filterVals[fieldName] = selectField.value;
        _update();
    }
    
    /** Задать ф-ции сортировки
     @param {Object} sortFunctions Хеш из ф-ций {Имя столбца -> ф-ция или массив из двух ф-ций}.
        Если массив из двух ф-ций, то первая используется для сортировки по возрастанию, вторая - по убыванию. 
        Если просто ф-ция, то по убыванию используется инвертная к ней. 
        Формат ф-ции совпадает с ф-цией для sort().
    */
    this.setSortFunctions = function(sortFunctions)
    {
        _sortFunctions = sortFunctions;
    }
};

// простое стравнение по атрибутам объекта.
// Использование: genAttrSort(func(a)->value), genAttrSort(attrName), genAttrSort(attrName1, attrName2)
scrollTable.StaticDataProvider.genAttrSort = function(attrName1, attrName2)
{
    if (typeof attrName1 === 'function')
    {
        return function(a, b) {
            var av = attrName1(a),
                bv = attrName1(b);
            if (av > bv)      return 1; 
            else if (av < bv) return -1;
            else              return 0;
        }
    }
    else if (attrName2)
    {
        return function(a, b) {
            var av = a[attrName1][attrName2];
            var bv = b[attrName1][attrName2];
            if (av > bv)      return 1; 
            else if (av < bv) return -1;
            else              return 0;
        }
    } else {
        return function(a, b) {
            var av = a[attrName1];
            var bv = b[attrName1];
            if (av > bv)      return 1;
            else if (av < bv) return -1;
            else              return 0;
        }
    }
}

//если есть вьюер, добавляем для него переменные в глобальный namespace
if ('nsGmx' in window && 'GeomixerFramework' in window.nsGmx)
{
    window.scrollTable = scrollTable; //Depricated - use nsGmx
    window.nsGmx.ScrollTable = scrollTable;
}
    
if (typeof window.gmxCore !== 'undefined')
{
    gmxCore.addModule("ScrollTableControl", 
        {
            ScrollTable: scrollTable
        }, 
        {
            require: ['translations', 'utilities'],
            css: 'table.css',
            init: function(module, path)
            {
                modulePath = path || "";
                appendTranslations();
            }
        }
    );
}

})(jQuery, nsGmx.Utils._);
var nsMapCommon = function($){
    var publicInterface = {
        generateWinniePermalink: function() {
            var mapProps = nsGmx.gmxMap.properties,
                lmap = nsGmx.leafletMap,
                center = lmap.getCenter(),
                layersState = {expanded: {}, visible: {}};
                
            _layersTree.treeModel.forEachNode(function(elem) {
                var props = elem.content.properties;
                if (elem.type == 'group') {
                    var groupId = props.GroupID;

                    if ($("div[GroupID='" + groupId + "']").length || props.changedByViewer) {
                        layersState.expanded[groupId] = props.expanded;
                    }
                } else {
                    if (props.changedByViewer) {
                        layersState.visible[props.name] = props.visible;
                    }
                }
            });
            
            var config = {
                app: {
                    gmxMap: {
                        mapID: mapProps.name
                    }
                },
                state: {
                    map: {
                        position: {
                            x: center.lng,
                            y: center.lat,
                            z: lmap.getZoom()
                        }
                    },
                    calendar: nsGmx.widgets.commonCalendar.getDateInterval().saveState(),
                    baseLayersManager: lmap.gmxBaseLayersManager.saveState(),
                    layersTree: layersState
                }
            }

            return nsGmx.Utils.TinyReference.create(config, false);
        },
        /**
        * Выбирает данные из дерева слоёв по описанию слоёв и групп
        * @param {FlashMapObject} map - текущая карта
        * @param {object} mapTree - дерево, в котором нужно искать
        * @param {array} description - массив с описанием нужных слоёв. Каждый элемент массива может быть либо строкой (имя слоя), либо объектом {group: '<groupName>'} - выбрать все слои из группы
        */
        selectLayersFromTree: function(map, mapTree, description)
        {
            var _array = [];
            var _hash = {};
            
            var _getLayersInGroup = function(map, mapTree, groupTitle)
            {
                var res = {};
                var visitor = function(treeElem, isInGroup)
                {
                    if (treeElem.type === "layer" && isInGroup)
                    {
                        res[treeElem.content.properties.name] = map.layers[treeElem.content.properties.name];
                    }
                    else if (treeElem.type === "group")
                    {
                        isInGroup = isInGroup || treeElem.content.properties.title == groupTitle;
                        var a = treeElem.content.children;
                        for (var k = a.length - 1; k >= 0; k--)
                            visitor(a[k], isInGroup);
                    }
                }

                visitor( {type: "group", content: { children: mapTree.children, properties: {} } }, false );
                return res;
            }    
            
            for (var k = 0; k < description.length; k++)
                if ( typeof description[k] === "string" )
                {
                    _hash[description[k]] = map.layers[description[k]];
                    _array.push( map.layers[description[k]] );
                }
                else if ('group' in description[k])
                {
                    var groupHash = _getLayersInGroup(map, mapTree, description[k].group);
                    for (var l in groupHash)
                    {
                        _hash[l] = groupHash[l];
                        _array.push( groupHash[l] );
                    }
                }
                
            return {
                asArray: function() { return _array; },
                asHash: function() { return _hash; },
                names: function()
                {
                    var res = [];
                    
                    for (var l in _hash) 
                        res.push(l);
                        
                    return res;
                }
            }
        }
    };
    
    if (typeof gmxCore !== 'undefined')
    {
        gmxCore.addModule('MapCommon', publicInterface);
    }
    
    return publicInterface;
}(jQuery);
!(function(_) {
/** Разнообразные вспомогательные контролы (базовые элементы GUI)
    @namespace nsGmx.Controls
*/
nsGmx.Controls = {

	/** Создаёт контрол выбора цвета */
	createColorPicker: function(color, showFunc, hideFunc, changeFunc){
		var colorPicker = _div(null, [['dir','className','colorSelector'], ['css','backgroundColor',nsGmx.Utils.convertColor(color)]]);

		$(colorPicker).ColorPicker({
			color: nsGmx.Utils.convertColor(color),
			onShow: showFunc,
			onHide: hideFunc,
			onChange: changeFunc
		});

		_title(colorPicker, _gtxt("Цвет"));

		return colorPicker;
	},

	/** Создаёт иконку по описанию стиля слоя и типа геометрии
    */
	createGeometryIcon: function(parentStyle, type){
		var icon = _div(null, [['css','display','inline-block'],['dir','className','colorIcon'],['attr','styleType','color'],['css','backgroundColor','#FFFFFF']]);

		if (type.indexOf('linestring') < 0)
		{
            if (parentStyle.fill && parentStyle.fill.pattern)
            {
                var opaqueStyle = L.gmxUtil.fromServerStyle($.extend(true, {}, parentStyle, {fill: {opacity: 100}})),
                    patternData = L.gmxUtil.getPatternIcon(null, opaqueStyle);
                icon = patternData ? patternData.canvas : document.createElement('canvas');
                _(icon, [], [['dir','className','icon'],['attr','styleType','icon'],['css','width','13px'],['css','height','13px']]);
            }
            else
            {
                var fill = _div(null, [['dir','className','fillIcon'],['css','backgroundColor',(parentStyle.fill && typeof parentStyle.fill.color != 'undefined') ? nsGmx.Utils.convertColor(parentStyle.fill.color) : "#FFFFFF"]]),
                    border = _div(null, [['dir','className','borderIcon'],['attr','styleType','color'],['css','borderColor',(parentStyle.outline && typeof parentStyle.outline.color != 'undefined') ? nsGmx.Utils.convertColor(parentStyle.outline.color) : "#0000FF"]]),
                    fillOpacity = (parentStyle.fill && typeof parentStyle.fill.opacity != 'undefined') ? parentStyle.fill.opacity : 100,
                    borderOpacity = (parentStyle.outline && typeof parentStyle.outline.opacity != 'undefined') ? parentStyle.outline.opacity : 100;


                fill.style.opacity = fillOpacity / 100;
                border.style.opacity = borderOpacity / 100;

                if (type.indexOf('point') > -1)
                {

                    border.style.height = '5px';
                    fill.style.height = '5px';
                    border.style.width = '5px';
                    fill.style.width = '5px';

                    border.style.top = '3px';
                    fill.style.top = '4px';
                    border.style.left = '1px';
                    fill.style.left = '2px';
                }

                _(icon, [border, fill]);
            }
		}
		else
		{
			var border = _div(null, [['dir','className','borderIcon'],['attr','styleType','color'],['css','borderColor',(parentStyle.outline && typeof parentStyle.outline.color != 'undefined') ? nsGmx.Utils.convertColor(parentStyle.outline.color) : "#0000FF"]]),
				borderOpacity = (parentStyle.outline && typeof parentStyle.outline.opacity != 'undefined') ? parentStyle.outline.opacity : 100;


            border.style.opacity = borderOpacity / 100;

            border.style.width = '4px';
            border.style.height = '13px';

			border.style.borderTop = 'none';
			border.style.borderBottom = 'none';
			border.style.borderLeft = 'none';

			_(icon, [border]);
		}

		icon.oncontextmenu = function(e)
		{
			return false;
		}

		return icon;
	},

	/** Создаёт контрол "слайдер".
    */
	createSlider: function(opacity, changeFunc)	{
		var divSlider = _div(null, [['css','width','86px'],['css','height','8px'],['css','border','1px solid #cdcdcd']]);

		$(divSlider).slider(
			{
				min:0,
				max:100,
				step:1,
				value: opacity,
				slide: function(event, ui)
				{
					changeFunc(event, ui);

					_title(divSlider.firstChild, ui.value)
				}
			});

		divSlider.firstChild.style.zIndex = 1;

		divSlider.style.width = '100px';
		divSlider.style.border = 'none';
		divSlider.style.backgroundImage = 'url(img/slider.png)';

		divSlider.firstChild.style.border = 'none';
		divSlider.firstChild.style.width = '12px';
		divSlider.firstChild.style.height = '14px';
		divSlider.firstChild.style.marginLeft = '-6px';

        divSlider.firstChild.style.top = '-3px';

		divSlider.firstChild.style.background = 'transparent url(img/sliderIcon.png) no-repeat';

		divSlider.firstChild.onmouseover = function()
		{
			divSlider.firstChild.style.backgroundImage = 'url(img/sliderIcon_a.png)';
		}
		divSlider.firstChild.onmouseout = function()
		{
			divSlider.firstChild.style.backgroundImage = 'url(img/sliderIcon.png)';
		}

		_title(divSlider.firstChild, opacity)
		_title(divSlider, _gtxt("Прозрачность"));

		return divSlider;
	},

	createInput: function(value, changeFunc){
		var input = _input(null, [['dir','className','inputStyle'],['css','width','30px'],['attr','value',value]]);
		input.onkeyup = changeFunc;
		return input;
	},

    /** Создаёт диалог, позволяющий выбрать пользователю один из нарисованных на карте объектов
     * @param {String} name Уникальный идентификатор диалога
     * @param {function(gmxAPI.DrawingObject)} callback Ф-ция, которая вызовется при выборе пользователем одного из объектов
     * @param {Object} [params] Дополнительные параметры диалога
     * @param {String} [params.title] Заголовок диалога
     * @param {String} [params.geomType=null] Ограничения на тип геометрии (POINT, LINESTRING, POLYGON). null - без ограничений
     * @param {String} [params.errorTitle] Заголовок диалога с ошибками (например, если нет объектов)
     * @param {String} [params.errorMessage] Текст диалога с ошибками (например, если нет объектов)
     * @param {Number} [params.width=250] Ширина диалога в пикселях
    */
    chooseDrawingBorderDialog: function(name, callback, params)
    {
        var TYPE_CONVERT_DICT = {
            Polyline: 'linestring',
            MultiPolyline: 'linestring',
            Rectangle: 'polygon',
            Polygon: 'polygon',
            MultiPolygon: 'polygon',
            Point: 'point'
        }
        var _params = $.extend({
            title:         _gtxt("Выбор контура"),
            geomType:      null,
            errorTitle:   _gtxt("$$phrase$$_12"),
            errorMessage: _gtxt("$$phrase$$_12"),
			width:        250
        }, params);

        if ($('#drawingBorderDialog' + name).length)
            return;

        var drawingObjs = [],
            _this = this;

        nsGmx.leafletMap.gmxDrawing.getFeatures().forEach(function(obj)
        {
            if (!_params.geomType || TYPE_CONVERT_DICT[obj.getType()] === _params.geomType.toLowerCase()) {
                drawingObjs.push(obj);
            }
        })

        if (!drawingObjs.length)
            showErrorMessage(_params.errorMessage, true, _params.errorTitle);
        else
        {
            gmxCore.loadModule('DrawingObjects').done(function(drawing) {
                var canvas = _div();
                var collection = new drawing.DrawingObjectCollection(nsGmx.leafletMap);

                for (var i = 0; i < drawingObjs.length; i++)
                {
                    collection.Add(drawingObjs[i]);
                }

                var list = new drawing.DrawingObjectList(nsGmx.leafletMap, canvas, collection, {
                    allowDelete: false,
                    editStyle: false,
                    showButtons: false,
                    click: function(drawingObject) {
                        callback && callback(drawingObject);
                        removeDialog(jDialog);
                    }
                });

                var jDialog = nsGmx.Utils.showDialog(
                        _params.title,
                        _div([canvas], [['attr','id','drawingBorderDialog' + name],['dir','className','drawingObjectsCanvas']]),
                        {
                            width: _params.width,
                            height: 180
                        }
                    )
            })
        }
    },
    /**
     Создаёт виджет для управления видимостью (скрытия/показа) других элементов
     Сам виджет представляет из себя изменяющуюся иконку с текстом заголовка рядом с ней
     @class
     @param {String} title - текст заголовка
     @param {DOMElement} titleElem - элемент для размещения самого виджета
     @param {DOMElement|Array[]} managedElems - элементы, видимостью которых будем
     @param {Bool} isCollapsed - начальное состояние виджета
    */
    CollapsibleWidget: function(title, titleElem, managedElems, isCollapsed)
    {
        //var contentTr = _tr([_td([layerTagsParent], [['dir', 'colSpan', '2']])]);
        var collapseTagIcon = $('<div/>').addClass('collabsible-icon');
        var _isCollapsed = !!isCollapsed;

        managedElems = managedElems || [];
        if (!$.isArray(managedElems))
            managedElems = [managedElems];

        var updateElems = function()
        {
            for (var iE = 0; iE < managedElems.length; iE++)
            $(managedElems[iE]).toggle(!_isCollapsed);
        }

        var updateView = function()
        {
            collapseTagIcon
                .toggleClass('collabsible-icon-hidden', _isCollapsed)
                .toggleClass('collabsible-icon-shown', !_isCollapsed);
            updateElems();
        }

        updateView();

        $(titleElem).empty().append(
            collapseTagIcon,
            $('<div/>').addClass('collabsible-title').text(title)
        ).click(function()
        {
            _isCollapsed = !_isCollapsed;
            updateView();
        })

        this.addManagedElements = function(elems)
        {
            managedElems = managedElems.concat(elems);
            updateElems();
        }

        this.isCollapsed = function() { return _isCollapsed; };
    },

    /** Показывает аттрибутивную информацию объекта в виде таблички в отдельном диалоге */
    showLayerInfo: function(layer, obj)
    {
        var trs = [];
        var typeSpans = {};
        for (var key in obj.properties)
        {
            var content = _div(),
                contentText = String(obj.properties[key]);

            if (contentText.indexOf("http://") == 0 || contentText.indexOf("www.") == 0)
                contentText = "<a href=\"" + contentText + "\" target=\"_blank\">" + contentText + "</a>";

            content.innerHTML = contentText;

            var typeSpan = _span([_t(key)]);

            typeSpans[key] = typeSpan;

            trs.push(_tr([_td([typeSpan], [['css','width','30%']]), _td([content], [['css','width','70%']])]));
        }

        var title = _span(null, [['dir','className','title'], ['css','cursor','default']]),
            summary = _span(null, [['dir','className','summary']]),
            div;

        if ($('#layerPropertiesInfo').length)
        {
            div = $('#layerPropertiesInfo')[0];

            if (!trs.length && !layer.properties.Legend)
            {
                $(div.parentNode).dialog('close');

                return;
            }

            $(div).empty();

            _(div, [_table([_tbody(trs)], [['dir','className','vectorInfoParams']])]);

            if (layer.properties.Legend)
            {
                var legend = _div();

                legend.innerHTML = layer.properties.Legend;

                _(div, [legend])
            }

            var dialogTitle = div.parentNode.parentNode.firstChild.firstChild;

            $(dialogTitle).empty();

            _(dialogTitle, [_t(_gtxt("Слой [value0]", layer.properties.title))]);

            $(div.parentNode).dialog('open');
        }
        else
        {
            if (!trs.length && !layer.properties.Legend)
                return;

            div = _div([_table([_tbody(trs)], [['dir','className','vectorInfoParams']])], [['attr','id','layerPropertiesInfo']]);

            if (layer.properties.Legend)
            {
                var legend = _div();

                legend.innerHTML = layer.properties.Legend;

                _(div, [legend])
            }

            showDialog(_gtxt("Слой [value0]", layer.properties.title), div, 360, 'auto', false, false, null, function(){return true});

        }

        //подстраиваем ширину
        setTimeout(function()
        {
            var dialogDiv = $('#layerPropertiesInfo')[0].parentNode;
            var width = $(div).find('.vectorInfoParams').width();
            if (width > 340) {
                $(dialogDiv).dialog('option', 'width', width + 18);
            }
        }, 100)

        nsGmx.TagMetaInfo.loadFromServer(function(tagInfo)
        {
            for (var key in typeSpans)
            {
                if (tagInfo.isTag(key))
                    $(typeSpans[key]).attr('title', tagInfo.getTagDescription(key));
            }
        });
    }
}

gmxCore.addModule('Controls', nsGmx.Controls);

})(nsGmx.Utils._);

var nsGmx = nsGmx || {};

/** Узел дерева слоёв
 * @typedef nsGmx.LayersTree~Node
 * @property {String} type тип узла (`layer` или `group`)
 * @property {Object} content содержимое узла
 * @property {Object} [content.properties] свойства узла
 * @property {Object} [content.children] потомки узла
*/

/** Результат поиска узла в дереве слоёв
 * @typedef nsGmx.LayersTree~SearchResult
 * @property {nsGmx.LayersTree~Node} elem Найденный элемент
 * @property {nsGmx.LayersTree~Node[]} parents Массив родителей. Самый последний элемент массива - сама карта
 * @property {Number} index Индекс найденного элемента в своей группе
*/

/** Visitor при обходе слоёв дерева
 * @callback nsGmx.LayersTree~LayerVisitor
 * @param {Object} layerContent Содержимое узла слоя
 * @param {Boolean} isVisible Видимость слоя с учётом видимости всех родителей
 * @param {Number} nodeDepth Глубина слоя в дереве (начинается с 0)
*/

/** Visitor при обходе узлов дерева слоёв
 * @callback nsGmx.LayersTree~NodeVisitor
 * @param {nsGmx.LayersTree~Node} node Свойства узла
 * @param {Boolean} isVisible Видимость узла с учётом видимости всех родителей
 * @param {Number} nodeDepth Глубина узла в дереве (начинается с 0)
*/

/** Класс для работы с деревом слоёв
 * @class
 * @param {Object} tree Дерево слоёв в формате сервера
*/
nsGmx.LayersTree = function( tree )
{
    /** Изменилась видимость узла дерева. Если изменения касаются нескольких узлов, событие будет 
        генерироваться для каждого узла по отдельности. Кроме того, это же событие генерируется 
        на отдельных узлах дерева.
     * @event nsGmx.LayersTree#nodeVisibilityChange
     * @param {nsGmx.LayersTree~Node} node Узел, видимость которой изменилась
     */
    var _tree = tree;
    var _this = this;
    
    var _findElem = function(elem, propName, propValue, parents)
    {
        var childs = typeof elem.children != 'undefined' ? elem.children : elem.content.children;
        
        for (var i = 0; i < childs.length; i++)
        {
            var props = childs[i].content.properties;
            if (propName in props && props[propName] === propValue) {
                return {elem:childs[i], parents: [elem].concat(parents || []), index: i};
            }
            
            if (typeof childs[i].content.children != 'undefined')
            {
                var res = _findElem(childs[i], propName, propValue, [elem].concat(parents || []));
                
                if (res)
                    return res;
            }
        }
    }
    
    /** Получить исходное дерево слоёв
    */
    this.getRawTree = function() 
    {
        return _tree;
    }
    
    /** Получить свойства карты
    */
    this.getMapProperties = function() 
    {
        return _tree.properties;
    }
    
    /** Поиск узла дерева по значению одного из атрибутов. Ищет как папки, так и слои. Возвращает первый найденный результат
     * @param {String} propName Имя атрибута
     * @param {String} propValue Значение атрибута
     * @return {nsGmx.LayersTree~SearchResult} Результат поиска. undefined если ничего не найденно
    */
    this.findElem = function(propName, propValue)
    {
        return _findElem(_tree, propName, propValue);
    }
    
    this.findElemByGmxProperties = function(gmxProperties)
    {
        if (gmxProperties.type == 'group') //группа
            return this.findElem("GroupID", gmxProperties.content.properties.GroupID);
        else
            return this.findElem("name", gmxProperties.content.properties.name);
    }
    
    /** Итерирование по всем слоям группы дерева
     * @param {nsGmx.LayersTree~LayerVisitor} callback Будет вызвана для каждого слоя внутри группы. Первый аргумент - свойства слоя, второй - видимость слоя
     * @param {nsGmx.LayersTree~Node} [groupNode] Группа, внутри которой проводить поиск. Если не указана, будет проводиться поиск по всему дереву.
     */
    this.forEachLayer = function(callback, groupNode)
    {
        this.forEachNode(function(node, isVisible, nodeDepth) {
            if (node.type === 'layer') {
                callback(node.content, isVisible, nodeDepth);
            }
        }, groupNode)
    }
    
    /** Итерирование по всем под-узлам узла дерева
     * @param {nsGmx.LayersTree~NodeVisitor} callback Будет вызвана для каждого узла внутри группы. Первый аргумент - узел, второй - видимость узла
     * @param {nsGmx.LayersTree~Node} [groupNode] Группа, внутри которой проводить поиск. Если не указана, будет проводиться поиск по всему дереву.
     */
    this.forEachNode = function(callback, groupNode)
    {
        var forEachNodeRec = function(o, isVisible, nodeDepth)
        {
            isVisible = isVisible && !!o.content.properties.visible;
            
            callback(o, isVisible, nodeDepth);
            
            if (o.type === 'group') {
                var a = o.content.children;
                for (var k = a.length - 1; k >= 0; k--)
                    forEachNodeRec(a[k], isVisible, nodeDepth + 1);
            }
        }
        
        var layers = groupNode ? groupNode.content : _tree;
        
        for (var k = layers.children.length - 1; k >= 0; k--) {
            forEachNodeRec(layers.children[k], true, 0);
        }
    }
    
    /** Клонирование дерева с возможностью его модификации
     * @param {function(node):nsGmx.LayersTree~Node|null} filterFunc - ф-ция, которая может модифицировать узлы дерева. 
                Вызывается при клонировании очередного узла. Изменения данных можно делать in-place.
                Для групп вызывается после обработки всех потомков. Если возвращает null, то узел удаляется
     */
    this.cloneRawTree = function(filterFunc) {
        filterFunc = filterFunc || function(node) {return node;};
        var res = {};
        var forEachLayerRec = function(o)
        {
            if (o.type == "layer") {
                return filterFunc($.extend(true, {}, o));
            }
            else if (o.type == "group") {
                var a = o.content.children;
                var newChildren = [];
                for (var k = 0; k < a.length; k++) {
                    var newNode = forEachLayerRec(a[k]);
                    newNode && newChildren.push(newNode);
                }
                return filterFunc({
                    type: 'group', 
                    content: {
                        children: newChildren,
                        properties: $.extend(true, {}, o.content.properties)
                    }
                })
            }
        }
        
        var newFirstLevelGroups = [];
        for (var k = 0; k < _tree.children.length; k++) {
            var newNode = forEachLayerRec(_tree.children[k]);
            newNode && newFirstLevelGroups.push(newNode);
        }
        
        return {
            properties: $.extend(true, {}, _tree.properties),
            children: newFirstLevelGroups
        }
    }
    
    //Методы управления видимостью слоёв в дереве
    
    //проходится по всему поддереву elem и устанавливает видимость isVisible всем узлам включая elem (учитывая ограничения на radio buttons)
    var setSubtreeVisibility = function(elem, isVisible) {
        var props = elem.content.properties;
        if (props.visible != isVisible) {
            props.visible = isVisible;
            $(_this).triggerHandler('nodeVisibilityChange', [elem]);
            $(elem).triggerHandler('nodeVisibilityChange', [elem]);
            
            if (elem.content.children) {
                for (var c = 0; c < elem.content.children.length; c++) {
                    var vis = isVisible && (!props.list || c == 0); //когда делаем видимой группу-список, виден только первый элемент группы
                    setSubtreeVisibility(elem.content.children[c], vis);
                }
            }
        }
    }    
    
    /** Устанавливает видимость узла дерева и всех родительских элементов данного узла в зависимости от видимости его прямых потомков. Узел должен быть группой.
     * При этом разруливаются конфликты с несколькими видимыми узлами в radio-группах.
     * @param {nsGmx.LayersTree~Node} node Узел дерева, видимость которого нужно обновить
     * @param {nsGmx.LayersTree~Node} triggerSubnode один их прямых потомков node, состояние которого должно остаться неизменным (важно для разруливания конфликтов в radio-групп)
     * @param {nsGmx.LayersTree~Node[]} [parents] массив всех родителей, опционально
     */
    this.updateNodeVisibility = function(elem, triggerSubnode, parents) {
        var props = elem.content.properties,
            isList = props.list,
            children = elem.content.children,
            triggerNodeVisible = triggerSubnode ? triggerSubnode.content.properties.visible : false,
            visibleNode = triggerNodeVisible ? triggerSubnode : null;
        
        var isVisible = false;
        for (var c = 0; c < children.length; c++) {
            var child = children[c];
            var childVisible = child.content.properties.visible;
            isVisible = isVisible || childVisible;
            
            if (childVisible && !visibleNode) {
                visibleNode = child;
            }
            
            if (isList && childVisible && child !== visibleNode) {
                setSubtreeVisibility(child, false);
            }
        }
        
        if (isVisible !== props.visible) {
            props.visible = isVisible;
            
            $(this).triggerHandler('nodeVisibilityChange', [elem]);
            $(elem).triggerHandler('nodeVisibilityChange', [elem]);
            
            if (!parents) {
                parents = this.findElemByGmxProperties(elem).parents;
                parents.pop(); //последний элемент - карта; нас не интересует
            }
            var parent = parents.shift();
            parent && this.updateNodeVisibility(parent, elem, parents);
        }
    }
    
    /** Задать видимость узла дерева. Будут сделаны все нужные изменения видимости как выше, 
     * так и ниже по дереву относительно этого узла.
     * @param {nsGmx.LayersTree~Node} node Узел дерева, которому мы хотим задать видимость
     * @param {Boolean} isVisible Видимость узла (true - виден)
     */
    this.setNodeVisibility = function(node, isVisible) {
        if (node.content.properties.visible != isVisible) {
            //устанавливаем видимость поддерева, которое начинается с этого элемента
            setSubtreeVisibility(node, isVisible);
            
            //идём вверх по дереву до корня и меняем видимость родителей
            var parentElem = _this.findElemByGmxProperties(node).parents[0];
            parentElem && parentElem.content && this.updateNodeVisibility(parentElem, node);
        }
    }
}
var nsGmx = nsGmx || {};

/** Вспомогательные ф-ции ГеоМиксера
@namespace _mapHelper
*/
nsGmx.mapHelper = {

}


var mapHelp =
{
	mapHelp: {},
	serviceHelp: {},
	tabs: {},
	externalMaps : {}
}

!(function(_) {

var mapHelper = function()
{
	this.builded = false;
    //this._treeView = false;

	this.defaultStyles =
	{
		'point':{outline:{color:0x0000FF, thickness:1},marker:{size:8}, fill:{color:0xFFFFFF, opacity:20}},
		'linestring':{outline:{color:0x0000FF, thickness:1}},
		'polygon':{outline:{color:0x0000FF, thickness:1}, fill:{color:0xFFFFFF, opacity:20}}
	}

	this.defaultPhotoIconStyles = {
		'point': {
			marker: {
				image: 'http://maps.kosmosnimki.ru/api/img/camera18.png',
				center: true
			}
		}
	}

	this.stylesDialogsHash = {};
	this.drawingDialogsHash = {};

	this.layerEditorsHash = {};

	this.layerStylesHash = {};

	this.attrValues = {};

	this.customErrorsHash = {
		"Unable to locate EXIF content" : "Unable to locate EXIF content"
	}

	// контролирует пользовательские объекты, которые являются редактируемыми контурами растровых слоёв.
	// все такие объекты не будут сериализоваться
	this.drawingBorders = (function()
	{
		var _borders = {};

		//не будем сериализовать все пользовательские объекты, являющиеся контурами слоёв, так как это временные объекты
		nsGmx.DrawingObjectCustomControllers.addDelegate({
			isSerializable: function(obj)
			{
				for (var name in _borders)
					if (_borders[name] === obj)
						return false;

				return true;
			}
		});

		return {
			set: function(name, obj)
			{
                if (name in _borders) {
                    _borders[name].drawingFeature.off('edit', _borders[name].editListener);
                }
                var editListener = function() {
                    _borders[name].isChanged = true;
                }

                obj.on('edit', editListener);

				_borders[name] = {
                    isChanged: !!_borders[name],
                    drawingFeature: obj,
                    editListener: editListener
                }
			},
			get: function(name)
			{
				return _borders[name] && _borders[name].drawingFeature;
			},
			length: function()
			{
				return objLength(_borders);
			},

			//callback(name, obj)
			forEach: function(callback)
			{
				for (var name in _borders)
					callback(name, _borders[name].drawingFeature);
			},

            isChanged: function(name) {
                return !!_borders[name] && _borders[name].isChanged;
            },

			updateBorder: function(name, span)
			{
				if (!_borders[name])
					return;

                var geom = _borders[name].drawingFeature.toGeoJSON().geometry,
                    areaStr = L.gmxUtil.prettifyArea(L.gmxUtil.geoArea(geom, false));

				if (span)
				{
					_(span, [_t(areaStr)]);
					return;
				}

				if (!$('#drawingBorderDescr' + name).length)
					return;

				$('#drawingBorderDescr' + name).empty();

				_($('#drawingBorderDescr' + name)[0], [_t(areaStr)]);
			},

			//Удаляет объект из списка контуров слоя
			//?removeDrawring {bool, default: false} - удалять ли сам пользовательский объект
			removeRoute: function(name, removeDrawing)
			{
				if (!(name in _borders))
					return;

                _borders[name].drawingFeature.off('edit', _borders[name].editListener);

				if (removeDrawing) {
					nsGmx.leafletMap.gmxDrawing.remove(_borders[name].drawingFeature);
                }

				delete _borders[name];

				$('#drawingBorderDescr' + name).empty();
			}
		}
	})();

	this.unsavedChanges = false;

}

mapHelper.prototype = new leftMenu();

/** Менеджер кастомных параметров карты.
 * Содержит набор провайдеров доп. параметров, которые могут сохранять и загружать данные из хранилища параметров
 * Данные загружаются один раз. Возможна асинхронная загрузка данных/добавление провайдеров.
 * Порядок вызова провайдеров не определён.
 *
 * @memberOf _mapHelper
 * @name customParamsManager
 */
mapHelper.prototype.customParamsManager = (function()
{
	var _providers = [];
	var _params = []; //хранит параметры, которые не были загружены провайдерами

	var loadProviderState = function( provider )
	{
		if ( provider.name in _params && typeof provider.loadState !== 'undefined')
		{
			provider.loadState( _params[ provider.name ] );
			delete _params[ provider.name ];
		}
	}

	return {
		saveParams: function()
		{
			if ( !_providers.length ) return;
			var params = {};
			for (var p = 0; p < _providers.length; p++ )
			{
				if (typeof _providers[p].saveState !== 'undefined')
                    params[_providers[p].name] = _providers[p].saveState();
			}

			return params;
		},
		loadParams: function(params)
		{
			_params = params;
			for (var p = 0; p < _providers.length; p++ )
				loadProviderState( _providers[p] );
		},

		//интерфейс провайдера: name, saveState(), loadState(state)
		addProvider: function(provider)
		{
			_providers.push( provider );
			loadProviderState( provider );
		},

        isProvider: function(providerName) {
            return !!nsGmx._.findWhere(_providers, {name: providerName});
        },
        removeProvider: function(providerName) {
            _providers = nsGmx._.filter(_providers, function(provider) {
                return provider.name !== providerName;
            })
        }
	}
})();

mapHelper.prototype.makeStyle = function(style)
{
    style = style || {};
	var givenStyle = {};

	if (typeof style.RenderStyle != 'undefined')
		givenStyle = style.RenderStyle;
	else if (style.outline || style.marker)
		givenStyle = style;
	else
	{
		if (style.PointSize)
			givenStyle.marker = { size: parseInt(style.PointSize) };
		if (style.Icon)
		{
			var src = (style.Icon.indexOf("http://") != -1) ?
				style.Icon :
				(baseAddress + "/" + style.Icon);
			givenStyle.marker = { image: src, center: true };
		}
		if (style.BorderColor || style.BorderWidth)
			givenStyle.outline = {
				color: parseColor(style.BorderColor),
				thickness: parseInt(style.BorderWidth || "1")
			};
		if (style.FillColor)
			givenStyle.fill = {
				color: parseColor(style.FillColor),
				opacity: 100 - parseInt(style.Transparency || "0")
			};

		var label = style.label || style.Label;
		if (label)
			givenStyle.label = {
				field: label.FieldName,
				color: parseColor(label.FontColor),
				size: parseInt(label.FontSize || "12")
			};
	}

	return givenStyle;
}

mapHelper.prototype.getMapStateAsPermalink = function(callback)
{
    // сохраняем состояние карты
    var mapState = _mapHelper.getMapState();

    // туда же сохраним созданные объекты
    nsGmx.userObjectsManager.collect();
    mapState.userObjects = JSON.stringify(nsGmx.userObjectsManager.getData());

    nsGmx.Utils.TinyReference.create(mapState, true).then(callback);
}

mapHelper.prototype.reloadMap = function()
{
    if (!nsGmx.gmxMap) {
        window.location.reload();
    }

    _mapHelper.getMapStateAsPermalink(function(permalinkID)
    {
        createCookie("TempPermalink", permalinkID);
        window.location.replace(window.location.href.split("?")[0] + "?permalink=" + permalinkID + (defaultMapID == globalMapName ? "" : ("&" + globalMapName)));
    })
}

mapHelper.prototype.updateUnloadEvent = function(flag)
{
	if (typeof flag != 'undefined')
		this.unsavedChanges = flag;

	if (this.unsavedChanges)
	{
		window.onbeforeunload = function(e)
		{
			return _gtxt("В дереве слоев остались несохраненные изменения!");
		}
	}
	else
		window.onbeforeunload = null;
}

mapHelper.prototype.setBalloon = function(filter, template)
{
	filter.enableHoverBalloon(function(o)
	{
		return template.replace(/\[([a-zA-Z0-9_а-яА-Я ]+)\]/g, function()
		{
			var key = arguments[1];
			if (key == "SUMMARY")
				return o.getGeometrySummary();
			else
				return o.properties[key];
		});
	});
}

mapHelper.prototype.updateMapStyles = function(newStyles, name)
{
    var layer = nsGmx.gmxMap.layersByID[name],
        styles = newStyles.map(nsGmx.Utils.prepareGmxLayerStyle);

    layer.setStyles(styles);
}

//TODO: remove isEditableStyles
mapHelper.prototype.updateTreeStyles = function(newStyles, div, treeView, isEditableStyles)
{
    isEditableStyles = typeof isEditableStyles === 'undefined' || isEditableStyles;
	div.gmxProperties.content.properties.styles = newStyles;

	var multiStyleParent = $(div).children('[multiStyle]')[0];

	var parentIcon = $(div).children("[styleType]")[0],
		newIcon = _mapHelper.createStylesEditorIcon(newStyles, div.gmxProperties.content.properties.GeometryType.toLowerCase(), {addTitle: isEditableStyles});

	$(parentIcon).empty().append(newIcon).attr('styleType', $(newIcon).attr('styleType'));

	$(multiStyleParent).empty();

	_mapHelper.createMultiStyle(div.gmxProperties.content.properties, treeView, multiStyleParent)
}

mapHelper.prototype.restoreTinyReference = function(id, callbackSuccess, errorCallback)
{
	window.suppressDefaultPermalink = true;
    nsGmx.Utils.TinyReference.get(id).then(function(obj) {
		if (obj.position) {
            var latLngPos = L.Projection.Mercator.unproject(obj.position);
			obj.position.x = latLngPos.lng;
			obj.position.y = latLngPos.lat;
			obj.position.z = 17 - obj.position.z;
			if (obj.drawnObjects) {
				for (var i in obj.drawnObjects) {
                    //эта двойная конвертация в действительности просто перевод координат из Меркатора в LatLng
					obj.drawnObjects[i].geometry = L.gmxUtil.geoJSONtoGeometry(L.gmxUtil.geometryToGeoJSON(obj.drawnObjects[i].geometry, true));
				}
            }
		}
        obj.originalReference = id;
		callbackSuccess(obj);
    }, errorCallback);
}

mapHelper.prototype.getMapState = function() {
    var lmap = nsGmx.leafletMap;

    if (!lmap) {
        return {};
    }

    var drawnObjects = [],
		drawings = lmap.gmxDrawing.saveState(),
		features = drawings.featureCollection.features;
        openPopups = {},
        condition = {expanded:{}, visible:{}},
		LayersTreePermalinkParams = {},
		mercCenter = L.Projection.Mercator.project(lmap.getCenter());

		for (var i = 0; i < features.length; i++) {
			if (features[i].properties.exportRect) {
				features.splice(i, 1);
			}
		}

    lmap.gmxDrawing.getFeatures().forEach(function(feature) {
        if (!nsGmx.DrawingObjectCustomControllers.isSerializable(feature) || feature.options.exportRect) {
            return;
        }

        var geoJSON = feature.toGeoJSON();

        var elem = {
            properties: geoJSON.properties,
            geometry: L.gmxUtil.geoJSONtoGeometry(geoJSON, true)
        };

        if (elem.geometry.type !== "POINT") {
            var style = feature.getOptions().lineStyle;

            if (style) {
                elem.thickness = style.weight || 2;
                elem.color = style.color;
                elem.opacity = (style.opacity || 0.8) * 100;
            }
        }

        if (lmap.hasLayer(feature.getPopup())) {
            elem.isBalloonVisible = true;
        }

        drawnObjects.push(elem);
    });

    for (var l in nsGmx.gmxMap.layersByID) {
        var layer = nsGmx.gmxMap.layersByID[l];

        if (layer.getPopups) {
            var popups = layer.getPopups();
            if (popups.length) {
                openPopups[l] = popups;
            }
        }
    }

    this.findTreeElems(_layersTree.treeModel.getRawTree(), function(elem) {
        var props = elem.content.properties;
        if (elem.type == 'group') {
            var groupId = props.GroupID;

            if (!$("div[GroupID='" + groupId + "']").length && !props.changedByViewer)
                return;

            condition.visible[groupId] = props.visible;
            condition.expanded[groupId] = props.expanded;
        } else {
            if (props.changedByViewer) {
                condition.visible[props.name] = props.visible;
            }
        }
    });

	// layers tree permalink params (without server)
	this.findTreeElems(_layersTree.treeModel.getRawTree(), function(elem) {
		var props = elem.content.properties,
			id = elem.type == 'group' ? props.GroupID : props.LayerID;

		if (props.permalinkParams) {
			LayersTreePermalinkParams[id] = props.permalinkParams;
		}
	});

	var dateIntervals = {};

	for (var l in nsGmx.gmxMap.layersByID) {
		var layer = nsGmx.gmxMap.layersByID[l];
			props = layer.getGmxProperties(),
			isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.setDateInterval);

		if (isTemporalLayer && layer.getDateInterval) {
			dateIntervals[props.LayerID] = layer.getDateInterval();
		}
	}

    return {
        mode: lmap.gmxBaseLayersManager.getCurrentID(),
        mapName: globalMapName,
        position: {
            x: mercCenter.x,
            y: mercCenter.y,
            z: 17 - lmap.getZoom()
        },
        mapStyles: this.getMapStyles(),
		drawings: drawings,
		drawnObjects: drawnObjects,
        isFullScreen: window.layersShown ? "false" : "true",
        condition: condition,
		LayersTreePermalinkParams: LayersTreePermalinkParams,
        language: window.language,
		customParamsCollection: this.customParamsManager.saveParams(),
		dateIntervals: dateIntervals,
        openPopups: openPopups
    }
}

mapHelper.prototype.getMapStyles = function()
{
	var styles = {};

	this.findChilds(_layersTree.treeModel.getRawTree(), function(child)
	{
		if (child.content.properties.type == "Vector" && $("div[LayerID='" + child.content.properties.LayerID + "']").length)
			styles[child.content.properties.name] = child.content.properties.styles;
	}, true);

	return styles;
}

mapHelper.prototype.showPermalink = function()
{
	this.createPermalink(function(id){
        var url = "http://" + window.location.host + window.location.pathname + "?permalink=" + id + (defaultMapID == globalMapName ? "" : ("&" + globalMapName));
        var input = _input(null, [['dir','className','inputStyle inputFullWidth'],['attr','value', url]]);

        showDialog(_gtxt("Ссылка на текущее состояние карты"), _div([input]), 311, 80, false, false);

        input.select();
    });
}

mapHelper.prototype.createExportPermalink = function(params, callback)
{
	var mapState = $.extend(this.getMapState(), params),
		def = nsGmx.Utils.TinyReference.create(mapState, false);
    def.then(callback);
	return def;
}

mapHelper.prototype.createPermalink = function(callback)
{
	var mapState = this.getMapState(),
        def = nsGmx.Utils.TinyReference.create(mapState, false);

    def.then(callback);
    return def;
}

mapHelper.prototype.updateTinyMCE = function(container) {
    gmxCore.loadModule('TinyMCELoader', 'http://' + window.location.host + window.location.pathname.replace('index.html', '') + 'TinyMCELoader.js', function() {
        $('.balloonEditor', container).each(function() {
            var id = $(this).attr('id');
            if (!tinyMCE.get(id)) {
                tinyMCE.execCommand("mceAddControl", true, id);
            }
        })
    });
}

//event: selected(url)
mapHelper.ImageSelectionWidget = Backbone.View.extend({
    tagName: 'span',
    className: 'gmx-icon-choose',
    events: {
        'click': function() {
            var imagesDir = nsGmx.AuthManager.getUserFolder() + 'images'
                _this = this;
            sendCrossDomainJSONRequest(serverBase + 'FileBrowser/CreateFolder.ashx?WrapStyle=func&FullName=' + encodeURIComponent(imagesDir), function(response) {
                if (!parseResponse(response))
                    return;

                _fileBrowser.createBrowser(_gtxt("Изображение"), ['jpg', 'jpeg', 'png', 'gif', 'swf'], function(path) {
                    var relativePath = path.substring(imagesDir.length);
                    if (relativePath[0] == '\\') {
                        relativePath = relativePath.substring(1);
                    }

                    var url = serverBase + "GetImage.ashx?usr=" + encodeURIComponent(nsGmx.AuthManager.getLogin()) + "&img=" + encodeURIComponent(relativePath);

                    _this.trigger('selected', url);
                }, {startDir: imagesDir, restrictDir: imagesDir});
            });
        }
    }
});

mapHelper.ImageInputControl = function(initURL) {
    var prevValue = initURL || '';
    var inputUrl = _input(null, [['dir','className','inputStyle'],['attr','value', prevValue], ['css','width','170px']]);
    _title(inputUrl, _gtxt('URL изображения'));

    var _this = this;

    var update = function() {
        if (inputUrl.value != prevValue) {
            prevValue = inputUrl.value;
            $(_this).change();
        }
    }

    var mainDiv = $('<div/>').append(inputUrl);
    inputUrl.onkeyup = inputUrl.change = update;

    if (nsGmx.AuthManager.canDoAction(nsGmx.ACTION_UPLOAD_FILES)) {
        var imageSelectionWidget = new mapHelper.ImageSelectionWidget();
        imageSelectionWidget.on('selected', function(url) {
            inputUrl.value = url;
            update();
        });

        mainDiv.append(imageSelectionWidget.el);
    }

    this.getControl = function()
    {
        return mainDiv[0];
    }

    this.value = function()
    {
        return inputUrl.value;
    }
}

//params:
//  * addTitle {bool, default: true}
mapHelper.prototype.createStylesEditorIcon = function(parentStyles, type, params)
{
    var _params = $.extend({addTitle: true}, params);
	var icon;

	if ($.isArray(parentStyles) && parentStyles.length > 1)
		icon =  _img(null, [['attr','src','img/misc.png'],['css','margin','0px 2px -3px 4px'],['css','cursor','pointer'],['attr','styleType','multi']]);
	else
	{
		var parentStyle = _mapHelper.makeStyle(parentStyles[0]);

		if (parentStyle.marker && parentStyle.marker.image)
		{
			if (typeof parentStyle.marker.color == 'undefined')
			{
				icon = _img(null, [['dir','className','icon'],['attr','styleType','icon']]);

				var fixFunc = function()
					{
						var width = this.width,
							height = this.height,
                            scale;

                        if (width && height) {
							var scaleX = 14.0 / width;
							var scaleY = 14.0 / height
							scale = Math.min(scaleX, scaleY);
                        } else {
                            scale = 1;
                            width = height = 14;
                        }

						setTimeout(function()
						{
							icon.style.width = Math.round(width * scale) + 'px';
							icon.style.height = Math.round(height * scale) + 'px';
						}, 10);
					}

				icon.onload = fixFunc;
                icon.src = parentStyle.marker.image;
			}
			else
			{
				var dummyStyle = {};

				$.extend(dummyStyle, parentStyle);

				dummyStyle.outline = {color: parentStyle.marker.color, opacity: 100};
				dummyStyle.fill = {color: parentStyle.marker.color, opacity: 100};

				icon = nsGmx.Controls.createGeometryIcon(dummyStyle, type);
			}
		}
		else
		{
			icon = nsGmx.Controls.createGeometryIcon(parentStyle, type);
		}
	}

    if (_params.addTitle)
        _title(icon, _gtxt("Редактировать стили"));

	icon.geometryType = type;

	return icon;
}

mapHelper.prototype.createLoadingLayerEditorProperties = function(div, parent, layerProperties, params)
{
	var elemProperties = div.gmxProperties.content.properties,
		loading = _div([_img(null, [['attr','src','img/progress.gif'],['css','marginRight','10px']]), _t(_gtxt('загрузка...'))], [['css','margin','3px 0px 3px 20px']]),
        type = elemProperties.type,
		_this = this;

    if (type == "Vector")
    {
        nsGmx.createLayerEditor(div, type, parent, layerProperties, params);

        return;
    }
    else
    {
        if (elemProperties.name)
        {
            _(parent, [loading]);

            sendCrossDomainJSONRequest(serverBase + "Layer/GetLayerInfo.ashx?WrapStyle=func&LayerName=" + elemProperties.name, function(response)
            {
                if (!parseResponse(response))
                    return;

                loading.removeNode(true);

                nsGmx.createLayerEditor(div, type, parent, response.Result, params)
            })
        }
    }
}

mapHelper.prototype.createNewLayer = function(type)
{
	if ($('#new' + type + 'Layer').length)
		return;

	var parent = _div(null, [['attr','id','new' + type + 'Layer'], ['css', 'height', '100%']]),
		height = (type == 'Vector') ? 340 : 360;

    if (type !== 'Multi')
    {
		var properties = {Title:'', Description: '', Date: '', TilePath: {Path:''}, ShapePath: {Path:''}};
        var dialogDiv = showDialog(type != 'Vector' ? _gtxt('Создать растровый слой') : _gtxt('Создать векторный слой'), parent, 340, height, false, false);
        nsGmx.createLayerEditor(false, type, parent, properties,
            {
                doneCallback: function()
                {
                    removeDialog(dialogDiv);
                }
            }
        );
    }
    else
    { //мультислой
        var _this = this;
        nsGmx.createMultiLayerEditorNew( _layersTree );
    }
}

// перенос clipLayer из маплетов карты
mapHelper.prototype.clipLayer = function(layer, props)
{
	var sw = L.latLng([props.MinViewY, props.MinViewX]),
		nw = L.latLng([props.MaxViewY, props.MinViewX]),
		ne = L.latLng([props.MaxViewY, props.MaxViewX]),
		se = L.latLng([props.MinViewY, props.MaxViewX]),
		clip = L.polygon([sw, nw, ne, se, sw]);

	    layer.addClipPolygon(clip);
}

// Формирует набор элементов tr используя контролы из shownProperties.
// Параметры:
// - shownProperties: массив со следующими свойствами:
//   * tr - если есть это свойство, то оно помещается в tr, все остальные игнорируются
//   * name - названия свойства, которое будет писаться в левой колонке
//   * elem - если есть, то в правую колонку помещается этот элемент
//   * field - если нет "elem", в правый столбец подставляется layerProperties[field]
//   * trid - id для DOM элементов. Не применяется, если прямо указано tr
//   * trclass - class для DOM элементов. Не применяется, если прямо указано tr
// - layerProperties - просто хеш строк для подстановки в правую колонку
// - style:
//   * leftWidth - ширина левой колонки в пикселях
//   * leftcolumnclass - class для td элементов первого столбца. Не применяется, если прямо указано tr
//   * rightcolumnclass - class для td элементов второго столбца. Не применяется, если прямо указано tr
mapHelper.prototype.createPropertiesTable = function(shownProperties, layerProperties, style)
{
	var _styles = $.extend({leftWidth: 100}, style);
	var trs = [];
	for (var i = 0; i < shownProperties.length; i++)
	{
		var td;
		if (typeof shownProperties[i].tr !== 'undefined')
		{
			trs.push(shownProperties[i].tr);
			continue;
		}

		if (typeof shownProperties[i].elem !== 'undefined')
			td = _td([shownProperties[i].elem]);
		else
			td = _td([_t(layerProperties[shownProperties[i].field] != null ? layerProperties[shownProperties[i].field] : '')],[['css','padding','0px 3px']]);

        var tdTitle = _td([_t(shownProperties[i].name)],[['css','width', _styles.leftWidth + 'px']]);

		var tr = _tr([tdTitle, td]);

        _(tdTitle, [], [['dir', 'className', 'propertiesTable-title ' + (_styles.leftcolumnclass || '')]]);

        if (_styles.rightcolumnclass)
            _(td, [], [['dir', 'className', _styles.rightcolumnclass]]);

        if (shownProperties[i].trid)
            _(tr, [], [['attr', 'id', shownProperties[i].trid]]);

        if (shownProperties[i].trclass)
            _(tr, [], [['dir', 'className', shownProperties[i].trclass]]);

		trs.push(tr);
	}

	return trs;
}

mapHelper.prototype.createLayerEditor = function(div, treeView, selected, openedStyleIndex)
{
	var elemProperties = div.gmxProperties.content.properties,
        layerName = elemProperties.name,
		_this = this;

	if (elemProperties.type == "Vector")
	{
		if (typeof this.layerEditorsHash[layerName] != 'undefined')
		{
			if (this.layerEditorsHash[layerName] != false) {
                this.layerEditorsHash[layerName].selectTab(selected);
            }

			return;
		}

		this.layerEditorsHash[layerName] = false;

		var mapName = elemProperties.mapName,
			createTabs = function(layerProperties)
			{
				var id = 'layertabs' + layerName,
					divProperties = _div(null,[['attr','id','properties' + id], ['css', 'height', '100%']]),
					tabMenu,
                    additionalTabs = [];

				var pos = nsGmx.Utils.getDialogPos(div, true, 390),
                    updateFunc = function()
                    {
                    },
					closeFunc = function()
					{
                        updateFunc();
						return false;
					};

				_this.createLoadingLayerEditorProperties(div, divProperties, layerProperties, {
                    doneCallback: function()
                    {
                        $(divDialog).dialog('close');
                    },
                    additionalTabs: additionalTabs,
                    selected: selected,
                    createdCallback: function(layerEditor) {
                        _this.layerEditorsHash[layerName] = layerEditor;
                        _this.layerEditorsHash[layerName].closeFunc = closeFunc;
                        _this.layerEditorsHash[layerName].updateFunc = updateFunc;
                    }
                });

				var divDialog = showDialog(_gtxt('Слой [value0]', elemProperties.title), divProperties, 350, 470, pos.left, pos.top, null, function()
                {
                    closeFunc();
                    delete _this.layerEditorsHash[layerName];
                });

				// при сохранении карты сбросим все временные стили в json карты
				divProperties.closeFunc = closeFunc;
				divProperties.updateFunc = updateFunc;
			};

		if (!this.attrValues[mapName])
			this.attrValues[mapName] = {};

		sendCrossDomainJSONRequest(serverBase + "Layer/GetLayerInfo.ashx?WrapStyle=func&NeedAttrValues=false&LayerName=" + layerName, function(response)
		{
			if (!parseResponse(response))
				return;

            var columns = response.Result.Columns;
            var attributesHash = {};

            for (var i = 0; i < columns.length; i++) {
                attributesHash[columns[i].Name] = [];
            }

			_this.attrValues[mapName][layerName] = new nsGmx.LazyAttributeValuesProviderFromServer(attributesHash, layerName);

			createTabs(response.Result);
		})
	}
	else if (elemProperties.type == "Raster")
	{
		if (elemProperties.LayerID)
		{
			if (this.layerEditorsHash[layerName])
				return;

			this.layerEditorsHash[layerName] = true;

			var id = 'layertabs' + layerName,
				divProperties = _div(null,[['attr','id','properties' + id], ['css', 'height', '100%']]),
				divStyles = _div(null,[['attr','id','styles' + id], ['css', 'height', '100%'], ['css', 'overflowY', 'auto']]);

			var layer = nsGmx.gmxMap.layersByID[layerName],
				parentStyle = elemProperties.styles && elemProperties.styles[0] || elemProperties;

            var zoomPropertiesControl = new nsGmx.ZoomPropertiesControl(parentStyle.MinZoom, parentStyle.MaxZoom),
                liMinZoom = zoomPropertiesControl.getMinLi(),
                liMaxZoom = zoomPropertiesControl.getMaxLi();

            $(zoomPropertiesControl).change(function()
            {
                layer.setZoomBounds(this.getMinZoom(), this.getMaxZoom());
            });

			_(divStyles, [_ul([liMinZoom, liMaxZoom])]);

			this.createLoadingLayerEditorProperties(div, divProperties, null, {
                doneCallback: function()
                {
                    $(divDialog).dialog('close');
                },
                additionalTabs: [{title: _gtxt("Стили"), name: 'styles', container: divStyles}]

            });

			var pos = nsGmx.Utils.getDialogPos(div, true, 330),
				closeFunc = function()
				{
                    elemProperties.styles = elemProperties.styles || [];
                    elemProperties.styles[0] = elemProperties.styles[0] || {};

					elemProperties.styles[0].MinZoom = zoomPropertiesControl.getMinZoom();
					elemProperties.styles[0].MaxZoom = zoomPropertiesControl.getMaxZoom();

					delete _this.layerEditorsHash[layerName];

					treeView.findTreeElem(div).elem.content.properties = elemProperties;

					_this.drawingBorders.removeRoute(layerName, true);

					if ($('#drawingBorderDialog' + layerName).length)
						removeDialog($('#drawingBorderDialog' + layerName)[0].parentNode);

					return false;
				};

			var divDialog = showDialog(_gtxt('Слой [value0]', elemProperties.title), divProperties, 330, 410, pos.left, pos.top, null, closeFunc);
		}
		else
		{
            nsGmx.createMultiLayerEditorServer(elemProperties, div, treeView);
        }
	} else if (elemProperties.type == "Virtual"){
        var divProperties = _div(null,[['attr','id','properties' + id], ['css', 'height', '100%']]);

        this.createLoadingLayerEditorProperties(div, divProperties, null, {
            doneCallback: function() {
                $(divDialog).dialog('close');
            }
        });

        var closeFunc = function() {
            delete _this.layerEditorsHash[layerName];
        };

        var pos = nsGmx.Utils.getDialogPos(div, true, 330);

        var divDialog = showDialog(_gtxt('Слой [value0]', elemProperties.title), divProperties, 330, 410, pos.left, pos.top, null);
    }
}

mapHelper.prototype.createWFSStylesEditor = function(parentObject, style, geometryType, divCanvas)
{
	var _this = this,
		templateStyle = {};

	$.extend(true, templateStyle, style);

    var elemCanvas = _mapHelper.createStylesEditorIcon([{MinZoom:1, MaxZoom: 21, RenderStyle: style.regularStyle}], geometryType);
    var spanIcon = _span([elemCanvas]);

	spanIcon.onclick = function()
	{
        var listenerId = parentObject.addListener('onSetStyle', function(style)
            {
                var newIcon = _this.createStylesEditorIcon([{MinZoom:1,MaxZoom:21,RenderStyle:style.regularStyle}], geometryType);
                $(spanIcon).empty().append(newIcon).attr('styleType', $(newIcon).attr('styleType'));
            });

		var canvasStyles = _div(null,[['css','marginTop','10px']]),
			canvasCharts = _div(null,[['css','marginTop','10px']]),
			closeFunc = function()
			{
				$(canvasStyles).find(".colorSelector").each(function()
				{
					$('#' + $(this).data("colorpickerId")).remove();
				});

				var layerElemCanvas = $(divCanvas).find("[geometryType='" + geometryType.toUpperCase() + "']")[0];
				layerElemCanvas.graphDataType = $(canvasCharts).find("select")[0].value;
				layerElemCanvas.graphDataProperties = $(canvasCharts).find("input")[0].value;

                parentObject.removeMapStateListener('onSetStyle', listenerId);
			};

		var id = 'wfstabs' + String(Math.random()).substring(2, 9),
			tabMenu = _div([_ul([_li([_a([_t(_gtxt("Стили"))],[['attr','href','#styles' + id]])]),
								 _li([_a([_t(_gtxt("Диаграммы"))],[['attr','href','#graph' + id]])])])]),
			divStyles = _div(null,[['attr','id','styles' + id]]),
			divGraph = _div(null,[['attr','id','graph' + id]]);

		_(tabMenu, [divStyles, divGraph]);

        gmxCore.loadModule('LayerStylesEditor').done(function(module) {
            var resObject = module.createStyleEditor(canvasStyles, templateStyle, geometryType, false);

            $(resObject).change(function()
            {
                nsGmx.Utils.setMapObjectStyle(parentObject, templateStyle);
            })
        });

		canvasStyles.firstChild.style.marginLeft = '0px';
		_(divStyles, [canvasStyles]);

		_mapHelper.createChartsEditor(canvasCharts, $(divCanvas).find("[geometryType='" + geometryType.toUpperCase() + "']")[0]);
		canvasCharts.firstChild.style.marginLeft = '0px';
		_(divGraph, [canvasCharts]);

		var pos = nsGmx.Utils.getDialogPos(spanIcon, false, 160);
		showDialog(_gtxt('Редактирование стилей объекта'), tabMenu, 330, 180, pos.left, pos.top, false, closeFunc);

		$(tabMenu).tabs({active: 0});
	}

	spanIcon.getStyle = function()
	{
		return templateStyle;
	}

    return spanIcon;
}

mapHelper.prototype.createChartsEditor = function(parent, elemCanvas)
{
	var graphTypeSel = nsGmx.Utils._select([_option([_t(_gtxt("График по времени"))], [['attr','value','func']]),
								_option([_t(_gtxt("Круговая"))], [['attr','value','pie']])], [['dir','className','selectStyle'],['css','width','180px']]),
		propertiesMask = _input(null, [['dir','className','inputStyle'],['css','width','180px']]);

	switchSelect(graphTypeSel, elemCanvas.graphDataType);
	propertiesMask.value = elemCanvas.graphDataProperties;

	_(parent, [_table([_tbody([_tr([_td([_t(_gtxt("Тип"))], [['css','width','100px']]), _td([graphTypeSel])]),
								_tr([_td([_t(_gtxt("Маска атрибутов"))]), _td([propertiesMask])])])])]);
}

mapHelper.prototype.createMultiStyle = function(elem, treeView, multiStyleParent, treeviewFlag, layerManagerFlag)
{
	var filters = elem.styles;

	if (filters.length < 2)
	{
		multiStyleParent.style.display = 'none';

		return;
	}

	multiStyleParent.style.display = '';

	var ulFilters = _ul();

	for (var i = 0; i < filters.length; i++)
	{
		var icon = this.createStylesEditorIcon([elem.styles[i]], elem.GeometryType.toLowerCase(), {addTitle: !layerManagerFlag}),
			name = elem.styles[i].Name || elem.styles[i].Filter || 'Без имени ' + (i + 1),
            iconSpan = _span([icon]),
			li = _li([_div([iconSpan, _span([_t(name)],[['css','marginLeft','3px']])])]);

        $(iconSpan).attr('styleType', $(icon).attr('styleType'));

		if (!layerManagerFlag)
		{
			(function(i)
			{
				iconSpan.onclick = function()
				{
                    nsGmx.createStylesDialog(elem, treeView, i);
					//_mapHelper.createLayerEditor(multiStyleParent.parentNode, treeView, 'styles', i);
				}
			})(i);
		}

		_(ulFilters, [li])
	}

	ulFilters.style.display = 'none';
	ulFilters.className = 'hiddenTree';

	_(multiStyleParent, [_ul([_li([_div([_t(_gtxt("Стили слоя"))]), ulFilters])])]);

	if (typeof treeviewFlag == 'undefined')
        $(multiStyleParent.firstChild).treeview();
}

mapHelper.prototype.load = function()
{
	var _this = this;

	if (!this.builded)
	{
		var fileName;

		if (typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.usageFilePrefix !== 'undefined')
			fileName = window.gmxViewerUI.usageFilePrefix;
		else
			fileName = window.gmxJSHost ? window.gmxJSHost + "usageHelp" : "usageHelp";

		fileName += _gtxt("helpPostfix");

		_mapHelper._loadHelpTextFromFile(fileName, function( text )
		{
			var div = _div(null, [['dir','className','help']]);
			div.innerHTML = text;
			_(_this.workCanvas, [div]);
		});

		this.builded = true;
	}
}

mapHelper.prototype._loadHelpTextFromFile = function( fileName, callback, num, data )
{
	var proceess = function( text ) {
		callback(Handlebars.compile(text)({gmxVersion: num, gmxData: data}));
	}

	if (fileName.indexOf("http://") !== 0)
		$.ajax({url: fileName, success: proceess});
	else
		sendCrossDomainJSONRequest(serverBase + "ApiSave.ashx?get=" + encodeURIComponent(fileName), function(response)
		{
			proceess(response.Result);
		});
}

mapHelper.prototype.version = function()
{
    var div = $("<div class='gmx-about'></div>");

    var fileName;

    if (typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.helpFilePrefix !== 'undefined')
        fileName = window.gmxViewerUI.helpFilePrefix;
    else
        fileName = window.gmxJSHost ? window.gmxJSHost + "help" : "help";

    fileName += _gtxt("helpPostfix");

    _mapHelper._loadHelpTextFromFile( fileName, function(text)
    {
        div.html(text);
        showDialog(_gtxt("О проекте"), div[0], 500, 300, false, false);
    }, window.nsGmx.GeomixerFrameworkVersion, '' );
}

mapHelper.prototype.print = function() {
	var centerControl = nsGmx.leafletMap.gmxControlsManager.get('center'),
		map = nsGmx.leafletMap,
    	toggleMode = function(isPreviewMode) {
        	map.gmxControlsManager.get('hide').setActive(!isPreviewMode);
        	window.printMode = isPreviewMode;
        	$('#header, #leftMenu, #leftCollapser, #bottomContent, #tooltip, .ui-datepicker-div').toggleClass('print-preview-hide', isPreviewMode);
        	$('#all').toggleClass('print-preview-all', isPreviewMode);
			$('.ui-dialog').toggle();
			$('.leaflet-gmx-iconSvg-hide').toggle();
			$('.leaflet-control-container').toggle();
    	};

    toggleMode(true);
	centerControl.removeFrom(map);

    var ui = $(Handlebars.compile('<div class="print-ui"><span class="print-ui-inner">' +
        '<button class="print-ui-close">Закрыть</button>' +
        '<button class="print-ui-print">Печать</button>' +
			'<span class="layoutContainer">' +
				'<label><input type="radio" name="layout" value="portrait" checked="true">' + _gtxt('портретная') + '</label>' +
				'<label><input type="radio" name="layout" value="layout">' + _gtxt('альбомная') + '</label>' +
			'</span>' +
		'</span>' +
		'</div>')());

	var BIG = 1150,
		SMALL = BIG / 1.4142
	var layout = {
		width: SMALL + 'px',
		height: BIG + 'px'
	};

	ui.find('input[value="portrait"]').click(function() {
		this.checked = true;
		layout.width = SMALL + 'px';
		layout.height = BIG + 'px';

		$('#flash').css({
			width: layout.width,
			height: layout.height
		});

	    map.invalidateSize();
	});

	ui.find('input[value="layout"]').click(function() {
		this.checked = true;
		layout.width = BIG + 'px';
		layout.height = SMALL + 'px';

		$('#flash').css({
			width: layout.width,
			height: layout.height
		});

	    map.invalidateSize();
	});

	ui.find('.print-ui-print').click(function() {
		window.print();
	})

    ui.find('.print-ui-close').click(function() {
        toggleMode(false);
		centerControl.addTo(map);

        $('#flash').css({
            marginLeft: '0px',
            marginTop: '0px'
        });

        window.resizeAll();
        ui.remove();
    });

    $('body').append(ui);

    $('#flash').css({
		top: '0px',
		left: '0px',
		width: layout.width,
		height: layout.height
	});

    map.invalidateSize();
}

// экспортный режим редактора
mapHelper.prototype.exportMap = function(params) {
	var map = nsGmx.leafletMap;

    map.gmxControlsManager.get('hide').setActive(false);
	map.gmxControlsManager.get('center').removeFrom(map);
    window.exportMode = true;

	if (params.grid) {
		var grid = nsGmx.gridManager.gridControl;

		grid.setFixBounds(L.latLngBounds(params.exportBounds._southWest, params.exportBounds._northEast));

	} else {
		nsGmx.gridManager.setState(false);
	}

    $('#header, #leftMenu, #leftCollapser, #bottomContent, #tooltip, .ui-datepicker-div').toggleClass('print-preview-hide', true);

    $('#all').toggleClass('print-preview-all', true);

	$('.leaflet-control-container').hide();

    $('#leftContent').mCustomScrollbar({live:"off"});

	var exportCssParams = {
		top: '0px',
		left: '0px',
		width: '100%',
		height: '100%'
	};

	$('#flash').css(exportCssParams);
	map.invalidateSize();
}

//вызывает callback для всех слоёв поддерева treeElem. Параметры: callback(layerInfo, visibilityFlag)
mapHelper.prototype.findChilds = function(treeElem, callback, flag)
{
	var childsArr = treeElem.content ? treeElem.content.children : treeElem.children;
	if (childsArr)
	{
		for (var i = 0; i < childsArr.length; i++)
		{
			var child = childsArr[i];

			if (child.type == 'group')
				this.findChilds(child, callback, flag && child.content.properties.visible)
			else
				callback(child, flag && child.content.properties.visible);
		}
	}
}

mapHelper.prototype.findTreeElems = function(treeElem, callback, flag, list)
{
	var childsArr = treeElem.content ? treeElem.content.children : treeElem.children;

	for (var i = 0; i < childsArr.length; i++)
	{
		var child = childsArr[i];

		if (child.type == 'group')
		{
			callback(child, flag, treeElem.content ? treeElem.content.properties.list : treeElem.properties.list, i);

			this.findTreeElems(child, callback, flag && child.content.properties.visible, treeElem.content ? treeElem.content.properties.list : treeElem.properties.list)
		}
		else
			callback(child, flag, treeElem.content ? treeElem.content.properties.list : treeElem.properties.list, i);
	}
}

/**
 *  Модифицирует объекты внутри векторного слоя, отправляя изменения на сервер и информируя об этом API
 *
 * @memberOf _mapHelper
 * @name modifyObjectLayer
 * @function
 * @param {String} layerName Имя слоя
 * @param {Object[]} objs Массив описания объектов. Каждое описание представляет из себя объект:
 *
 *  * id {String} ID объекта слоя, над которым производятся изменения (только для модификации и удаления)
 *  * geometry Описание геометрии (вставка и изменение). GeoJSON
 *  * source: {rc: <name КР-источника>, rcobj: <id объекта внутри КР>}
 *  * properties Свойства объекта (вставка и изменение)
 *  * action {'delete'|'insert'|'update'} Производимое действие. Если не указано, то вычисляется следующим образом:
 *    * Если не указан id, то вставка
 *    * Если указан id, то модифицируем
 *    * Для удаления объекта нужно явно прописать параметр
 * @param {String} [crs='EPSG:3395'] Название системы координат геометрии объектов. Поддерживаются 3395, 4326, 3857
 * @return {jQuery.Deferred} Ресолвится в соответствии с ответом сервера
*/
mapHelper.prototype.modifyObjectLayer = function(layerName, objs, crs)
{
    var def = $.Deferred();

    $.each(objs, function(i, obj)
    {
        obj.action = obj.action || (obj.id ? 'update' : 'insert');
    });
    var params = {
        WrapStyle: 'window',
        LayerName: layerName,
        objects: JSON.stringify(objs)
    };
    if (crs) {
        params.geometry_cs = crs;
    }
    sendCrossDomainPostRequest(serverBase + "VectorLayer/ModifyVectorObjects.ashx",
        params
        ,
        function(addResponse)
        {
            if (!parseResponse(addResponse))
            {
                def.reject();
                return;
            }

            var mapLayer = nsGmx.gmxMap.layersByID[layerName];
            if (mapLayer) {
                L.gmx.layersVersion.chkVersion(mapLayer, function() {
                    def.resolve();
                });
            }
            else
            {
                def.resolve();
            }
        }
    )

    return def.promise();
}

/** Запросить с сервера объекты векторного слоя
 * @memberOf _mapHelper
 * @name searchObjectLayer
 * @function
 * @param {String} layerName ID векторного слоя
 * @param {Object} options Параметры запроса
 * @param {String} [options.query] SQL-подобное выражение для выборки объектов
 * @param {Boolean} [options.includeGeometry=false] Возвращать ли геометрию с сервера или нет
 * @param {Object} [options.border=null] GeoJSON для ограничения выборки по геометрии
 * @param {Number} [options.page=0] номер страницы результатов (0 - результаты с самого первого)
 * @param {Number} [options.pagesize=100000] максимальное кол-во объектов в ответе
 * @return {jQuery.Deferred} Promise, который ресолвится массивом найденных объектов. Каждый объект имеет свойства properties и, возможно, geometry
*/
mapHelper.prototype.searchObjectLayer = function(layerName, options) {
    options = options || {};

    var def = $.Deferred();

    var requestParams = {
        WrapStyle: 'message',
        layer: layerName
    }

    if (options.query) {
        requestParams.query = options.query;
    }

    if (options.includeGeometry) {
        requestParams.geometry = true;
    }

    if (options.border) {
        requestParams.border = JSON.stringify(options.border);
    }

    requestParams.page = options.page || 0;
    requestParams.pagesize = options.pagesize || 100000;

    sendCrossDomainPostRequest(serverBase + "VectorLayer/Search.ashx", requestParams, function(response) {
        if (!parseResponse(response)) {
            def.reject(response);
            return;
        }
        var values = response.Result.values;
        var fields = response.Result.fields;
        var objects = [];
        for (var i = 0; i < values.length; i++) {
            var obj = {properties: {}};

            for (var p = 0; p < values[i].length; p++) {
                if (fields[p] === 'geomixergeojson') {
                    obj.geometry = values[i][p];
                } else {
                    obj.properties[fields[p]] = values[i][p];
                }
            }
            objects.push(obj);
        }

        def.resolve(objects);
    });

    return def.promise();
}

/** Скачать векторный слой с сервера
 * @memberOf _mapHelper
 * @name downloadVectorLayer
 * @function
 * @param {Object} params Параметры запроса
 * @param {String} params.name ID векторного слоя, который нужно скачать
 * @param {String} params.host хост, с которого будем скачивать слой
 * @param {String} [params.format=Shape] В каком формате хотим получить (Shape, Tab, gpx, csv, csv_wkt, excel, kml или несколько через запятую)
 * @param {String} [params.query] SQL запрос для сохранения выборки данных вместо всех данных слоя
 * @param {Array} [params.columns] Атрибуты, которые нужно скачать. Массив объектов с ключами {Value, Alias}
*/
mapHelper.prototype.downloadVectorLayer = function(params) {
    var requestParams = {
        t: params.name
    };

    if (params.format) {
        requestParams.format = params.format;
    }

    if (params.query) {
        requestParams.query = params.query;
    }

    if (params.columns) {
        requestParams.columns = JSON.stringify(params.columns);
    }

    sendCrossDomainPostRequest("http://" + params.host + "/" + "DownloadLayer.ashx", requestParams);
}

var _mapHelper = new mapHelper();
window._mapHelper = _mapHelper;
window.mapHelper = mapHelper;

mapHelp.mapHelp.load = function()
{
	var alreadyLoaded = _mapHelper.createWorkCanvas(arguments[0]);

	if (!alreadyLoaded)
		_mapHelper.load()
}

mapHelp.mapHelp.unload = function()
{
}

mapHelp.serviceHelp.load = function()
{
	var alreadyLoaded = _serviceHelper.createWorkCanvas(arguments[0]);

	if (!alreadyLoaded)
		_serviceHelper.load()
}
mapHelp.serviceHelp.unload = function()
{
}

var serviceHelper = function()
{
	this.builded = false;
}

serviceHelper.prototype = new leftMenu();

serviceHelper.prototype.load = function()
{
	var _this = this;
	if (!this.builded)
	{
		var fileName;

		if (typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.servicesFilePrefix !== 'undefined')
			fileName = window.gmxViewerUI.servicesFilePrefix;
		else
			fileName = window.gmxJSHost ? window.gmxJSHost + "servicesHelp" : "servicesHelp";

		fileName += _gtxt("helpPostfix");

		_mapHelper._loadHelpTextFromFile(fileName, function( text )
		{
			var div = _div(null, [['dir','className','help']]);
			div.innerHTML = text;
			_(_this.workCanvas, [div]);
		});

		this.builded = true;
	}
}

var _serviceHelper = new serviceHelper();
window._serviceHelper = _serviceHelper;

mapHelp.tabs.load = function()
{
	var alreadyLoaded = _queryTabs.createWorkCanvas(arguments[0]);

	if (!alreadyLoaded)
		_queryTabs.load()
}
mapHelp.tabs.unload = function()
{
}

mapHelp.externalMaps.load = function()
{
	var alreadyLoaded = _queryExternalMaps.createWorkCanvas(arguments[0]);

	if (!alreadyLoaded)
		_queryExternalMaps.load()
}
mapHelp.externalMaps.unload = function()
{
}

//Динамически подгружаемые части вьюера

//Редактирование мультислоя
nsGmx.createMultiLayerEditorServer = gmxCore.createDeferredFunction('MultiLayerEditor', 'createMultiLayerEditorServer');
nsGmx.createMultiLayerEditorNew = gmxCore.createDeferredFunction('MultiLayerEditor', 'createMultiLayerEditorNew');

//Редактирование карты и группы
nsGmx.addSubGroup = gmxCore.createDeferredFunction('GroupEditor', 'addSubGroup');
nsGmx.createGroupEditor = gmxCore.createDeferredFunction('GroupEditor', 'createGroupEditor');
nsGmx.createMapEditor = gmxCore.createDeferredFunction('GroupEditor', 'createMapEditor');

//Редактирование свойств слоя
nsGmx.createLayerEditor = gmxCore.createDeferredFunction('LayerEditor', 'createLayerEditor');

//Редактирование стилей векторного слоя
nsGmx.createStylesDialog = gmxCore.createDeferredFunction('LayerStylesEditor', 'createStylesDialog');

//Библиотека стилей
nsGmx.showStyleLibraryDialog = gmxCore.createDeferredFunction('StyleLibrary', 'showStyleLibraryDialog');

})(nsGmx.Utils._);

(function(){

//Интерфейс для провайдеров значений параметров
nsGmx.ILazyAttributeValuesProvider = function()
{
	this.isAttributeExists = function( attrName ){};
	this.getValuesForAttribute = function( attrName, callback ){};
};

//Простая обёртка над массивами для обратной совместимости
nsGmx.LazyAttributeValuesProviderFromArray = function( attributes )
{
	var _attrs = attributes;

	this.isAttributeExists = function( attrName )
	{
		return attrName in _attrs; 
	};
	
	this.getValuesForAttribute = function( attrName, callback )
	{
		if ( attrName in _attrs )
			callback(_attrs[attrName]);
		else
			callback();
	};
};
nsGmx.LazyAttributeValuesProviderFromArray.prototype = new nsGmx.ILazyAttributeValuesProvider();

/** При необходимости этот провайдер будет запрашивать значения аттрибутов у сервера
 * @class
 * @memberOf nsGmx
 * @param {Object} attributes Хеш имён атрибутов, значения которых хочется иметь
 * @param {String} layerName ID слоя
*/
nsGmx.LazyAttributeValuesProviderFromServer = function(attributes, layerName)
{
	var _attrs = attributes;
	var _isInited = false;
	var _isProcessing = false;
	
	//в процессе ожидания ответа от сервера мы можем получать запросы на разные аттрибуты
	//важно все их правильно сохранить и выхвать при получении данных
	var _callbacks = {};

    /** Проверить, есть ли такой атрибут
        @param {String} attrName Имя атрибута
        @return {Boolean} Есть ли такой атрибут среди атрибутов
    */
	this.isAttributeExists = function( attrName )
	{
		return attrName in _attrs; 
	};
	
    /** Получить доступные значения атрибута
        @param {String} attrName Имя атрибута
        @param {Function} callback Ф-ция, которая будет вызвана со списком атрибутов, когда он станет доступным
    */
	this.getValuesForAttribute = function( attrName, callback )
	{
		if ( !(attrName in _attrs) ) //вообще нет такого имени
			callback();
		else if ( _attrs[attrName].length ) //есть вектор значений!
			callback( _attrs[attrName] ); 
		else if (_isInited) //вектора значений всё ещё нет и уже ходили на сервер - второй раз пробовать не будем...
			callback(); 
		else
		{
			if ( !(attrName in _callbacks) )
				_callbacks[attrName] = [];
			
			_callbacks[attrName].push(callback);
			
			if (_isProcessing) return;
			//идём на сервер и запрашиваем значения аттрибутов!
			
			_isProcessing = true;
			sendCrossDomainJSONRequest(serverBase + "VectorLayer/GetVectorAttrValues.ashx?WrapStyle=func&LayerName=" + layerName, function(response)
			{
				_isInited = true;
				_isProcessing = false;
				if (!parseResponse(response))
				{
					for (var n in _callbacks)
						for (var k = 0; k < _callbacks[n].length; k++)
							_callbacks[n][k]();
					return;
				}
				
				_attrs = response.Result;
				for (var n in _callbacks)
					for (var k = 0; k < _callbacks[n].length; k++)
						_callbacks[n][k](_attrs[n]);
			});
		}
	};
}
nsGmx.LazyAttributeValuesProviderFromServer.prototype = new nsGmx.ILazyAttributeValuesProvider();

})();
//event: change
nsGmx.ShpEncodingWidget = function()
{
    var _encodings = {
        'windows-1251': 'windows-1251',
        'utf-8': 'utf-8',
        'koi8-r': 'koi8-r',
        'utf-7': 'utf-7',
        'iso-8859-5': 'iso-8859-5',
        'koi8-u': 'koi8-u',
        'cp866': 'cp866'
        
    };
    var _DEFAULT_ENCODING = 'windows-1251';
    var _curEncoding = _DEFAULT_ENCODING;
    var _this = this;
    
    this.drawWidget = function(container, initialEncoding)
    {
        initialEncoding = initialEncoding || _DEFAULT_ENCODING;
        var select = $("<select></select>").addClass('selectStyle VectorLayerEncodingInput');
        select.change(function()
        {
            _curEncoding = $('option:selected', select).val();
            $(_this).change();
        });
        
        var isStandard = false;
        for (var enc in _encodings)
        {
            var opt = $('<option></option>').val(enc).text(enc);
            
            if (_encodings[enc] === initialEncoding)
            {
                opt.attr('selected', 'selected');
                _curEncoding = enc;
                isStandard = true;
            }
                
            select.append(opt);
        }
        
        var anotherCheckbox = $("<input></input>", {'class': 'box', type: 'checkbox', id: 'otherEncoding'});
        var anotherInput = $("<input></input>", {'class': 'VectorLayerEncodingInput'});
        
        if (!isStandard)
        {
            anotherCheckbox[0].checked = 'checked';
            anotherInput.val(initialEncoding);
            select.attr('disabled', 'disabled');
        }
        else
        {
            anotherInput.attr('disabled', 'disabled');
        }
        
        anotherInput.bind('keyup', function()
        {
            _curEncoding = this.value;
            $(_this).change();
        });
        
        anotherCheckbox.click(function()
        {
            if (this.checked)
            {
                select.attr('disabled', 'disabled');
                anotherInput.removeAttr('disabled');
                anotherInput.focus();
                _curEncoding = anotherInput.val();
            }
            else
            {
                select.removeAttr('disabled');
                anotherInput.attr('disabled', 'disabled');
                _curEncoding = $('option:selected', select).val();
            }
            $(_this).change();
        });
        
        
        var tr1 = $("<tr></tr>")
            .append($("<td></td>").text(_gtxt("Кодировка")))
            .append($("<td></td>").append(select));
            
        var tr2 = $("<tr></tr>")
            .append($("<td></td>").append(anotherCheckbox).append($("<label></label>", {'for': 'otherEncoding'}).text(_gtxt("Другая"))))
            .append($("<td></td>").append(anotherInput));
        
        $(container)
            .append($("<table></table>", {'class': 'VectorLayerEncoding'})
                .append(tr1).append(tr2));
    }
    
    this.getServerEncoding = function()
    {
        return _curEncoding;
    }
};
/** Менеджер дополнительных данных карты. Данные собираются и используются набором сборщиков данных, каждый из которых имеет свой уникальный id.
 @class userObjectsManager
 @memberOf nsGmx 
*/
nsGmx.userObjectsManager = {
    _data: {},
    _collectors: {},
    
    /**
     Устанавливает данные, которые потом могут быть использованы поставщиками данных
	 @method
    */
    setData: function(data) {
        this._data = data;
    },
    
    /**
     Возвращает собранные данные
	 @method
    */
    getData: function() {
        return this._data;
    },
    
	/**
	 Собирает данные со всех сборщиков данных. Собранные данные доступны через метод getData
	 @method
	*/
    collect: function() {
        for (var id in this._collectors) {
            if ('collect' in this._collectors[id]) {
                var data = this._collectors[id].collect();
                if (data !== null) {
                    this._data[id] = data;
                }
            }
        }
    },
    
    /**
	 Вызывает метод load() у всех поставщиков данных, для которых есть данные.
     После вызова метода данные для данного загрузчика будут удалены (чтобы предотвратить множественную загрузку)
	 @method
	*/
    load: function(dataCollectorNames) {
        var collectors = {};
        
        if (dataCollectorNames)
        {
            if (typeof dataCollectorNames === 'string')
                dataCollectorNames = [dataCollectorNames];

            for (var dc = 0; dc < dataCollectorNames.length; dc++)
            {
                var name = dataCollectorNames[dc];
                if (name in this._collectors)
                    collectors[name] = this._collectors[name];
            }
        }
        else
            collectors = this._collectors;
        
        for (var id in collectors) {
            if (id in this._data && 'load' in collectors[id])
            {
                collectors[id].load(this._data[id]);
                delete this._data[id];
            }
        }
    },
    
    /**
	 Добавляет новый сборщик данных. Если в момент добавления есть какие-нибудь данные для загрузчика, они будут ему сразу же переданы
	 @method
     @param collectorId {String} - уникальный идентификатор сборщика данных
     @param collector {Object} - сборщик данных. Должен иметь следующие методы:<br/>
         collect()->Object - возвращает собранные данные. Если данных нет, нужно вернуть null
         load(data)->void - передаёт существующие данные загрузчику
	*/
    addDataCollector: function( collectorId, collector ) {
        this._collectors[collectorId] = collector;
        if (collectorId in this._data && 'load' in collector)
        {
            collector.load(this._data[collectorId])
            delete this._data[collectorId];
        }
    }
}
//Отображение закладок карты в левой панели

//TODO: сделать глобально доступным
nsGmx.Controls = nsGmx.Controls || {};
nsGmx.Controls.LanguageSelector = function(container, defLang) {

    var LANGUAGES = [
            {lang: 'rus', title: 'rus'},
            {lang: 'eng', title: 'eng'}
        ],
        lang = null,
        _this = this;

    var template = Handlebars.compile('<div class = "language-container">' +
        '{{#langs}}' +
            '<span data-lang = "{{lang}}" class="language-item">{{title}}</span>' +
        '{{/langs}}' +
    '</div>');

    $(container).empty().append($(template({langs: LANGUAGES})));

    var update = function() {
        var newLang = $(this).data('lang'),
            prevLang = lang;

        if (newLang !== prevLang) {
            lang = newLang;
            $(this).addClass('language-selected')
                .siblings().removeClass('language-selected');
            $(_this).trigger('change', [prevLang, newLang]);
        }
    }

    $(container).find('span').click(update);
    update.bind($(container).find('span')[0])();

    this.getLang = function() {return lang;};
}

var queryTabs = function()
{
	this.builded = false;

	this.tabsCanvas = null;

	this.tabs = [];
}

queryTabs.prototype = new leftMenu();

queryTabs.prototype.load = function()
{
	if (!this.builded)
	{
		var _this = this;
		this.tabsCanvas = _div(null, [['dir','className','tabsCanvas']])

		this.workCanvas.appendChild(this.tabsCanvas);

		for (var i = 0; i < this.tabs.length; i++)
			this.draw(this.tabs[i]);

		this.builded = true;

		$(this.tabsCanvas).sortable({
			axis: 'y',
			tolerance: 'pointer',
			containment: 'parent'
		});
		$(this.tabsCanvas).bind('sortupdate', function(event, ui)
		{
			var orderedTabs = [];
			$(_this.tabsCanvas).children().each(function()
			{
				orderedTabs.push(this.tabInfo);
			})

			_this.tabs = orderedTabs;
		});

        this.leftPanelItem.hide();
	}
}

queryTabs.prototype.add = function(tabInfo, tabIndex)
{
    var isNew = typeof tabIndex === 'undefined';
    tabInfo = tabInfo || {
        name_rus: '',
        description_rus: '',
        name_eng: '',
        description_eng: ''
    };

    if (typeof tabInfo.name_rus === 'undefined') {
        tabInfo.name_rus = tabInfo.name;
    }

    if (typeof tabInfo.description_rus === 'undefined') {
        tabInfo.description_rus = tabInfo.description;
    }

    var uiTemplate = Handlebars.compile(
        '<div class = "addtabs-container">' +
            '<div class = "addtabs-info">{{i "Название"}}</div>' +
            '<input class = "addtabs-title-input inputStyle" value="{{title}}"><br>' +
            '<div class = "addtabs-info">{{i "Описание"}}</div>' +
            '<textarea class = "addtabs-title-description inputStyle">{{description}}</textarea><br>' +
            '<button class = "addtabs-create">{{buttonTitle}}</button>' +
            '<div class = "addtabs-lang-placeholder"></div>' +
        '</div>');


    var titleLoc = {rus: tabInfo.name_rus, eng: tabInfo.name_eng};
    var descrLoc = {rus: tabInfo.description_rus, eng: tabInfo.description_eng};
    var ui = $(uiTemplate({
            title: titleLoc.rus,
            description: descrLoc.rus,
            buttonTitle: isNew ? _gtxt('Создать') : _gtxt('Изменить')
        })),
        titleInput = $('.addtabs-title-input', ui);

    var updateDataLoc = function(lang) {
        titleLoc[lang] = titleInput.val();
        descrLoc[lang] = $('.addtabs-title-description', ui).val();
    }

    var langControl = new nsGmx.Controls.LanguageSelector(ui.find('.addtabs-lang-placeholder'));
    $(langControl).change(function(event, prevLang, newLang) {
        updateDataLoc(prevLang);
        titleInput.val(titleLoc[newLang]);
        $('.addtabs-title-description', ui).val(descrLoc[newLang]);
    })

    titleInput.keyup(function(e) {
        $(this).toggleClass('error', this.value == '');

        if (e.keyCode == 13)
        {
			createTab();
	  		return false;
	  	}

		return true;
    });

    titleInput.focus();

	var createTab = function() {
            updateDataLoc(langControl.getLang());
            var mapState = _mapHelper.getMapState(),
                tab = {
                    name: titleLoc.rus || titleLoc.eng,
                    description: descrLoc.rus || descrLoc.eng,

                    name_rus: titleLoc.rus,
                    description_rus: descrLoc.rus,
                    name_eng: titleLoc.eng,
                    description_eng: descrLoc.eng,

                    state: mapState
                };

            if (isNew) {
            _this.tabs.push(tab);
            } else {
                _this.tabs[tabIndex] = tab;
            }
            _this.draw(tab, tabIndex);

            removeDialog(dialogDiv);
        },
        _this = this;

    $('.addtabs-create', ui).click(createTab);

	var dialogDiv = showDialog(_gtxt("Имя закладки"), ui[0], 280, 230, false, false);
}

queryTabs.prototype.draw = function (tabInfo, tabIndex)
{
    var selectValLoc = function(paramName) {
        var lang = nsGmx.Translations.getLanguage();
        return tabInfo[paramName + '_' + lang] || tabInfo[paramName];
    }

    var tmpl = Handlebars.compile('<div class="canvas">' +
        '<div class="buttonLink tabName" title="{{description}}">{{name}}</div>' +
        '<div class="gmx-icon-edit"></div>' +
        '<div class="gmx-icon-close"></div>' +
    '</div>');


    var canvas = $(tmpl({
            name: selectValLoc('name'),
            description: selectValLoc('description')
        }))[0];
    var _this = this;

	canvas.tabInfo = tabInfo;

    $('.tabName', canvas).click(this.show.bind(this, tabInfo.state));

    $('.gmx-icon-close', canvas).click(function() {
		var index = getOwnChildNumber(canvas);

		_this.tabs.splice(index, 1);

		canvas.removeNode(true);
	})

    $('.gmx-icon-edit', canvas).click(function() {
        var index = getOwnChildNumber(canvas);
        _this.add(_this.tabs[index], index);
    }).toggle(_queryMapLayers.currentMapRights() === "edit");

    if (typeof tabIndex === 'undefined') {
        $(this.tabsCanvas).append(canvas);
    } else {
        $(this.tabsCanvas).find('.canvas').eq(tabIndex).replaceWith(canvas);
    }
}

queryTabs.prototype.show = function(state)
{
	var parsedState = {},
        lmap = nsGmx.leafletMap,
        gmxDrawing = lmap.gmxDrawing;

	$.extend(true, parsedState, state);
    var pos = parsedState.position;

    lmap.setView(L.Projection.Mercator.unproject(L.point(pos.x, pos.y)), 17 - pos.z);

    for (var i = 0; i < state.drawnObjects.length; i++)
    {
        parsedState.drawnObjects[i].geometry = L.gmxUtil.geometryToGeoJSON(state.drawnObjects[i].geometry, true);
    }

    lmap.gmxBaseLayersManager.setCurrentID(lmap.gmxBaseLayersManager.getIDByAlias(parsedState.mode));

    //удаляем все фичи
    gmxDrawing.getFeatures().slice(0).forEach(gmxDrawing.remove.bind(gmxDrawing));

	for (var i = 0; i < parsedState.drawnObjects.length; i++)
	{
        //старый формат - число, новый - строка
		var rawColor = parsedState.drawnObjects[i].color,
            color = (typeof rawColor === 'number' ? '#' + L.gmxUtil.dec2hex(rawColor) : rawColor) || '#0000FF',
			thickness = parsedState.drawnObjects[i].thickness || 2,
			opacity = parsedState.drawnObjects[i].opacity || 80;

        gmxDrawing.addGeoJSON(parsedState.drawnObjects[i].geometry, {
            lineStyle: {
                color: color,
                weight: thickness,
                opacity: opacity/100
            }
        });
	}

	_queryMapLayers.applyState(parsedState.condition, parsedState.mapStyles);

    if (typeof parsedState.customParamsCollection !== 'undefined')
        _mapHelper.customParamsManager.loadParams(parsedState.customParamsCollection);

    if (parsedState.openPopups) {
        for (var l in parsedState.openPopups) {
            var layer = nsGmx.gmxMap.layersByID[l];
            if (layer && layer.addPopup) {
                parsedState.openPopups[l].forEach(layer.addPopup.bind(layer));
            }
        }
    }
}

var _queryTabs = new queryTabs();

nsGmx.userObjectsManager.addDataCollector('tabs', {
    collect: function()
    {
        if (!_queryTabs.tabs.length)
            return null;

        var tabs = [];

        for (var i = 0; i < _queryTabs.tabs.length; i++)
        {
            var tab = {};

            $.extend(tab, _queryTabs.tabs[i]);

            tabs.push(tab);
        }

        return tabs;
    },
    load: function(data)
    {
        if (!data || !data.length)
            return;

        $('#left_mapTabs').remove();

        _queryTabs.builded = false;
        _queryTabs.tabs = data;

        mapHelp.tabs.load('mapTabs');
    }
})

//Загрузка и отображение дополнительных карт в левой панели
!(function(_) {
    
var queryExternalMaps = function()
{
	this.maps = [];
	this.loadedMaps = {};
}

queryExternalMaps.prototype = new leftMenu();

queryExternalMaps.prototype.load = function()
{
	if (!this.builded)
	{
		var hostButton = _input(null, [['dir','className','inputStyle'],['css','width','200px']]),
			nameButton = _input(null, [['dir','className','inputStyle'],['css','width','200px']]),
			loadButton = makeButton(_gtxt("Загрузить")),
			addMap = makeLinkButton(_gtxt("Добавить карту")),
			paramsTable = _table([_tbody([_tr([_td([_t(_gtxt("Хост"))],[['css','colSpan',2],['css','paddingTop','3px']])]),
											_tr([_td([hostButton]), _td()]),
											_tr([_td([_t(_gtxt("Имя"))],[['css','colSpan',2]])]),
											_tr([_td([nameButton]), _td([loadButton])])])],[['css','margin','3px 0px 0px 10px']]),
			_this = this;
		
		_(this.workCanvas, [_div([addMap],[['css','margin','5px 0px 5px 10px']]), paramsTable]);
		
		paramsTable.style.display = 'none';
		
		hostButton.value = window.serverBase;
		
		addMap.onclick = function()
		{
			if (paramsTable.style.display == 'none')
				paramsTable.style.display = '';
			else
				paramsTable.style.display = 'none';
		}
		
		loadButton.onclick = function()
		{
			if (hostButton.value == '')
				inputError(hostButton);
			
			if (nameButton.value == '')
				inputError(nameButton);
			
			if (hostButton.value == '' || nameButton.value == '')
				return;
			
			_this.addMapElem(hostButton.value, nameButton.value);
			
			nameButton.value = '';
		}

		this.mapsCanvas = _div(null,[['dir','className','drawingObjectsCanvas externalMapsCanvas'],['css','paddingLeft','0px'], ['attr', 'id', 'externalMapsCanvas']]);
		
		_(this.workCanvas, [this.mapsCanvas]);
		
		this.builded = true;
        
		for (var i = 0; i < this.maps.length; ++i)
			this.addMapElem(this.maps[i].hostName, this.maps[i].mapName, true);
	}
}

queryExternalMaps.prototype.addMapElem = function(hostName, mapName, silent)
{
    this.createWorkCanvas('externalMaps');
    this.load();
    
	var mapElem = _div(),
		div = _div(null, [['css','position','relative'],['css','margin','2px 0px 2px 14px']]),
		remove = $('<div class="gmx-icon-close"></div>'),
        mapInfo,
        _this = this;
	
    for (var i = 0; i < this.maps.length; i++) {
        var map = this.maps[i];
        if (map.hostName === hostName && map.mapName === mapName) {
            if (map.container) {
                return;
            }
            mapInfo = map;
            break;
        }
    }
    
    if (!mapInfo) {
        mapInfo = {
            hostName: hostName,
            mapName: mapName
        }
        this.maps.push(mapInfo);
    }
    
    mapInfo.container = div
	
	div.hostName = hostName;
	div.mapName = mapName;
	
	_(div, [mapElem, remove[0]]);
	_(this.mapsCanvas, [div]);
	
	this.addMap(hostName, mapName, mapElem, silent);
	
	remove.click(function()
	{
		div.removeNode(true);
		
		if (!mapElem.extLayersTree)
			return;
		
		mapElem.extLayersTree.treeModel.forEachLayer(function(layer, isVisible) 
		{
			var name = layer.properties.name;
			
			if (nsGmx.layersByID[name].external)
				_queryMapLayers.removeLayer(name);
		});
        
        for (var i = 0; i < _this.maps.length; i++) {
            var map = _this.maps[i];
            if (map.hostName === hostName && map.mapName === mapName) {
                _this.maps.splice(i, 1);
                break;
            }
        }
	})
}

queryExternalMaps.prototype.addMap = function(hostName, mapName, parent, silent)
{
	var loading = _div([_img(null, [['attr','src','img/progress.gif'],['css','marginRight','10px'],['css','width','16px'],['css','height','16px']]), _t(_gtxt('загрузка...'))], [['css','margin','3px 0px 3px 20px']]),
		_this = this;

	_(parent, [loading]);
	
	this.loadMap(hostName, mapName, function(gmxMap)
	{
		if (gmxMap == null)
		{
			loading.parentNode.parentNode.removeNode(true);
			
			silent || showErrorMessage(_gtxt("Невозможно загрузить карту [value0] с домена [value1]", mapName, hostName), true);
			
			return;
		}
		
        var extLayersTree = new layersTree({showVisibilityCheckbox: true, allowActive: false, allowDblClick: true});
		
		var	tree = extLayersTree.drawTree(gmxMap.rawTree, 2);
		$(tree).treeview();
		extLayersTree.runLoadingFuncs();
        
		loading.removeNode(true);
		_(parent, [tree]);
        
        //добавляем перетаскивание в основную карту только если доп. карта с того же домена
        if ( hostName === _layersTree.treeModel.getMapProperties().hostName )
            _queryMapLayers.addDraggable(parent);
		
		parent.extLayersTree = extLayersTree;
	});
}

queryExternalMaps.prototype.loadMap = function(hostName, mapName, callback)
{
    var _this = this;
	L.gmx.loadMap(mapName, {hostName: hostName, leafletMap: nsGmx.leafletMap, apiKey: window.apiKey, isGeneralized: 'isGeneralized' in window ? window.isGeneralized : true}).then(function(gmxMap)
	{
        for (var i = 0; i < gmxMap.layers.length; i++) {
            var layer = gmxMap.layers[i];
            var id = layer.getGmxProperties().name;
            
            layer.external = true;
            
            if (!(id in nsGmx.gmxMap.layersByID)) {
                nsGmx.gmxMap.addLayer(layer);
            }
        }

        if (gmxMap.properties.Copyright)
        {
            var copyrightLayer = {
                options: {
                    attribution: gmxMap.properties.Copyright
                },
                onAdd: function() {},
                onRemove: function() {}
            }
            
            copyrightLayer.addTo(nsGmx.leafletMap);
        }
        
        gmxMap.properties.hostName = hostName;
        
        callback(gmxMap);
        $(_queryExternalMaps).triggerHandler('map_loaded', gmxMap);
        
        for (var i = 0; i < _this.maps.length; i++) {
            var map = _this.maps[i];
            if (map.hostName === hostName && map.mapName === mapName) {
                map.tree = layers;
                break;
            }
        }
	}, 
	function()
	{
		callback(null);
		$(_queryExternalMaps).triggerHandler('map_loaded', null);
	});
}

var _queryExternalMaps = new queryExternalMaps();
window._queryExternalMaps = _queryExternalMaps;

nsGmx.userObjectsManager.addDataCollector('externalMaps', {
    collect: function()
    {
        if (!_queryExternalMaps.workCanvas)
            return;
        
        var value = [];
        
        $(_queryExternalMaps.workCanvas.lastChild).children("div").each(function()
        {
            value.push({hostName:this.hostName, mapName:this.mapName})
        })
        
        if (!value.length)        
            return null;
        
        return value;
    },
    load: function(data)
    {
        if (!data || !data.length)
            return;
        
        $('#left_externalMaps').remove();
        
        _queryExternalMaps.builded = false;
        _queryExternalMaps.maps = data;
        
        mapHelp.externalMaps.load('externalMaps');
    }
});

})(nsGmx.Utils._);
var pointsBinding = 
{
	pointsBinding: {}
}

var queryBinding = function()
{
	this.conf = false;
	
	this.imgPoints = [],
	this.mapPoints = [],
	this.mapPointsFlags = [0,0,0,0],
	this.parentImage = null;
	this.toggle = null;
	
	this.dx = -7;
	this.dy = -26;
	
	this.loadTimer = null;
	
	this.imgDialog = null;
}

queryBinding.prototype = new leftMenu();

queryBinding.prototype.load = function()
{
	this.parentImage = globalFlashMap.rasters.addObject();
	
	for (var i = 0; i < 4; i++)
	{
		this.mapPoints[i] = globalFlashMap.addObject({type:'POINT', coordinates: [0, 0]});
	  	this.mapPoints[i].setStyle({marker: {image: "img/" + (i + 1) + "u.png", dx: this.dx, dy: this.dy}},{marker: {image: "img/" + (i + 1) + "uh.png", dx: this.dx, dy: this.dy}});
		this.mapPoints[i].setVisible(false);
	}
	
	var _this = this;
	
	for (var i = 0; i < 4; i++)
	{
		(function(i)
		{
	    	_this.mapPoints[i].setHandler('onMouseDown', function()
	    	{
	    		var draggedPoint = _this.mapPoints[i];
	    		var dx = draggedPoint.getGeometry().coordinates[0] - globalFlashMap.getMouseX();
	    		var dy = draggedPoint.getGeometry().coordinates[1] - globalFlashMap.getMouseY();

				globalFlashMap.freeze();
				globalFlashMap.setHandler('onMouseMove', function()
				{
					draggedPoint.setPoint(globalFlashMap.getMouseX() + dx, globalFlashMap.getMouseY() + dy);
					
					if (_this.getConformity(true))
						_this.drawConformity();
				});
	    	});
	    	_this.mapPoints[i].setHandler('onMouseUp', function()
	    	{
	    		globalFlashMap.unfreeze();
				globalFlashMap.setHandler('onMouseMove', null);
	    	});
    	})(i)
	}
	
	this.workArea = _div(null,[['dir','className','workArea']]);
	this.imgCanvas = _img(null, [['css','display','none']]);
	
	_(this.workArea, [this.imgCanvas]);
	
	var formFile = _form(null,[['attr','enctype','multipart/form-data'],['dir','method','post'],['dir','action', getAPIHostRoot() + 'imgSave.ashx?WrapStyle=window'],['attr','target','pictureBinding_iframe']]);
	formFile.style.width = '220px';
	_(formFile, [_input(null,[['attr','type','hidden'],['attr','name','id'],['dir','className','inputStyle'], ['attr','value','pictureBinding' + Math.random()]])]);

	var attach = _input(null,[['attr','type','file'],['dir','name','rawdata'],['attr','size',25]]);
	_(formFile, [attach]);
	
	var loadButton = makeButton(_gtxt("Загрузить"));
	loadButton.onclick = function()
	{
		var iframe = createPostIframe("pictureBinding_iframe", function(response)
		{
			if (!parseResponse(response))
				return;
			
			reloadButton.disabled = false;
			
			_this.showPictureDialog();
			
			_this.reloadImg(response.Result)
		});
		
		_(document.body, [iframe]);
		
		formFile.firstChild.setAttribute('value','pictureBinding' + Math.random())
		formFile.submit();
	}
	
	_(this.workCanvas, [_table([_tbody([_tr([_td([formFile]), _td([loadButton])])])],[['css','margin','10px 0px 5px 20px']])]);
		
	var imgTds = [],
		mapTds = [];
	
	this.workArea.imgLeft = 0;
	this.workArea.imgTop = 0;
		
	for (var i = 0; i < 4; i++)
	{
		(function(i)
		{
			var imgPoint = _div(null, [['dir','className','imgBoundingPoint'],['css','position','absolute']]);
			
			imgPoint.style.marginLeft = _this.dx + 'px';
			imgPoint.style.marginTop = _this.dy + 'px';
			
			$(imgPoint).draggable(
			{
				containment: _this.workArea,
				drag: function(ev, ui)
				{
					var pos = _this.getImgPosition();
					
					imgPoint.beginLeft = ui.absolutePosition.left - _this.workArea.imgLeft - pos.left,
					imgPoint.beginTop = ui.absolutePosition.top - _this.workArea.imgTop - pos.top;
					
					if (_this.getConformity(true))
						_this.drawConformity();
				}
			})
			
			imgPoint.style.left = '-500px';
			imgPoint.style.top = '-500px';
			
			imgPoint.beginLeft = -500;
			imgPoint.beginTop = -500;
			
			imgPoint.style.display = 'none';

			_(_this.workArea, [imgPoint]);
				
			_this.imgPoints.push(imgPoint);
			
			var imgHelperPoint = _div(null, [['dir','className','imgHelperPoint']])
			imgHelperPoint.onclick = function()
			{
				imgPoint.style.left = Math.floor(_this.getImgWidth() / 2) + 'px';
				imgPoint.style.top = Math.floor(_this.getImgHeight() / 2) + 'px';
				
				imgPoint.beginLeft = Math.floor(_this.getImgWidth() / 2) - _this.workArea.imgLeft;
				imgPoint.beginTop = Math.floor(_this.getImgHeight() / 2) - _this.workArea.imgTop;
				
				imgPoint.style.display = '';
			}
			
			imgTds.push(_td([imgHelperPoint]));
			
			var mapHelperPoint = _div(null, [['dir','className','imgHelperPoint']])
			mapHelperPoint.onclick = function(e)
			{
				_this.mapPoints[i].setGeometry({type:'POINT', coordinates: [globalFlashMap.getX(),globalFlashMap.getY()]})
				
				_this.mapPoints[i].setVisible(true);
				
				_this.mapPointsFlags[i] = 1;
			}
			
			mapTds.push(_td([mapHelperPoint]));
			
			imgHelperPoint.style.backgroundImage = "url(img/" + (i + 1) + "i.png)";
			mapHelperPoint.style.backgroundImage = "url(img/" + (i + 1) + "i.png)";
			imgPoint.style.backgroundImage = "url(img/" + (i + 1) + "u.png)";
			
			imgPoint.onmouseover = function()
			{
				imgPoint.style.backgroundImage = "url(img/" + (i + 1) + "uh.png)";
			}
			imgPoint.onmouseout = function()
			{
				imgPoint.style.backgroundImage = "url(img/" + (i + 1) + "u.png)";
			}
		})(i)
	}
	
	_(this.workCanvas, [_div([_table([_tbody([_tr([_td([_t(_gtxt('Точки на изображении:'))],[['css','width','150px'],['css','fontSize','12px']])].concat(imgTds))])],[['css','margin','5px 0px 0px 20px']])]),
						  _div([_table([_tbody([_tr([_td([_t(_gtxt('Точки на карте:'))],[['css','width','150px'],['css','fontSize','12px']])].concat(mapTds))])],[['css','margin','5px 0px 0px 20px']])])]);
	
	var drawButton = makeButton(_gtxt('Нарисовать'))
	drawButton.onclick = function()
	{
		if (_this.getConformity())
			_this.drawConformity();
	}
	
	var reloadButton = makeButton(_gtxt("Восстановить"))
	reloadButton.onclick = function()
	{
		$(_this.imgDialog).dialog('open')
	}
	
	if (!this.imgLoaded)
		reloadButton.disabled = true;
	
	this.toggle = _input(null, [['attr','type','checkbox'],['dir','className','box']])
	this.toggle.onclick = function()
	{
		if (_this.parentImage)
			_this.parentImage.setVisible(this.checked);
	}
	
	var tempStyle = typeof this.tempStyle != 'undefined' ? this.tempStyle : {fill: {opacity: 100}};
	
	this.slider = nsGmx.Controls.createSlider(typeof this.tempStyle != 'undefined' ? _this.tempStyle.fill.opacity : 100, 
		function(event, ui)
		{
			if (_this.parentImage)
			{
				tempStyle.fill.opacity = ui.value;
				_this.tempStyle = tempStyle;
				
				_this.parentImage.setStyle(tempStyle);
			}
		});
	
	var table = _table([_tbody([_tr([_td([_t(_gtxt("Видимость"))],[['css','width','100px'],['css','fontSize','12px']]),_td([this.toggle])]),
								_tr([_td([_t(_gtxt("Прозрачность"))],[['css','fontSize','12px']]), _td([this.slider])])])], [['css','margin','15px 0px 10px 0px']])
	
	_(this.workCanvas, [_div([_table([_tbody([_tr([_td([drawButton],[['css','paddingRight','15px']]),_td([reloadButton])])])]), table],[['css','padding','15px 0px 0px 20px']])]);
}

queryBinding.prototype.getImgWidth = function()
{
	return this.workArea.clientWidth;
}
queryBinding.prototype.getImgHeight = function()
{
	return this.workArea.clientHeight;
}
queryBinding.prototype.getImgPosition = function()
{
	return getOffsetRect(this.workArea);
}

queryBinding.prototype.showPictureDialog = function()
{
	if (this.imgDialog)
	{
		$(this.imgDialog).dialog('destroy');
		
		this.imgDialog.removeNode(true);
	}
	
	var canvas = _div([this.workArea]);
	
	showDialog(_gtxt("Привязка изображения"), canvas, 400, 400, 310, 35, null, function(){return true});
	
	this.imgDialog = canvas.parentNode;
}

queryBinding.prototype.reloadImg = function(id)
{
	var img = _img(null, [['attr','src',getAPIHostRoot() + 'imgSave.ashx?id=' + id]]),
		_this = this;
	
	img.onload = function()
	{
		img.style.width = img.width + 'px';
		img.style.height = img.height + 'px';
	}
	
	$(img).draggable(
	{
		cursor: 'crosshair',
		drag: function(ev,ui)
		{
			for (var i = 0; i < 4; i++)
			{
				var imgPoint = _this.imgPoints[i];
				
				var left = imgPoint.beginLeft + ui.position.left,
					top = imgPoint.beginTop + ui.position.top;
				
				imgPoint.style.left = left + 'px';
				imgPoint.style.top = top + 'px';
				
				if (top < 0 ||
					top > _this.getImgHeight() ||
					left < 0 ||
					left > _this.getImgWidth())
					imgPoint.style.display = 'none';
				else
					imgPoint.style.display = '';
			}
			
			_this.workArea.imgLeft = ui.position.left;
			_this.workArea.imgTop = ui.position.top;
		}
	});
	
	$(this.imgCanvas).replaceWith(img);
	
	this.imgCanvas = img;
	
	this.workArea.imgLeft = 0;
	this.workArea.imgTop = 0;
	
	delete this.tempStyle;
	
	for (var i = 0; i < 4; i++)
	{
		var imgPoint = this.imgPoints[i];
			
		imgPoint.style.left = '-500px';
		imgPoint.style.top = '-500px';
		
		imgPoint.beginLeft = -500;
		imgPoint.beginTop = -500;
		
		imgPoint.style.display = 'none';
	}
}

queryBinding.prototype.unload = function()
{
/*	if (this.parentImage)
		this.parentImage.setVisible(false);*/
	if (this.mapPoints && this.mapPoints[0])
		this.mapPoints[0].setVisible(false);
	if (this.mapPoints && this.mapPoints[1])
		this.mapPoints[1].setVisible(false);
	if (this.mapPoints && this.mapPoints[2])
		this.mapPoints[2].setVisible(false);
	
	if (this.imgDialog)
	{
		$(this.imgDialog).dialog("destroy")
			
		this.imgDialog.removeNode(true);
	}
}
queryBinding.prototype.reload = function()
{
/*	if (this.parentImage)
		this.parentImage.setVisible(true);*/
	if (this.mapPoints && this.mapPoints[0])
		this.mapPoints[0].setVisible(true);
	if (this.mapPoints && this.mapPoints[1])
		this.mapPoints[1].setVisible(true);
	if (this.mapPoints && this.mapPoints[2])
		this.mapPoints[2].setVisible(true);
}

queryBinding.prototype.getConformity = function(skipMessage)
{
	this.conf = false;
	
	for (var i = 0; i < 4; i++)
	{
		var imgPoint = this.imgPoints[i],
			conformity = {};
		
		if (imgPoint.beginLeft < 0 ||
			imgPoint.beginLeft > this.imgCanvas.clientWidth ||
			imgPoint.beginTop < 0 ||
			imgPoint.beginTop > this.imgCanvas.clientHeight)
		{
			if (typeof skipMessage != 'undefined' && !skipMessage)
				showErrorMessage(_gtxt("$$phrase$$_2", i + 1), true)
			
			return false;
		}
		
		conformity.x = imgPoint.beginLeft;
		conformity.y = imgPoint.beginTop;
		
		if (!this.mapPointsFlags[i])
		{
			if (typeof skipMessage != 'undefined' && !skipMessage)
				showErrorMessage(_gtxt("$$phrase$$_3", i + 1), true)
			
			return false;
		}
		
		conformity.lat = this.mapPoints[i].getGeometry().coordinates[0];
		conformity.lon = this.mapPoints[i].getGeometry().coordinates[1];
		
		if (!this.conf)
			this.conf = [];
		
		this.conf.push(conformity)
	}
	
	return true;
}

queryBinding.prototype.drawConformity = function()
{
	this.parentImage.setImage(this.imgCanvas.getAttribute('src'), 	this.conf[0].x, this.conf[0].y,
																	this.conf[1].x, this.conf[1].y,
																	this.conf[2].x, this.conf[2].y,
																	this.conf[3].x, this.conf[3].y,
																	this.conf[0].lat, this.conf[0].lon,
																	this.conf[1].lat, this.conf[1].lon,
																	this.conf[2].lat, this.conf[2].lon,
																	this.conf[3].lat, this.conf[3].lon)
	
	this.parentImage.setVisible(true);
	
	this.parentImage.setStyle({fill: {opacity: $(this.slider).slider('option', 'value')}});
	
	this.toggle.checked = true;
}

var _queryBinding = new queryBinding();

pointsBinding.pointsBinding.load = function()
{
	var alreadyLoaded = _queryBinding.createWorkCanvas(arguments[0], _queryBinding.unload);
	
	if (!alreadyLoaded)
		_queryBinding.load();
	else
		_queryBinding.reload();
}
pointsBinding.pointsBinding.unload = function()
{
	_queryBinding.unload();
}


!(function(_) {

var mapLayers =
{
	mapLayers:{}
}

window.mapLayers = mapLayers;

AbstractTree = function()
{
}

AbstractTree.prototype.makeSwapChild = function()
{
	var div = _div(null, [['attr','swap',true],['dir','className','swap'],['css','fontSize','0px']]);

	return div;
}

AbstractTree.prototype.getChildsUl = function(node)
{
	var ul = $(node).children("ul");

	if (ul.length > 0)
		return ul[0];
	else
		return false;
}

AbstractTree.prototype.toggle = function(box)
{
	box.onclick = function()
	{
		$(this.parentNode)
			.find(">.hitarea")
				.swapClass('collapsable-hitarea', 'expandable-hitarea')
				.swapClass('lastCollapsable-hitarea', 'lastExpandable-hitarea')
			.end()
			.swapClass('collapsable', 'expandable')
			.swapClass('lastCollapsable', 'lastExpandable')

		if ($(this.parentNode).hasClass('expandable') || $(this.parentNode).hasClass('lastExpandable'))
			hide(_abstractTree.getChildsUl(this.parentNode))
		else
			show(_abstractTree.getChildsUl(this.parentNode))
	}
}
AbstractTree.prototype.addNode = function(node, newNodeCanvas)
{
	var childsUl = _abstractTree.getChildsUl(node);

	if (childsUl)
		childsUl.insertBefore(newNodeCanvas, childsUl.firstChild)
	else
	{
		// если первый потомок
		var newSubTree = _ul([newNodeCanvas]);
		//_(node, [newSubTree, this.makeSwapChild()]);
		node.insertBefore(newSubTree, node.lastChild)

		newSubTree.loaded = true;

		var div = _div(null, [['dir','className','hitarea']]);

		if ($(node).hasClass("last"))
		{
			$(div).addClass('lastCollapsable-hitarea collapsable-hitarea');
			$(node).addClass('lastCollapsable');
		}
		else
		{
			$(div).addClass('collapsable-hitarea');
			$(node).addClass('collapsable');
		}

		this.toggle(div);

		node.insertBefore(div, node.firstChild);

		_layersTree.addExpandedEvents(node);

		if ($(newNodeCanvas).hasClass('collapsable'))
		{
			$(newNodeCanvas).addClass('lastCollapsable')
			$(newNodeCanvas).children('div.hitarea').addClass('lastCollapsable-hitarea')
		}
		if ($(newNodeCanvas).hasClass('expandable'))
		{
			$(newNodeCanvas).addClass('lastExpandable')
			$(newNodeCanvas).children('div.hitarea').addClass('lastExpandable-hitarea')
		}
		if (!$(newNodeCanvas).hasClass('lastCollapsable') && !$(newNodeCanvas).hasClass('lastExpandable'))
			$(newNodeCanvas).addClass('last');
	}

	$(_abstractTree.getChildsUl(node)).children(":not(li:last)").each(function()
	{
		$(this).removeClass('last').replaceClass('lastCollapsable', 'collapsable').replaceClass('lastExpandable', 'expandable');
		$(this).children('div.lastCollapsable-hitarea').replaceClass('lastCollapsable-hitarea', 'collapsable-hitarea');
		$(this).children('div.lastExpandable-hitarea').replaceClass('lastExpandable-hitarea', 'expandable-hitarea');
	})
}
AbstractTree.prototype.delNode = function(node, parentTree, parent)
{
	if (parentTree.childNodes.length == 0)
	{
		// потомков не осталось, удалим контейнеры
		parentTree.removeNode(true);
		parent.firstChild.removeNode(true);

		// изменим дерево родителя
		$(parent).removeClass("collapsable")
		$(parent).replaceClass("lastCollapsable","last")
	}
	else
	{
		// изменим дерево родителя
		if ($(parentTree).children("li:last").hasClass("collapsable"))
		{
			$(parentTree).children("li:last").addClass("lastCollapsable");

			$(parentTree).children("li:last").each(function()
				{
					$(this.firstChild).addClass("lastCollapsable-hitarea");
				})
		}
		else
			$(parentTree).children("li:last").addClass("last")
	}
}

AbstractTree.prototype.swapNode = function(node, newNodeCanvas)
{
	$(node).after(newNodeCanvas)

	$(node.parentNode).children(":not(li:last)").each(function()
	{
		$(this).removeClass('last').replaceClass('lastCollapsable', 'collapsable').replaceClass('lastExpandable', 'expandable');
		$(this).children('div.lastCollapsable-hitarea').replaceClass('lastCollapsable-hitarea', 'collapsable-hitarea');
		$(this).children('div.lastExpandable-hitarea').replaceClass('lastExpandable-hitarea', 'expandable-hitarea');
	})

	// изменим дерево родителя
	if ($(node.parentNode).children("li:last").hasClass("collapsable"))
	{
		$(node.parentNode).children("li:last").addClass("lastCollapsable");

		$(node.parentNode).children("li:last").each(function()
			{
				$(this.firstChild).addClass("lastCollapsable-hitarea");
			})
	}
	else if ($(node.parentNode).children("li:last").hasClass("expandable"))
	{
		$(node.parentNode).children("li:last").addClass("lastExpandable");

		$(node.parentNode).children("li:last").each(function()
			{
				$(this.firstChild).addClass("lastExpandable-hitarea");
			})
	}
	else
		$(node.parentNode).children("li:last").addClass("last")
}

var _abstractTree = new AbstractTree();
window._abstractTree = _abstractTree;

//renderParams:
//  * showVisibilityCheckbox {Bool} - показывать или нет checkbox видимости
//  * allowActive {Bool} - возможен ли в дереве активный элемент
//  * allowDblClick {Bool} - переходить ли по двойному клику к видимому экстенту слоя/группы
//  * showStyle {Bool} - показывать ли иконку стилей
//  * visibilityFunc {function(layerProps, isVisible)} - ф-ция, которая будет выполнена при изменении видимости слоя.
//    По умолчанию устанавливает видимость соответствующего слоя в API
//
//события:
//  * layerVisibilityChange - при изменении видимости слоя (параметр - элемент дерева с изменившимся слоем)
//  * addTreeElem - добавили новый элемент дерева (параметр - новый элемент)
//  * activeNodeChange - изменили активную ноду дерева (парамер - div активной ноды)
var layersTree = function( renderParams )
{
    this._renderParams = $.extend({
        showVisibilityCheckbox: true,
        allowActive: true,
        allowDblClick: true,
        showStyle: true,
        visibilityFunc: function(props, isVisible) {
            if (props.name in nsGmx.gmxMap.layersByID) {
                nsGmx.leafletMap[isVisible ? 'addLayer' : 'removeLayer'](nsGmx.gmxMap.layersByID[props.name]);
            }
        }
    }, renderParams);

	// тип узла
	this.type = null;

	// содержимое узла
	this.content = null;

	this.condition = {visible:{},expanded:{}};

	this.mapStyles = {};

	this.groupLoadingFuncs = [];

    this._treeCanvas = null; //контейнер отрисованного дерева слоёв

    this._layerViewHooks = [];
}

layersTree.prototype.addLayerViewHook = function(hook) {
    hook && this._layerViewHooks.push(hook);
}

layersTree.prototype._applyLayerViewHooks = function(div, layerProps) {
    this._layerViewHooks.forEach(function(hook) {
        hook(div, layerProps);
    })
}

// layerManagerFlag == 0 для дерева слева
// layerManagerFlag == 1 для списка слоев
// layerManagerFlag == 2 для списка карт

layersTree.prototype.drawTree = function(tree, layerManagerFlag)
{
	var permalinkParams = this.LayersTreePermalinkParams;

	if (permalinkParams) {
		var tempTree = new nsGmx.LayersTree(tree);

		tempTree.forEachNode(function(elem) {
			var props = elem.content.properties,
			id = elem.type == 'group' ? props.GroupID : props.LayerID;

			if (id in permalinkParams) {
				props.permalinkParams = permalinkParams[id];
			}
		});

		tree = tempTree.getRawTree();
	}

	this._treeCanvas = _ul([this.getChildsList(tree, false, layerManagerFlag, true)], [['dir','className','filetree']]);
    this.treeModel = new nsGmx.LayersTree(tree);
    this._mapTree = tree; //Устарело: используйте this.treeModel для доступа к исходному дереву

    this.treeModel.forEachLayer(function(layerContent, isVisible) {
        layerContent.properties.initVisible = layerContent.properties.visible;
    });

    var _this = this;
    $(this.treeModel).on('nodeVisibilityChange', function(event, elem) {
        var props = elem.content.properties;

        _this.updateVisibilityUI(elem);
        props.changedByViewer = true;

        if (elem.type === 'layer') {
            _this._renderParams.visibilityFunc(props, props.visible);
            $(_this).triggerHandler('layerVisibilityChange', [elem]);
        }
    })

    nsGmx.leafletMap.on('layeradd layerremove', function(event) {
        if (event.layer.getGmxProperties) {
            var name = event.layer.getGmxProperties().name;

            //добавился именно слой из основной карты, а не просто с таким же ID
            if (event.layer === nsGmx.gmxMap.layersByID[name]) {
                var searchRes = _this.treeModel.findElem('name', name);
                if (searchRes && (!layerManagerFlag || layerManagerFlag == 0)) {
                    _this.treeModel.setNodeVisibility(searchRes.elem, nsGmx.leafletMap.hasLayer(event.layer));
                }
            }
        }
    });

    return this._treeCanvas;
}

layersTree.prototype.getChildsList = function(elem, parentParams, layerManagerFlag, parentVisibility)
{
	// добавляем новый узел
	var li = _li(),
		_this = this;

	_(li, [this.drawNode(elem, parentParams, layerManagerFlag, parentVisibility)]);

	if (elem.content && elem.content.children && elem.content.children.length > 0)
	{
		var	childsUl = _ul();

        // initExpand - временное свойство, сохраняющее начальное состояние развёрнутости группы.
        // В expanded будет храниться только текущее состояние (не сохраняется)
        if (typeof elem.content.properties.initExpand == 'undefined')
            elem.content.properties.initExpand = elem.content.properties.expanded;

		if (!elem.content.properties.expanded)
		{
			childsUl.style.display = 'none';
			childsUl.className = 'hiddenTree';

			if (!layerManagerFlag)
			{
				childsUl.loaded = false;

				this.addLoadingFunc(childsUl, elem, parentParams, layerManagerFlag);
			}
			else
			{
				childsUl.loaded = true;

				var childs = [];

				for (var i = 0; i < elem.content.children.length; i++)
					childs.push(this.getChildsList(elem.content.children[i], elem.content.properties, layerManagerFlag, true));

				_(childsUl, childs)
			}
		}
		else
		{
			childsUl.loaded = true;

			var childs = [];

			for (var i = 0; i < elem.content.children.length; i++)
				childs.push(this.getChildsList(elem.content.children[i], elem.content.properties, layerManagerFlag, parentVisibility && elem.content.properties.visible));

			_(childsUl, childs)
		}

		_(li, [childsUl, _abstractTree.makeSwapChild()])
	}
	else if (elem.children)
	{
		if (elem.children.length > 0)
		{
			var childs = [];

			for (var i = 0; i < elem.children.length; i++)
				childs.push(this.getChildsList(elem.children[i], elem.properties, layerManagerFlag, true));

			var	childsUl = _ul(childs);

			childsUl.loaded = true;

			_(li, [childsUl])
		}

		_(li, [_div()])

		li.root = true;
	}
	else
		_(li, [_abstractTree.makeSwapChild()])

	// видимость слоя в дереве
	if (!nsGmx.AuthManager.isRole(nsGmx.ROLE_ADMIN) &&
		elem.type && elem.type == 'layer' &&
		typeof invisibleLayers != 'undefined' && invisibleLayers[elem.content.properties.name])
		li.style.display = 'none';

	return li;
}

layersTree.prototype.addLoadingFunc = function(parentCanvas, elem, parentParams, layerManagerFlag)
{
	var func = function()
	{
		$(parentCanvas.parentNode.firstChild).bind('click', function()
		{
			if (!parentCanvas.loaded)
			{
				parentCanvas.loaded = true;

				var childs = [];

				for (var i = 0; i < elem.content.children.length; i++)
					childs.push(_this.getChildsList(elem.content.children[i], elem.content.properties, layerManagerFlag, _this.getLayerVisibility($(parentCanvas.parentNode).children("div[GroupID]")[0].firstChild)));

				_(parentCanvas, childs);

				if (_queryMapLayers.currentMapRights() == "edit")
				{
					_queryMapLayers.addDraggable(parentCanvas);

					if (!layerManagerFlag)
					{
						_queryMapLayers.addDroppable(parentCanvas);

						_queryMapLayers.addSwappable(parentCanvas);
					}
				}

				$(parentCanvas).treeview();

				_layersTree.addExpandedEvents(parentCanvas);

				_this.runLoadingFuncs();

				_queryMapLayers.applyState(_this.condition, _this.mapStyles, $(parentCanvas.parentNode).children("div[GroupID]")[0]);
			}
		})
	},
	_this = this;

	this.groupLoadingFuncs.push(func);
}

layersTree.prototype.runLoadingFuncs = function()
{
	for (var i = 0; i < this.groupLoadingFuncs.length; i++)
		this.groupLoadingFuncs[i]();

	this.groupLoadingFuncs = [];
}

layersTree.prototype.addExpandedEvents = function(parent)
{
	var _this = this;
	$(parent).find("div.hitarea").each(function()
	{
		if (!this.clickFunc)
		{
			this.clickFunc = true;

			var divClick = this;

			if (divClick.parentNode.parentNode.parentNode.getAttribute("multiStyle"))
				return;

			$(divClick).bind('click', function()
			{
				var div = $(divClick.parentNode).children("div[MapID],div[GroupID],div[LayerID],div[MultiLayerID]")[0],
					treeElem = _this.findTreeElem(div);

				if (!treeElem.parents.length)
					return;

				var flag = $(divClick).hasClass("expandable-hitarea");
				treeElem.elem.content.properties.expanded = !flag;
			})
		}
	})
}

layersTree.prototype.drawNode = function(elem, parentParams, layerManagerFlag, parentVisibility)
{
	var div;
    var _this = this;

	if (elem.type == "layer")
	{
        // var elemProperties = !layerManagerFlag ? nsGmx.gmxMap.layersByID[elem.content.properties.name].getGmxProperties(): elem.content.properties;

		var elemProperties;
		if (nsGmx.gmxMap.layersByID[elem.content.properties.name]) {
			elemProperties = !layerManagerFlag ? nsGmx.gmxMap.layersByID[elem.content.properties.name].getGmxProperties(): elem.content.properties;
		} else {
			elemProperties = elem.content.properties;
		}

		var childs = this.drawLayer(elemProperties, parentParams, layerManagerFlag, parentVisibility);

		if (typeof elem.content.properties.LayerID != 'undefined')
			div = _div(childs, [['attr','LayerID',elem.content.properties.LayerID]]);
		else if (typeof elem.content.properties.MultiLayerID != 'undefined')
			div = _div(childs, [['attr','MultiLayerID',elem.content.properties.MultiLayerID]]);
        else
            div = _div(childs, [['attr','LayerID',elem.content.properties.name]]);

		div.gmxProperties = elem;
		div.gmxProperties.content.properties = elemProperties;

        this._applyLayerViewHooks(div, elemProperties);
	}
	else
	{
		if (elem.properties && elem.properties.MapID)
			div = _div(this.drawHeaderGroupLayer(elem.properties, parentParams, layerManagerFlag), [['attr','MapID',elem.properties.MapID]])
		else
			div = _div(this.drawGroupLayer(elem.content.properties, parentParams, layerManagerFlag, parentVisibility), [['attr','GroupID',elem.content.properties.GroupID]])

		div.gmxProperties = elem;
	}

	div.oncontextmenu = function(e)
	{
		return false;
	}

	return div;
}

layersTree.prototype.setActive = function(span)
{
	$(this._treeCanvas).find(".active").removeClass("active");

    if (span) {
        $(span.parentNode).addClass("active");
        $(this).triggerHandler("activeNodeChange", [span.parentNode.parentNode]);
    } else {
        $(this).triggerHandler("activeNodeChange", [null]);
    }
}

layersTree.prototype.getActive = function()
{
    var activeDiv = $(this._treeCanvas).find(".active");
    return activeDiv[0] ? activeDiv[0].parentNode : null;
}

layersTree.prototype.getMinLayerZoom = function(layer)
{
    if (!layer.getStyles) {
        return 1;
    }

    var minLayerZoom = 20,
        styles = layer.getStyles();

    for (var i = 0; i < styles.length; i++) {
        minLayerZoom = Math.min(minLayerZoom, styles[i].MinZoom);
    }

    return minLayerZoom;
}

layersTree.prototype.layerZoomToExtent = function(bounds, minZoom)
{
    if (!bounds) return;

    var lmap = nsGmx.leafletMap,
        z = lmap.getBoundsZoom(bounds);

	if (minZoom !== 20) {
		z = Math.max(z, minZoom);
    }

    z = Math.min(lmap.getMaxZoom(), Math.max(lmap.getMinZoom(), z));

    //анимация приводит к проблемам из-за бага https://github.com/Leaflet/Leaflet/issues/3249
    //а указать явно zoom в fitBounds нельзя
    //TODO: enable animation!
    lmap.fitBounds(bounds, {animation: false});

    //если вызывать setZoom всегда, карта начнёт глючить (бага Leaflet?)
    if (z !== lmap.getZoom()) {
        lmap.setZoom(z);
    }
}

layersTree.prototype.drawLayer = function(elem, parentParams, layerManagerFlag, parentVisibility)
{
	var box,
		_this = this;

	if (this._renderParams.showVisibilityCheckbox)
	{
		box = _checkbox(elem.visible, parentParams.list ? 'radio' : 'checkbox', parentParams.GroupID || parentParams.MapID);

		box.className = 'box layers-visibility-checkbox';

		box.setAttribute('box','layer');

		box.onclick = function()
		{
            _this.treeModel.setNodeVisibility(_this.findTreeElem(this.parentNode).elem, this.checked);
		}
	}

	var span = _span([_t(elem.title)], [['dir','className','layer'],['attr','dragg',true]]);

    var timer = null,
        clickFunc = function()
        {
            var treeNode = _this.findTreeElem(span.parentNode.parentNode).elem;
            $(treeNode).triggerHandler('click', [treeNode]);

            if (_this._renderParams.allowActive)
                _this.setActive(span);

            if (_this._renderParams.showVisibilityCheckbox)
            {
                _this.treeModel.setNodeVisibility(treeNode, true);
            }
        },
        dbclickFunc = function()
        {
            var treeNode = _this.findTreeElem(span.parentNode.parentNode).elem;
            var layer = nsGmx.gmxMap.layersByID[elem.name];
            $(treeNode).triggerHandler('dblclick', [treeNode]);
            if (treeNode.content.geometry && layer && layer.getBounds) {
                var minLayerZoom = _this.getMinLayerZoom(layer);
                _this.layerZoomToExtent(layer.getBounds(), minLayerZoom);
            }
        };

    span.onclick = function()
    {
        if (timer)
            clearTimeout(timer);

        timer = setTimeout(clickFunc, 200)
    }

    if (this._renderParams.allowDblClick)
    {
        span.ondblclick = function()
        {
            if (timer)
                clearTimeout(timer);

            timer = null;

            clickFunc();
            dbclickFunc();
        }
    }

    disableSelection(span);

	var spanParent = _div([span],[['attr','titleDiv',true],['css','display','inline'],['css','position','relative'],['css','borderBottom','none'],['css','paddingRight','3px']]),
		spanDescr = _span(null,[['dir','className','layerDescription']]);

	spanDescr.innerHTML = elem.description ? elem.description : '';

	if (layerManagerFlag == 1)
		return [_img(null, [['attr','src', (elem.type == "Vector") ? 'img/vector.png' : (typeof elem.MultiLayerID != 'undefined' ? 'img/multi.png' : 'img/rastr.png')],['css','marginLeft','3px']]), spanParent, spanDescr];

	if (this._renderParams.showVisibilityCheckbox && !elem.visible) {
		$(spanParent).addClass("invisible");
    }

	nsGmx.ContextMenuController.bindMenuToElem(spanParent, 'Layer', function(){return true;}, {
		layerManagerFlag: layerManagerFlag,
		elem: elem,
		tree: this
	});

    var borderDescr = _span();

    var count = 0;
    var props = {};
    if (elem.MetaProperties)
    {
        for (key in elem.MetaProperties)
        {
            var tagtype = elem.MetaProperties[key].Type;
            props[key] = nsGmx.Utils.convertFromServer(tagtype, elem.MetaProperties[key].Value);
            count++;
        }
    }

    if (count || elem.Legend)
    {
        _(borderDescr, [_t('i')], [['dir','className','layerInfoButton']]);
        borderDescr.onclick = function()
        {
            nsGmx.Controls.showLayerInfo({properties:elem}, {properties: props});
        }
    }

	if (elem.type == "Vector")
	{
		var icon = _mapHelper.createStylesEditorIcon(elem.styles, elem.GeometryType ? elem.GeometryType.toLowerCase() : 'polygon', {addTitle: !layerManagerFlag}),
			multiStyleParent = _div(null,[['attr','multiStyle',true]]),
            iconSpan = _span([icon]);

        if ( elem.styles.length === 1 && elem.name in nsGmx.gmxMap.layersByID )
        {
            var layer = nsGmx.gmxMap.layersByID[elem.name];
            layer.on('stylechange', function() {
                if (layer.getStyles().length === 1)
                {
                    var style = L.gmxUtil.toServerStyle(layer.getStyles()[0].RenderStyle);
                    var newIcon = _mapHelper.createStylesEditorIcon(
                        [{MinZoom:1, MaxZoom: 21, RenderStyle: style}],
                        elem.GeometryType ? elem.GeometryType.toLowerCase() : 'polygon',
                        {addTitle: !layerManagerFlag}
                    );
                    $(iconSpan).empty().append(newIcon);
                }
            });
        }

        $(iconSpan).attr('styleType', $(icon).attr('styleType'));

		_mapHelper.createMultiStyle(elem, this, multiStyleParent, true, layerManagerFlag);

		if (!layerManagerFlag)
		{
			if (!parentVisibility || !elem.visible)
				$(multiStyleParent).addClass("invisible")

			iconSpan.onclick = function()
			{
				if (_queryMapLayers.currentMapRights() == "edit") {
                    nsGmx.createStylesDialog(elem, _this);
                }
			}
		}

        var resElems = [spanParent, spanDescr, borderDescr];

        if (this._renderParams.showStyle) {
            resElems.push(multiStyleParent);
            resElems.unshift(iconSpan);
        }
        this._renderParams.showVisibilityCheckbox && resElems.unshift(box);

        return resElems;
	}
	else
	{
		if (this._renderParams.showVisibilityCheckbox)
			return [box, spanParent, spanDescr, borderDescr];
		else
			return [spanParent, spanDescr, borderDescr];
	}
}

layersTree.prototype.drawGroupLayer = function(elem, parentParams, layerManagerFlag, parentVisibility)
{
	var box,
		_this = this;

	if (this._renderParams.showVisibilityCheckbox)
	{
		box = _checkbox(elem.visible, parentParams.list ? 'radio' : 'checkbox', parentParams.GroupID || parentParams.MapID);

		box.className = 'box layers-visibility-checkbox';

		box.setAttribute('box','group');

		box.onclick = function()
		{
            _this.treeModel.setNodeVisibility(_this.findTreeElem(this.parentNode).elem, this.checked);
		}

		if (typeof elem.ShowCheckbox !== 'undefined' && !elem.ShowCheckbox)
		{
			box.isDummyCheckbox = true;
			box.style.display = 'none';
        }
	}

	var span = _span([_t(elem.title)], [['dir','className','groupLayer'],['attr','dragg',true]]);

    var timer = null,
        clickFunc = function()
        {
            if (_this._renderParams.allowActive)
                _this.setActive(span);

            if (_this._renderParams.showVisibilityCheckbox)
            {
                var div = span.parentNode.parentNode;

                if (div.gmxProperties.content.properties.ShowCheckbox) {
                    _this.treeModel.setNodeVisibility(_this.findTreeElem(div).elem, true);
                }

                var clickDiv = $(div.parentNode).children("div.hitarea");
                if (clickDiv.length)
                    $(clickDiv[0]).trigger("click");
            }
        },
        dbclickFunc = function()
        {
            var childsUl = _abstractTree.getChildsUl(span.parentNode.parentNode.parentNode);

            if (childsUl)
            {
                var bounds = new L.LatLngBounds(),
                    minLayerZoom = 20;

                _mapHelper.findChilds(_this.findTreeElem(span.parentNode.parentNode).elem, function(child)
                {
                    if (child.type == 'layer' && (child.content.properties.LayerID || child.content.properties.MultiLayerID) && child.content.geometry)
                    {
                        	var layer = nsGmx.gmxMap.layersByID[child.content.properties.name];
							bounds.extend(layer.getBounds());

                        minLayerZoom = Math.min(minLayerZoom, _this.getMinLayerZoom(layer));
                    }
                });

                _this.layerZoomToExtent(bounds, minLayerZoom);
            }
        };

    span.onclick = function()
    {
        if (timer)
            clearTimeout(timer);

        timer = setTimeout(clickFunc, 200)
    }

    if (this._renderParams.allowDblClick)
    {
        span.ondblclick = function()
        {
            if (timer)
                clearTimeout(timer);

            timer = null;

            clickFunc();
            dbclickFunc();
        }
    }

    disableSelection(span);

	var spanParent = _div([span],[['attr','titleDiv',true],['css','display','inline'],['css','position','relative'],['css','borderBottom','none'],['css','paddingRight','3px']]);

    if (this._renderParams.showVisibilityCheckbox && (!parentVisibility || !elem.visible)) {
        $(spanParent).addClass("invisible");
    }

	if (!layerManagerFlag)
	{

		nsGmx.ContextMenuController.bindMenuToElem(spanParent, 'Group', function()
		{
				return _queryMapLayers.currentMapRights() == "edit";
		},
		function(){
			return {
				div: spanParent.parentNode,
				tree: _this
		}
		});
    }

    if (this._renderParams.showVisibilityCheckbox)
        return [box, spanParent];
	else
		return [spanParent];
}
layersTree.prototype.drawHeaderGroupLayer = function(elem, parentParams, layerManagerFlag)
{
	var span = _span([_t(elem.title)], [['dir','className','groupLayer']]),
		spanParent = _div([span],[['css','display','inline'],['css','position','relative'],['css','borderBottom','none'],['css','paddingRight','3px']]),
		_this = this;

	if (this._renderParams.allowActive) {
        span.onclick = function()
        {
            _this.setActive(this);
        }
    }

    if (!layerManagerFlag)
    {
        nsGmx.ContextMenuController.bindMenuToElem(spanParent, 'Map', function()
            {
                return _queryMapLayers.currentMapRights() == "edit";
            },
            function()
            {
                return {
                    div: spanParent.parentNode,
                    tree: _this
                }
            }
        );
    }

	return [spanParent];
}

layersTree.prototype.removeGroup = function(div)
{
    var template = Handlebars.compile('<div class="removeGroup-container">' +
        '{{#if anyChildren}}' +
            '<label><input type="checkbox" checked class="removeGroup-layers">{{i "Включая вложенные слои"}}</label><br>' +
        '{{/if}}' +
        '<button class="removeGroup-remove">{{i "Удалить"}}</button>' +
    '</div>');
    var groupNode = _layersTree.treeModel.findElemByGmxProperties(div.gmxProperties).elem;

    var ui = $(template({anyChildren: groupNode.content.children.length > 0})),
        pos = nsGmx.Utils.getDialogPos(div, true, 90),
        _this = this;

    ui.find('.removeGroup-remove').click(function() {
        var parentTree = div.parentNode.parentNode,
            childsUl = _abstractTree.getChildsUl(div.parentNode);

        if (ui.find('.removeGroup-layers').prop('checked')) {
            _layersTree.treeModel.forEachLayer(function(layerContent) {
                _queryMapLayers.removeLayer(layerContent.properties.name);
            }, groupNode);
        } else {
            //TODO: не работает, когда группа не раскрыта или раскрыта не полностью
            var divDestination = $(parentTree.parentNode).children("div[MapID],div[GroupID]")[0];

            if (childsUl) {
                // переносим все слои наверх
                $(childsUl).find("div[LayerID],div[MultiLayerID]").each(function()
                {
                    var spanSource = $(this).find("span.layer")[0];

                    _this.moveHandler(spanSource, divDestination);
                })
            }
        }

        _this.removeTreeElem(div);

        div.parentNode.removeNode(true);

        _abstractTree.delNode(null, parentTree, parentTree.parentNode)

        $(dialogDiv).dialog('destroy');
        dialogDiv.removeNode(true);

        _mapHelper.updateUnloadEvent(true);

        _this.updateZIndexes();
    });

    var title = _gtxt("Удаление группы [value0]", div.gmxProperties.content.properties.title);
    var dialogDiv = showDialog(title, ui[0], 250, 100, pos.left, pos.top);
}

//по элементу дерева слоёв ищет соответствующий элемент в DOM представлении
layersTree.prototype.findUITreeElem = function(elem)
{
	var props = elem.content.properties,
        searchStr;

	if (props.LayerID)
		searchStr = "div[LayerID='" + props.LayerID + "']";
	else if (props.MultiLayerID)
		searchStr = "div[MultiLayerID='" + props.MultiLayerID + "']";
	else if (props.GroupID)
		searchStr = "div[GroupID='" + props.GroupID + "']";
    else
        searchStr = "div[LayerID='" + props.name + "']";

    return $(this._treeCanvas).find(searchStr)[0];
}

layersTree.prototype.getLayerVisibility = function(box)
{
	if (!box.checked)
		return false;

	var	el = box.parentNode.parentNode.parentNode;

	while (!el.root)
	{
		var group = $(el).children("[GroupID]");

		if (group.length > 0)
		{
			if (!group[0].firstChild.checked)
				return false;
		}

		el = el.parentNode;
	}

	return true;
}

//Устанавливает галочку в checkbox и нужный стиль DOM ноде дерева в зависимости от видимости
//ничего не трогает вне ноды и в самом дереве
layersTree.prototype.updateVisibilityUI = function(elem) {
    var div = this.findUITreeElem(elem);
    if (div) {
        var isVisible = elem.content.properties.visible;
        $(div).children("[titleDiv], [multiStyle]").toggleClass("invisible", !isVisible);
        div.firstChild.checked = isVisible;
    }
}

layersTree.prototype.dummyNode = function(node)
{
	var text = node.innerHTML;

    if (text.length > 40) {
        text = text.substring(0, 37) + '...';
    }

	return div = _div([_t(text)],[['dir','className','dragableDummy']]);
}

//проходится по всем слоям дерева и устанавливает им z-индексы в соответствии с их порядком в дереве
layersTree.prototype.updateZIndexes = function() {
    var curZIndex = 0;

    this.treeModel.forEachLayer(function(layerContent, isVisible, nodeDepth) {
        var layer = nsGmx.gmxMap.layersByID[layerContent.properties.name];

        var zIndex = curZIndex++;
        layer.setZIndex && layer.setZIndex(zIndex);
    })
}

layersTree.prototype.moveHandler = function(spanSource, divDestination)
{
	var node = divDestination.parentNode,
        divSource = spanSource.parentNode.parentNode.parentNode,
		parentTree = divSource.parentNode,
        parentElem = this.findTreeElem($(divSource).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0]).parents[0];

	this.removeTreeElem(spanSource.parentNode.parentNode);
	this.addTreeElem(divDestination, 0, spanSource.parentNode.parentNode.gmxProperties);

	// добавим новый узел
	var childsUl = _abstractTree.getChildsUl(node);

	if (childsUl)
	{
		_abstractTree.addNode(node, divSource);

		this.updateListType(divSource);

		if (!childsUl.loaded)
			divSource.removeNode(true)
	}
	else
	{
		_abstractTree.addNode(node, divSource);

		this.updateListType(divSource);
	}

    parentElem && parentElem.content && this.treeModel.updateNodeVisibility(parentElem);

	// удалим старый узел
	_abstractTree.delNode(node, parentTree, parentTree.parentNode);

	_mapHelper.updateUnloadEvent(true);

    this.updateZIndexes();
}

layersTree.prototype.swapHandler = function(spanSource, divDestination)
{
	var node = divDestination.parentNode,
        divSource = spanSource.parentNode.parentNode.parentNode,
		parentTree = divSource.parentNode,
        parentElem = this.findTreeElem($(divSource).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0]).parents[0];

	if (node == divSource)
		return;

	this.removeTreeElem(spanSource.parentNode.parentNode);

	var divElem = $(divDestination.parentNode).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0],
		divParent = $(divDestination.parentNode.parentNode.parentNode).children("div[MapID],div[GroupID]")[0],
		index = this.findTreeElem(divElem).index;

	this.addTreeElem(divParent, index + 1, spanSource.parentNode.parentNode.gmxProperties);

	_abstractTree.swapNode(node, divSource);

	this.updateListType(divSource);

    parentElem && parentElem.content && this.treeModel.updateNodeVisibility(parentElem);

	// удалим старый узел
	_abstractTree.delNode(node, parentTree, parentTree.parentNode);

	_mapHelper.updateUnloadEvent(true);

    this.updateZIndexes();
}

layersTree.prototype.copyHandler = function(gmxProperties, divDestination, swapFlag, addToMap)
{
    var _this = this;
	var isFromList = typeof gmxProperties.content.geometry === 'undefined';
	var layerProperties = (gmxProperties.type !== 'layer' || !isFromList) ? gmxProperties : false,
		copyFunc = function()
		{
			if (addToMap)
            {
                if ( !_this.addLayersToMap(layerProperties) )
                    return;
            }
            else
            {
                if ( _this.treeModel.findElemByGmxProperties(gmxProperties) )
                {
                    if (layerProperties.type === 'layer')
                        showErrorMessage(_gtxt("Слой '[value0]' уже есть в карте", layerProperties.content.properties.title), true)
                    else
                        showErrorMessage(_gtxt("Группа '[value0]' уже есть в карте", layerProperties.content.properties.title), true)

                    return;
                }
            }

			var node = divDestination.parentNode,
				parentProperties = swapFlag ? $(divDestination.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0].gmxProperties : divDestination.gmxProperties,
				li;

			if (swapFlag)
			{
				var parentDiv = $(divDestination.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0];

				li = _this.getChildsList(layerProperties, parentProperties, false, parentDiv.getAttribute('MapID') ? true : _this.getLayerVisibility(parentDiv.firstChild));
			}
			else
				li = _this.getChildsList(layerProperties, parentProperties, false, _this.getLayerVisibility(divDestination.firstChild));

			if (layerProperties.type == 'group')
			{
				// добавляем группу
				if (_abstractTree.getChildsUl(li))
				{
					var div = _div(null, [['dir','className','hitarea']]);

					if (layerProperties.content.properties.expanded)
					{
						$(div).addClass('collapsable-hitarea');
						$(li).addClass('collapsable');
					}
					else
					{
						$(div).addClass('expandable-hitarea');
						$(li).addClass('expandable');
					}

					_abstractTree.toggle(div);

					li.insertBefore(div, li.firstChild);

					$(li).treeview();

					// если копируем из карты
					if (isFromList)
                        _layersTree.runLoadingFuncs();
				}

				_queryMapLayers.addDraggable(li)

				_queryMapLayers.addDroppable(li);
			}
			else
			{
				_queryMapLayers.addDraggable(li);

				if (layerProperties.type == 'layer' && layerProperties.content.properties.styles.length > 1)
					$(li).treeview();
			}

			_queryMapLayers.addSwappable(li);

			if (swapFlag)
			{
				var divElem = $(divDestination.parentNode).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0],
					divParent = $(divDestination.parentNode.parentNode.parentNode).children("div[MapID],div[GroupID]")[0],
					index = _this.findTreeElem(divElem).index;

				_this.addTreeElem(divParent, index + 1, layerProperties);

				_abstractTree.swapNode(node, li);

				_this.updateListType(li, true);
			}
			else
			{
				_this.addTreeElem(divDestination, 0, layerProperties);

				var childsUl = _abstractTree.getChildsUl(node);

                _abstractTree.addNode(node, li);
                _this.updateListType(li, true);

				if (childsUl && !childsUl.loaded)
				{
                    li.removeNode(true)
				}
			}

			_mapHelper.updateUnloadEvent(true);

            _this.updateZIndexes();
		},
		_this = this;

	if (!layerProperties)
	{
		if (gmxProperties.content.properties.LayerID)
		{
			sendCrossDomainJSONRequest(serverBase + "Layer/GetLayerJson.ashx?WrapStyle=func&LayerName=" + gmxProperties.content.properties.name, function(response)
			{
				if (!parseResponse(response))
					return;

				layerProperties = {type:'layer', content: response.Result};

				if (layerProperties.content.properties.type == 'Vector')
					layerProperties.content.properties.styles = [{MinZoom:layerProperties.content.properties.VtMaxZoom, MaxZoom:21, RenderStyle: layerProperties.content.properties.IsPhotoLayer ? _mapHelper.defaultPhotoIconStyles[layerProperties.content.properties.GeometryType] : _mapHelper.defaultStyles[layerProperties.content.properties.GeometryType]}]
				else if (layerProperties.content.properties.type != 'Vector' && !layerProperties.content.properties.MultiLayerID)
					layerProperties.content.properties.styles = [{MinZoom:layerProperties.content.properties.MinZoom, MaxZoom:21}];

				layerProperties.content.properties.mapName = _this.treeModel.getMapProperties().name;
				layerProperties.content.properties.hostName = _this.treeModel.getMapProperties().hostName;
				layerProperties.content.properties.visible = true;

				copyFunc();
			})
		}
		else
		{
			sendCrossDomainJSONRequest(serverBase + "MultiLayer/GetMultiLayerJson.ashx?WrapStyle=func&MultiLayerID=" + gmxProperties.content.properties.MultiLayerID, function(response)
			{
				if (!parseResponse(response))
					return;

				layerProperties = {type:'layer', content: response.Result};

				layerProperties.content.properties.styles = [{MinZoom:layerProperties.content.properties.MinZoom, MaxZoom:20}];

				layerProperties.content.properties.mapName = _this.treeModel.getMapProperties().name;
				layerProperties.content.properties.hostName = _this.treeModel.getMapProperties().hostName;
				layerProperties.content.properties.visible = true;

				copyFunc();
			})
		}
	}
	else
		copyFunc();
}

//не работает для мультислоёв
layersTree.prototype.addLayerToTree = function(layerName) {
    var gmxProperties = {
        type: 'layer',
        content: {
            properties: {
                LayerID: layerName,
                name: layerName
            }
        }
    };

    var targetDiv = $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0];

    this.copyHandler(gmxProperties, targetDiv, false, true);
}

//геометрия слоёв должна быть в координатах меркатора
layersTree.prototype.addLayersToMap = function(elem)
{
	var DEFAULT_VECTOR_LAYER_ZINDEXOFFSET = 2000000;

	var layerOrder = nsGmx.gmxMap.rawTree.properties.LayerOrder,
		currentZoom = nsGmx.leafletMap.getZoom();

    if (typeof elem.content.properties.GroupID != 'undefined')
    {
        for (var i = 0; i < elem.content.children.length; i++)
        {
            var res = this.addLayersToMap(elem.content.children[i]);

            if (!res)
                return false;
        }
    }
    else
    {
        var layer = elem.content,
            name = layer.properties.name;

        if (!nsGmx.gmxMap.layersByID[name])
        {
			var visibility = typeof layer.properties.visible != 'undefined' ? layer.properties.visible : false,
				rcMinZoom = layer.properties.RCMinZoomForRasters,
            	layerOnMap = L.gmx.createLayer(layer, {
            		layerID: name,
            		hostName: window.serverBase,
					zIndexOffset: null
            });

			updateZIndex(layerOnMap);
            nsGmx.gmxMap.addLayer(layerOnMap);

            visibility && nsGmx.leafletMap.addLayer(layerOnMap);

            layerOnMap.getGmxProperties().changedByViewer = true;

			nsGmx.leafletMap.on('zoomend', function(e) {
				currentZoom = nsGmx.leafletMap.getZoom();

				for (var l = 0; l < nsGmx.gmxMap.layers.length; l++) {
					var layer = nsGmx.gmxMap.layers[l];

					updateZIndex(layer);
				}
			});
        }
        else
        {
            showErrorMessage( _gtxt("Слой '[value0]' уже есть в карте", nsGmx.gmxMap.layersByID[name].getGmxProperties().title), true );
            return false;
        }
    }

	function updateZIndex (layer) {
		var props = layer.getGmxProperties();

        switch (layerOrder) {
            case 'VectorOnTop':
            if (props.type === 'Vector') {
                if (props.IsRasterCatalog) {
                    var rcMinZoom = props.RCMinZoomForRasters;
                    layer.setZIndexOffset(currentZoom < rcMinZoom ? DEFAULT_VECTOR_LAYER_ZINDEXOFFSET : 0);
                } else {
                    layer.setZIndexOffset(DEFAULT_VECTOR_LAYER_ZINDEXOFFSET);
                }
            }
            break;
        }
    }

    return true;
}

layersTree.prototype.getParentParams = function(li)
{
    //при визуализации дерева в него добавляются новые элементы. Используем хак, чтобы понять, было отрисовано дерево или нет
	var parentParams = li.parentNode.parentNode.childNodes[1].tagName == "DIV" ? li.parentNode.parentNode.childNodes[1].gmxProperties : li.parentNode.parentNode.childNodes[0].gmxProperties,
		listFlag;

	if (parentParams.content)
		listFlag = parentParams.content.properties;
	else
		listFlag = parentParams.properties;

	return listFlag;
}

layersTree.prototype.updateListType = function(li, skipVisible)
{
    //при визуализации дерева в него добавляются новые элементы. Используем хак, чтобы понять, было отрисовано дерево или нет
	var parentParams = li.parentNode.parentNode.childNodes[1].tagName == "DIV" ? li.parentNode.parentNode.childNodes[1].gmxProperties : li.parentNode.parentNode.childNodes[0].gmxProperties,
		listFlag;

	if (parentParams.content)
		listFlag = parentParams.content.properties.list;
	else
		listFlag = parentParams.properties.list;

	var box = $(li).children("div[MapID],div[GroupID],div[LayerID],div[MultiLayerID]")[0].firstChild,
		newBox = _checkbox(
            box.checked,
            listFlag ? 'radio' : 'checkbox',
            parentParams.content ? parentParams.content.properties.GroupID : parentParams.properties.MapID
        ),
		_this = this;

	newBox.className = 'box layers-visibility-checkbox';

	if (box.getAttribute('box') == 'group')
		newBox.setAttribute('box', 'group');

	$(box).replaceWith(newBox);

	newBox.onclick = function()
	{
		_this.treeModel.setNodeVisibility(_this.findTreeElem(this.parentNode).elem, this.checked);
	}

	if ( box.isDummyCheckbox )
	{
		newBox.isDummyCheckbox = true;
		newBox.style.display = 'none';
	}

	if (!skipVisible)
	{
        var parentDiv = $(newBox.parentNode.parentNode.parentNode.parentNode).children("div[GroupID]")[0];
        parentDiv && this.treeModel.updateNodeVisibility(this.findTreeElem(parentDiv).elem, this.findTreeElem(newBox.parentNode).elem);
	}

	return newBox;
}

layersTree.prototype.removeTreeElem = function(div)
{
	var elem = this.findTreeElem(div);

	if (typeof elem.parents[0].children != 'undefined')
		elem.parents[0].children.splice(elem.index, 1);
	else
		elem.parents[0].content.children.splice(elem.index, 1);
}

layersTree.prototype.addTreeElem = function(div, index, elemProperties)
{
	var elem = this.findTreeElem(div);

	if (typeof elem.elem.children != 'undefined')
		elem.elem.children.splice(index, 0, elemProperties);
	else
		elem.elem.content.children.splice(index, 0, elemProperties);

    $(this.treeModel.getRawTree()).triggerHandler('addTreeElem', [elemProperties]);
}

layersTree.prototype.findTreeElem = function(div)
{
	if (div.getAttribute("MapID"))
		return {elem:this.treeModel.getRawTree(), parents:[], index: false};
	else if (div.getAttribute("GroupID"))
		return this.treeModel.findElem("GroupID", div.getAttribute("GroupID"));
	else if (div.getAttribute("LayerID"))
		return this.treeModel.findElem("name", div.getAttribute("LayerID"));
	else if (div.getAttribute("MultiLayerID"))
		return this.treeModel.findElem("name", div.getAttribute("MultiLayerID"));
}

//Дерево основной карты
var _layersTree = new layersTree({showVisibilityCheckbox: true, allowActive: true, allowDblClick: true});

window.layersTree = layersTree;
window._layersTree = _layersTree;

//Виджет в левой панели для отображения основного дерева
var queryMapLayers = function()
{
	this.buildedTree = null;
	this.builded = false;

	this.buttonsCanvas = _div();

    this.loadDeferred = $.Deferred();
}

queryMapLayers.prototype = new leftMenu();

queryMapLayers.prototype.addLayers = function(data, condition, mapStyles, LayersTreePermalinkParams)
{
	if (condition)
		_layersTree.condition = condition;

	if (mapStyles)
		_layersTree.mapStyles = mapStyles;

	if (LayersTreePermalinkParams)
		_layersTree.LayersTreePermalinkParams = LayersTreePermalinkParams;

	this.buildedTree = _layersTree.drawTree(data);
}

queryMapLayers.prototype.applyState = function(condition, mapLayersParam, div)
{
	if (!objLength(condition.visible) && !objLength(condition.expanded) && !objLength(mapLayersParam))
		return;

	var parentElem = typeof div == 'undefined' ? _layersTree.treeModel.getRawTree() : _layersTree.findTreeElem(div).elem,
		visFlag = typeof div == 'undefined' ? true : _layersTree.getLayerVisibility(div.firstChild),
		_this = this;

	_mapHelper.findTreeElems(parentElem, function(elem, visibleFlag)
	{
        var props = elem.content.properties;
		if (elem.type == 'group')
		{
			var groupId = props.GroupID;

			if (typeof condition.visible[groupId] != 'undefined' && props.visible != condition.visible[groupId])
			{
				props.visible = condition.visible[groupId];

				var group = $(_this.buildedTree).find("div[GroupID='" + groupId + "']");

				if (group.length)
					group[0].firstChild.checked = condition.visible[groupId];
			}

			if (typeof condition.expanded[groupId] != 'undefined' && props.expanded != condition.expanded[groupId])
			{
				props.expanded = condition.expanded[groupId];

				var group = $(_this.buildedTree).find("div[GroupID='" + groupId + "']");

				if (group.length)
				{
					var clickDiv = $(group[0].parentNode).children("div.hitarea");

					if (clickDiv.length)
						$(clickDiv[0]).trigger("click");
				}
			}
		}
		else
		{
            var name = props.name;
			if (typeof condition.visible[name] != 'undefined') {
                _layersTree.treeModel.setNodeVisibility(elem, condition.visible[name]);
			} else {
                _layersTree.treeModel.setNodeVisibility(elem, props.initVisible);
            }

			if (props.type == "Vector" && typeof mapLayersParam != 'undefined' &&  typeof mapLayersParam[name] != 'undefined' &&
				!_this.equalStyles(props.styles, mapLayersParam[name]))
			{
				// что-то менялось в стилях
				var newStyles = mapLayersParam[name],
					div = $(_this.buildedTree).find("div[LayerID='" + props.LayerID + "']")[0];

                props.styles = newStyles;

                _mapHelper.updateMapStyles(newStyles, name);
                props.changedByViewer = true;

                div && _mapHelper.updateTreeStyles(newStyles, div, _layersTree, true);
			}
		}
	}, visFlag)
}

queryMapLayers.prototype.equalStyles = function(style1, style2)
{
	if (style1.length != style2.length)
		return false;

	for (var i = 0; i < style1.length; i++)
		if (!equals(style1[i], style2[i]))
			return false;

	return true;
}

queryMapLayers.prototype.getContainerBefore = function() {
    if (!this.builded) return;

    return $('.layers-before', this.workCanvas).show();
}

queryMapLayers.prototype.getContainerAfter = function() {
    if (!this.builded) return;

    return $('.layers-after', this.workCanvas).show();
}

queryMapLayers.prototype.load = function(data)
{
	if (this.buildedTree && !this.builded)
	{
		var _this = this;

		this.treeCanvas = _div(null, [['dir', 'className', 'layers-tree']]);

        //Для обратной совместимости - есть много мапплетов карт, которые пытаются интегрироваться после первого table
        //TODO: изнечтожить все такие мапплеты
        _(this.workCanvas, [_table()]);

		_(this.workCanvas, [
            _div([
                //_table([_tbody([_tr([_td([_span([_t(_gtxt("Шкала прозрачности"))],[['css','marginLeft','7px'],['css','color','#153069'],['css','fontSize','12px']])]), _td([this.rasterLayersSlider(_queryMapLayers.treeCanvas)])])])])
            ], [['dir', 'className', 'layers-before'], ['css', 'display', 'none']])
        ]);

		_(this.workCanvas, [this.treeCanvas]);

		_(this.treeCanvas, [this.buildedTree]);

		_(this.workCanvas, [
            _div([
                //_table([_tbody([_tr([_td([_span([_t(_gtxt("Шкала прозрачности"))],[['css','marginLeft','7px'],['css','color','#153069'],['css','fontSize','12px']])]), _td([this.rasterLayersSlider(_queryMapLayers.treeCanvas)])])])])
            ], [['dir', 'className', 'layers-after'], ['css', 'display', 'none']])
        ]);

		$(this.buildedTree).treeview();

		_layersTree.runLoadingFuncs();

		_layersTree.addExpandedEvents(this.buildedTree);

        //при клике на любом пустом месте дерева слоёв снимаем выделение
        $(this.treeCanvas).click(function(event) {
            var t = $(event.target);
            //все элементы, на которых можно кликнуть без снятия выделения
            if (t.hasClass('hitarea') || t.hasClass('groupLayer') || t.attr('styletype') || t.parents('div[layerid],div[MultiLayerID]').length) {
                return;
            }
            _layersTree.setActive(null);
        });

        $(this.treeCanvas).droppable({
            accept: "span[dragg]",
            drop: function(ev, ui) {
                queryMapLayers._droppableHandler.bind($(_this.buildedTree).find('[mapid]')[0], ev, ui)();
            }
        })

		this.applyState(_layersTree.condition, _layersTree.mapStyles);

		this.builded = true;

        $(this).triggerHandler('load');
        this.loadDeferred.resolve();
	}
}

queryMapLayers.prototype.applyOpacityToRasterLayers = function(opacity, parent) {

    var active = $(parent).find(".active");

    // слой
    if (active[0] && (active[0].parentNode.getAttribute("LayerID") || active[0].parentNode.getAttribute("MultiLayerID")))
    {
        var props = active[0].parentNode.gmxProperties.content.properties,
            layer = nsGmx.gmxMap.layersByID[props.name];

        layer.setRasterOpacity && layer.setRasterOpacity(opacity/100);

        return;
    }

    if (active.length) {
        // группа или карта
        var treeElem = _layersTree.findTreeElem(active[0].parentNode);

        _mapHelper.findChilds(treeElem.elem, function(child)
        {
            var props = child.content.properties;
            var layer = nsGmx.gmxMap.layersByID[props.name];
            layer.setRasterOpacity && layer.setRasterOpacity(opacity/100);
        }, true);
    } else {
        // все растровые слои
        var layers = nsGmx.gmxMap.layers;
        for (var i = 0; i < layers.length; i++) {
            layers[i].setRasterOpacity && layers[i].setRasterOpacity(opacity/100);
        }
    }
}

queryMapLayers.prototype.rasterLayersSlider = function(parent)
{
	var slider = nsGmx.Controls.createSlider(100,
			function(event, ui)
			{
				_queryMapLayers.applyOpacityToRasterLayers(ui.value, parent);
			}),
		elem = _div([slider], [['css','width','120px']]);

	slider.style.margin = '10px';
	slider.style.backgroundColor = '#F4F4F4';

	_title(slider, _gtxt("Прозрачность выбранного слоя/группы/карты"));

	return _div([elem],[['css','padding','5px 0px 0px 15px']]);
}

queryMapLayers.prototype.currentMapRights = function()
{
    var mapProperties = _layersTree.treeModel && _layersTree.treeModel.getMapProperties();
	return mapProperties ? mapProperties.Access : "none";
}

queryMapLayers.prototype.layerRights = function(name)
{
    var layer = nsGmx.gmxMap.layersByID[name];
	return layer ? layer.getGmxProperties().Access : null;
}

queryMapLayers.prototype.addUserActions = function()
{
	if (this.currentMapRights() == "edit")
	{
		this.addDraggable(this.treeCanvas);

		this.addDroppable(this.treeCanvas);

		this.addSwappable(this.treeCanvas);
	}
}

queryMapLayers.prototype.removeUserActions = function()
{
//	removeChilds(this.buttonsCanvas);

	this.removeDraggable(this.treeCanvas);

	this.removeDroppable(this.treeCanvas);

	this.removeSwappable(this.treeCanvas);
}

queryMapLayers.prototype.addDraggable = function(parent)
{
	$(parent).find("span[dragg]").draggable(
	{
		helper: function(ev)
		{
			return _layersTree.dummyNode(ev.target)
		},
		cursorAt: { left: 5 , top: 10},
		appendTo: document.body
	});
}
queryMapLayers.prototype.removeDraggable = function(parent)
{
	$(parent).find("span[dragg]").draggable('destroy');
}

queryMapLayers._droppableHandler = function(ev, ui)
{
    $('body').css("cursor", '');

    // удалим элемент, отображающий копирование
    ui.helper[0].removeNode(true)

    // уберем заведомо ложные варианты - сам в себя, копирование условий
    if (this == ui.draggable[0].parentNode.parentNode) return;

    var circle = false,
        layerManager = false;

    $(this).parents().each(function()
    {
        if ($(this).prev().length > 0 && $(this).prev()[0] == ui.draggable[0].parentNode.parentNode)
            circle = true;
    })

    if (circle) return;

    var isFromExternalMaps = false;
    $(ui.draggable[0].parentNode.parentNode).parents().each(function()
    {
        if (this == $('#layersList')[0] || this == $('#mapsList')[0] || this == $('#externalMapsCanvas')[0] )
            layerManager = true;

        if ( this == $('#externalMapsCanvas')[0] )
            isFromExternalMaps = true;
    })

    if (!layerManager)
        _layersTree.moveHandler(ui.draggable[0], this)
    else
        _layersTree.copyHandler(ui.draggable[0].parentNode.parentNode.gmxProperties, this, false, !isFromExternalMaps)
}

queryMapLayers.prototype.addDroppable = function(parent)
{
	$(parent).find("div[GroupID],div[MapID]").droppable({
        accept: "span[dragg]",
        hoverClass: 'droppableHover',
        greedy: true,
        drop: queryMapLayers._droppableHandler
    })

    $(parent).find("div[LayerID],div[MultiLayerID]").droppable({
        accept: "span[dragg]",
        greedy: true,
        drop: function(ev, ui) {
            var swapElem = $(this).next();
            swapElem.removeClass('swap-droppableHover');
            queryMapLayers._swapHandler.call(swapElem[0], ev, ui);
        },
        over: function(ev, ui) {
            $(this).next().addClass('swap-droppableHover');
        },
        out: function(ev, ui) {
            $(this).next().removeClass('swap-droppableHover');
        }
    })
}
queryMapLayers.prototype.removeDroppable = function(parent)
{
	$(parent).find("div[GroupID],div[MapID]").droppable('destroy');
}

//статическая ф-ция
queryMapLayers._swapHandler = function(ev, ui)
{
    $('body').css("cursor", '');

    // удалим элемент, отображающий копирование
    ui.helper[0].removeNode(true);

    //проверим, не идёт ли копирование группы внутрь самой себя
    var circle = false;

    $(this).parents().each(function()
    {
        if ($(this).prev().length > 0 && $(this).prev()[0] == ui.draggable[0].parentNode.parentNode)
            circle = true;
    })

    if (circle) return;

    var layerManager = false;

    var isFromExternalMaps = false;
    $(ui.draggable[0].parentNode.parentNode).parents().each(function()
    {
        if ( this == $('#layersList')[0] || this == $('#mapsList')[0] || this == $('#externalMapsCanvas')[0] )
            layerManager = true;

        if ( this == $('#externalMapsCanvas')[0] )
            isFromExternalMaps = true;
    })

    var gmxProperties = ui.draggable[0].parentNode.parentNode.gmxProperties;

    if (!layerManager)
        _layersTree.swapHandler(ui.draggable[0], this)
    else
        _layersTree.copyHandler(gmxProperties, this, true, !isFromExternalMaps)
}

queryMapLayers.prototype.addSwappable = function(parent)
{
	$(parent).find("div[swap]").droppable({accept: "span[dragg]", hoverClass: 'swap-droppableHover', greedy: true, drop: queryMapLayers._swapHandler})
}
queryMapLayers.prototype.removeSwappable = function(parent)
{
	$(parent).find("div[swap]").droppable('destroy');
}

queryMapLayers.prototype.asyncCreateLayer = function(promise, title)
{
    var _this = this;

    var taskDiv = _div(),
        active = $(_this.buildedTree).find(".active")[0],
        parentDiv;

    if (active && (active.parentNode.getAttribute('MapID') || active.parentNode.getAttribute('GroupID')))
        parentDiv = active.parentNode.parentNode;
    else
        parentDiv = _this.buildedTree.firstChild;

    _abstractTree.addNode(parentDiv, _li([taskDiv, _div(null,[['css','height','5px'],['css','fontSize','0px']])]));

    promise.fail(function(taskInfo)
    {
        var parentTree = taskDiv.parentNode.parentNode;
        taskDiv.parentNode.removeNode(true);
        _abstractTree.delNode(null, parentTree, parentTree.parentNode);
	}).done(function(taskInfo)
    {
        if (!$.isArray(taskInfo.Result)) {
            taskInfo.Result = [taskInfo.Result];
        }

        var parentDiv = $(taskDiv.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0],
            parentProperties = parentDiv.gmxProperties;

        var parentTree = taskDiv.parentNode.parentNode;
        taskDiv.parentNode.removeNode(true);
        _abstractTree.delNode(null, parentTree, parentTree.parentNode);

        for (var l = 0; l < taskInfo.Result.length; l++) {
            var newLayer = taskInfo.Result[l];
            var newProps = newLayer.properties;

            var mapProperties = _layersTree.treeModel.getMapProperties();
            newProps.mapName = mapProperties.name;
            newProps.hostName = mapProperties.hostName;
            newProps.visible = true;

            if (!newProps.styles)
            {
                if (newProps.type == 'Vector')
                    newProps.styles = [{MinZoom:1, MaxZoom:21, RenderStyle: newProps.IsPhotoLayer ? _mapHelper.defaultPhotoIconStyles[newProps.GeometryType] : _mapHelper.defaultStyles[newProps.GeometryType]}]
                else if (newProps.type != 'Vector' && !newProps.MultiLayerID)
                    newProps.styles = [{MinZoom: newProps.MinZoom, MaxZoom: 21}];
            }

            var convertedCoords = newLayer.geometry ? L.gmxUtil.convertGeometry(newLayer.geometry, true) : null;

            _layersTree.addLayersToMap({content:{properties: newProps, geometry: newLayer.geometry}});

            var li = _layersTree.getChildsList(
                    {
                        type: 'layer',
                        content: {properties:newProps, geometry:convertedCoords}
                    },
                    parentProperties,
                    false,
                    parentDiv.getAttribute('MapID') ? true : _layersTree.getLayerVisibility(parentDiv.firstChild)
                );

            _abstractTree.addNode(parentDiv.parentNode, li);

            var divElem = $(li).children("div[LayerID]")[0],
                divParent = $(li.parentNode.parentNode).children("div[MapID],div[GroupID]")[0];

            _layersTree.addTreeElem(divParent, 0, {type:'layer', content: {properties: newProps, geometry: convertedCoords}});

            _queryMapLayers.addSwappable(li);

            _queryMapLayers.addDraggable(li);

            _layersTree.updateListType(li);
        }

		_mapHelper.updateUnloadEvent(true);
        _layersTree.updateZIndexes();
    }).progress(function(taskInfo)
	{
        $(taskDiv).empty();
		_(taskDiv, [_span([_t(title + ':')], [['css','color','#153069'],['css','margin','0px 3px']]), _t(taskInfo.Status)])
	})
}

queryMapLayers.prototype.asyncUpdateLayer = function(promise, properties, recreateLayer)
{
    var layerDiv = $(_queryMapLayers.buildedTree).find("[LayerID='" + properties.LayerID + "']")[0],
        _this = this;

    promise
        .done(function(taskInfo)
        {
            if (recreateLayer)
            {
                var newLayerProperties = taskInfo.Result.properties;

                var mapProperties = _layersTree.treeModel.getMapProperties();
                newLayerProperties.mapName = mapProperties.name;
                newLayerProperties.hostName = mapProperties.hostName;
                newLayerProperties.visible = layerDiv.gmxProperties.content.properties.visible;

                newLayerProperties.styles = layerDiv.gmxProperties.content.properties.styles;

                //var convertedCoords = from_merc_geometry(taskInfo.Result.geometry);
                var origGeometry = taskInfo.Result.geometry,
                    convertedGeometry = origGeometry ? L.gmxUtil.geometryToGeoJSON(origGeometry, true) : null;

                _this.removeLayer(newLayerProperties.name);

                _layersTree.addLayersToMap({content: {properties: newLayerProperties, geometry: origGeometry}});

                var parentProperties = $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0].gmxProperties,
                    li = _layersTree.getChildsList({type:'layer', content:{properties:newLayerProperties, geometry:convertedGeometry}}, parentProperties, false, _layersTree.getLayerVisibility(layerDiv.firstChild));

                $(li).find('[multiStyle]').treeview();

                $(layerDiv.parentNode).replaceWith(li);

                _layersTree.findTreeElem($(li).children("div[LayerID]")[0]).elem = {type:'layer', content:{properties: newLayerProperties, geometry: convertedGeometry}}

                _queryMapLayers.addSwappable(li);

                _queryMapLayers.addDraggable(li);

                _layersTree.updateListType(li);
                _layersTree.updateZIndexes();
            }
            else
            {
                $('#' + taskInfo.TaskID).remove();

                layerDiv.style.display = '';
            }
        }).fail(function(taskInfo)
        {
            $('#' + taskInfo.TaskID).remove();
            layerDiv.style.display = '';
        }).progress(function(taskInfo)
        {
            var taskDiv;

            if (!$('#' + taskInfo.TaskID).length)
            {
                taskDiv = _div(null, [['attr','id',taskInfo.TaskID]]);

                layerDiv.style.display = 'none';

                $(layerDiv).before(taskDiv);
            }
            else
            {
                taskDiv = $('#' + taskInfo.TaskID)[0];

                $(taskDiv).empty();
            }

            _(taskDiv, [_span([_t(properties.Title + ':')], [['css','color','#153069'],['css','margin','0px 3px']]), _t(taskInfo.Status)]);
        })
}

queryMapLayers.prototype.asyncCopyLayer = function(promise, title) {
	console.log('layer copied');

	var _this = this;

    var taskDiv = _div(),
        active = $(_this.buildedTree).find(".active")[0],
        parentDiv;

    if (active && (active.parentNode.getAttribute('MapID') || active.parentNode.getAttribute('GroupID')))
        parentDiv = active.parentNode.parentNode;
    else
        parentDiv = _this.buildedTree.firstChild;

    _abstractTree.addNode(parentDiv, _li([taskDiv, _div(null,[['css','height','5px'],['css','fontSize','0px']])]));

    promise.fail(function(taskInfo)
    {
		console.log('failed');
        var parentTree = taskDiv.parentNode.parentNode;
        taskDiv.parentNode.removeNode(true);
        _abstractTree.delNode(null, parentTree, parentTree.parentNode);
	}).done(function(taskInfo)
    {
		console.log('ok');
        if (!$.isArray(taskInfo.Result)) {
            taskInfo.Result = [taskInfo.Result];
        }

        var parentDiv = $(taskDiv.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0],
            parentProperties = parentDiv.gmxProperties;

        var parentTree = taskDiv.parentNode.parentNode;
        taskDiv.parentNode.removeNode(true);
        _abstractTree.delNode(null, parentTree, parentTree.parentNode);

        for (var l = 0; l < taskInfo.Result.length; l++) {
            var newLayer = taskInfo.Result[l];
            var newProps = newLayer.properties;

            var mapProperties = _layersTree.treeModel.getMapProperties();
            newProps.mapName = mapProperties.name;
            newProps.hostName = mapProperties.hostName;
            newProps.visible = true;

            if (!newProps.styles)
            {
                if (newProps.type == 'Vector')
                    newProps.styles = [{MinZoom:1, MaxZoom:21, RenderStyle: newProps.IsPhotoLayer ? _mapHelper.defaultPhotoIconStyles[newProps.GeometryType] : _mapHelper.defaultStyles[newProps.GeometryType]}]
                else if (newProps.type != 'Vector' && !newProps.MultiLayerID)
                    newProps.styles = [{MinZoom: newProps.MinZoom, MaxZoom: 21}];
            }

            var convertedCoords = newLayer.geometry ? L.gmxUtil.convertGeometry(newLayer.geometry, true) : null;

            _layersTree.addLayersToMap({content:{properties: newProps, geometry: newLayer.geometry}});

            var li = _layersTree.getChildsList(
                    {
                        type: 'layer',
                        content: {properties:newProps, geometry:convertedCoords}
                    },
                    parentProperties,
                    false,
                    parentDiv.getAttribute('MapID') ? true : _layersTree.getLayerVisibility(parentDiv.firstChild)
                );

            _abstractTree.addNode(parentDiv.parentNode, li);

            var divElem = $(li).children("div[LayerID]")[0],
                divParent = $(li.parentNode.parentNode).children("div[MapID],div[GroupID]")[0];

            _layersTree.addTreeElem(divParent, 0, {type:'layer', content: {properties: newProps, geometry: convertedCoords}});

            _queryMapLayers.addSwappable(li);

            _queryMapLayers.addDraggable(li);

            _layersTree.updateListType(li);
        }

		_mapHelper.updateUnloadEvent(true);
        _layersTree.updateZIndexes();
    }).progress(function(taskInfo)
	{
		console.log('progress');
        $(taskDiv).empty();
		_(taskDiv, [_span([_t(title + ':')], [['css','color','#153069'],['css','margin','0px 3px']]), _t(taskInfo.Status)])
	}).always(function(taskInfo){
		console.log(taskInfo);
	})
}

queryMapLayers.prototype.removeLayer = function(name)
{
    var layer = nsGmx.gmxMap.layersByID[name];
    if (layer) {
        nsGmx.leafletMap.removeLayer(layer);
        nsGmx.gmxMap.removeLayer(layer);
    }
}

queryMapLayers.prototype.getLayers = function()
{
    this.createLayersManager();
}

queryMapLayers.prototype.createLayersManager = function()
{
	var canvas = _div();
	var layerManagerControl = new nsGmx.LayerManagerControl(canvas, 'layers');

    var existLayers = [];
    for (var i = 0; i < nsGmx.gmxMap.layers.length; i++)
        existLayers.push(nsGmx.gmxMap.layers[i].getGmxProperties().name);

    layerManagerControl.disableLayers(existLayers);

	var dialogDiv = showDialog(_gtxt("Список слоев"), canvas, 571, 485, 535, 130, function(size) {
        layerManagerControl.resize(size.height - 55);
    });
}

queryMapLayers.prototype.getMaps = function()
{
	if (!$('#mapsList').length)
        new nsGmx.MapsManagerControl();
}

queryMapLayers.prototype.createMapDialog = function(title, buttonName, func, addLink)
{
	var uiTemplate = Handlebars.compile(
        '<div class = "createMap-container">' +
            '<input class = "inputStyle inputFullWidth createMap-input">' +
            '<button class = "createMap-button">{{buttonName}}</button>' +
        '</div>');

    var ui = $(uiTemplate({buttonName: buttonName})),
        input = $('.createMap-input', ui)[0];

    var tryCreateMap = function() {
        input.focus();
        if (input.value != '') {
            removeDialog(dialogDiv);
            func(input.value);
        } else {
            inputError(input);
        }
    }

	$(input, ui).on('keydown', function(e) {
	  	if (e.keyCode === 13) {
            tryCreateMap();
	  		return false;
	  	}
	})

	$('.createMap-button', ui).click(tryCreateMap)

	addLink && ui.append(addLink);

	var dialogDiv = showDialog(title, ui[0], 280, 115 + (addLink ? 20 : 0), false, false);
}

queryMapLayers.prototype.createMap = function(name)
{
	sendCrossDomainJSONRequest(serverBase + 'Map/Insert.ashx?WrapStyle=func&Title=' + encodeURIComponent(name), function(response)
	{
		if (!parseResponse(response))
			return;

		window.location.replace(window.location.href.split(/\?|#/)[0] + "?" + response.Result);
	})
};

(function()
{

    var saveMapInternal = function(scriptName, mapTitle, callback)
    {
        var mapID = String($(_queryMapLayers.buildedTree).find("[MapID]")[0].gmxProperties.properties.MapID),
            saveTree = {};

        window._mapEditorsHash && _mapEditorsHash[mapID] && _mapEditorsHash[mapID].update();

        //обновим стили слоёв из всех незакрытых диалогов редактирования стилей
        var mStyleEditor = gmxCore.getModule('LayerStylesEditor');
        mStyleEditor && mStyleEditor.updateAllStyles();

        nsGmx.userObjectsManager.collect();
        $(_queryMapLayers.buildedTree).find("[MapID]")[0].gmxProperties.properties.UserData = JSON.stringify(nsGmx.userObjectsManager.getData());

        $.extend(true, saveTree, _layersTree.treeModel.getRawTree());

        var attributesToSave = ['visible', 'styles', 'AllowSearch', 'TiledQuicklook', 'TiledQuicklookMinZoom', 'name', 'MapStructureID'];
        saveTree.properties.BaseLayers = JSON.stringify(nsGmx.leafletMap.gmxBaseLayersManager.getActiveIDs());

        //раскрываем все группы так, как записано в свойствах групп
        _mapHelper.findTreeElems(saveTree, function(child, flag)
        {
            var props = child.content.properties;
            if (child.type === "group") {
                props.expanded = typeof props.initExpand !== 'undefined' ? props.initExpand : false;
                delete props.initVisible;
                delete props.initExpand;
            } else {
                var propsToSave = {};
                for (var i = 0; i < attributesToSave.length; i++) {
                    var attrName = attributesToSave[i];
                    if (attrName in props) {
                        propsToSave[attrName] = props[attrName];
                    }
                }

                var styles = props.styles || [];

                for (var s = 0; s < styles.length; s++) {
                    delete styles[s].HoverStyle;
                }

                child.content.properties = propsToSave;
                delete child.content.geometry;
            }
        }, true);

        var params = {
                WrapStyle: 'window',
                MapID: mapID,

                MapJson: JSON.stringify(saveTree)
            }

        if (mapTitle)
            params.Title = mapTitle;

        sendCrossDomainPostRequest(serverBase + scriptName, params,
            function(response)
            {
                if (!parseResponse(response))
                    return;

                callback && callback(response.Result);

                _mapHelper.updateUnloadEvent(false);

                nsGmx.widgets.notifications.stopAction('saveMap', 'success', _gtxt("Сохранено"));
            }
        )
    }

    queryMapLayers.prototype.saveMap = function()
    {
        nsGmx.widgets.notifications.startAction('saveMap');
		saveMapInternal("Map/SaveMap.ashx", null);
    }

    queryMapLayers.prototype.saveMapAs = function(name)
    {
        nsGmx.widgets.notifications.startAction('saveMap');
        saveMapInternal("Map/SaveAs.ashx", name);
    }

})();

var _queryMapLayers = new queryMapLayers();
window._queryMapLayers = _queryMapLayers;

mapLayers.mapLayers.load = function()
{
	var alreadyLoaded = _queryMapLayers.createWorkCanvas('layers', {
            path: null,
            showCloseButton: false,
            showMinimizeButton: false
        });

	if (!alreadyLoaded)
		_queryMapLayers.load()
}
mapLayers.mapLayers.unload = function()
{
}

})(nsGmx.Utils._);

!(function() {
//Контроллёр контектных меню и соответствующие пункты всех меню...

nsGmx = nsGmx || {};

/** 
* Контроллёр контекстных меню.
* @class
* @name ContextMenuController
* @memberOf nsGmx
* 
* @description Позволяет добавлять элементы контектсного меню разного типа и привязывать меню к отдельным DOM элементам. 
* Возможно динамическое создание меню при клике на объекте. Элементам меню передаётся контекст, 
* указанный при привязке меню к элементу (он так же может создаваться в момент клика на элементе)
* Каждый элемент меню - отдельный объект, они независимо добавляются в контроллер. 
* При создании меню определённого типа из этого набора выбираются нужные элементы.
*/
nsGmx.ContextMenuController = (function()
{
	var _menuItems = {};
	var SUGGEST_TIMEOUT = 700;
	
	// Показывает контектное меню для конкретного элемента. 
	// В Opera меню показывается при наведении на элемент в течении некоторого времени, во всех остальных браузерах - по правому клику.
	// Меню исчезает при потере фокуса
	// Параметры:
	// * elem {DOMElement} - элемент, на который навешивается меню
	// * menuFunc {Function, menuFunc()->DomElement} - функция, создающая меню
	// * checkFunc {Function, checkFunc()->Bool} - если возвращает false, то ничего не показывается...
	var _context = function(elem, menuFunc, checkFunc)
	{
        var menu = null;
        elem.oncontextmenu = function(e)
        {
            if (typeof checkFunc != 'undefined' && !checkFunc())
                return false;
                
            if (menu && menu.parentNode) 
                menu.parentNode.removeChild(menu);
                
            menu = menuFunc();
            if (!menu) return false;
            
            var contextMenu = _div([menu],[['dir','className','contextMenu'], ['attr','id','contextMenuCanvas']])
            
            var evt = e || window.event;
            
            hidden(contextMenu);
            document.body.appendChild(contextMenu)
            
            // определение координат курсора для ie
            if (evt.pageX == null && evt.clientX != null )
            {
                var html = document.documentElement
                var body = document.body
                
                evt.pageX = evt.clientX + (html && html.scrollLeft || body && body.scrollLeft || 0) - (html.clientLeft || 0)
                evt.pageY = evt.clientY + (html && html.scrollTop || body && body.scrollTop || 0) - (html.clientTop || 0)
            }
            
            if (evt.pageX + contextMenu.clientWidth < getWindowWidth())
                contextMenu.style.left = evt.pageX - 5 + 'px';
            else
                contextMenu.style.left = evt.pageX - contextMenu.clientWidth + 5 + 'px';
            
            if (evt.pageY + contextMenu.clientHeight < getWindowHeight())
                contextMenu.style.top = evt.pageY - 5 + 'px';
            else
                contextMenu.style.top = evt.pageY - contextMenu.clientHeight + 5 + 'px';
            
            visible(contextMenu)
            
            var menuArea = contextMenu.getBoundingClientRect();
            
            contextMenu.onmouseout = function(e)
            {
                var evt = e || window.event;
                
                // определение координат курсора для ie
                if (evt.pageX == null && evt.clientX != null )
                {
                    var html = document.documentElement
                    var body = document.body
                    
                    evt.pageX = evt.clientX + (html && html.scrollLeft || body && body.scrollLeft || 0) - (html.clientLeft || 0)
                    evt.pageY = evt.clientY + (html && html.scrollTop || body && body.scrollTop || 0) - (html.clientTop || 0)
                }
                
                if (evt.pageX <= menuArea.left || evt.pageX >= menuArea.right ||
                    evt.clientY <= menuArea.top || evt.clientY >= menuArea.bottom)
                {
                    menu = null;
                    contextMenu.removeNode(true);
                }
            }
            
            return false;
        }
	}	
	
	var _contextClose = function()
	{
        $('#contextMenuCanvas').remove();
	}	
	
	var _generateMenuDiv = function(type, context)
	{
        var uiTemplate = Handlebars.compile('<div>' +
            '{{#menuItems}}' +
                '{{#if separator}}<div class = "contextMenuSeparator"></div>{{/if}}' + 
                '<div class = "contextMenuItem" data-itemIndex="{{index}}">{{title}}</div>' +
            '{{/menuItems}}' +
        '</div>');
        
		var items = _menuItems[type],
            visibleItems = [];
		
		for (var e = 0; e < items.length; e++) {
			var menuElem = items[e];
            if (menuElem.isVisible && !menuElem.isVisible(context)) {
                continue;
            }
            
            visibleItems.push({
                index: e,
                title: typeof menuElem.title === 'function' ? menuElem.title() : menuElem.title,
                separator: menuElem.isSeparatorBefore && menuElem.isSeparatorBefore(context)
            });
        }
        
        if (visibleItems.length) {
            var ui = $(uiTemplate({menuItems: visibleItems}));
            ui.find('.contextMenuItem').click(function() {
                var itemIndex = Number($(this).data('itemindex'));
                context.contentMenuArea = getOffsetRect(this);
                context.contentMenuType = type;
                _contextClose();
                _menuItems[type][itemIndex].clickCallback(context);
            });
            
            return ui[0];
        }
        
        return null;
	}
	
	//public interface
	return {
	
		/**
		 * Добавляет новый пункт меню
         * @memberOf nsGmx.ContextMenuController
		 * @function
		 * @param {nsGmx.ContextMenuController.IContextMenuElem} menuItem Элемент контекстного меню
		 * @param {String | String[]} menuType Тип меню (например: "Layer", "Map", "Group"). Если массив, то данный элемент применяется в нескольких типах меню
		 */
		addContextMenuElem: function(menuItem, menuType)
		{
			if (typeof menuType === 'string')
				menuType = [menuType];
				
			for (var i = 0; i < menuType.length; i++)
			{
				_menuItems[menuType[i]] = _menuItems[menuType[i]] || [];
				_menuItems[menuType[i]].push(menuItem);
			}
		},
		
		/**
		 * Добавляет к DOM элементу контекстное меню
		 * @function
         * @memberOf nsGmx.ContextMenuController
		 * @param {DOMElement} elem Целевой DOM-элемент
		 * @param {String} type Тип меню
		 * @param {function():Boolean} checkFunc Проверка, показывать ли сейчас меню. Если ф-ция возвращает false, меню не показывается
		 * @param {Object|function(context):Object} context Контекст, который будет передан в элемент меню при клике на DOM-элементе. 
		 *        Если контект - ф-ция, она будет вызвана непосредственно при клике. В контекст при клике будут добавлены элементы contentMenuArea и contentMenuType.
		 */
		bindMenuToElem: function(elem, type, checkFunc, context)
		{
			_context(elem, function()
			{
				if (typeof context === 'function')
					context = context(); //
					
				return _generateMenuDiv(type, context);
			}, checkFunc, SUGGEST_TIMEOUT)
		}
	}
})();


/** Интерфейс для задания контекстного меню пользователей
* @class
* @name nsGmx.ContextMenuController.IContextMenuElem
*/

/** Нужно ли отображать данный пункт меню для данного элемента и типа дерева. Необязательная (по умолчанию отображается)
@function
@name isVisible
@memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
@param {Object} context - контекст, специфический для конкретного типа меню
*/

/** Нужно ли рисовать перед данным пунктом разделитель (гориз. черту). Необязательная (по умолчанию не рисуется)
@function
@name isSeparatorBefore
@memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
@param {Object} context - контекст, специфический для конкретного типа меню
*/

/** Вызывается при клике по соответствующему пункту меню
* @function
* @name clickCallback
* @memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
* @param {object} context - контекст, который был передан при привязке меню к DOM-элементу. В контекст будут добавлены поля:
* 
*  * contentMenuArea {Object} - координаты верхнего левого угла пункта меню, на которое было нажатие. {left: int, top: int}. Если нужно привязаться к месту текущего клика
*  * contentMenuType {String}- тип вызванного контекстного меню. Актуально, если элемент меню используется в нескольких типах меню.
*/

/** Строка или ф-ция, которую нужно отображать в контекстном меню. Если ф-ция, то она будет вызываться при каждом формировании меню и должна возвращать строку.
@name title
@memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
*/


//Все заголовки элементов меню заданы как ф-ции, так как на момент выполенения этого кода неизвестен выбранный язык системы

///////////////////////////////////////////////////////////////////////////////
/////////////////////////// Контекстное меню слоёв ////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/*
В контексте типа "Layer" присутствуют следующие атрибуты:
 * layerManagerFlag {int} Тип дерева
 * elem Элемент (слой), для которого стротся меню
 * tree {layersTree} Текущее дерево, внутри которого находится слой
*/

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Свойства"); },
	isVisible: function(context)
	{
		return !context.layerManagerFlag && nsGmx.AuthManager.isLogin();
	},
	clickCallback: function(context)
	{
		var div;
		if (context.elem.MultiLayerID)
			div = $(_queryMapLayers.buildedTree).find("div[MultiLayerID='" + context.elem.MultiLayerID + "']")[0];
		else
			div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + context.elem.name + "']")[0];
		_mapHelper.createLayerEditor(div, context.tree, 'main', div.gmxProperties.content.properties.styles.length > 1 ? -1 : 0);
	}
}, 'Layer');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Стили"); },
	isVisible: function(context)
	{
		return !context.layerManagerFlag && context.elem.type === "Vector" && _queryMapLayers.currentMapRights() === "edit";
	},
	clickCallback: function(context)
	{
        nsGmx.createStylesDialog(context.elem, context.tree);
	}
}, 'Layer');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Таблица атрибутов"); },
	isVisible: function(context)
	{
		return !context.layerManagerFlag && (_queryMapLayers.currentMapRights() === "edit" || _queryMapLayers.layerRights(context.elem.name) == 'edit' || _queryMapLayers.layerRights(context.elem.name) === 'editrows') && context.elem.type === "Vector";
	},
	clickCallback: function(context)
	{
		nsGmx.createAttributesTable(context.elem.name);
	}
}, 'Layer');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Права доступа"); },
	isVisible: function(context)
	{
		return !context.layerManagerFlag && 
				nsGmx.AuthManager.canDoAction( nsGmx.ACTION_SEE_MAP_RIGHTS ) && 
				_queryMapLayers.layerRights(context.elem.name) === 'edit';
	},
	clickCallback: function(context) {
		if (context.elem.MultiLayerID) {
            var securityDialog = new nsGmx.multiLayerSecurity();
			securityDialog.getRights(context.elem.MultiLayerID, context.elem.title);
        } else {
            var securityDialog = new nsGmx.layerSecurity(context.elem.type);
			securityDialog.getRights(context.elem.name, context.elem.title);
        }
	}
}, 'Layer');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Скачать"); },
	isVisible: function(context)
	{
		return !context.layerManagerFlag && 
				( _queryMapLayers.currentMapRights() === "edit" || (_queryMapLayers.currentMapRights() == "view" && nsGmx.AuthManager.isLogin() ) ) && 
				context.elem.type == "Vector" &&
				context.tree.treeModel.getMapProperties().CanDownloadVectors;
	},
	clickCallback: function(context)
	{
		_mapHelper.downloadVectorLayer({
            name: context.elem.name,
            host: context.elem.hostName
        });
	}
}, 'Layer');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Удалить"); },
	isVisible: function(context)
	{
		return !context.layerManagerFlag && _queryMapLayers.currentMapRights() === "edit";
	},
	clickCallback: function(context)
	{
		_queryMapLayers.removeLayer(context.elem.name)
		
		var div;
			
		if (context.elem.MultiLayerID)
			div = $(_queryMapLayers.buildedTree).find("div[MultiLayerID='" + context.elem.MultiLayerID + "']")[0];
		else
			div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + context.elem.name + "']")[0];
		
		var treeElem = _layersTree.findTreeElem(div).elem,
			node = div.parentNode,
			parentTree = node.parentNode;
		
		_layersTree.removeTreeElem(div);

		node.removeNode(true);
		
		_abstractTree.delNode(null, parentTree, parentTree.parentNode);
		
		_mapHelper.updateUnloadEvent(true);
	}
}, 'Layer');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Добавить снимки"); },
	isVisible: function(context)
	{
        var layerRights = _queryMapLayers.layerRights(context.elem.name);
		return !context.layerManagerFlag &&
               (layerRights === 'edit' || layerRights === 'editrows') && 
               context.elem.type == "Vector" &&
               context.elem.IsRasterCatalog;
	},
	clickCallback: function(context)
	{
        new nsGmx.RCAddLayerControl(nsGmx.gmxMap, context.elem.name);
	}
}, 'Layer');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Копировать стиль"); },
	isVisible: function(context)
	{
		return context.elem.type == "Vector" && 
		       (context.layerManagerFlag || _queryMapLayers.currentMapRights() === "edit");
	},
	isSeparatorBefore: function(context)
	{
		return !context.layerManagerFlag;
	},
	clickCallback: function(context)
	{            
		var rawTree = context.tree.treeModel,
            elem;
        if (context.elem.MultiLayerID)
			elem = rawTree.findElem("MultiLayerID", context.elem.MultiLayerID).elem;
		else
			elem = rawTree.findElem("LayerID", context.elem.name).elem;

        nsGmx.ClipboardController.addItem('LayerStyle', {type: context.elem.GeometryType, style: elem.content.properties.styles});
	}
}, 'Layer');

var applyStyleContentMenuItem = {
	title: function() { return _gtxt("Применить стиль"); },
	isVisible: function(context)
	{
        if (context.layerManagerFlag || 
            _queryMapLayers.currentMapRights() !== "edit" || 
            nsGmx.ClipboardController.getCount('LayerStyle') === 0 ) 
        {
            return false;
        }
        
        if (context.contentMenuType === 'Layer') {
            return context.elem.type == "Vector" && 
                nsGmx.ClipboardController.get('LayerStyle', -1).type === context.elem.GeometryType;
        } else { //группы
            return true;
        }
	},
	clickCallback: function(context)
	{
		var 
            newStyles = nsGmx.ClipboardController.get('LayerStyle', -1).style,
            stylesType = nsGmx.ClipboardController.get('LayerStyle', -1).type;
            
		if (context.contentMenuType === 'Layer') {
            var div;
            if (context.elem.MultiLayerID)
                div = $(_queryMapLayers.buildedTree).find("div[MultiLayerID='" + context.elem.MultiLayerID + "']")[0];
            else
                div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + context.elem.name + "']")[0];
            
            div.gmxProperties.content.properties.styles = newStyles;
            
            _mapHelper.updateMapStyles(newStyles, context.elem.name);
            
            _mapHelper.updateTreeStyles(newStyles, div, context.tree, true);
        } else { //группа
            var tree = context.tree.treeModel,
                node = tree.findElemByGmxProperties(context.div.gmxProperties).elem;
                
            tree.forEachLayer(function(layerContent) {
                if (layerContent.properties.type !== "Vector" || layerContent.properties.GeometryType !== stylesType){
                    return;
                };
                
                layerContent.properties.styles = newStyles;
                _mapHelper.updateMapStyles(newStyles, layerContent.properties.name);
                
                var div = context.tree.findUITreeElem({content: layerContent});
                if (div) {
                    // div.gmxProperties.content.properties.styles = newStyles;
                    _mapHelper.updateTreeStyles(newStyles, div, context.tree, true);
                }
            }, node);
        }
	}
};

nsGmx.ContextMenuController.addContextMenuElem(applyStyleContentMenuItem, 'Layer');

///////////////////////////////////////////////////////////////////////////////
/////////////////////////// Контекстное меню групп ////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/*
В контексте типа "Group" присутствуют следующие атрибуты:
 * div {DOMElement} Элемент дерева, для которого стротся меню
 * tree {layersTree} Текущее дерево карты
*/

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Свойства"); },
	clickCallback: function(context)
	{
		nsGmx.createGroupEditor(context.div);
	}
}, 'Group');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Добавить подгруппу"); },
	clickCallback: function(context)
	{
		nsGmx.addSubGroup(context.div, context.tree);
	}
}, 'Group');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Удалить"); },
	clickCallback: function(context)
	{
		context.tree.removeGroup(context.div);
		_mapHelper.updateUnloadEvent(true);
	}
}, 'Group');

nsGmx.ContextMenuController.addContextMenuElem(applyStyleContentMenuItem, 'Group');
///////////////////////////////////////////////////////////////////////////////
/////////////////////////// Контекстное меню карты ////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/*
В контексте типа "Map" присутствуют следующие атрибуты:
 * div {DOMElement} Элемент дерева, для которого стротся меню
 * tree {layersTree} Текущее дерево карты
*/
nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Свойства"); },
	clickCallback: function(context)
	{
		nsGmx.createMapEditor(context.div);
	}
}, 'Map');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Добавить подгруппу"); },
	clickCallback: function(context)
	{
		nsGmx.addSubGroup(context.div, context.tree);
	}
}, 'Map');

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Права доступа"); },
	clickCallback: function(context)
	{
        var securityDialog = new nsGmx.mapSecurity();
		securityDialog.getRights(context.tree.treeModel.getMapProperties().MapID, context.tree.treeModel.getMapProperties().title);
	},
	isVisible: function(context)
	{
		return nsGmx.AuthManager.canDoAction(nsGmx.ACTION_SEE_MAP_RIGHTS) &&
            (_queryMapLayers.currentMapRights() === "edit" || nsGmx.AuthManager.isRole(nsGmx.ROLE_ADMIN));
	}
}, 'Map');

//групповое редактирование слоев
nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Права доступа к слоям"); },
	isVisible: function(context)
	{
		var treeModel = context.tree.treeModel,
			layersFlag = false,
			layersRights = false;
		treeModel.forEachNode(function (node) {
			if (node.type !== 'group') {
				layersFlag = true;
				if (_queryMapLayers.layerRights(node.content.properties.LayerID) === 'edit') {
					layersRights = true;
				}
			}
		});

		return nsGmx.AuthManager.canDoAction( nsGmx.ACTION_SEE_MAP_RIGHTS ) &&
			layersFlag &&
			layersRights;
	},
	clickCallback: function(context) {
        var securityDialog = new nsGmx.layersGroupSecurity(),
			props = _layersTree.treeModel.getMapProperties();
		securityDialog.getRights(props.MapID, props.title);

	}
}, 'Map');

})();

//рисует диалог со списком карт.
//позволяет загрузить карту, просмотреть слои карты, перетащить слой в текущую карту
!(function(_){

nsGmx.MapsManagerControl = function()
{
    var _this = this;
    this._activeIndex = 0;
    this._mapsTable = new nsGmx.ScrollTable();
    this._canvas = _div(null, [['attr','id','mapsList']]);
    this._mapPreview = null;
    
    $(this._canvas).append('<div class="gmx-icon-progress"></div>');
    
    this._dialogDiv = showDialog(_gtxt("Список карт"), this._canvas, 571, 360, 535, 130, this._resize.bind(this));
    
    sendCrossDomainJSONRequest(serverBase + "Map/GetMaps.ashx?WrapStyle=func", function(response)
    {
        $(_this._canvas).empty();
        
        if (!parseResponse(response))
            return;

        _this._drawMapsDialog(response.Result);
    })
    this._previewMapName = null;
}

nsGmx.MapsManagerControl.prototype._resize = function() {
    var canvas = this._canvas,
        mapsTable = this._mapsTable,
        mapPreview = this._mapPreview;
        
    var dialogWidth = canvas.parentNode.parentNode.offsetWidth;
    mapsTable.tableParent.style.width = dialogWidth - 15 - 21 + 'px';
    mapsTable.tableBody.parentNode.parentNode.style.width = dialogWidth + 5 - 21 + 'px';
    mapsTable.tableBody.parentNode.style.width = dialogWidth - 15 - 21 + 'px';

    mapsTable.tablePages.parentNode.parentNode.parentNode.parentNode.style.width = dialogWidth - 12 - 21 + 'px';

    mapsTable.tableParent.style.height = '200px';
    mapsTable.tableBody.parentNode.parentNode.style.height = '170px';
    
    if (mapPreview) {
        mapPreview.style.height = canvas.parentNode.offsetHeight - canvas.firstChild.offsetHeight - 250 + 'px';
        mapPreview.style.width = dialogWidth + 5 - 21 + 'px';
    }
}

nsGmx.MapsManagerControl.prototype._drawMapsDialog = function(mapsList)
{
    var searchUITemplate = Handlebars.compile(
        '<div class="mapslist-search">' +
            '<table class="mapslist-search-table"><tr>' +
                '<td>' +
                    '{{i "Название"}}<input class="inputStyle mapslist-search-name">' +
                '</td><td>' +
                    '{{i "Владелец"}}<input class="inputStyle mapslist-search-owner">' +
                '</td>' +
            '</tr></table>' +
        '</div>');
        
    var searchCanvas = $(searchUITemplate())[0];
	var canvas = this._canvas,
		name = 'maps',
        mapsTable = this._mapsTable,
		_this = this;
	
	var mapNameInput = $('.mapslist-search-name', searchCanvas)[0],
        mapOwnerInput = $('.mapslist-search-owner', searchCanvas)[0];
	_(canvas, [searchCanvas]);
	
	var tableParent = _div(),
		sortFuncs = {};
			
	var sign = function(n1, n2) { return n1 < n2 ? -1 : (n1 > n2 ? 1 : 0) };
	var sortFuncFactory = function(f1, f2) {
		return [
			function(_a,_b){ return sign(f1(_a), f1(_b)) || sign(f2(_a), f2(_b)); },
			function(_b,_a){ return sign(f1(_a), f1(_b)) || sign(f2(_a), f2(_b)); }
		]
	}
	
    var idFunc = function(_a){ return _a.Name; };
    var titleFunc = function(_a){ return String(_a.Title).toLowerCase(); };
    var ownerFunc = function(_a){ return String(_a.Owner).toLowerCase(); };
    var dateFunc  = function(_a){ return _a.LastModificationDateTime; };
    
	sortFuncs[_gtxt('Имя')]                 = sortFuncFactory(titleFunc, idFunc);
	sortFuncs[_gtxt('Владелец')]            = sortFuncFactory(ownerFunc, idFunc);
	sortFuncs[_gtxt('Последнее изменение')] = sortFuncFactory(dateFunc, idFunc);
	
	mapsTable.createTable(tableParent, name, 410, ["", _gtxt("Имя"), _gtxt("Владелец"), _gtxt("Последнее изменение"), ""], ['5%', '55%', '15%', '15%', '5%'], function(map, i)
    {
        return _this._drawMaps.call(this, map, i, _this);
    }, sortFuncs);
    
    mapsTable.getDataProvider().setSortFunctions(sortFuncs);
	
	var inputPredicate = function(value, fieldValue)
    {
        return !!value && String(value).toLowerCase().indexOf(fieldValue) > -1;
    };

    $([mapNameInput, mapOwnerInput]).bind('keydown', function(event) {
        var numItems = mapsTable.getVisibleItems().length;
        
        if (event.keyCode === 13) {
            var firstItem = mapsTable.getVisibleItems()[_this._activeIndex];
            firstItem && window.location.replace(window.location.href.split(/\?|#/)[0] + "?" + firstItem.Name);
        }
        
        if (event.keyCode === 38) {
            _this._activeIndex = Math.max(0, Math.min(_this._activeIndex - 1, numItems - 1));
            $(mapsTable.getDataProvider()).change();
            event.preventDefault();
        }
        
        if (event.keyCode === 40) {
            _this._activeIndex = Math.max(0, Math.min(_this._activeIndex + 1, numItems - 1));
            $(mapsTable.getDataProvider()).change();
            event.preventDefault();
        }
    })
    
	mapsTable.getDataProvider().attachFilterEvents(mapNameInput, 'Title', function(fieldName, fieldValue, vals)
	{
		if (fieldValue == "") {
			return vals;
        }
        
        fieldValue = fieldValue.toLowerCase();
		
        return vals.filter(function(value) {
            return inputPredicate(value[fieldName], fieldValue) || value['Name'].toLowerCase() === fieldValue;
        });
	})
	
	mapsTable.getDataProvider().attachFilterEvents(mapOwnerInput, 'Owner', function(fieldName, fieldValue, vals)
	{
		if (fieldValue == "") {
			return vals;
        }
        
        fieldValue = fieldValue.toLowerCase();
        
        return vals.filter(function(value) {
            return inputPredicate(value[fieldName], fieldValue);
        });
	})

	_(canvas, [tableParent]);
	
	mapsTable.tableHeader.firstChild.childNodes[1].style.textAlign = 'left';

	this._resize();
	
	mapsTable.getDataProvider().setOriginalItems(mapsList);
	
	mapNameInput.focus();
}

nsGmx.MapsManagerControl.prototype._drawMaps = function(map, mapIndex, mapsManager)
{
	var name = makeLinkButton(map.Title),
        img_url = map.Name === mapsManager._previewMapName ? 'img/collapse-arrow-se.png' : 'img/collapse-arrow-right.gif',
		load = makeImageButton(img_url, img_url),
		remove = makeImageButton("img/recycle.png", "img/recycle_a.png");

	_title(name, _gtxt("Загрузить"));
	_title(load, _gtxt("Показать"));
	_title(remove, _gtxt("Удалить"));
	
    name.className = name.className + ' maps-manager-mapname';
	
	name.onclick = function()
	{
		window.location.replace(window.location.href.split(/\?|#/)[0] + "?" + map.Name);
	}
    
    nsGmx.ContextMenuController.bindMenuToElem(name, 'MapListItem', function(){return true;},
    {
        name: map.Name
	});
	
	load.onclick = function()
	{
		$(mapsManager._mapPreview).empty();
		
		var loading = _div([_img(null, [['attr','src','img/progress.gif'],['css','marginRight','10px']]), _t(_gtxt('загрузка...'))], [['css','margin','3px 0px 3px 20px']]);
		
        if (!mapsManager._mapPreview) {
            mapsManager._mapPreview = _div(null, [['css','marginTop','5px'],['css','borderTop','1px solid #216B9C'],['css','overflowY','auto']]);
            $(mapsManager._canvas).append(mapsManager._mapPreview);
            $(mapsManager._dialogDiv).dialog('option', 'height', 550);
            $(mapsManager._dialogDiv).dialog('option', 'minHeight', 550);
            mapsManager._resize();
            
        }
		_(mapsManager._mapPreview, [loading]);
        

		// раз уж мы список получили с сервера, то и карты из этого списка точно нужно загружать с него же...
		mapsManager._loadMapJSON(window.serverBase, map.Name, mapsManager._mapPreview); 

        $(mapsManager._mapsTable.getDataProvider()).change();
	}
	
	remove.onclick = function()
	{
		if (map.Name == defaultMapID)
		{
			showErrorMessage(_gtxt("$$phrase$$_14"), true)
			
			return;
		}
		
		if (map.Name == globalMapName)
		{
			showErrorMessage(_gtxt("$$phrase$$_15"), true)
			
			return;
		}
		
		if (confirm(_gtxt("Вы действительно хотите удалить эту карту?")))
		{
			var loading = loading = _div([_img(null, [['attr','src','img/progress.gif']]), _t(_gtxt('удаление...'))], [['css','marginLeft','5px']]);
		
			$(remove.parentNode.parentNode).replaceWith(_tr([_td([loading], [['attr','colSpan', 5]])]))
			
			sendCrossDomainJSONRequest(serverBase + "Map/Delete.ashx?WrapStyle=func&MapID=" + map.MapID, function(response){mapsManager._deleteMapHandler(response, map.MapID)});
		}
	}
	
	var date = new Date(map.LastModificationDateTime*1000);
	var modificationDateString = $.datepicker.formatDate('dd.mm.yy', date); // + " " + date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds();
	
	var tr = _tr([
		_td([load], [['css','textAlign','center']]), 
		_td([name]), 
		_td([_t(map.Owner)], [['css','textAlign','center'],['dir','className','invisible maps-manager-owner'], ['dir','title',map.Owner]]), 
		_td([_t(modificationDateString)], [['css','textAlign','center'],['dir','className','invisible']]), 
		_td([remove], [['css','textAlign','center']])
	]);
	
	for (var i = 0; i < tr.childNodes.length; i++)
		tr.childNodes[i].style.width = this._fields[i].width;
	
	attachEffects(tr, 'hover');
    
    if (mapsManager._activeIndex === mapIndex) {
        $(tr).addClass('maps-manager-active');
    }
	
	return tr;
}

nsGmx.MapsManagerControl.prototype._deleteMapHandler = function(response, id)
{
	if (!parseResponse(response))
		return;
	
    var mapsTable = this._mapsTable;
    
	if (response.Result == 'deleted')
	{
        mapsTable.start = 0;
		mapsTable.reportStart = mapsTable.start * mapsTable.limit;
        mapsTable.getDataProvider().filterOriginalItems(function(elem)
		{
			return elem.MapID != id;
		});
	}
	else
		showErrorMessage(_gtxt("Ошибка!"), true, _gtxt("Слоя нет в базе"))
}

nsGmx.MapsManagerControl.prototype._loadMapJSON = function(host, name, parent)
{
	//loadMapJSON(host, name, function(layers)
    this._previewMapName = name;
    
    var hostName = L.gmxUtil.normalizeHostname(host),
        apiKey = window.mapsSite ? window.apiKey : null; //передаём apiKey только если не локальная версия ГеоМиксера
    
    L.gmx.gmxMapManager.getMap(hostName, apiKey, name, window.gmxSkipTiles).then(function(mapInfo) {
        var previewLayersTree = new layersTree({showVisibilityCheckbox: false, allowActive: false, allowDblClick: false}),
            ul = previewLayersTree.drawTree(mapInfo, 2);

        $(ul).treeview();

        //раскрываем группы по клику
        $(ul).click(function(event) {
            if ($(event.target).hasClass('groupLayer')) {
                var clickDiv = $(event.target.parentNode.parentNode.parentNode).children("div.hitarea");
                clickDiv.length && $(clickDiv[0]).trigger('click');
            }
        })
		
		$(parent).empty();
        
        var hint = $('<div class="mapslist-hint">' + _gtxt('maplist.hint') + '</div>');

		_(parent, [hint[0], ul]);
		
		_queryMapLayers.addDraggable(parent);
	})
}

nsGmx.ContextMenuController.addContextMenuElem({
    title: function() { return "Открыть в новом окне"; },
    clickCallback: function(context)
    {
        window.open(window.location.href.split(/\?|#/)[0] + "?" + context.name, '_blank');
    }
}, 'MapListItem');

})(nsGmx.Utils._);
//Управление показом списка слоёв и поиска по этому списку
var nsGmx = nsGmx || {};

(function(_){

var LayersListProvider = function(filtersProvider)
{
    var _this = this;
    $(filtersProvider).change(function()
    {
        $(_this).change();
    });
    
    var getQueryText = function()
    {
        var filterStrings = [];
        
        if (filtersProvider.getTitle() !== '')
            filterStrings.push("([Title] containsIC '" + filtersProvider.getTitle() + "' or [Name] = GetLayerName('" + filtersProvider.getTitle() + "'))");
        
        if (filtersProvider.getOwner() !== '')
            filterStrings.push("[OwnerNickname] containsIC '" + filtersProvider.getOwner() + "'");
        
        var types = filtersProvider.getTypes();
        var typeFilters = $.map(types, function(type) {
            if (type === 'catalog')
            {
                return "([LayerType]=LayerTypeCode('vector') AND [IsRasterCatalog]=true)"
            }
            else if (type)
            {
                return "[LayerType]=LayerTypeCode('" + type + "')";
            }
        })
        
        if (typeFilters.length > 0) 
            filterStrings.push('(' + typeFilters.join(' OR ') + ')');
            
        var dateBegin = filtersProvider.getDateBegin();
        var dateEnd = filtersProvider.getDateEnd();
        
        dateBegin && filterStrings.push("[DateCreate] >= '" + $.datepicker.formatDate('yy.mm.dd', dateBegin) + "'");
        dateEnd   && filterStrings.push("[DateCreate] < '"  + $.datepicker.formatDate('yy.mm.dd', dateEnd) + "'");
        
        var layerTags = filtersProvider.getTags();
        
        if (layerTags)
        {
            layerTags.each(function(id, tag, value)
            {
                if (tag)
                {
                    if (value !== '')
                        filterStrings.push("[" + tag + "] containsIC '" + value + "'");
                    else
                        filterStrings.push("PropertyExist('" + tag + "')");
                }
            });
        }
        
        return '&query=' + encodeURIComponent(filterStrings.join(' AND '));
    }
    
    this.getCount = function(callback)
    {
        var query = getQueryText();
        sendCrossDomainJSONRequest(serverBase + 'Layer/Search2.ashx?count=true' + query, function(response)
        {
            if (!parseResponse(response))
            {
                callback();
                return;
            }
            callback(response.Result.count);
        })
    }
    
    this.getItems = function(page, pageSize, sortParam, sortDec, callback)
    {
        this.getCountAndItems(page, pageSize, sortParam, sortDec, function(count, items)
        {
            callback(items);
        })
    }
    
    this.getCountAndItems = function(page, pageSize, sortParam, sortDec, callback)
    {
        var sortParams = {};
        sortParams[_gtxt("Имя")] = "title";
        sortParams[_gtxt("Дата создания")] = "datecreate";
        sortParams[_gtxt("Владелец")] = "ownernickname";
        
        var query = getQueryText();
        
        sendCrossDomainJSONRequest(serverBase + 'Layer/Search2.ashx?page=' + page + '&pageSize=' + pageSize + "&orderby=" + sortParams[sortParam] + " " + (sortDec ? "desc" : "") + query, function(response)
        {
            if (!parseResponse(response))
            {
                callback();
                return;
            }
            
            callback(response.Result.count, response.Result.layers);
        })
    }
}

var drawLayers = function(layer, params)
{
	var _params = $.extend({onclick: function(){ removeLayerFromList(); }, enableDragging: true, disabled: false}, params);
	var newLayerProperties = {properties:layer};
	
    var mapProperties = _layersTree.treeModel.getMapProperties();
	newLayerProperties.properties.mapName = mapProperties.name;
	newLayerProperties.properties.hostName = mapProperties.hostName;
	newLayerProperties.properties.visible = false;
    
    // newLayerProperties.properties.type = newLayerProperties.properties.type === 1 ? 'Vector' : 'Raster';
	
	if (newLayerProperties.properties.type == 'Vector')
		newLayerProperties.properties.styles = [{MinZoom:newLayerProperties.properties.VtMaxZoom, MaxZoom:20, RenderStyle:_mapHelper.defaultStyles[newLayerProperties.properties.GeometryType]}]
	else if (newLayerProperties.properties.type != 'Vector' && !newLayerProperties.properties.MultiLayerID)
		newLayerProperties.properties.styles = [{MinZoom:newLayerProperties.properties.MinZoom, MaxZoom:20}];
	
	var res = _layersTree.drawNode({type: 'layer', content:newLayerProperties}, false, 1),
		icon = res.firstChild.cloneNode(true),
		remove = makeImageButton("img/recycle.png", "img/recycle_a.png"),
		tr,
		tdRemove = (layer.Access == 'edit') ? _td([remove], [['css','textAlign','center']]) : _td(),
		removeLayerFromList = function()
		{
			var active = $(_queryMapLayers.buildedTree).find(".active");
			
            var gmxProperties = $(res).find("span[dragg]")[0].parentNode.parentNode.gmxProperties;
			if (active.length && (active[0].parentNode.getAttribute('MapID') || active[0].parentNode.getAttribute('GroupID'))){
                _layersTree.copyHandler(gmxProperties, active[0].parentNode, false, true)
            } else {
                _layersTree.copyHandler(gmxProperties, $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0], false, true);
            }
            $(res).addClass('gmx-disabled');
		},
		_this = this;
	
	_title(remove, _gtxt("Удалить"));
	
	res.firstChild.removeNode(true);
	
	remove.onclick = function()
	{
		if (confirm(_gtxt("Вы действительно хотите удалить этот слой?")))
		{
			var loading = loading = _div([_img(null, [['attr','src','img/progress.gif']]), _t('удаление...')], [['css','marginLeft','5px']]);
		
			$(remove.parentNode.parentNode).replaceWith(_tr([_td([loading], [['attr','colSpan', 5]])]))
            
            var deleteLayerHandler = function(response, id, flag)
            {
                if (!parseResponse(response))
                    return;
                
                if (response.Result == 'deleted')
                    $(_this.getDataProvider()).change();
                else
                    showErrorMessage(_gtxt("Ошибка!"), true, _gtxt("Слоя нет в базе"));
            }
			
			if (newLayerProperties.properties.MultiLayerID)
				sendCrossDomainJSONRequest(serverBase + "MultiLayer/Delete.ashx?WrapStyle=func&MultiLayerID=" + newLayerProperties.properties.MultiLayerID, deleteLayerHandler);
			else	
				sendCrossDomainJSONRequest(serverBase + "Layer/Delete.ashx?WrapStyle=func&LayerID=" + newLayerProperties.properties.LayerID, deleteLayerHandler);
		}
	}
	
	var span = $(res).find("span.layer")[0];
    
    if (_params.disabled)
            $(span).addClass('invisible');
	
	if (!_params.disabled && _params.onclick)
	{
		span.onclick = function()
		{
			_params.onclick({ elem: layer, scrollTable: _this });
		}
	}
    else
    {
        span.onclick = null;
        $(span).css('cursor', 'auto');
    }
    
    span.ondblclick = null;
	
	if (_params.enableDragging && !params.disabled)
	{
		$(res).find("span[dragg]").draggable(
		{
			helper: function(ev)
			{
				return _layersTree.dummyNode(ev.target)
			},
			cursorAt: { left: 5 , top: 10},
			cursor: 'move',
			delay: 200,
			appendTo: document.body
		});
	}
	
	var nameDivInternal = _div([res], [['css','position','absolute'], ['css','width','100%'],['css','padding',"1px 0px"], ['css','overflowX','hidden'],['css','whiteSpace','nowrap']]);
	var nameDiv = _div([nameDivInternal], [['css', 'position', 'relative'], ['css', 'height', '100%']]);
	
	tr = _tr([_td(), _td([icon], [['css','textAlign','center']]), _td([nameDiv]), _td([_t(layer.date)], [['css','textAlign','center'],['dir','className','invisible']]),  _td([_t(layer.Owner)], [['css','textAlign','center'],['dir','className','invisible']]), tdRemove]);
    
	for (var i = 0; i < tr.childNodes.length; i++)
		tr.childNodes[i].style.width = this._fields[i].width;
	
	attachEffects(tr, 'hover')
	
	return tr;
}

/** Внутри контейнера помещает табличку со списком слоёв и контролами для фильтрации
* @param {HTMLNode} parentDiv Куда помещать контрол
* @param {String} name Уникальное имя этого инстанса
* @param {object} params Параметры отображения списка:
*
*  * fixType {String | Vector} Какой тип слоёв показывать. 'vector', 'raster', 'multilayer', 'catalog' или ''. Если '', то добавится контрол с выбором типа слоя. Вектор 
*  * enableDragging {Boolean}
*  * height {Integer} высота всего виджета. Если не указана, то будет применяться дефолтная высота (~460px)
*  * onclick {function({ elem: , scrollTable: })}
*/
var LayerManagerControl = function( parentDiv, name, params )
{
	var _params = $.extend({fixType: [], height: ''}, params);
    
    if (typeof _params.fixType === 'string')
        _params.fixType = [_params.fixType];
        
	var canvas = _div(null, [['attr','id','layersList']]),
		searchCanvas = _div(null, [['dir','className','layersSearchCanvas']]),
		_this = this;
	
	var layerName = _input(null, [['dir','className','inputStyle'],['css','width','185px']]),
		layerOwner = _input(null, [['dir','className','inputStyle'],['css','width','185px']]);
	
	var typeSel = nsGmx.Utils._select([_option([_t(_gtxt("Любой"))], [['attr','value','']]),
					   _option([_t(_gtxt("Векторный"))], [['attr','value','vector']]),
					   _option([_t(_gtxt("Растровый"))], [['attr','value','raster']]),
					   _option([_t(_gtxt("Мультислой"))], [['attr','value','multilayer']]),
					   _option([_t(_gtxt("Каталог растров"))], [['attr','value','catalog']])], [['dir','className','selectStyle'], ['css','width','100px']]);
                       
    var calendar = new nsGmx.CalendarWidget({
        minimized: false, 
        showSwitcher: false,
        dateInterval: new nsGmx.DateInterval({dateBegin: null, dateEnd: null})
    });
    // calendar.init('layerManager', {
        // minimized: false, 
        // showSwitcher: false,
        // dateBegin: null,
        // dateEnd: null
    // });
    
    var _disabledLayers = {};
					   
	_(searchCanvas, [_div([_table([_tbody([_tr([_td([_span([_t(_gtxt("Название"))],[['css','fontSize','12px']])]), _td([layerName])]),
										   _tr([_td([_span([_t(_gtxt("Владелец"))],[['css','fontSize','12px']])]),_td([layerOwner])]),
                                           _tr([_td([_span([_t(_gtxt("Период"))],[['css','fontSize','12px']])]),_td([calendar.canvas[0]])]),
										   _tr([_td([_span([_t(_gtxt("Тип"))],[['css','fontSize','12px']])]), _td([typeSel])])])])], [['css','marginBottom','10px']])]);
								
    $.each(_params.fixType, function(i, type) {
        if (type !== '')
            $("tr:last", searchCanvas).hide();
    });
	
	var tableParent = _div();
    
    var sortColumns = {};
    sortColumns[_gtxt('Имя')] = true;
    sortColumns[_gtxt('Владелец')] = true;
    sortColumns[_gtxt('Дата создания')] = true;

    // Временно сервер не поддерживает сортировку по типу
    // if (_params.fixType.length > 1 || _params.fixType[0] === '')
        // sortColumns[_gtxt('Тип')] = true;
	
    var tagsParent = _div(null, [['css', 'height', '100px'], ['css', 'overflow', 'auto']]);
    
    _(canvas, [_table([_tbody([_tr([
        _td([searchCanvas], [['css', 'width', '50%']]),
        _td([tagsParent])
    ])])], [['css', 'width', '100%']])]);
    
    var LayersFilterParams = (function()
    {
        var prevLayerName, prevLayerOwner;
        
        layerName.oninput = layerName.onkeyup = function()
        {
            if (this.value !== prevLayerName) {
                prevLayerName = this.value;
                $(pi).change();
            }
        }
        
        layerOwner.oninput = layerOwner.onkeyup = function()
        {
            if (this.value !== prevLayerOwner) {
                prevLayerOwner = this.value;
                $(pi).change();
            }
        }
        
        typeSel.onchange = function()
        {
            $(pi).change();
        }
            
        calendar.getDateInterval().on('change', function()
        {
            $(pi).change();
        });
        
        var _layerTags = null;
        
        var pi = {
            setTags: function(layerTags)
            {
                _layerTags = layerTags;
                $(_layerTags).change(function()
                {
                    $(pi).change();
                })
            },
            getTitle:     function() { return layerName.value; },
            getOwner:     function() { return layerOwner.value; },
            getDateBegin: function() { return calendar.getDateInterval().get('dateBegin'); },
            getDateEnd:   function() { return calendar.getDateInterval().get('dateEnd'); },
            getTags:      function() { return _layerTags; },
            getTypes:     function() { return _params.fixType.length > 0 ? _params.fixType : [$("option:selected", typeSel).val()]; }
        }
        
        return pi;
    })();
    
    nsGmx.TagMetaInfo.loadFromServer(function(tagsInfo)
    {
        var layerTags = new nsGmx.LayerTagsWithInfo(tagsInfo);
        new nsGmx.LayerTagSearchControl(layerTags, tagsParent, {inputWidth: 115});
        LayersFilterParams.setTags(layerTags);
    });
    
    var layersListProvider = new LayersListProvider(LayersFilterParams);
    var layersTable = new nsGmx.ScrollTable({height: _params.height ? _params.height - 130 : ''});
    layersTable.setDataProvider(layersListProvider);
    
	layersTable.createTable(tableParent, name, 0, 
		["", _gtxt("Тип"), _gtxt("Имя"), _gtxt("Дата создания"), _gtxt("Владелец"), ""], 
		['1%','5%','45%','24%','20%','5%'], 
		function(layer)
		{
            var curParams = $.extend( {}, _params, {disabled: layer.name in _disabledLayers } );
			return drawLayers.apply(this, [layer, curParams]);
		}, 
		sortColumns
	);

	_(canvas, [tableParent]);

	$(parentDiv).empty().append(canvas);
	
	layerName.focus();
    
    this.getScrollTable = function()
    {
        return layersTable;
    }
    
    /** Деактивировать слои
      @param layerNames {String|String[]} - массив имён слоёв (или просто имя), которые нужно сделать неактивными
    */
    this.disableLayers = function(layerNames)
    {
        if (!$.isArray(layerNames))
            layerNames = [layerNames];
           
        for (var k = 0; k < layerNames.length; k++)
            _disabledLayers[layerNames[k]] = true;
            
        layersTable.repaint();
    }
    
    /** Aктивировать слои
      @param layerNames {String|String[]} - массив имён слоёв (или просто имя), которые нужно сделать активными
    */
    this.enableLayers = function(layerNames)
    {
        if (!$.isArray(layerNames))
            layerNames = [layerNames];
        
        for (var k = 0; k < layerNames.length; k++)
            delete _disabledLayers[layerNames[k]];
            
        layersTable.repaint();
    }

    this.resize = function(h) {
        layersTable.updateHeight(h - 130);
    }
}

nsGmx.LayerManagerControl = LayerManagerControl;
nsGmx.drawLayers = drawLayers;

gmxCore.addModule('LayersManagerControl', {
    LayerManagerControl: LayerManagerControl,
    drawLayers: drawLayers
});

})(nsGmx.Utils._);

_translationsHash.addtext("rus", {
							"loadShape.inputTitle": "Добавить shp-файл (в zip)",
                            "loadShape.loadDone": "Геометрия успешно загружена",
                            "loadShape.loadFail": "Ошибка загрузки геометрии"
						 });
						 
_translationsHash.addtext("eng", {
							"loadShape.inputTitle": "Add shp-file (zipped)",
                            "loadShape.loadDone": "Successfully loaded",
                            "loadShape.loadFail": "Error loading file"
						 });

var drawingObjects = 
{
	loadShp: {}
}

var queryLoadShp = function()
{
	this.builded = false;
	
	this.uploader = null;
}

queryLoadShp.prototype = new leftMenu();

//Старый вариант для IE9
//просто удаляет все контролы и создаёт все их заново...
queryLoadShp.prototype._regenerateControl = function()
{
    var _this = this;
    $(this.workCanvas).empty();

    var fileInput = _input(null, [['attr', 'type', 'file'], ['attr', 'name', 'file'], ['attr', 'id', 'upload_shapefile']]);
    fileInput.onchange = function()
    {
        if (this.value != "")
            _this.upload();
    }

    //задаём одновременно и enctype и encoding для корректной работы в IE
    this.postForm = _form([fileInput], [['attr', 'method', 'POST'], ['attr', 'encoding', 'multipart/form-data'], ['attr', 'enctype', 'multipart/form-data'], ['attr', 'id', 'upload_shapefile_form']]);

    this.progress = _img(null,[['attr','src','img/progress.gif'],['css','display','none']])

    this.inputControl = _div([_span([_t(_gtxt("loadShape.inputTitle") + ":")]), this.postForm]);

    this.workCanvas.appendChild(_div([this.inputControl, this.progress], [['css','padding','10px 0px 5px 20px']]));
}

queryLoadShp.prototype.load = function()
{
    if (!this.builded)
    {
        this._regenerateControl();
        this.builded = true;
    }
}

queryLoadShp.prototype._showObjectsOnMap = function(objs){
    if (objs.length == 0)
    {
        showErrorMessage(_gtxt("Загруженный shp-файл пуст"), true);
        return;
    }
    var lmap = nsGmx.leafletMap,
        gmxDrawing = lmap.gmxDrawing,
        latLngBounds = L.latLngBounds([]);
    for (var i = 0; i < objs.length; i++) {
        var it = objs[i],
            geoJSON = L.gmxUtil.geometryToGeoJSON(it.geometry),
            b = gmxDrawing.addGeoJSON(geoJSON, {fill: false, properties: it.properties})[0].getBounds();

        latLngBounds.extend(b);
    }
    if (latLngBounds.isValid()) {
        lmap.fitBounds(latLngBounds);
    }
}

//files - массив File или WebForms
queryLoadShp.prototype.loadAndShowFiles = function(files) {
    nsGmx.widgets.notifications.startAction('uploadShp');
    
    var def = $.when.apply($, [].slice.call(files).map(function(file) {
        return nsGmx.Utils.parseShpFile(file);
    }));
    
    def.then(function() {
        this._showObjectsOnMap(_.flatten([].slice.call(arguments)));
        nsGmx.widgets.notifications.stopAction('uploadShp', 'success', _gtxt('loadShape.loadDone'));
    }.bind(this), function() {
        nsGmx.widgets.notifications.stopAction('uploadShp', 'failure', _gtxt('loadShape.loadFail'));
    });
    
    return def;
}


//Загружает файлы из поля "file"
queryLoadShp.prototype.upload = function()
{
	hide(this.inputControl);
	show(this.progress);

    this.loadAndShowFiles([this.postForm]).always(function() {
        this.inputControl.removeChild(this.postForm);
        this._regenerateControl();
    }.bind(this));
}

var _queryLoadShp = new queryLoadShp();


drawingObjects.loadShp.load = function() {
    if ('File' in window) {
        $('<input type="file" multiple>').change(function(e) {
            _queryLoadShp.loadAndShowFiles(e.target.files);
        }).click();
    } else { //IE9
        var alreadyLoaded = _queryLoadShp.createWorkCanvas(arguments[0] || "shp");

        if (!alreadyLoaded)
            _queryLoadShp.load()
    }
}

drawingObjects.loadShp.unload = function()
{
}
/**
* @namespace DrawingObjects
* @description SDK для редактирования объектов на карте
*/
!(function($, _){

nsGmx.Translations.addText('rus', {
    drawingObjects: {
        editStyleTitle: 'Редактировать стиль',
        removeObject: 'Удалить',
        pointTitle: 'точка',
        lineTitle: 'линия',
        polygonTitle: 'многоугольник',
        rectangleTitle: 'прямоугольник',
        removeAll: 'Очистить',
        downloadShp: 'shp',
        downloadGeoJSON: 'geojson',
        downloadGpx: 'gpx',
        downloadCsv: 'csv',
        downloadNameTitle: 'Введите имя файла для скачивания',
        download: 'Скачать файл',
        downloadRaster: 'Скачать фрагмент растра',
        noRectangleError: 'Выберите область рамкой на карте',
        noRasterError: 'К прямоугольнику не подходит ни одного растрового слоя',

        edit: {
            border: 'Граница',
            color: 'Цвет',
            transparency: 'Прозрачность',
            lineWidth: 'Толщина линии',
            description: 'Описание',
            title: 'Редактирование стиля объекта'
        }
    }
})

nsGmx.Translations.addText('eng', {
    drawingObjects: {
        editStyleTitle: 'Edit style',
        removeObject: 'Delete',
        pointTitle: 'point',
        lineTitle: 'line',
        polygonTitle: 'polygon',
        rectangleTitle: 'rectangle',
        removeAll: 'Delete',
        downloadShp: 'shp',
        downloadGeoJSON: 'geojson',
        downloadGpx: 'gpx',
        downloadCsv: 'csv',
        downloadNameTitle: 'Enter file name to download',
        download: 'Download file',
        downloadRaster: 'Download fragment of raster',
        noRectangleError: 'Select region using frame',
        noRasterError: 'No one raster layer fit the rectangle',

        edit: {
            border: 'Outline',
            color: 'Color',
            transparency: 'Transparency',
            lineWidth: 'Line thickness',
            description: 'Description',
            title: 'Object style editing'
        }
    }
});

var setDrawingFeatureStyle = function(drawingFeature, templateStyle) {
    var color = '#' + L.gmxUtil.dec2hex(templateStyle.outline.color),
        opacity = templateStyle.outline.opacity/100;
    drawingFeature.setOptions({
        lineStyle: {
            color: color,
            opacity: opacity,
            weight: templateStyle.outline.thickness
        },
        pointStyle: {
            color: color,
            opacity: opacity
        }
    });
}

var CreateDrawingStylesEditorIcon = function(style, type)
{
	var icon = nsGmx.Controls.createGeometryIcon(style, type);

	_title(icon, _gtxt('drawingObjects.editStyleTitle'));

	return icon;
}

var CreateDrawingStylesEditor = function(parentObject, style, elemCanvas)
{
	var templateStyle = {};
    var jQueryDialog = null;

	$.extend(true, templateStyle, style);

	elemCanvas.onclick = function()
	{
        if (jQueryDialog) {
            return;
        }
		var canvas = _div(null,[['css','marginTop','10px']]),
			outlineParent = _tr(),
			outlineTitleTds = [],
			outlineTds = [];

		outlineTitleTds.push(_td([_t(_gtxt('drawingObjects.edit.border'))],[['css','width','70px']]));

		var outlineColor = nsGmx.Controls.createColorPicker(templateStyle.outline.color,
			function (colpkr){
				$(colpkr).fadeIn(500);
				return false;
			},
			function (colpkr){
				$(colpkr).fadeOut(500);
				return false;
			},
			function (hsb, hex, rgb) {
				outlineColor.style.backgroundColor = '#' + hex;

				templateStyle.outline.color = outlineColor.hex = parseInt('0x' + hex);

				$(elemCanvas).find(".borderIcon")[0].style.borderColor = '#' + hex;

				setDrawingFeatureStyle(parentObject, templateStyle);
			});

		outlineColor.hex = templateStyle.outline.color;

		_title(outlineColor, _gtxt('drawingObjects.edit.color'));

		outlineTds.push(_td([outlineColor],[['css','width','40px']]));

		var divSlider = nsGmx.Controls.createSlider(templateStyle.outline.opacity,
				function(event, ui)
				{
					templateStyle.outline.opacity = ui.value;

                    setDrawingFeatureStyle(parentObject, templateStyle);
				})

		_title(divSlider, _gtxt('drawingObjects.edit.transparency'));

		outlineTds.push(_td([divSlider],[['css','width','100px'],['css','padding','4px 5px 3px 5px']]));

		var outlineThick = nsGmx.Controls.createInput((templateStyle.outline && typeof templateStyle.outline.thickness != 'undefined') ? templateStyle.outline.thickness : 2,
				function()
				{
					templateStyle.outline.thickness = Number(this.value);

                    setDrawingFeatureStyle(parentObject, templateStyle);

					return true;
				}),
			closeFunc = function()
			{
				var newIcon = CreateDrawingStylesEditorIcon(templateStyle, parentObject.toGeoJSON().geometry.type.toLowerCase());
				CreateDrawingStylesEditor(parentObject, templateStyle, newIcon);

				$(elemCanvas).replaceWith(newIcon);

				$(canvas).find(".colorSelector").each(function()
				{
					$('#' + $(this).data("colorpickerId")).remove();
				});
			};

		_title(outlineThick, _gtxt('drawingObjects.edit.lineWidth'));

		outlineTds.push(_td([outlineThick],[['css','width','30px']]));

		_(outlineParent, outlineTitleTds.concat(_td([_div([_table([_tbody([_tr(outlineTds)])])],[['attr','fade',true]])])));

		var text = _input(null, [['attr','value', parentObject.options.title || ""],['dir','className','inputStyle'],['css','width','180px']]);
		$(text).on('keyup', function(evt)
		{
            if (evt.keyCode === 13)
            {
                $(jQueryDialog).dialog('destroy');
                return;
            }

            parentObject.setOptions({title: this.value});

			$(parentObject).triggerHandler('onEdit', [parentObject]);

			return true;
		})

		_(canvas, [_table([_tbody([_tr([_td([_t(_gtxt('drawingObjects.edit.description'))], [['css','width','70px']]), _td([text])])])]), _br(), _table([_tbody([outlineParent])])])

		var pos = nsGmx.Utils.getDialogPos(elemCanvas, false, 80);
		jQueryDialog = showDialog(_gtxt('drawingObjects.edit.title'), canvas, 280, 130, pos.left, pos.top, false, closeFunc);
        
        $(jQueryDialog).addClass('drawing-object-leaflet-id-' + parentObject._leaflet_id);
	}

	elemCanvas.getStyle = function()
	{
		return templateStyle;
	}
}

/** Конструктор
 @class Коллекция нарисованных объектов
 @memberOf DrawingObjects
 @param oInitMap Карта, из которой будут добавляться объекты в коллекцию
*/
var DrawingObjectCollection = function(oInitMap) {
	var _objects = []; //{item:, editID: , removeID: }
	var _this = this;
    var _map = oInitMap;

	var onEdit = function(drawingObject) {
		/** Вызывается при изменении объекта в коллекции
		@name DrawingObjects.DrawingObjectCollection.onEdit
		@event
		@param {drawingObject} drawingObject изменённый объект*/
		$(_this).triggerHandler('onEdit', [drawingObject]);
	}

	var onRemove = function(drawingObject) {
		_this.Remove(drawingObject);
	}

	/** Возвращает элемент по номеру
	@param {int} index № объекта в коллекции*/
	this.Item = function(index){
		return _objects[index].item;
	}

	/** Возвращает количество элементов в коллекции*/
	this.Count = function(){
		return _objects.length;
	}

	/** Добавляет объект в коллекцию
	@param {drawingObject} drawingObject Добавляемый объект*/
	this.Add = function(drawingObject){

        var editID = drawingObject.on('edit', function() {
            onEdit(drawingObject);
        });

        var removeID = drawingObject.on('remove', function() {
            onRemove(drawingObject);
        });

		_objects.push({
            item: drawingObject,
            editID: editID,
            removeID: removeID
        });

		/** Вызывается при добавлении объекта в коллекцию
		@name DrawingObjects.DrawingObjectCollection.onAdd
		@event
		@param {drawingObject} drawingObject добавленный объект*/
		$(this).triggerHandler('onAdd', [drawingObject]);
	};

	/** Удаляет объект из коллекции
	@param {int} index индекс удаляемого объекта*/
	this.RemoveAt = function(index){
		var obj = _objects.splice(index, 1)[0];

		/** Вызывается при удалении объекта из коллекции
		@name DrawingObjects.DrawingObjectCollection.onRemove
		@event
		@param {int} index индекс удаляённого объекта*/
		$(this).triggerHandler('onRemove', [index]);
	};

	/** Удаляет объект из коллекции
	@param {drawingObject} drawingObject удаляемый объект*/
	this.Remove = function(drawingObject){
		for (var i=0; i<_objects.length; i++){
			if (_objects[i].item === drawingObject) this.RemoveAt(i);
		}
	}

    /** Получить индекс объекта в коллекции. null, если объект не найден
	@param {drawingObject} drawingObject объект, индекс которого мы хотим найти*/
	this.getIndex = function(drawingObject){
		for (var i=0; i<_objects.length; i++){
			if (_objects[i].item === drawingObject) return i;
		}

        return null;
	}
}

/** Конструктор
 @class Строка с описанием объекта и ссылкой на него
 @description К строке биндится контекстное меню типа "DrawingObject"
 @memberOf DrawingObjects
 @param {L.Map} oInitMap Карта Leaflet
 @param oInitContainer Объект, в котором находится контрол (div)
 @param drawingObject Объект для добавления на карту
 @param options дополнительные параметры
 @param {bool} [options.allowDelete=true] рисовать ли крестик удаления объекта
 @param {bool} [options.editStyle=true] нужна ли возможность редактировать стили
 @param {function(DrawingObject)} [options.click] ф-ция, которая будет вызвана при клике на объекте.
        По умолчанию - центрирование карты на объекте.
*/
var DrawingObjectInfoRow = function(oInitMap, oInitContainer, drawingObject, options) {
    var defaultClickFunction = function(obj) {
        var geom = obj.toGeoJSON().geometry;
        var coords = geom.coordinates;
		if (geom.type == "Point") {
            _map.setView([coords[1], coords[0]], Math.max(14, _map.getZoom()));
        } else {
            _map.fitBounds(drawingObject.getBounds());
        }
    }

    var _options = $.extend({
        allowDelete: true,
        editStyle: true,
        click: defaultClickFunction
    }, options);

	var _drawingObject = drawingObject;
	var _this = this;
	var _map = oInitMap;

	var _canvas = _div(null, [['dir','className','drawingObjectsItemCanvas']]);
	var _title = _span(null, [['dir','className','drawingObjectsItemTitle']]);
	var _text = _span(null, [['dir','className', 'drawingObjectsItemTitle']]);
	var _summary = _span(null, [['dir','className','summary']]);

    if (_options.click) {
        _canvas.onclick = function(e) {
            if (e.target !== remove && (!_options.editStyle || e.target !== icon)) {
                _options.click(_drawingObject);
            }
        };
    }

    var lineOptions = _drawingObject.options.lineStyle || L.GmxDrawing.utils.defaultStyles.lineStyle;

	var icon = null;

    var geom = _drawingObject.toGeoJSON().geometry;
    if (_options.editStyle)
    {
        if (geom.type == "Point")
        {
            icon = _img(null, [['attr','src', (window.gmxJSHost || '') + 'img/flag_min.png'], ['dir', 'className', 'colorIcon']])
        }
        else
        {
            var regularDrawingStyle = {
                outline: {
                    color: parseInt('0x' + lineOptions.color.split('#')[1]),
                    thickness: lineOptions.weight,
                    opacity: lineOptions.opacity * 100
                }
            };

            icon = CreateDrawingStylesEditorIcon(regularDrawingStyle, geom.type.toLowerCase());
            CreateDrawingStylesEditor(_drawingObject, regularDrawingStyle, icon);
        }
    }
    else
        icon = _span(null, [['dir', 'className', geom.type + (L.gmxUtil.isRectangle(geom.coordinates) ? ' RECTANGLE' : '')]]);

	var remove = _span();

    if (_options.allowDelete)
    {
        remove.setAttribute('title', _gtxt('drawingObjects.removeObject'));
        remove.className = 'gmx-icon-close';
        remove.onclick = function(){
            $(_this).triggerHandler('onRemove', [_drawingObject]);
        }
    }

	_(_canvas, [_span([icon, _title, _text, _summary], [['dir','className','drawingObjectsItem']]), remove]);

	_(oInitContainer, [_canvas])

    this._mouseOverHandler = function() {
        $(_canvas).addClass('drawingObjectsActiveItemCanvas');
    };

    this._mouseOutHandler = function() {
        $(_canvas).removeClass('drawingObjectsActiveItemCanvas');
    }

    _drawingObject.on('mouseover', this._mouseOverHandler);
    _drawingObject.on('mouseout', this._mouseOutHandler);

	/** Обновляет информацию о геометрии */
	this.UpdateRow = function(){
        var summary = _drawingObject.getSummary(),
            text = _drawingObject.options.title,
            type = _drawingObject.getType();

		$(_title).empty();
		$(_text).empty();
		$(_summary).empty();

		if (type === 'Point')
		{
			_(_title, [_t(_gtxt('drawingObjects.pointTitle'))]);
			_(_summary, [_t("(" + summary + ")")]);
		}
		else if (type === 'Polyline' || type === 'MultiPolyline')
		{
			_(_title, [_t(_gtxt('drawingObjects.lineTitle'))]);
			_(_summary, [_t("(" + summary + ")")]);
		}
		else if (type === 'Polygon' || type === 'MultiPolygon' || type === 'Rectangle')
		{
			_(_title, [_t(type === 'Rectangle' ? _gtxt('drawingObjects.rectangleTitle') : _gtxt('drawingObjects.polygonTitle'))]);
			_(_summary, [_t("(" + summary + ")")]);
		}

		_(_text, [_t(text ? text.replace(/<[^<>]*>/g, " ") : "")])

		if (text)
			_title.style.display = 'none';
		else
			_title.style.display = '';
	}

	/** Удаляет строчку */
	this.RemoveRow = function(){

		if (_canvas.parentNode)
            _canvas.parentNode.removeChild(_canvas);

        if (_drawingObject === null) return;

        _drawingObject.off('edit', this.UpdateRow);
        _drawingObject.off('remove', this.RemoveRow);
        _drawingObject.off('mouseover', this._mouseOverHandler);
        _drawingObject.off('mouseout', this._mouseOutHandler);

        _drawingObject = null;
	}

    /** Удаляет строчку */
    this.getContainer = function() {return _canvas;};

    if (nsGmx && nsGmx.ContextMenuController) {
        nsGmx.ContextMenuController.bindMenuToElem(_title, 'DrawingObject', function(){return true; }, {obj: _drawingObject} );
    }

    this.getDrawingObject = function(){
        return _drawingObject;
    }

    _drawingObject.on('edit', this.UpdateRow);
    _drawingObject.on('remove', this.RemoveRow);

	this.UpdateRow();
}

/** Конструктор
 @class Контрол для отображения коллекции пользовательских объектов
 @memberOf DrawingObjects
 @param oInitMap Карта
 @param {documentElement} oInitContainer Объект, в котором находится контрол (div)
 @param {DrawingObjects.DrawingObjectCollection} oInitDrawingObjectCollection Коллекция пользовательских объектов
 @param {Object} options Дополнительные параметры.Включает все доп. параметры DrawingObjectInfoRow
 @param {bool} [options.showButtons=true] показывать ли кнопки под списком
 @param {selectedIndex} [options.selectedIndex=null] индекс выбранного элемента
*/
var DrawingObjectList = function(oInitMap, oInitContainer, oInitDrawingObjectCollection, options){
    var _options = $.extend({showButtons: true, selectedIndex: null}, options);
	var _this = this;
	var _rows = [];
	var _containers = [];
	var _map = oInitMap;
	var _collection = oInitDrawingObjectCollection;
	var _container = oInitContainer;
	var _divList = _div(null, [['dir', 'className', 'DrawingObjectList']]);
	var _divButtons = _div();

	/** Добавляет объект в "список объектов на карте"
	@param {drawingObject} drawingObject добавляемый объект */
	var add = function(drawingObject){
		var divRow = _div();
		_(_divList, [divRow]);
		var row = new DrawingObjectInfoRow(_map, divRow, drawingObject, options);
		_containers.push(divRow);
		_rows.push(row);
		$(row).bind('onRemove', function(){ drawingObject.remove(); } );
		if (_collection.Count() == 1 && _options.showButtons) show(_divButtons);

        /** В списке мышь переместилась над объект
		@name DrawingObjects.DrawingObjectList.mouseover
		@event
		@param {drawingObject} drawingObject объект, над которым находится мышь*/

        /** В списке мышь переместилась с объекта
		@name DrawingObjects.DrawingObjectList.mouseout
		@event
		@param {drawingObject} drawingObject объект, с которого переместилась мышь*/

        $(divRow).bind({
            mouseover: function() {
                $(_this).triggerHandler('mouseover', [drawingObject]);
            },
            mouseout: function() {
                $(_this).triggerHandler('mouseout', [drawingObject]);
            }
        });
	}

	var onRemove = function(event, index){
		if (_collection.Count() == 0) hide(_divButtons);
		var removedDiv = _containers.splice(index, 1)[0];
		_rows.splice(index, 1);
		removedDiv.parentNode && removedDiv.parentNode.removeChild(removedDiv);

        if (index === _selectedIndex) {
            _selectedIndex = null;
        } else if (index < _selectedIndex) {
            _selectedIndex--;
        }
	}

	$(_collection).bind('onRemove', onRemove);
	$(_collection).bind('onAdd', function(event, drawingObject){
		add(drawingObject);
	});

	for (var i=0; i<_collection.Count(); i++){ add(_collection.Item(i));}

    /** Очищает список пользовательских объектов*/
	this.Clear = function(){
		while (_collection.Count()>0){
			_collection.Item(0).remove();
		}

        _selectedIndex = null;
	}

	/** Возвращает div, в котором находится кнопка "Очистить" и который не виден при пустой коллекции */
	this.GetDivButtons = function(){
		return _divButtons;
	}

    var delAll = makeLinkButton(_gtxt('drawingObjects.removeAll'));
	delAll.onclick = this.Clear;

	_(_divButtons, [_div([delAll])]);
	_( oInitContainer, [_divList, _divButtons]);

	if (_collection.Count() == 0 || !_options.showButtons) hide(_divButtons);

    var _selectedIndex = null;

    /** Устанавливает выбранный элемент списка пользовательских объектов.
        null - нет активного. Неправильные индексы игнорируются. К контейнеру выбранного элемента добавляется класс drawingObjectsSelectedItemCanvas
    */
    this.setSelection = function(selectedIndex) {
        var isValidIndex = !!_rows[selectedIndex] || selectedIndex === null;
        if (selectedIndex === _selectedIndex || !isValidIndex) {
            return _selectedIndex;
        }

        if (_rows[_selectedIndex]) {
            $(_rows[_selectedIndex].getContainer()).removeClass('drawingObjectsSelectedItemCanvas');
        }

        if (_rows[selectedIndex]) {
            $(_rows[selectedIndex].getContainer()).addClass('drawingObjectsSelectedItemCanvas');
        }

        _selectedIndex = selectedIndex;

        return _selectedIndex;
    };

    /** Возвращает индекс выбранного элемента списка пользовательских объектов, null - если нет выбранного*/
    this.getSelection = function() {
        return _selectedIndex;
    }

    this.setSelection(_options.selectedIndex);
}

/** Конструктор
 @memberOf DrawingObjects
 @class Встраивает список объектов на карте в геомиксер*/
var DrawingObjectGeomixer = function() {
	var _this = this;
	var oMap = null;
    var gmxMap = null;
	var oMenu = new leftMenu();
	var oListDiv = _div(null, [['dir', 'className', 'DrawingObjectsLeftMenu']]);
	var bVisible = false;
    var oCollection = null;

	/** Вызывается при скрывании меню*/
	this.Unload = function(){ bVisible = false; };

	/** Загружает меню*/
	this.Load = function(){
		if (oMenu != null){
			var alreadyLoaded = oMenu.createWorkCanvas("DrawingObjects", this.Unload);
			if(!alreadyLoaded) _(oMenu.workCanvas, [oListDiv]);
		}
		bVisible = true;
	}

	var fnAddToCollection = function(ev) {
        var feature = ev.object;
		if (!nsGmx.DrawingObjectCustomControllers || !nsGmx.DrawingObjectCustomControllers.isHidden(feature)) {
            oCollection.Add(feature);
            var tt = 1;
        }
	}

	var checkDownloadVisibility = function(){
		var isAnyRectangle = false,
            isNonPolygon = false;

		for (var i=0; i< oCollection.Count(); i++){
            var feature = oCollection.Item(i);
            var geom = feature.toGeoJSON().geometry;
            isAnyRectangle = isAnyRectangle || L.gmxUtil.isRectangle(geom.coordinates);
            isNonPolygon = isNonPolygon || geom.type !== 'Polygon';
		}

        $(downloadContainer).toggle(oCollection.Count() > 0);
        $(downloadRaster).toggle(gmxMap.properties.CanDownloadRasters && isAnyRectangle);
        $(downloadGpx).toggle(isNonPolygon);
	}

    var downloadFormat = null;

	var downloadShp = makeLinkButton(_gtxt('drawingObjects.downloadShp'));
	downloadShp.onclick = function(){
        downloadFormat = 'Shape';
        downloadNameContainer.toggle();
	}
    downloadShp.style.margin = '0px 3px';

	var downloadGeoJSON = makeLinkButton(_gtxt('drawingObjects.downloadGeoJSON'));
	downloadGeoJSON.onclick = function(){
        downloadFormat = 'GeoJSON';
        downloadNameContainer.toggle();
	}
    downloadGeoJSON.style.margin = '0px 3px';

    var downloadGpx = makeLinkButton(_gtxt('drawingObjects.downloadGpx'));
	downloadGpx.onclick = function(){
        downloadFormat = 'gpx';
        downloadNameContainer.toggle();
	}
    downloadGpx.style.margin = '0px 3px';

    var downloadCsv = makeLinkButton(_gtxt('drawingObjects.downloadCsv'));
	downloadCsv.onclick = function(){
        downloadFormat = 'csv_wkt';
        downloadNameContainer.toggle();
	}
    downloadCsv.style.margin = '0px 3px';

    var downloadNameInput = $('<input/>', {title: _gtxt('drawingObjects.downloadNameTitle')}).val('markers').addClass('inputStyle');

    downloadNameInput.keyup(function(e) {
        if (e.keyCode == 13) {
            downloadNameButton.click();
        }
    })

    var downloadNameButton = $('<input/>', {type: 'button'}).val(_gtxt('drawingObjects.download')).addClass('btn').click(function() {
        downloadMarkers(downloadNameInput.val(), downloadFormat);
        downloadNameContainer.hide();
        downloadFormat = null;
    });
    var downloadNameContainer = $('<div/>').append(downloadNameInput, downloadNameButton).hide();

    var downloadRasterOptions = $(
        '<div class="drawingObjectsDownloadRaster">' +
            '<label><input type="radio" name="rasterFormat" checked value="univers">jpeg + georefernce</label>' +
            '<label><input type="radio" name="rasterFormat" value="garmin">kmz (Garmin Custom Maps)</label>' +
            '<button id="downloadRaster" class="btn">' + _gtxt('drawingObjects.download') + '</button>' +
        '</div>'
    ).hide();

    $('#downloadRaster', downloadRasterOptions).click(function() {
        var checkInfo = checkRasterLayer();
        if (checkInfo) {
            var bounds = checkInfo.bounds,
                layer = checkInfo.layer,
                format = $('input:checked', downloadRasterOptions).val(),
                temporalParam = "",
                props = layer.getGmxProperties();

            if (props.Temporal) {
                var dateInterval = layer.getDateInterval();
                if (dateInterval) {
                    var dateBeginStr = nsGmx.Utils.convertFromServer('date', dateInterval.beginDate/1000),
                        dateEndStr = nsGmx.Utils.convertFromServer('date', dateInterval.endDate/1000);

                    temporalParam = "&StartDate=" + encodeURIComponent(dateBeginStr) + "&EndDate=" + encodeURIComponent(dateEndStr);
                }
            }

            var truncate9 = function(x) { return ("" + x).substring(0, 9); };

            window.location.href =
                "http://" + props.hostName + "/DownloadLayer.ashx" +
                "?t=" + props.name +
                "&MinX=" + truncate9(bounds.getWest()) +
                "&MinY=" + truncate9(bounds.getSouth()) +
                "&MaxX=" + truncate9(bounds.getEast()) +
                "&MaxY=" + truncate9(bounds.getNorth()) +
                "&Format=" + format +
                temporalParam;
        }
    })

	var downloadRaster = makeLinkButton(_gtxt('drawingObjects.downloadRaster'));
	downloadRaster.onclick = function(){
        if (downloadRasterOptions.find(':visible').length || checkRasterLayer()) {
            downloadRasterOptions.toggle();
        }
	}

    var downloadContainer = _div();

	/** Встраивает список объектов на карте в геомиксер*/
	this.Init = function(leafletMap, initGmxMap){
		oMap = leafletMap;
        gmxMap = initGmxMap;
		oCollection = new DrawingObjectCollection(leafletMap);
        $(oCollection).bind('onAdd', function (){
            if(!bVisible) _this.Load();
        });

        $(oCollection).bind('onRemove', function (){
            oCollection.Count() || oMenu.leftPanelItem.close();
        });

        var lmap = nsGmx.leafletMap,
            gmxDrawing = lmap.gmxDrawing,
            features = gmxDrawing.getFeatures();

        features.map(function(ret){
			fnAddToCollection(ret);
		});

        lmap.gmxDrawing.on('add', fnAddToCollection);

        $(oCollection).bind('onRemove onAdd', checkDownloadVisibility);

        var oDrawingObjectList = new DrawingObjectList(oMap, oListDiv, oCollection);
        _(downloadContainer, [
            _div([_span([_t(_gtxt('drawingObjects.download'))], [['css', 'fontSize', '12px']]), downloadShp, downloadGeoJSON, downloadGpx, downloadCsv]),
            downloadNameContainer[0],
            _div([downloadRaster]),
            downloadRasterOptions[0]
        ]);
		_(oDrawingObjectList.GetDivButtons(), [downloadContainer]);

		checkDownloadVisibility();
	}

	/** Скачивает shp файл*/
	var downloadMarkers = function(fileName, format) {
        var geoms = [];

		for (var i = 0; i < oCollection.Count(); i++) {
            geoms.push(oCollection.Item(i).toGeoJSON());
        }

        nsGmx.Utils.downloadGeometry(geoms, {
            fileName: fileName,
            format: format
        });
	}

	/** Скачивает растровые слои*/
	var checkRasterLayer = function(){
		var obj = false,
			_this = this;

		for (var i = 0; i < oCollection.Count(); i++){
			var elem = oCollection.Item(i);

			if (elem.getType() == 'Rectangle') {
				obj = elem;
            }
		}

		if (!obj)
		{
			showErrorMessage(_gtxt('drawingObjects.noRectangleError'), true);
			return;
		}

		var bounds = obj.getBounds(),
            center = bounds.getCenter(),
			layer = false;

		var testPolygon = function(polygon, latlng){
			var testRing = function(ring, x, y)
			{
				var isInside = false;
				for (var j = 0; j < ring.length - 1; j++)
				{
					var x1 = ring[j][0],
						y1 = ring[j][1],
						x2 = ring[j + 1][0],
						y2 = ring[j + 1][1];

					if (((y1 >= y) != (y2 >= y)) && ((x1 + (x2 - x1)*(y - y1)/(y2 - y1)) > x))
						isInside = !isInside;
				}

				return isInside;
			}

			for (var j = 0; j < polygon.length; j++)
				if (testRing(polygon[j], latlng.lng, latlng.lat) != (j == 0))
					return false;

			return true;
		}

        for (var iLayerN = 0; iLayerN < gmxMap.layers.length; iLayerN++) {
            var l = gmxMap.layers[iLayerN],
                props = l.getGmxProperties(),
                layerBounds = l.getBounds && l.getBounds(),
                isProperType = props.type == "Raster" || props.IsRasterCatalog;

            if (isProperType && oMap.hasLayer(l) && layerBounds && layerBounds.isValid() && layerBounds.contains(center)) {
                var geom = l.getGeometry(),
                    coords = geom.coordinates,
                    bIsPolygonBad = false;

                if (geom.type === "Polygon" && !testPolygon(coords, center)) {
                    bIsPolygonBad = true;
                } else if (geom.type == "MultiPolygon") {
                    bIsPolygonBad = true;
                    for (var k = 0; k < coords.length; k++)
                        if (testPolygon(coords[k], center)){
                            bIsPolygonBad = false;
                            break;
                        }
                }

                if (!bIsPolygonBad && l && (!layer || (props.MaxZoom > layer.getGmxProperties().MaxZoom))) {
                    layer = l;
                }
            }
        };

        if (!layer) {
            showErrorMessage(_gtxt('drawingObjects.noRasterError'), true);
            return;
        }

        return {bounds: bounds, layer: layer};
	}
}

var publicInterface = {
	DrawingObjectCollection: DrawingObjectCollection,
	DrawingObjectInfoRow: DrawingObjectInfoRow,
	DrawingObjectList: DrawingObjectList,
	DrawingObjectGeomixer: DrawingObjectGeomixer
}

gmxCore.addModule("DrawingObjects", publicInterface);

})(jQuery, nsGmx.Utils._);

!(function(_){

/** 
* @class Веб браузер для выбора и загрузки файлов на сервер
*/
var fileBrowser = function()
{
    var _this = this;
	this.parentCanvas = null;
	
	this._homeDir = '';
    
    this._status = {
        _state: false,
        start: function() {
            this._state = true;
            var me = this;
            setTimeout(function() {
                if (me._state) {
                    $(_this.statusContainer).show();
                }
            }, 100);
        },
        stop: function() {
            $(_this.statusContainer).hide();
            this._state = false;
        }
    }
    
    this._path = (function()
    {
        var path;
        var alternativePath;
        return {
            set: function(newPath, newAlternativePath)
            {
                path = newPath + (newPath.charAt(newPath.length-1) === _this.slash ? '' : _this.slash);
                if (newAlternativePath) {
                    alternativePath = newAlternativePath + (newAlternativePath.charAt(newAlternativePath.length-1) === _this.slash ? '' : _this.slash);
                } else {
                    alternativePath = undefined;
                }
                $(this).change();
            },
            get: function()
            {
                return path;
            },
            getAlternative: function()
            {
                return alternativePath;
            },
            isRoot: function()
            {
                return path && path.indexOf(_this.slash) === path.length-1;
            },
            isInited: function()
            {
                return typeof path !== 'undefined';
            },
            isInHome: function()
            {
                return path && path.indexOf(_this._homeDir) === 0;
            },
            getRoot: function()
            {
                var index = String(path).indexOf(_this.slash);
                return newPath = String(path).substr(0, index+1);
            },
            getParentFolder: function()
            {
                var index = String(path).lastIndexOf(_this.slash, path.length-2);
                return String(path).substr(0, index+1);
            }
        }
    })();
	
	this.currentFiles = [];
	
	this.slash = "\\";
	
	this.fileCanvas = null;
	this.fileHeader = null;
	this.fileUpload = null;
	
	this.sortFuncs = 
	{
		name:[
			function(_a,_b){var a = String(_a.Name).toLowerCase(), b = String(_b.Name).toLowerCase(); if (a > b) return 1; else if (a < b) return -1; else return 0},
			function(_a,_b){var a = String(_a.Name).toLowerCase(), b = String(_b.Name).toLowerCase(); if (a < b) return 1; else if (a > b) return -1; else return 0}
		],
		ext:[
			function(_a,_b)
			{
				var a = String(_a.Name).toLowerCase(),
					b = String(_b.Name).toLowerCase(),
					index1 = a.lastIndexOf('.'),
					ext1 = a.substr(index1 + 1, a.length),
					index2 = b.lastIndexOf('.'),
					ext2 = b.substr(index2 + 1, b.length);
				
				if (ext1 > ext2) return 1; else if (ext1 < ext2) return -1; else return 0;
			},
			function(_a,_b)
			{
				var a = String(_a.Name).toLowerCase(),
					b = String(_b.Name).toLowerCase(),
					index1 = a.lastIndexOf('.'),
					ext1 = a.substr(index1 + 1, a.length),
					index2 = b.lastIndexOf('.'),
					ext2 = b.substr(index2 + 1, b.length);
				
				if (ext1 < ext2) return 1; else if (ext1 > ext2) return -1; else return 0;
			}
		],
		size:[
			function(a,b){return a.Size - b.Size},
			function(a,b){return b.Size - a.Size}
		],
		date:[
			function(a,b){return a.Date - b.Date},
			function(a,b){return b.Date - a.Date}
		]
	};
	
	this.currentSortType = 'name';
	this.currentSortIndex = 
	{
		name: 0,
		ext: 0,
		size: 0,
		date: 0
	};
		
	this.shownPathScroll = false;

	this.returnMask = ['noname'];
	
	this._discs = null;
     
    this._params = null;
	
	this.ext7z = ['7Z', 'ZIP', 'GZIP', 'BZIP2', 'TAR', 'ARJ', 'CAB', 'CHM', 'CPIO', 'DEB', 'DMG', 'HFS', 'ISO', 'LZH', 'LZMA', 'MSI', 'NSIS', 'RAR', 'RPM', 'UDF', 'WIM', 'XAR', 'Z'];
}

fileBrowser.MAX_UPLOAD_SIZE = 500*1024*1024;

/**
 Показать браузер пользователю. Если браузер уже показывается, он будет закрыт и открыт новый
 @param {String} title Заголовок окна браузера
 @param {String[]} mask Массив допустимых для выбора разрешений файлов. Если массив пустой, то выбираются директории, а не отдельные файлы
 @param {function(path)} closeFunc Функция, которая будет вызвана при выборе файла/директории (если браузер просто закрыли, не вызовется)
 @param {Object} params Параметры браузера
 @param {String} params.restrictDir Ограничивающая директория (поддерево). Нельзя посмотреть файлы вне этой директории (даже для админов)
 @param {String} params.startDir Начальная директория. Если нет, то будет открыто в том же месте, где и закрыт в прошлый раз.
*/
fileBrowser.prototype.createBrowser = function(title, mask, closeFunc, params)
{
    this._params = $.extend({restrictDir: null, startDir: null}, params);
    
    if (this._params.startDir !== null)
        this._path.set(this._params.startDir);
    
	if ($('#fileBrowserDialog').length)
	{
		$('#fileBrowserDialog').parent().dialog("destroy");
		$('#fileBrowserDialog').parent().remove();
	}
	
	var canvas = _div(null, [['attr','id','fileBrowserDialog']]);
    
	var oDialog = showDialog(title, canvas, 800, 400, false, false, this.resize);
	
	this.returnMask = mask;
	this.parentCanvas = canvas;
	this.closeFunc = closeFunc;
    this._homeDir = nsGmx.AuthManager.getUserFolder();
	
	if (this._discs === null )// && nsGmx.AuthManager.canDoAction(nsGmx.ACTION_SEE_FILE_STRUCTURE )
		this.loadInfo();
	else
		this.loadInfoHandler()
		
	return oDialog;
}

fileBrowser.prototype.resize = function()
{
	if (!$("#fileBrowserDialog").find(".fileCanvas").length)
		return;
    
    var container = $('#fileBrowserDialog')[0];
	
	var titleHeight = container.parentNode.parentNode.firstChild.offsetHeight;
    
	
	container.childNodes[1].lastChild.style.height = container.parentNode.parentNode.offsetHeight - titleHeight - 6 - container.lastChild.offsetHeight - container.firstChild.offsetHeight - container.childNodes[1].firstChild.offsetHeight - 20 + 'px';
}

fileBrowser.prototype.close = function(path)
{
	this.closeFunc(path);
	
	var canvas = $('#fileBrowserDialog')[0];
	
	$(canvas.parentNode).dialog("destroy");
	
	canvas.parentNode.removeNode(true);
}

fileBrowser.prototype.loadInfo = function()
{
	var _this = this;
	sendCrossDomainJSONRequest(serverBase + "FileBrowser/GetDrives.ashx?WrapStyle=func", function(response)
	{
		if (!parseResponse(response))
			return;
		
        _this._discs = response.Result;
		_this.loadInfoHandler()
	})
}

fileBrowser.prototype._showWarningDialog = function() {
    var canvas = _div([_t(_gtxt("FileBrowser.ExceedLimitMessage"))], [['dir', 'className', 'CustomErrorText']]);
    showDialog(_gtxt("Ошибка!"), canvas, 220, 100);
}

fileBrowser.prototype._uploadFilesAjax = function(formData) {
    var _this = this;
    this.progressBar.progressbar('option', 'value', 0);
    this.progressBar.show();
    
    formData.append('WrapStyle', 'None');
    
    var xhr = new XMLHttpRequest();
    
    xhr.upload.addEventListener("progress", function(e) {
        _this.progressBar.progressbar('option', 'value', e.loaded / e.total * 100);
    }, false);
    
    xhr.open('POST', serverBase + 'FileBrowser/Upload.ashx');
    xhr.withCredentials = true;
    xhr.onload = function () {
        _this.progressBar.hide();
        if (xhr.status === 200) {
            response = JSON.parse(xhr.responseText);
            
            if (!parseResponse(response))
                return;
                
            if (typeof response.Result == 'string') {
                var indexSlash = String(response.Result).lastIndexOf(_this.slash),
                    fileName = String(response.Result).substring(indexSlash + 1, response.Result.length);
                
                _this.shownPath = fileName;
            }
            
            _this.getFiles();
        }
    };
    
    xhr.send(formData);    
}

fileBrowser.prototype.loadInfoHandler = function()
{
    var _this = this;
	if (!this._path.isInited())
	{
        var mapFolder = _layersTree.treeModel.getMapProperties().LayersDir;
        if (mapFolder) {
            this._path.set(_layersTree.treeModel.getMapProperties().LayersDir, nsGmx.AuthManager.getUserFolder());
        } else {
            this._path.set(nsGmx.AuthManager.getUserFolder());
        }
	}
	
	this.currentSortFunc = this.sortFuncs['name'][0];
	
	this.fileUpload = _div(null, [['dir','className','fileUpload']]);
	this.fileHeader = _div(null, [['css','height','24px']]);
	this.fileCanvas = _div(null, [['dir','className','fileCanvas']]);
    
    $(this.parentCanvas).bind('dragover', function()
    {
        return false;
    });
    
    $(this.parentCanvas).bind('drop', function(e)
    {
        if (!window.FormData) return false;
        
        var files = e.originalEvent.dataTransfer.files;
        var formData = new FormData();
        
        var totalSize = 0;
        for (var f = 0; f < files.length; f++) {
            totalSize += files[f].size;
        }
        
        if (totalSize > fileBrowser.MAX_UPLOAD_SIZE) {
            _this._showWarningDialog();
            return false;
        }
        
        for (var f = 0; f < files.length; f++) {
            formData.append('rawdata', files[f]);
        }
        
        formData.append('ParentDir', _this._path.get());
        
        _this._uploadFilesAjax(formData);
        
        return false;
    })
	
	_(this.parentCanvas, [this.fileHeader, this.fileCanvas, this.fileUpload]);
	
	this.createHeader();
	this.createUpload();
	
	this._updateUploadVisibility();
	
	this.getFiles();
}

fileBrowser.prototype._updateUploadVisibility = function()
{
    $([this.fileUpload, this.tdAddFolder]).toggle(nsGmx.AuthManager.isRole(nsGmx.ROLE_ADMIN) || this._path.isInHome())
}

fileBrowser.prototype.createHeader = function()
{
	var reloadButton = makeImageButton("img/reload.png"),
		homeButton = makeImageButton("img/home.png"),
		discButtonTds = [],
		_this = this;
	
	reloadButton.style.margin = '0px 5px 0px 10px';
	homeButton.style.margin = '0px 10px 0px 5px';
	
	reloadButton.style.width = '14px';
	reloadButton.style.height = '15px';
	homeButton.style.width = '15px';
	homeButton.style.height = '15px';
	
	_title(reloadButton, _gtxt("Обновить"));
	_title(homeButton, _gtxt("Домашняя директория"));
	
	reloadButton.onclick = function()
	{
		_this.getFiles();
	}
	
	homeButton.onclick = function()
	{
        _this._path.set(_layersTree.treeModel.getMapProperties().LayersDir, _this._homeDir);
		_this.getFiles(_layersTree.treeModel.getMapProperties().LayersDir);
	}
	
	//if ( nsGmx.AuthManager.canDoAction(nsGmx.ACTION_SEE_FILE_STRUCTURE ) )
	//{
		for (var i = 0; i < this._discs.length; i++)
		{
			var discButtons = makeButton(this._discs[i]);
			
			(function(i)
			{
				discButtons.onclick = function()
				{
					_this.getFiles(_this._discs[i])
				}
			})(i)
			
			discButtonTds.push(_td([discButtons]))
		}
	//}
	
	discButtonTds.push(_td([reloadButton], [['attr','vAlign','top']]));
	discButtonTds.push(_td([homeButton], [['attr','vAlign','top']]));
	
	var newFolderName = _input(null, [['dir','className','inputStyle'], ['css','width','150px']]),
		showFolderButton = makeImageButton("img/newfolder.png"),
		newFolderButton = makeButton(_gtxt("Создать")),
		createFolder = function()
		{
            _this._status.start();
			sendCrossDomainJSONRequest(serverBase + 'FileBrowser/CreateFolder.ashx?WrapStyle=func&FullName=' + encodeURIComponent(_this._path.get() + newFolderName.value), function(response)
			{
                _this._status.stop();
				if (!parseResponse(response))
					return;
				
				_this.shownPath = newFolderName.value;
				
				newFolderName.value = '';
				
				_this.getFiles();
			})
		};
		
	showFolderButton.style.width = '16px';
	showFolderButton.style.height = '13px';
	
	newFolderName.style.margin = '0px 3px';
	
	_title(showFolderButton, _gtxt("Новая папка"))
	
	showFolderButton.style.marginRight = '10px';
	
	showFolderButton.onclick = function()
	{
        $(newFolderName).toggle().focus();
        $(newFolderButton).toggle();
	}
	
	newFolderName.style.display = 'none';
	newFolderButton.style.display = 'none';
		
	$(newFolderName).on('keydown', function(e)
	{
		if (e.keyCode === 13)
	  	{
	  		if (newFolderName.value != '')
				createFolder();
			else
				inputError(newFolderName);
	  		
	  		return false;
	  	}
	});
	
	newFolderButton.onclick = function()
	{
		if (newFolderName.value != '')
			createFolder();
		else
			inputError(newFolderName);
	}
	
	this.tdAddFolder = _td([_table([_tbody([_tr([
            _td([showFolderButton], [['attr','vAlign','top']]),
            _td([newFolderName]),
            _td([newFolderButton])]
        )])])], [['attr','vAlign','top'], ['css','height','20px']]);
        
	discButtonTds.push(this.tdAddFolder);
	
	_(this.fileHeader, [_table([_tbody([_tr(discButtonTds)])])]);
}

fileBrowser.prototype.createUpload = function()
{
	var div = _div(null, [['css','height','30px']]),
		_this = this;
	
	var formFile = _form(null,[['attr','enctype','multipart/form-data'],['dir','method','post'],['dir','action', serverBase + 'FileBrowser/Upload.ashx?WrapStyle=message'],['attr','target','fileBrowserUpload_iframe']]);

	var attach = _input(null,[['attr','type','file'],['dir','name','rawdata'],['css','width','200px'], ['attr','multiple','multiple']]);
	_(formFile, [attach]);
    
    attach.onchange = function()
	{
        if (attach.files && attach.files[0] && attach.files[0].size > fileBrowser.MAX_UPLOAD_SIZE) {
            _this._showWarningDialog();
            return;
        }
        
        //если можем послать через AJAX, посылаем - будет работать прогресс-бар
        if (window.FormData) {
            var formData = new FormData(formFile);
            formData.append('ParentDir', _this._path.get());
            _this._uploadFilesAjax(formData);
            return;
        }
        
        sendCrossDomainPostRequest(serverBase + 'FileBrowser/Upload.ashx', 
            {
                WrapStyle: 'message',
                ParentDir: _this._path.get()
            },
            function(response) {
                if (!parseResponse(response))
                    return;
                
                var indexSlash = String(response.Result).lastIndexOf(_this.slash),
                    fileName = String(response.Result).substring(indexSlash + 1, response.Result.length);
                
                _this.shownPath = fileName;
                
                _this.getFiles();
            }, 
            formFile
        );
	}
    
    var dropInfoDiv = window.FormData ? _div([_t(_gtxt('FileBrowser.DropInfo'))], [['dir', 'className', 'fileBrowser-dragFileMessage']]) : _div();
	
	_(div, [
        dropInfoDiv,
        _table([_tbody([_tr([
            _td([formFile], [['css', 'paddingTop', '18px']])
        ])])])
    ]);
    
    this.progressBar = $('<div/>').addClass('fileBrowser-progressBar').progressbar({value: 100}).hide();
    
    _(this.fileUpload, [this.progressBar[0], div]);
}

fileBrowser.prototype.getFiles = function(path)
{
	var path = (typeof path != 'undefined') ? path : this._path.get();
    var alternativePath = this._path.getAlternative();
	var _this = this;
    
    if (this._isRestrictedPath(path)) 
        return;
        
    var doProcessResponce = function(response) {
        _this._status.stop();
        
		if (!parseResponse(response))
			return;
		
		_this.getFilesHandler(response.Result, path);
    }

    this._status.start();
	sendCrossDomainJSONRequest(serverBase + "FileBrowser/GetDirectoryContent.ashx?WrapStyle=func&root=" + encodeURIComponent(path), function(response)
	{
        if (response.Status !== 'ok' && alternativePath) {
            path = alternativePath;
            _this._path.set(alternativePath);
            sendCrossDomainJSONRequest(serverBase + "FileBrowser/GetDirectoryContent.ashx?WrapStyle=func&root=" + encodeURIComponent(alternativePath), doProcessResponce);
        } else {
            doProcessResponce(response);
        }
	})
}

fileBrowser.prototype.getFilesHandler = function(files, path)
{
	this._path.set(path);
	this.currentFiles = files;

	this._updateUploadVisibility();

	this.reloadFiles();
}

fileBrowser.prototype.pathWidget = function()
{
    var shortPath = this._path.get();
    var _this = this;
    
    var parent = $('<span/>', {'class': 'fileBrowser-pathWidget'});
    var pathElements = [];
    
    var highlightPath = function(index)
    {
        for (var e = 0; e < pathElements.length; e++)
            if (e <= index)
                pathElements[e].addClass('fileBrowser-activePathElem');
            else
                pathElements[e].removeClass('fileBrowser-activePathElem');
    }
    
    var appendElem = function(text, path){
        var elemIndex = pathElements.length;
        var newElem = $('<span/>', {'class': 'fileBrowser-pathElem'}).text(text + _this.slash)
        .click(function()
        {
            _this.getFiles(path[path.legnth - 1] === _this.slash ? path : path  + _this.slash);
        })
        .hover(function(){highlightPath(elemIndex)}, function(){highlightPath(-1)});
        
        pathElements.push(newElem);
        parent.append(newElem);//.append( $('<span/>').text(_this.slash) );
    }
    
    var curFolder = '';
    while (shortPath.length)
    {
        var index = shortPath.indexOf(this.slash);
        if (index == 0) break;
            
        if (index < 0)
        {
            appendElem(shortPath, curFolder + shortPath);
            break;
        }
        var curText = shortPath.substr(0, index);
        curFolder += curText + this.slash;
        shortPath = shortPath.substr(index+1);
        
        appendElem(curText, curFolder.substr(0, curFolder.length-1));
    }
    
    return parent[0];
}

fileBrowser.prototype.quickSearch = function()
{
	var input = _input(null, [['dir','className','inputStyle'],['css','width','200px']]),
		_this = this;
	
	input.onkeyup = function()
	{
		if (this.value != "")
		{
			var scroll = _this.findContent(this.value);
			
			if (scroll >= 0)
				_this.fileCanvas.lastChild.scrollTop = scroll;
		}
	}
	
	return input;
}

fileBrowser.prototype.findContent = function(value)
{
	var tbody = this.fileCanvas.lastChild.firstChild.lastChild;
	
	for (var i = 0; i < tbody.childNodes.length; ++i)
	{
		var text = tbody.childNodes[i].textContent.toLowerCase();
		
		if (text != "[..]" && text.indexOf(value.toLowerCase()) == 0)
			return tbody.childNodes[i].offsetTop;
	}
	
	return -1;
}

fileBrowser.prototype.reloadFiles = function()
{
    $(this.fileCanvas).empty();
    
    this.statusContainer = _div(null, [['dir', 'className', 'fileBrowser-progress'], ['css', 'display', 'none']]);
	
	_(this.fileCanvas, [_div([this.pathWidget(), _br(), _t(_gtxt("Фильтр")), this.quickSearch(), this.statusContainer], [['dir','className','currentDir'],['css','color','#153069'],['css','fontSize','12px']])]);
	
	_(this.fileCanvas, [this.draw(this.currentFiles)]);
	
	this.resize();
	
	if (this.shownPathScroll)
	{
		this.fileCanvas.lastChild.scrollTop = this.shownPathScroll.offsetTop;
		
		this.shownPathScroll = false;
	}
}

fileBrowser.prototype._getParentFolder = function(path)
{
    var index = String(path).lastIndexOf(this.slash),
        newPath = String(path).substr(0, index);
    
    if (new RegExp(/^[a-z]:$/i).test(newPath))
        newPath += this.slash;
        
    return newPath;
}

fileBrowser.prototype._isRestrictedPath = function(path)
{
    return this._params.restrictDir !== null && path.indexOf(this._params.restrictDir) != 0;
}

fileBrowser.prototype.draw = function(files)
{
	var nameSort = makeLinkButton(_gtxt("Имя")),
		extSort = makeLinkButton(_gtxt("Тип")),
		sizeSort = makeLinkButton(_gtxt("Размер")),
		dateSort = makeLinkButton(_gtxt("Дата")),
		_this = this;
	
	nameSort.sortType = 'name';
	extSort.sortType = 'ext';
	sizeSort.sortType = 'size';
	dateSort.sortType = 'date';
	
	nameSort.onclick = extSort.onclick = sizeSort.onclick = dateSort.onclick = function()
	{
		_this.currentSortType = this.sortType;
		_this.currentSortIndex[_this.currentSortType] = 1 - _this.currentSortIndex[_this.currentSortType];
		
		_this.reloadFiles();
	}
	
	var tdRoot = _td(null, [['css','width','20px']]);
	
	if ( nsGmx.AuthManager.canDoAction(nsGmx.ACTION_SEE_FILE_STRUCTURE ) )
	{
		var rootButton = makeButton(this.slash);
		
		_(tdRoot, [rootButton]);
		
		rootButton.onclick = function()
		{
			_this.getFiles(_this._path.getRoot());
		}
	}
	
	var tableHeaderTr = _tr([tdRoot, _td([nameSort],[['css','textAlign','left']]), _td([extSort], [['css','width','10%'],['css','textAlign','center']]), _td([sizeSort], [['css','width','15%'],['css','textAlign','center']]), _td([dateSort], [['css','width','25%'],['css','textAlign','center']])]),
		prevDirTr = _tr([_td(), _td([_t("[..]")]), _td(), _td(), _td()]),
		tableFilesTrs = [];
	
    var parentFolder = _this._path.getParentFolder();
	if (parentFolder && !this._isRestrictedPath(parentFolder))
	{
        tableFilesTrs.push(prevDirTr)
	
		attachEffects(prevDirTr, 'hover')

		prevDirTr.onclick = function()
		{
			_this.getFiles(parentFolder);
		}
	}
	
	tableFilesTrs = tableFilesTrs.concat(this.drawFolders(files));
	tableFilesTrs = tableFilesTrs.concat(this.drawFiles(files));
	
	return _div([_table([_thead([tableHeaderTr]), _tbody(tableFilesTrs)], [['css','width','100%']])], [['css','overflowY','scroll']]);
}

fileBrowser.prototype.getCurrentSortFunc = function()
{
	return this.sortFuncs[this.currentSortType][this.currentSortIndex[this.currentSortType]];
}

fileBrowser.prototype.formatDate = function(sec)
{
	var sysDate = new Date(sec * 1000),
		date = [];

	date[0] = sysDate.getDate(),
	date[1] = sysDate.getMonth() + 1,
	date[2] = sysDate.getFullYear(),
	date[3] = sysDate.getHours(),
	date[4] = sysDate.getMinutes(),
	date[5] = sysDate.getSeconds();

	for (var i = 0; i < 6; i++)
		if (date[i] < 10)
			date[i] = '0' + date[i];

	return date[0] + '.' + date[1] + '.' + date[2] + ' ' + date[3] + ':' + date[4] + ':' + date[5];
}

fileBrowser.prototype.drawFolders = function(arr)
{
	var folders = [],
		trs = [],
		_this = this;;
	
	for (var i = 0; i < arr.length; i++)
		if (arr[i].Directory)
			folders.push(arr[i]);
	
	if (this.currentSortType == 'name' || this.currentSortType == 'date')
		folders = folders.sort(this.getCurrentSortFunc());
	
	for (var i = 0; i < folders.length; i++)
	{
		var tdReturn = _td();
		
		if (!this.returnMask.length)
		{
			var returnButton = makeImageButton("img/choose.png", "img/choose_a.png");
			returnButton.style.cursor = 'pointer';
			returnButton.style.marginLeft = '5px';
			
			_title(returnButton, _gtxt("Выбрать"));
			
			(function(i){
				returnButton.onclick = function(e)
				{
					_this.close(_this._path.get() + folders[i].Name + _this.slash);
				}
			})(i);
			
			_(tdReturn, [returnButton])
		}
		
		var tr = _tr([
            tdReturn, 
            _td([_div(null, [['dir','className','fileCanvas-folder-icon']]), this.createFolderActions(folders[i].Name)]), 
            _td(), 
            _td([_t(_gtxt("Папка"))],[['css','textAlign','center'],['dir','className','invisible']]), 
            _td([_t(this.formatDate(folders[i].Date))],[['css','textAlign','center'],['dir','className','invisible']])
        ]);
		
		(function(i){
			tr.onclick = function()
			{
				_this.getFiles(_this._path.get() + folders[i].Name);
			}
		})(i);
		
		attachEffects(tr, 'hover');
		
		if (this.shownPath && folders[i].Name == this.shownPath)
		{
			$(tr).children("td").css('backgroundColor', '#CEEECE');
			
			this.shownPath = null;
			
			this.shownPathScroll = tr;
		}
		
		trs.push(tr)
	}
	
	return trs;
}

fileBrowser.prototype.drawFiles = function(arr)
{
	var files = [],
		trs = [],
		_this = this;
	
	for (var i = 0; i < arr.length; i++)
		if (!arr[i].Directory)
			files.push(arr[i]);
	
	files = files.sort(this.getCurrentSortFunc());
	
	for (var i = 0; i < files.length; i++)
	{
		var index = String(files[i].Name).lastIndexOf('.'),
			name = String(files[i].Name).substr(0, index),
			ext = String(files[i].Name).substr(index + 1, files[i].Name.length),
			tdReturn = _td()
			tdSize = _td([_t(this.makeSize(files[i].Size))], [['attr','size',files[i].Size],['css','textAlign','right'],['dir','className','invisible']]);
		
		if (this.returnMask.length && valueInArray(this.returnMask, ext.toLowerCase()))
		{
			var returnButton = makeImageButton("img/choose.png", "img/choose_a.png");
			returnButton.style.cursor = 'pointer';
			returnButton.style.marginLeft = '5px';
			
			_title(returnButton, _gtxt("Выбрать"));
			
			(function(i){
				returnButton.onclick = function(e)
				{
					_this.close(_this._path.get() + files[i].Name);
				}
			})(i);
			
			_(tdReturn, [returnButton])
		}
		
		var	tr = _tr([tdReturn, _td([this.createFileActions(name, ext)]), _td([_t(ext)],[['css','textAlign','right'],['css','fontSize','12px']]), tdSize, _td([_t(this.formatDate(files[i].Date))],[['css','textAlign','center'],['dir','className','invisible']])]);
		
		attachEffects(tr, 'hover');
		
		if (this.shownPath && files[i].Name == this.shownPath)
		{
			$(tr).children("td").css('backgroundColor', '#CEEECE');
			
			this.shownPath = null;
			
			this.shownPathScroll = tr;
		}

		trs.push(tr)
	}
	
	return trs;
}

fileBrowser.prototype.createFolderActions = function(name)
{
	var span = _span([_t(name)],[['css','fontSize','12px']]),
		spanParent = _div([span],[['css','display', 'inline-block'],['css','position','relative']]),
		_this = this;
	
	nsGmx.ContextMenuController.bindMenuToElem(spanParent, 'FileBrowserFolder', 
		function()
		{
			return _this._path.isInHome() || nsGmx.AuthManager.canDoAction( nsGmx.ACTION_SEE_FILE_STRUCTURE );
		}, 
		{
			fullPath: this._path.get() + name + this.slash,
			fileBrowser: this,
			enableZip: true
		}
	);

	return spanParent;
}

fileBrowser.prototype.createFileActions = function(name, ext)
{
	var span = _span([_t(name)],[['css','fontSize','12px']]),
		spanParent = _div([span],[['css','display','inline-block'],['css','position','relative']]),
		_this = this;

	nsGmx.ContextMenuController.bindMenuToElem(spanParent, 'FileBrowserFile', 
		function()
		{
			return _this._path.isInHome() || nsGmx.AuthManager.canDoAction( nsGmx.ACTION_SEE_FILE_STRUCTURE );
		}, 
		{
			fullPath: this._path.get() + name + '.' + ext,
			fileBrowser: this,
			enableUnzip: valueInArray(_this.ext7z, ext.toUpperCase())
		}
	);
	
	return spanParent;
}

//TODO: translate
fileBrowser.prototype.makeSize = function(size)
{
	if (size > 1024 * 1024 * 1024)
		return (size / (1024 * 1024 * 1024)).toFixed(2) + ' Гб';
	else if (size > 1024 * 1024)
		return (size / (1024 * 1024)).toFixed(2) + ' Мб';
	else if (size > 1024)
		return (size / 1024).toFixed(2) + ' Кб';
	
	return size + ' б';
}

window.fileBrowser = fileBrowser;
window._fileBrowser = new fileBrowser();

///////////////////////////////////////////////////////////////////////////////
////////////////////////// Контекстное меню браузера //////////////////////////
///////////////////////////////////////////////////////////////////////////////

//фабрика, которая может возвращать элементы меню для архивирования (isZip=true) и разархивирования (isZip=false)
var zipUnzipActionFactory = function(isZip)
{
	return {
		title:  function() { return isZip ? _gtxt("Упаковать") : _gtxt("Извлечь"); },
		clickCallback: function(context)
		{
            context.fileBrowser._status.start();
			sendCrossDomainJSONRequest(serverBase + (context.enableUnzip ? 'FileBrowser/Unzip.ashx' : 'FileBrowser/Zip.ashx') + '?WrapStyle=func&FullName=' + encodeURIComponent(context.fullPath), function(response)
			{
                context.fileBrowser._status.stop();
                
				if (!parseResponse(response))
					return;
				
				var indexSlash = String(response.Result).lastIndexOf('\\'),
					fileName = String(response.Result).substring(indexSlash + 1, response.Result.length);
				
				context.fileBrowser.shownPath = fileName;
				
				context.fileBrowser.getFiles();
			})
		},
		isVisible: function(context)
		{
			return isZip ? !context.enableUnzip : context.enableUnzip; //XOR
		}
	}
}

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Скачать"); },
	clickCallback: function(context)
	{
		var form = _form([_input(null,[['attr','name','FullName'], ['attr','value', context.fullPath]])], [['css','display','none'],['attr','method','POST'],['attr','action',serverBase + "FileBrowser/Download.ashx"]]);
		
		_(document.body, [form]);
		
		form.submit();
		
		form.removeNode(true);
	}
}, ['FileBrowserFolder', 'FileBrowserFile']);

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Удалить"); },
	clickCallback: function(context)
	{
        context.fileBrowser._status.start();
		sendCrossDomainJSONRequest(serverBase + 'FileBrowser/Delete.ashx?WrapStyle=func&FullName=' + encodeURIComponent(context.fullPath), function(response)
		{
            context.fileBrowser._status.stop();
			if (!parseResponse(response))
				return;
			
			context.fileBrowser.getFiles();
		})
	}
}, ['FileBrowserFolder', 'FileBrowserFile']);

nsGmx.ContextMenuController.addContextMenuElem({
	title: function() { return _gtxt("Очистить"); },
	clickCallback: function(context)
	{
        context.fileBrowser._status.start();
		sendCrossDomainJSONRequest(serverBase + 'FileBrowser/CleanFolder.ashx?WrapStyle=func&FullName=' + encodeURIComponent(context.fullPath), function(response)
		{
            context.fileBrowser._status.stop();
			if (!parseResponse(response))
				return;
			
			context.fileBrowser.getFiles();
		})	
	}
}, 'FileBrowserFolder');

//упаковываем и файлы и папки
nsGmx.ContextMenuController.addContextMenuElem(zipUnzipActionFactory(true), ['FileBrowserFolder', 'FileBrowserFile']);

//распаковываем только файлы
nsGmx.ContextMenuController.addContextMenuElem(zipUnzipActionFactory(false), 'FileBrowserFile');

})(nsGmx.Utils._);

_translationsHash.addtext("rus", {
                            "tableBrowser.title" : "Список таблиц",
                            "tableBrowser.filterText" : "Фильтр по названию"
                         });
                         
_translationsHash.addtext("eng", {
                            "tableBrowser.title" : "Tables list",
                            "tableBrowser.filterText" : "Filter by name"
                         });                         

var tableBrowser = function()
{
	this.sortFuncs = 
	{
		name:[
			function(_a,_b){var a = String(_a).toLowerCase(), b = String(_b).toLowerCase(); if (a > b) return 1; else if (a < b) return -1; else return 0},
			function(_a,_b){var a = String(_a).toLowerCase(), b = String(_b).toLowerCase(); if (a < b) return 1; else if (a > b) return -1; else return 0}
		]
	};
	
	this.tables = [];
}

tableBrowser.prototype.createBrowser = function(closeFunc)
{
    var canvas = $('#tableBrowserDialog');
    
	if (canvas)
	{
		canvas.parent().dialog("destroy");
		
		canvas.parent().remove();
	}
		
	this.closeFunc = closeFunc;
	
	if (!this.tables.length)
		this.loadInfo();
	else
		this.loadInfoHandler(this.tables)
}

tableBrowser.prototype.close = function(name)
{
	this.closeFunc(name);
	
	var canvas = $('#tableBrowserDialog');
	
	$(canvas).parent().dialog("destroy");
	
	$(canvas).parent().remove();
}

tableBrowser.prototype.loadInfo = function()
{
	sendCrossDomainJSONRequest(serverBase + "VectorLayer/GetGeometryTables.ashx?WrapStyle=func", function(response)
	{
		if (!parseResponse(response))
			return;
		
		_tableBrowser.loadInfoHandler(response.Result)
	})
}

tableBrowser.prototype.loadInfoHandler = function(tables)
{
	this.tables = tables;
    
    var _this = this;
    var renderTableRow = function(table)
    {
        var	tdName = _td([_t(table)],[['css','fontSize','12px']]),
			returnButton = makeImageButton("img/choose.png", "img/choose_a.png"),
			tr = _tr([_td([returnButton]), tdName], [['dir', 'className', 'tableTableRow']]);
		
		returnButton.style.cursor = 'pointer';
		returnButton.style.marginLeft = '5px';
	
		_title(returnButton, _gtxt("Выбрать"));
			
        returnButton.onclick = function()
        {
            _this.close(table);
        }
		
		attachEffects(tr, 'hover');
        
        for (var i = 0; i < tr.childNodes.length; i++)
            tr.childNodes[i].style.width = this._fields[i].width;
        
        return tr;
    }
    
    var sortFuncs = {};
    sortFuncs[_gtxt('Имя')] = this.sortFuncs['name'];
    
    var tableProvider = new nsGmx.ScrollTable.StaticDataProvider();
    tableProvider.setOriginalItems(this.tables);
    tableProvider.setSortFunctions(sortFuncs);
    
    var tableTable = new nsGmx.ScrollTable({limit:5000, pagesCount: 5, height: 220, showFooter: false});
    tableTable.setDataProvider(tableProvider);
    
    var tableParent = _div(null, [['dir', 'id', 'tableBrowserDialog']]);
    tableTable.createTable({
        parent: tableParent, 
        name: 'tableTable', 
        width: 0, 
        fields: ['', _gtxt('Имя')], 
        fieldsWidths: ['10%', '90%'], 
        sortableFields: sortFuncs,
        drawFunc: renderTableRow, 
        isWidthScroll: false
    });
    
    var filterInput = _input(null, [['css','width','150px'],['dir','className','selectStyle']]);
    $(tableParent).prepend(filterInput).prepend($('<span/>', {'class': 'tableFilter'}).text(_gtxt("tableBrowser.filterText") + ": "));
    tableProvider.attachFilterEvents(filterInput, 'Table', function(fieldName, fieldValue, vals)
    {
        return vals.filter(function(val) {
            return String(val).toLowerCase().indexOf(fieldValue.toLowerCase()) > -1;
        });
    });
    
    showDialog( _gtxt("tableBrowser.title"), tableParent, {width: 300, height: 300} );
}

var _tableBrowser = new tableBrowser();
!(function(_) {
    
var wmsProjections = ['EPSG:3395', 'EPSG:4326', 'EPSG:41001'];	// типы проекций
    
var getTextContent = function(node) {
    if (typeof node.textContent != 'undefined')
        return node.textContent;
    
    var data = '';
    for (var i = 0; i < node.childNodes.length; i++)
        data += node.childNodes[i].data;
    
    return data;
}

var getScale = function(z)
{
    return Math.pow(2, -z)*156543.033928041;
}

/** Формирует URL картинки, который можно использовать для получения WMS слоя для данного положения карты
 * @property {String} url - WMS ссылка.
 * @property {object} props - атрибуты.
 * @property {String} props.srs - тип проекции.
 * @property {String} props.version - версия.
 * @property {String} props.name - Идентификатор слоя.
 * @property {object} props.bbox - ограничение по bounds(в географических координатах).
 * @property {object} requestProperties - атрибуты формата результирующего image.
 * @property {String} requestProperties.format - тип (по умолчанию 'image/jpeg').
 * @property {String} requestProperties.transparent - прозрачность подложки ('TRUE'/'FALSE' по умолчанию 'FALSE').
 * @returns {object} - {url: String, bounds: {Extent}}. bounds в географических координатах.
*/
var getWMSMapURL = function(url, props, requestProperties)
{
    var CRSParam = {'1.1.1': 'SRS', '1.3.0': 'CRS'};
    
    requestProperties = requestProperties || {};

    var lmap = nsGmx.leafletMap,
        extend = lmap.getBounds();
    
    var miny = Math.max(extend.getSouth(), -90);
    var maxy = Math.min(extend.getNorth(), 90);
    var minx = Math.max(extend.getWest(), -180);
    var maxx = Math.min(extend.getEast(), 180);
    
    if (props.bbox)
    {
        minx = Math.max(props.bbox.minx, minx);
        miny = Math.max(props.bbox.miny, miny);
        maxx = Math.min(props.bbox.maxx, maxx);
        maxy = Math.min(props.bbox.maxy, maxy);

        if (minx >= maxx || miny >= maxy)
            return;
    }
    
    var mercMin = L.Projection.Mercator.project({lat: miny, lng: minx}),
        mercMax = L.Projection.Mercator.project({lat: maxy, lng: maxx});
    
    var scale = getScale(lmap.getZoom());
    var w = Math.round((mercMax.x - mercMin.x)/scale);
    var h = Math.round((mercMax.y - mercMin.y)/scale);

    var isMerc = !(props.srs == wmsProjections[1]);

    var st = url;
    var format = requestProperties.format || 'image/jpeg';
    var transparentParam = requestProperties.transparent ? 'TRUE' : 'FALSE';
    var version = props.version || '1.1.1';
    var isV130 = version === '1.3.0';
    
    //st = st.replace(/Service=WMS[\&]*/i, '');
    //st = st.replace(/\&$/, '');
    
    st += (st.indexOf('?') == -1 ? '?':'&') + 'request=GetMap&Service=WMS';
    st += "&layers=" + encodeURIComponent(props.name) +
        "&VERSION=" + encodeURIComponent(version) +
        "&" + CRSParam[version] + "=" + encodeURIComponent(props.srs) +
        "&styles=" +
        "&width=" + w +
        "&height=" + h +
        "&bbox=" + (isMerc ? mercMin.x : isV130 ? miny : minx) +
             "," + (isMerc ? mercMin.y : isV130 ? minx : miny) +
             "," + (isMerc ? mercMax.x : isV130 ? maxy : maxx) +
             "," + (isMerc ? mercMax.y : isV130 ? maxx : maxy);

    if (url.indexOf('format=') == -1) st += "&format=" + encodeURIComponent(format);
    if (url.indexOf('transparent=') == -1) st += "&transparent=" + encodeURIComponent(transparentParam);
   
    return {url: st, bounds: {minX: minx, maxX: maxx, minY: miny, maxY: maxy}};
}

/**
 * Возвращает описание WMS-слоёв от XML, которую вернул сервер на запрос GetCapabilities
 * @returns {Array} - массив объектов с описанием слоёв
*/
var parseWMSCapabilities = function(response)
{
    var supportedVersions = {'1.1.1': true, '1.3.0': true};
    var SRSTagName = {'1.1.1': 'SRS', '1.3.0': 'CRS'};
    var BBOXTagName = {'1.1.1': 'LatLonBoundingBox', '1.3.0': 'EX_GeographicBoundingBox'};
    var serviceLayers = [],
        strResp = response.replace(/[\t\n\r]/g, ' '),
        strResp = strResp.replace(/\s+/g, ' '),
        xml = parseXML(response),
        mainTag = xml.getElementsByTagName('WMS_Capabilities')[0] || xml.getElementsByTagName('WMT_MS_Capabilities')[0],
        version = mainTag.getAttribute('version'),
        layersXML = xml.getElementsByTagName('Layer');
    
    if (!(version in supportedVersions)) {
        return [];
    }
    
    for (var i = 0; i < layersXML.length; i++)
    {
        var layer = {version: version},
            name = layersXML[i].getElementsByTagName('Name'),
            title = layersXML[i].getElementsByTagName('Title'),
            bbox = layersXML[i].getElementsByTagName(BBOXTagName[version]),
            srs = layersXML[i].getElementsByTagName(SRSTagName[version]);
        
        if (srs.length)
        {
            layer.srs = null;
            var supportedSrs = {};
            for (var si = 0; si < srs.length; si++)
            {
                var srsName = strip(getTextContent(srs[si]));
                supportedSrs[srsName] = true;
            }
            
            //порядок имеет значение!
            for (var p = 0; p < wmsProjections.length; p++) {
                if (wmsProjections[p] in supportedSrs) {
                    layer.srs = wmsProjections[p];
                    break;
                }
            }
            if (!layer.srs) continue;
        }
        else {
            layer.srs = wmsProjections[0];
        }

        if (name.length)
            layer.name = getTextContent(name[0]);
        
        if (bbox.length)
        {
            if (version == '1.1.1') {
                layer.bbox = 
                {
                    minx: Number(bbox[0].getAttribute('minx')),
                    miny: Number(bbox[0].getAttribute('miny')),
                    maxx: Number(bbox[0].getAttribute('maxx')),
                    maxy: Number(bbox[0].getAttribute('maxy'))
                };
            } else {
                layer.bbox = 
                {
                    minx: Number(getTextContent(bbox[0].getElementsByTagName('westBoundLongitude')[0])),
                    miny: Number(getTextContent(bbox[0].getElementsByTagName('southBoundLatitude')[0])),
                    maxx: Number(getTextContent(bbox[0].getElementsByTagName('eastBoundLongitude')[0])),
                    maxy: Number(getTextContent(bbox[0].getElementsByTagName('northBoundLatitude')[0]))
                };
            }
        }
        
        if (title.length)
            layer.title = getTextContent(title[0]);
        
        if (layer.name)
            serviceLayers.push(layer);
    }
    
    return serviceLayers;
}

var loadServerData = window.loadServerData =
{
	WFS:{},
	WMS:{}
}

/* Порядок координат в WFS зависит от формата SRS (http://geoserver.org/display/GEOSDOC/2.+WFS+-+Web+Feature+Service)
    * EPSG:xxxx: longitude/latitude (supported in WFS 1.1 requests too)
    * http://www.opengis.net/gml/srs/epsg.xml#xxxx: longitude/latitude (supported in WFS 1.1 requests too)
    * urn:x-ogc:def:crs:EPSG:xxxx: latitude/longitude
*/

var wfsParser = function()
{
	this.gmlns = 'http://www.opengis.net/gml';
	this.kmlns = 'http://earth.google.com/kml/2.0';
	
	this.axisOrder = null;
}

wfsParser.prototype.elementsNS = function(node,uri,name)
{
	var elements=[];
	
	if (node.getElementsByTagNameNS)
		elements = node.getElementsByTagNameNS(uri,name);
	else
	{
		var allNodes = node.getElementsByTagName("*"),
			potentialNode,
			fullName;
		
		for (var i = 0, len = allNodes.length; i < len ; ++i)
		{
			potentialNode = allNodes[i];
			fullName = (potentialNode.prefix) ? (potentialNode.prefix + ":" + name) : name;
			if ((name == "*") || (fullName == potentialNode.nodeName))
			{
				if( (uri == "*") || (uri == potentialNode.namespaceURI))
					elements.push(potentialNode);
			}
		}
	}
	
	return elements;
}

wfsParser.prototype.getChildValue = function(node, def)
{
	var value = def || "";
	if (node)
	{
		for(var child = node.firstChild; child; child = child.nextSibling)
		{
			switch (child.nodeType)
			{
				case 3:
				case 4: value += child.nodeValue;
			}
		}
	}
	
	return value;
}

wfsParser.prototype.parse = function(response, srs)
{
	var geometries = [],
		strResp = response.replace(/[\t\n\r]/g, ' '),
		strResp = strResp.replace(/\s+/g, ' '),
		xml = parseXML(strResp),
		parsedNS = strResp.indexOf('<kml') > -1 ? this.kmlns : this.gmlns;
	
	this.axisOrder = srs && srs.indexOf("urn:") == 0 ? 'latlong' : 'longlat';
	
	var order = ["Polygon","LineString","Point"];
	
	for (var i = 0, len = order.length; i < len; ++i)
	{
		var type = order[i],
			nodeList = this.elementsNS(xml.documentElement,parsedNS,type);
		
		for (var j = 0; j < nodeList.length; ++j)
		{
			geometry = this['parse' + type].apply(this,[nodeList[j]]);
			
			if (geometry)
				geometries.push(geometry);
		}
	}
	
	return geometries;
}

wfsParser.prototype.parsePoint = function(node)
{
	var coordString,
		coords=[],
		nodeList = this.elementsNS(node,this.gmlns,"pos");
	
	if (nodeList.length > 0)
	{
		coordString = strip(nodeList[0].firstChild.nodeValue);
		coords = coordString.split(" ");
	}
	if (coords.length == 0)
	{
		nodeList = this.elementsNS(node,this.gmlns,"coordinates");
		
		if (nodeList.length > 0)
		{
			coordString = strip(nodeList[0].firstChild.nodeValue);
			coords = coordString.split(",");
		}
	}
	if (coords.length == 0)
	{
		nodeList = this.elementsNS(node,this.gmlns,"coord");
		
		if (nodeList.length > 0)
		{
			var xList = this.elementsNS(nodeList[0],this.gmlns,"X"),
				yList = this.elementsNS(nodeList[0],this.gmlns,"Y");
			
			if (xList.length > 0 && yList.length > 0)
				coords = [xList[0].firstChild.nodeValue, yList[0].firstChild.nodeValue];
		}
	}
	
	return {feature:{}, geometry:{type: 'Point', coordinates: this.swapCoordinates([Number(coords[0]), Number(coords[1])])}}
}

wfsParser.prototype.parseLineString = function(node)
{
	var nodeList,
		coordString,
		coords = [],
		points = [],
		nodeList = this.elementsNS(node,this.gmlns,"posList");
	
	if (nodeList.length > 0)
	{
		coordString = strip(this.getChildValue(nodeList[0]));
		coords = coordString.split(" ");
		
		for (var i = 0; i < coords.length / 2; ++i)
		{
			j = i * 2;
			x = coords[j];
			y = coords[j + 1];
			
			points.push(this.swapCoordinates([Number(coords[j]), Number(coords[j + 1])]));
		}
	}
	if (coords.length == 0)
	{
		nodeList = this.elementsNS(node,this.gmlns,"coordinates");
		
		if (nodeList.length > 0)
		{
			coordString = strip(this.getChildValue(nodeList[0]));
			coordString = coordString.replace(/\s*,\s*/g,",");
			
			var pointList = coordString.split(" ");
			
			for (var i = 0; i < pointList.length; ++i)
			{
				coords = pointList[i].split(",");
				
				points.push(this.swapCoordinates([Number(coords[0]), Number(coords[1])]));
			}
		}
	}
	
	if (points.length != 0)
	{
		return {feature:{}, geometry:{type: 'LineString', coordinates: points}}
	}
	else
		return false
		
}

wfsParser.prototype.parsePolygon = function(node)
{
	var nodeList = this.elementsNS(node,this.gmlns,"LinearRing"),
		components = [];
	
	if (nodeList.length > 0)
	{
		var ring;
		
		for (var i = 0; i < nodeList.length; ++i)
		{
			ring = this.parseLineString.apply(this,[nodeList[i],true]);
			
			if (ring)
				components.push(ring.geometry.coordinates);
		}
	}
	
	return {feature:{}, geometry:{type: 'Polygon', coordinates: components}}
}

wfsParser.prototype.swapCoordinates = function(arr)
{
	if (this.axisOrder == 'latlong')
		return [arr[1], arr[0]]
	else
		return [arr[0], arr[1]];
}

var _wfsParser = new wfsParser();

var jsonParser = function()
{
	this.axisOrder = null;
}

jsonParser.prototype.parse = function(response, srs)
{
	var resp = JSON.parse(response),
		geometries = [];
	
	this.axisOrder = srs && srs.indexOf("urn:") == 0 ? 'latlong' : 'longlat';
	
	for (var i = 0; i < resp.features.length; i++)
	{
		if (resp.features[i].geometry.type.toLowerCase().indexOf('point') > -1)
			this.parsePoint(resp.features[i], geometries);
		else if (resp.features[i].geometry.type.toLowerCase().indexOf('linestring') > -1)
			this.parseLineString(resp.features[i], geometries);
		else if (resp.features[i].geometry.type.toLowerCase().indexOf('polygon') > -1)
			this.parsePolygon(resp.features[i], geometries);
	}
	
	return geometries;
}

jsonParser.prototype.parsePoint = function(feature, geometryArr)
{
	if (feature.geometry.type.toLowerCase().indexOf('multi') < 0)
		geometryArr.push({feature: feature, geometry:{type: 'POINT', coordinates: this.swapCoordinates(feature.geometry.coordinates)}});
	else
	{
		for (var i = 0; i < feature.geometry.coordinates.length; i++)
			geometryArr.push({feature: feature, geometry:{type: 'POINT', coordinates: this.swapCoordinates(feature.geometry.coordinates[i])}})
	}
}
jsonParser.prototype.parseLineString = function(feature, geometryArr)
{
	if (feature.geometry.type.toLowerCase().indexOf('multi') < 0)
	{
		var newCoords = [];
		
		for (var j = 0; j < feature.geometry.coordinates.length; j++)
			newCoords.push(this.swapCoordinates(feature.geometry.coordinates[j]))
		
		geometryArr.push({feature: feature, geometry:{type: 'LINESTRING', coordinates: newCoords}});
	}
	else
	{
		for (var i = 0; i < feature.geometry.coordinates.length; i++)
		{
			var newCoords = [];
		
			for (var j = 0; j < feature.geometry.coordinates[i].length; j++)
				newCoords.push(this.swapCoordinates(feature.geometry.coordinates[i][j]))
			
			geometryArr.push({feature: feature, geometry:{type: 'LINESTRING', coordinates: newCoords}});
		}
	}
}
jsonParser.prototype.parsePolygon = function(feature, geometryArr)
{
	if (feature.geometry.type.toLowerCase().indexOf('multi') < 0)
	{
		var newCoords = [];
		
		for (var k = 0; k < feature.geometry.coordinates.length; j++)
		{
			var newCoords2 = [];
			
			for (var j = 0; j < feature.geometry.coordinates[k].length; k++)
				newCoords2.push(this.swapCoordinates(feature.geometry.coordinates[k][j]))
			
			newCoords.push(newCoords2)
		}
		
		geometryArr.push({feature: feature, geometry:{type: 'POLYGON', coordinates: newCoords}});
	}
	else
	{
		for (var i = 0; i < feature.geometry.coordinates.length; i++)
		{
			var newCoords = [];
			
			for (var k = 0; k < feature.geometry.coordinates[i].length; k++)
			{
				var newCoords2 = [];
				
				for (var j = 0; j < feature.geometry.coordinates[i][k].length; j++)
					newCoords2.push(this.swapCoordinates(feature.geometry.coordinates[i][k][j]))
				
				newCoords.push(newCoords2)
			}
			
			geometryArr.push({feature: feature, geometry:{type: 'POLYGON', coordinates: newCoords}});
		}
	}
}
jsonParser.prototype.swapCoordinates = function(arr)
{
	if (this.axisOrder == 'latlong')
		return [arr[1], arr[0]]
	else
		return [arr[0], arr[1]];
}

var _jsonParser = new jsonParser();

var queryServerData = function()
{
	this.inputField = null;
	this.parentCanvas = null;
	
	this.wfsFormats = {};
	
	this.oldBalloon = false;
	this.oldBalloonIndex = -1;
	
	this.proj = ['EPSG:4326','EPSG:3395','EPSG:41001'];
	
	this.customParams = undefined;
}

queryServerData.prototype = new leftMenu();

/**
    Загружает виджет для добавления/просмотра WMS/WFS слоёв
 @param protocol
 @param parseFunc 
 @param drawFunc
 @param customParamsManager {object}- контролер дополнительных параметров. Имеет методы: <br/> 
        - init(targetDiv)->void Добавляет контрол к элементу targetDiv<br/>
        - collect()->Object Возвращает выбранные пользователем объекты<br/>
 @param version {string} Версия протокола, которая будет использоваться
*/
queryServerData.prototype.load = function(protocol, parseFunc, drawFunc, customParamsManager, version)
{
	window.convertCoords = function(coordsStr)
	{
		var res = [],
			coordsPairs = strip(coordsStr).replace(/\s+/,' ').split(' ');
		
		if (coordsStr.indexOf(',') == -1)
		{
			for (var j = 0; j < Math.floor(coordsPairs.length / 2); j++)
				res.push([Number(coordsPairs[2 * j + 1]), Number(coordsPairs[2 * j])])
		}
		else
		{
			for (var j = 0; j < coordsPairs.length; j++)
			{
				var parsedCoords = coordsPairs[j].split(',');
				
				res.push([Number(parsedCoords[1]), Number(parsedCoords[0])])
			}
		}
		
		return res;
	}
	
	window.parseGML = function(response, format, srs)
	{
		if (format == 'gml')
			return _wfsParser.parse(response, srs);
		else if (format == 'json')
			return _jsonParser.parse(response, srs);
		else
			return [];
	}
	
	var inputField = _input(null, [['dir','className','inputStyle'],['css','width','200px']]);
	
	this.parentCanvas = _div(null, [['dir','className','serverDataCanvas']]);
	
	var goButton = makeButton(_gtxt("Загрузить")),
		_this = this;
		
	var doGetCapabilities = function()
	{
		if (inputField.value != '')
		{
			if ( customParamsManager )
				_this.customParams = customParamsManager.collect();
				
			_this.getCapabilities(protocol, strip(inputField.value), parseFunc, drawFunc);
				
			inputField.value = '';
		}
		else
			inputError(inputField);
	}
	
	goButton.onclick = doGetCapabilities;
	
	$(inputField).on('keydown', function(e)
	{
		if (e.keyCode === 13)
	  	{
			doGetCapabilities();
	  		return false;
	  	}
	});
	
	var canvas = _div([_div([_span([_t(_gtxt("URL сервера"))])], [['css','marginBottom','3px']]),_table([_tbody([_tr([_td([inputField]),_td([goButton])])])], [['css','marginBottom','5px']])],[['css','margin','3px 0px 0px 10px']])
	
	if (customParamsManager)
	{
		var customParamsDiv = _div();
		$(canvas).append(customParamsDiv);
		_this.customParams = customParamsManager.init(customParamsDiv);
	}	

	_(this.workCanvas, [canvas, this.parentCanvas])
}

queryServerData.prototype.getCapabilities = function(protocol, url, parseFunc, drawFunc, version)
{
	var loading = _div([_img(null, [['attr','src','img/progress.gif'],['css','marginRight','10px']]), _t(_gtxt('загрузка...'))], [['css','margin','3px 0px 3px 20px']]),
		_this = this;
	
	if (this.parentCanvas.childNodes.length == 0)
		_(this.parentCanvas, [loading]);
	else
		this.parentCanvas.insertBefore(loading, this.parentCanvas.firstChild);
	
    var capabilitiesUrl = 
            url.replace(/REQUEST=GetCapabilities[\&]*/i, '')
               .replace(new RegExp('SERVICE=' + protocol + '[\&]', 'i'), '')
               .replace(/\&$/, '');
    
    capabilitiesUrl += capabilitiesUrl.indexOf('?') !== -1 ? '&' : '?';
    capabilitiesUrl += 'REQUEST=GetCapabilities&SERVICE=' + protocol;
    
    if (version) {
        capabilitiesUrl += '&VERSION=' + version;
    }
    
	sendCrossDomainJSONRequest(serverBase + "ApiSave.ashx?get=" + encodeURIComponent(capabilitiesUrl), function(response) {
		if (!parseResponse(response)) return;

		var servicelayers = parseFunc.call(_this, response.Result);

		drawFunc.call(_this, servicelayers, url, loading, undefined, _this.customParams);
	})
}

queryServerData.prototype.parseWFSCapabilities = function(response)
{
	var serviceLayers = [],
		strResp = response.replace(/[\t\n\r]/g, ' '),
		strResp = strResp.replace(/\s+/g, ' '),
		featuresXML = parseXML(response).getElementsByTagName('FeatureType');
	
	for (var i = 0; i < featuresXML.length; i++)
	{
		var layer = {},
			name = featuresXML[i].getElementsByTagName('Name'),
			title = featuresXML[i].getElementsByTagName('Title'),
			srs = featuresXML[i].getElementsByTagName('DefaultSRS');
		
		if (name.length)
			layer.name = getTextContent(name[0]);
		
		if (title.length)
			layer.title = getTextContent(title[0]);
		
		if (srs.length)
			layer.srs = getTextContent(srs[0]);
		
		if (layer.name)
			serviceLayers.push(layer);
	}
	
	return serviceLayers;
}

queryServerData.prototype.loadGML = function(url, parentTreeCanvas, box, header, format, loadLayerParams, srs)
{
	var _this = this;
	
	sendCrossDomainJSONRequest(serverBase + "ApiSave.ashx?get=" + encodeURIComponent(url), function(response)
	{
		if (!parseResponse(response)) return;
		var geometries = parseGML(response.Result, format, srs);
		_this.drawGML(geometries, url, parentTreeCanvas, box, header, loadLayerParams);
	})
}

queryServerData.prototype.saveGML = function(geometries)
{
	if (typeof geometries == 'undefined' || geometries == null)
	{
		geometries = [];
		
		globalFlashMap.drawing.forEachObject(function(ret)
		{
			geometries.push(ret.geometry);
		})
	}
	
	window.promptFunction(_gtxt('Введите имя gml-файла для скачивания:'), 'objects.gml', function(fileName)
	{
		globalFlashMap.saveObjects(geometries, nsGmx.Utils.translit(fileName));
	});
	
	return false;
}

queryServerData.prototype.drawGML = function(geometries, url, parentTreeCanvas, box, header, loadLayerParams)
{
	var parent = {
					'Point': L.gmx.createLayer({properties: {}}).addTo(nsGmx.leafletMap),
					'LineString': L.gmx.createLayer({properties: {}}).addTo(nsGmx.leafletMap),
					'Polygon': L.gmx.createLayer({properties: {}}).addTo(nsGmx.leafletMap)
				},
		styles = {
					'Point': typeof loadLayerParams != 'undefined' && loadLayerParams['point'] ? loadLayerParams['point'].RenderStyle : { marker: { size: 2 }, outline: { color: 0x0000ff, thickness: 1 } },
					'LineString': typeof loadLayerParams != 'undefined' && loadLayerParams['linestring'] ? loadLayerParams['linestring'].RenderStyle : { outline: { color: 0x0000ff, thickness: 2 } },
					'Polygon': typeof loadLayerParams != 'undefined' && loadLayerParams['polygon'] ? loadLayerParams['polygon'].RenderStyle : { outline: { color: 0x0000ff, thickness: 2, opacity: 100 }, fill: {color: 0xffffff, opacity: 20} }
				};
	// parent['POINT'].setStyle(styles['POINT']);
	// parent['LINESTRING'].setStyle(styles['LINESTRING']);
	// parent['POLYGON'].setStyle(styles['POLYGON']);
	
	var geomsPresent = {},
		bounds = L.gmxUtil.bounds(),
        items = {'Point': [], 'LineString': [], 'Polygon': []};
	
	for (var i = 0; i < geometries.length; i++)
	{
		//var elem = parent[geometries[i].geometry.type].addObject(geometries[i].geometry);
        items[geometries[i].geometry.type].push([L.gmxUtil.geoJSONtoGeometry(geometries[i].geometry, true)]);
        //parent[geometries[i].geometry.type].addItems();
		
		/*if (objLength(geometries[i].feature) > 0)
		{
			(function(i)
			{
				elem.setHandler("onClick", function(obj)
				{
					var elemCanvas = $(divCanvas).find("[geometryType='" + geometries[i].geometry.type + "']")[0];
					
					if (!elemCanvas.graphDataProperties ||
						!geometries[i].feature.properties)
						return;
					
					var balloonCanvas = _div();
						
					if (!_diagram.createBalloon(obj, balloonCanvas))
						return;
					
					if (_diagram.createDateTimeDiagramByAttrs(balloonCanvas, 500, 300, geometries[i].feature.properties, elemCanvas.graphDataProperties))
						_diagram.oldBalloon.resize();
				})
			})(i);
		}*/

		geomsPresent[geometries[i].geometry.type] = true;

		bounds.extendArray(geometries[i].geometry.coordinates[0]);
	}

    parent['Point'].addData(items['Point']);
    parent['LineString'].addData(items['LineString']);
    parent['Polygon'].addData(items['Polygon']);

	var divCanvas = _div(),
		divChilds = _div(),
		spanHeader = _span([_t(url.length < 45 ? url : url.substr(0, 45) + '...')]),
		_this = this;
	
	var clickFunc = function(flag)
	{
        var lmap = nsGmx.leafletMap,
            method = flag ? 'addLayer' : 'removeLayer';
        lmap[method](parent['Point']);
        lmap[method](parent['LineString']);
        lmap[method](parent['Polygon']);

		if (flag)
			show(divChilds);
		else
			hide(divChilds);
	}
	
	parentTreeCanvas.loaded = function() // переопределим функцию загрузки слоя на центрирование
	{
		if (!box.checked)
		{
			clickFunc.call(_this, true);
			
			box.checked = true;
		}
		
		//globalFlashMap.zoomToExtent(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
        nsGmx.leafletMap.fitBounds([[bounds.min.y, bounds.min.x], [bounds.max.y, bounds.max.x]]);
	}
	
	parentTreeCanvas.clear = function()
	{
        var lmap = nsGmx.leafletMap;
		lmap.removeLayer(parent['Point']);
		lmap.removeLayer(parent['LineString']);
		lmap.removeLayer(parent['Polygon']);
		
		divCanvas.removeNode(true);
	}
	
	box.onclick = function()
	{
		clickFunc.call(_this, this.checked);
	}
	
	$(parentTreeCanvas).empty();
	
	if (parentTreeCanvas.childNodes.length == 0)
		_(parentTreeCanvas, [divCanvas]);
	else
		parentTreeCanvas.insertBefore(divCanvas, parentTreeCanvas.firstChild);
	
	_(divCanvas, [divChilds]);
	
	// for (var type in geomsPresent)
	// {
		// var elemCanvas = _div(null, [['css','padding','2px'],['attr','geometryType', type]]),
			// //icon = _mapHelper.createStylesEditorIcon([{MinZoom:1,MaxZoom:20,RenderStyle:styles[type]}], type.toLowerCase()),
			// spanElem = _span(null, [['dir','className','layerfeature']]);
		
		// if (type == 'Point')
			// _(spanElem, [_t(_gtxt('точки'))]);
		// else if (type == 'LineString')
			// _(spanElem, [_t(_gtxt('линии'))]);
		// else if (type == 'Polygon')
			// _(spanElem, [_t(_gtxt('полигоны'))]);

        // var icon;
		// (function(type){
			// icon = _mapHelper.createWFSStylesEditor(parent[type], styles[type], type.toLowerCase(), divCanvas)
		// })(type);
		
		// if (typeof loadLayerParams != 'undefined' && loadLayerParams[type.toLowerCase()])
		// {
			// var info = loadLayerParams[type.toLowerCase()];
			
			// elemCanvas.graphDataType = info.graphDataType;
			// elemCanvas.graphDataProperties = info.graphDataProperties;
		// }
		// else
		// {
			// elemCanvas.graphDataType = "func";
			// elemCanvas.graphDataProperties = "";
		// }
		
		// _(elemCanvas, [icon, spanElem])
		// _(divChilds, [elemCanvas]);
		
	// }
	
	//globalFlashMap.zoomToExtent(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
    nsGmx.leafletMap.fitBounds([[bounds.min.y, bounds.min.x], [bounds.max.y, bounds.max.x]]);
	
	box.checked = true;
}

//loadParams - параметры для отдельных слоёв
//serverParams - параметры сервера, которые были указаны пользователем.
queryServerData.prototype.drawWMS = function(serviceLayers, url, replaceElem, loadParams, serverParams)
{
	var ulCanvas = _ul(null, [['css','paddingBottom','5px'], ['attr','url',url]]),
		ulChilds = _ul(),
		remove = makeImageButton('img/closemin.png','img/close_orange.png'),
		_this = this,
        lmap = nsGmx.leafletMap;
	
	$(replaceElem).replaceWith(ulCanvas)
    
    $(ulCanvas).data('serverParams', serverParams);
	
	remove.onclick = function()
	{
		for (var i = 0; i < ulChilds.childNodes.length; i++)
        {
			ulChilds.childNodes[i].firstChild.lastChild.clear && ulChilds.childNodes[i].firstChild.lastChild.clear();
            lmap.removeLayer(ulChilds.childNodes[i].firstChild.lastChild.gmxObject);
		}
        
		this.parentNode.parentNode.parentNode.removeNode(true);
	}
	
	remove.className = 'remove';
	remove.style.right = '0px';
	
	_(ulCanvas, [_li([_div([_span([_t(url.length < 45 ? url : url.substr(0, 45) + '...')],[['dir','className','urlHeader']]), remove],[['css','position','relative']]), ulChilds])])
	
	var clickFunc = function(layer, parent, flag)
	{
		if (!flag) {
			lmap.removeLayer(parent);
        } else {
			updateFunc(layer, parent);
			lmap.addLayer(parent);
		}
	}

	var updateFunc = function(layer, parent)
	{
        var requestParams = {}
		if (serverParams && serverParams.format)
        {
            requestParams.format = "image/" + serverParams.format;
            requestParams.transparent = serverParams.format === 'png';
        }
        
        var res = getWMSMapURL(url, layer, requestParams);
        
        if (res)
        {
            var b = res.bounds;
            parent.clearLayers();
            parent.addLayer(L.imageOverlay(serverBase + "ImgSave.ashx?now=true&get=" + encodeURIComponent(res.url), L.latLngBounds([[b.minY, b.minX], [b.maxY, b.maxX]])));
        }
	}
	
	serviceLayers.forEach(function(layer)
	{
		var elemCanvas = _div(null, [['css','padding','2px']]),
			box = _checkbox(false, 'checkbox'),
			spanElem = _span([_t(layer.title)], [['css','cursor','pointer'],['dir','className','layerfeature']]),
			parent = L.layerGroup().addTo(nsGmx.leafletMap);

        spanElem.gmxObject = parent;

		box.className = 'floatLeft';

        spanElem.onclick = function()
        {
            if (!box.checked)
                box.checked = true;
            
            clickFunc(layer, parent, true);
        }
        box.onclick = function()
        {
            clickFunc(layer, parent, this.checked);
        }
        box.update = function()
        {
            updateFunc(layer, parent);
        }
		
		box.setAttribute('layerName', layer.name);
		
		_(elemCanvas, [box, spanElem]);
		_(ulChilds, [_li([elemCanvas])]);
		
		if (typeof loadParams != 'undefined' && loadParams[layer.name])
			$(spanElem).trigger("click");
	});

	$(ulCanvas).treeview();

	nsGmx.leafletMap.on('moveend', function()
	{
        var boxes = ulChilds.getElementsByTagName('input');

        for (var i = 0; i < boxes.length; i++)
        {
            if (boxes[i].checked)
                boxes[i].update();
        }
	})
}

//Добавляет контрол выбора формата запроса к WMS и возвращает его в параметре format (пример: "png", "jpg")
queryServerData.prototype.customWMSParamsManager = (function()
{
	var _targetDiv = null;
	return {
		init: function(targetDiv) 
		{
			var select = nsGmx.Utils._select([_option([_t('png')]), _option([_t('jpeg')])], [['dir','className','selectStyle'], ['css', 'width', '60px']]);
			_targetDiv = targetDiv;
			_(_targetDiv, [_t(_gtxt('Формат изображения') + ': '), select]);
			_targetDiv.style.marginBottom = '5px';
		},
		collect: function() {
			return { format: $("option:selected", _targetDiv).text() };
		}
	}
})();

queryServerData.prototype.drawWFS = function(serviceLayers, url, replaceElem, loadParams)
{
	var ulCanvas = _ul(null, [['css','paddingBottom','5px'], ['attr','url',url]]),
		ulChilds = _ul(),
		divFormat = _div(),
		remove = makeImageButton('img/closemin.png','img/close_orange.png'),
		_this = this;
	
	$(replaceElem).replaceWith(ulCanvas)
	
	remove.onclick = function()
	{
		for (var i = 0; i < ulChilds.childNodes.length; i++)
			ulChilds.childNodes[i].firstChild.lastChild.clear && ulChilds.childNodes[i].firstChild.lastChild.clear();

		this.parentNode.parentNode.parentNode.removeNode(true);
	}

	remove.className = 'remove';
	remove.style.right = '0px';

	_(ulCanvas, [_li([_div([_span([_t(url.length < 45 ? url : url.substr(0, 45) + '...')],[['dir','className','urlHeader']]), divFormat, remove],[['css','position','relative']]), ulChilds])]);

	var formatSelect = nsGmx.Utils._select([_option([_t("JSON")], [['attr','value','json']]),
								_option([_t("GML / KML")], [['attr','value','gml']])], [['dir','className','selectStyle'],['css','width','100px']]);

	_(divFormat, [formatSelect]);

	var clickFunc = function(layer, flag, elemCanvas, box, header, loadLayerParams)
	{
		if (flag) {
			var newFormat = formatSelect.value;
			
			// загружаем данные только один раз
			if (!elemCanvas.loaded || elemCanvas.format != newFormat)
			{
				elemCanvas.clear && elemCanvas.clear();
				
                var separator = url.indexOf('?') !== -1 ? '&' : '?';
                
				var objUrl = url + separator + "request=GetFeature&version=1.0.0&typeName=" + layer.name;
				
				if (formatSelect.value == 'json')
					objUrl += '&outputFormat=json'
				
				_this.loadGML(objUrl, elemCanvas, box, header, newFormat, loadLayerParams, layer.srs);
				
				elemCanvas.loaded = true;
				elemCanvas.format = newFormat;
				
				var loading = _div([_img(null, [['attr','src','img/progress.gif'],['css','marginRight','10px']]), _t(_gtxt('загрузка...'))], [['css','margin','3px 0px']]);
		
				_(elemCanvas, [loading]);
			}
			else
			{
				if (typeof elemCanvas.loaded == 'function')
					elemCanvas.loaded();
			}
		}
	}
	
	for (var i = 0; i < serviceLayers.length; i++)
	{
		var elemCanvas = _div(null, [['css','padding','2px']]),
			box = _checkbox(false, 'checkbox'),
			spanElem = _span([_t(serviceLayers[i].title != '' ? serviceLayers[i].title : serviceLayers[i].name)],[['css','cursor','pointer'],['dir','className','layerfeature']]),
			elemChilds = _div(null, [['css','marginLeft','20px']]);

		box.className = 'floatLeft';

		box.setAttribute('layerName', serviceLayers[i].name);
		
		(function(layer, parentTreeCanvas, box, header){
			spanElem.onclick = function()
			{
				if (!box.checked)
					box.checked = true;
				
				clickFunc.call(_this, layer, true, parentTreeCanvas, box, header);
			}
			box.onclick = function()
			{
				clickFunc.call(_this, layer, this.checked, parentTreeCanvas, box, header);
			}
		})(serviceLayers[i], elemChilds, box, spanElem);
		
		_(elemCanvas, [box, _div([spanElem],[['css','display','inline']]), elemChilds])
		_(ulChilds, [_li([elemCanvas])])
			
		if (typeof loadParams != 'undefined' && loadParams[serviceLayers[i].name])
		{
			if (!box.checked)
				box.checked = true;
			
			formatSelect.value = loadParams[serviceLayers[i].name].format;
			clickFunc.call(_this, serviceLayers[i], true, elemChilds, box, spanElem, loadParams[serviceLayers[i].name].info);
		}
	}
	
	$(ulCanvas).treeview();
}


var _queryServerDataWFS = new queryServerData(),
	_queryServerDataWMS = new queryServerData();

loadServerData.WFS.load = function()
{
	var alreadyLoaded = _queryServerDataWFS.createWorkCanvas(arguments[0]);
	
	if (!alreadyLoaded)
		_queryServerDataWFS.load('WFS', _queryServerDataWFS.parseWFSCapabilities, _queryServerDataWFS.drawWFS, null, '1.0.0');
}
loadServerData.WFS.unload = function()
{
//	removeChilds($$('leftContent'))
}

loadServerData.WMS.load = function()
{
	var alreadyLoaded = _queryServerDataWMS.createWorkCanvas(arguments[0]);
	
	if (!alreadyLoaded)
		_queryServerDataWMS.load('WMS', parseWMSCapabilities, _queryServerDataWMS.drawWMS, _queryServerDataWMS.customWMSParamsManager);
}
loadServerData.WMS.unload = function()
{
//	removeChilds($$('leftContent'))
}

nsGmx.userObjectsManager.addDataCollector('wms', {
    collect: function()
    {
        if (!_queryServerDataWMS.workCanvas)
            return null;
        
        var value = {};
        
        $(_queryServerDataWMS.workCanvas.lastChild).children("ul[url]").each(function()
        {
            var url = this.getAttribute('url');
            var serverParams = $(this).data('serverParams');
            
            value[url] = {params: serverParams, layersVisibility: {}};
            
            $(this).find("input[type='checkbox']").each(function()
            {
                if (this.checked)
                {
                    value[url].layersVisibility[this.getAttribute('layerName')] = true;
                }
            })
        })
        
        if (!objLength(value))
            return null;
        
        return value;
    },
    
    load: function(data)
    {
        if (!data)
            return;

        $('#left_wms').remove();
        
        _queryServerDataWMS.builded = false;
        
        loadServerData.WMS.load('wms');
        
        for (var url in data)
        {
            (function(loadParams)
            {
                //поддержка старого формата данных
                if (!('layersVisibility' in loadParams))
                {
                    loadParams = {layersVisibility: loadParams};
                }
                
                _queryServerDataWMS.getCapabilities('WMS', url, parseWMSCapabilities, function(serviceLayers, url, replaceElem)
                {
                    _queryServerDataWMS.drawWMS(serviceLayers, url, replaceElem, loadParams.layersVisibility, loadParams.params);
                })
            })(data[url])
        }
    }
})

nsGmx.userObjectsManager.addDataCollector('wfs', {
    collect: function()
    {
        if (!_queryServerDataWFS.workCanvas)
            return null;
        
        var value = {};
        
        $(_queryServerDataWFS.workCanvas.lastChild).children("ul[url]").each(function()
        {
            var url = this.getAttribute('url');
            
            value[url] = {};
            
            $(this).find("input[type='checkbox']").each(function()
            {
                if (this.checked)
                {
                    var wfsLayerInfo = {};
                    
                    $(this.parentNode.lastChild).find(".colorIcon").each(function()
                    {
                        wfsLayerInfo[this.geometryType] = {RenderStyle: this.getStyle(), graphDataType: this.parentNode.graphDataType, graphDataProperties: this.parentNode.graphDataProperties}
                    })
                    
                    value[url][this.getAttribute('layerName')] = {format: this.parentNode.lastChild.format, info: wfsLayerInfo};
                }
            })
        })
        
        if (!objLength(value))   
            return null;
        
        return value;
    },
    
    load: function(data)
    {
        if (!data)
            return;

        $('#left_wfs').remove();
        
        _queryServerDataWFS.builded = false;
        
        loadServerData.WFS.load('wfs');
        
        for (var url in data)
        {
            (function(loadParams)
            {
                _queryServerDataWFS.getCapabilities('WFS', url, _queryServerDataWFS.parseWFSCapabilities, function(serviceLayers, url, replaceElem)
                {
                    _queryServerDataWFS.drawWFS(serviceLayers, url, replaceElem, loadParams);
                }, '1.0.0')
            })(data[url])
        }
    }
});

})(nsGmx.Utils._);
/*
 * Raphael 1.2.8 - JavaScript Vector Library
 *
 * Copyright (c) 2008 - 2009 Dmitry Baranovskiy (http://raphaeljs.com)
 * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) license.
 */

window.Raphael=(function(){var a=/[, ]+/,aH=/^(circle|rect|path|ellipse|text|image)$/,G=document,an=window,k={was:"Raphael" in an,is:an.Raphael},ai=function(){if(ai.is(arguments[0],"array")){var e=arguments[0],E=t[aO](ai,e.splice(0,3+ai.is(e[0],ag))),aS=E.set();for(var S=0,aT=e[l];S<aT;S++){var R=e[S]||{};aH.test(R.type)&&aS[d](E[R.type]().attr(R));}return aS;}return t[aO](ai,arguments);},aE="appendChild",aO="apply",aL="concat",am="",ah=" ",A="click dblclick mousedown mousemove mouseout mouseover mouseup".split(ah),L="hasOwnProperty",ae=/^\[object\s+|\]$/gi,ar="join",l="length",aQ="prototype",aR=String[aQ].toLowerCase,W=Math,f=W.max,aB=W.min,ag="number",at="toString",ap=Object[aQ][at],aJ={},aF=W.pow,d="push",aM=/^(?=[\da-f]$)/,c=/^url\(['"]?([^\)]+)['"]?\)$/i,u=/^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgb\(\s*([\d\.]+\s*,\s*[\d\.]+\s*,\s*[\d\.]+)\s*\)|rgb\(\s*([\d\.]+%\s*,\s*[\d\.]+%\s*,\s*[\d\.]+%)\s*\)|hs[bl]\(\s*([\d\.]+\s*,\s*[\d\.]+\s*,\s*[\d\.]+)\s*\)|hs[bl]\(\s*([\d\.]+%\s*,\s*[\d\.]+%\s*,\s*[\d\.]+%)\s*\))\s*$/i,J=W.round,s="setAttribute",w="split",P=parseFloat,B=parseInt,aG=String[aQ].toUpperCase,h={"clip-rect":"0 0 10e9 10e9",cursor:"default",cx:0,cy:0,fill:"#fff","fill-opacity":1,font:'10px "Arial"',"font-family":'"Arial"',"font-size":"10","font-style":"normal","font-weight":400,gradient:0,height:0,href:"http://raphaeljs.com/",opacity:1,path:"M0,0",r:0,rotation:0,rx:0,ry:0,scale:"1 1",src:"",stroke:"#000","stroke-dasharray":"","stroke-linecap":"butt","stroke-linejoin":"butt","stroke-miterlimit":0,"stroke-opacity":1,"stroke-width":1,target:"_blank","text-anchor":"middle",title:"Raphael",translation:"0 0",width:0,x:0,y:0},U={"clip-rect":"csv",cx:ag,cy:ag,fill:"colour","fill-opacity":ag,"font-size":ag,height:ag,opacity:ag,path:"path",r:ag,rotation:"csv",rx:ag,ry:ag,scale:"csv",stroke:"colour","stroke-opacity":ag,"stroke-width":ag,translation:"csv",width:ag,x:ag,y:ag},aI="replace";ai.version="1.2.8";ai.type=(an.SVGAngle||G.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure","1.1")?"SVG":"VML");ai.svg=!(ai.vml=ai.type=="VML");ai._id=0;ai._oid=0;ai.fn={};ai.is=function(i,e){e=aR.call(e);return((e=="object"||e=="undefined")&&typeof i==e)||(i==null&&e=="null")||aR.call(ap.call(i)[aI](ae,am))==e;};ai.setWindow=function(e){an=e;G=an.document;};var aw=function(E){if(ai.vml){var e=/^\s+|\s+$/g;aw=ad(function(S){var aS;S=(S+am)[aI](e,am);try{var aT=new ActiveXObject("htmlfile");aT.write("<body>");aT.close();aS=aT.body;}catch(aV){aS=createPopup().document.body;}var i=aS.createTextRange();try{aS.style.color=S;var aU=i.queryCommandValue("ForeColor");aU=((aU&255)<<16)|(aU&65280)|((aU&16711680)>>>16);return"#"+("000000"+aU[at](16)).slice(-6);}catch(aV){return"none";}});}else{var R=G.createElement("i");R.title="Rapha\xebl Colour Picker";R.style.display="none";G.body[aE](R);aw=ad(function(i){R.style.color=i;return G.defaultView.getComputedStyle(R,am).getPropertyValue("color");});}return aw(E);};ai.hsb2rgb=ad(function(aW,aU,a0){if(ai.is(aW,"object")&&"h" in aW&&"s" in aW&&"b" in aW){a0=aW.b;aU=aW.s;aW=aW.h;}var S,aS,a1;if(a0==0){return{r:0,g:0,b:0,hex:"#000"};}if(aW>1||aU>1||a0>1){aW/=255;aU/=255;a0/=255;}var aT=~~(aW*6),aX=(aW*6)-aT,R=a0*(1-aU),E=a0*(1-(aU*aX)),a2=a0*(1-(aU*(1-aX)));S=[a0,E,R,R,a2,a0,a0][aT];aS=[a2,a0,a0,E,R,R,a2][aT];a1=[R,R,a2,a0,a0,E,R][aT];S*=255;aS*=255;a1*=255;var aY={r:S,g:aS,b:a1},e=(~~S)[at](16),aV=(~~aS)[at](16),aZ=(~~a1)[at](16);e=e[aI](aM,"0");aV=aV[aI](aM,"0");aZ=aZ[aI](aM,"0");aY.hex="#"+e+aV+aZ;return aY;},ai);ai.rgb2hsb=ad(function(e,i,aU){if(ai.is(e,"object")&&"r" in e&&"g" in e&&"b" in e){aU=e.b;i=e.g;e=e.r;}if(ai.is(e,"string")){var aW=ai.getRGB(e);e=aW.r;i=aW.g;aU=aW.b;}if(e>1||i>1||aU>1){e/=255;i/=255;aU/=255;}var aT=f(e,i,aU),E=aB(e,i,aU),S,R,aS=aT;if(E==aT){return{h:0,s:0,b:aT};}else{var aV=(aT-E);R=aV/aT;if(e==aT){S=(i-aU)/aV;}else{if(i==aT){S=2+((aU-e)/aV);}else{S=4+((e-i)/aV);}}S/=6;S<0&&S++;S>1&&S--;}return{h:S,s:R,b:aS};},ai);var ax=/,?([achlmqrstvxz]),?/gi;ai._path2string=function(){return this.join(",")[aI](ax,"$1");};function ad(R,i,e){function E(){var S=Array[aQ].slice.call(arguments,0),aT=S[ar]("\u25ba"),aS=E.cache=E.cache||{},aU=E.count=E.count||[];if(aS[L](aT)){return e?e(aS[aT]):aS[aT];}aU[l]>=1000&&delete aS[aU.shift()];aU[d](aT);aS[aT]=R[aO](i,S);return e?e(aS[aT]):aS[aT];}return E;}ai.getRGB=ad(function(e){if(!e||!!((e=e+am).indexOf("-")+1)){return{r:-1,g:-1,b:-1,hex:"none",error:1};}if(e=="none"){return{r:-1,g:-1,b:-1,hex:"none"};}!(({hs:1,rg:1})[L](e.substring(0,2))||e.charAt()=="#")&&(e=aw(e));var aS,E,R,aV,aW,aT=e.match(u);if(aT){if(aT[2]){aV=B(aT[2].substring(5),16);R=B(aT[2].substring(3,5),16);E=B(aT[2].substring(1,3),16);}if(aT[3]){aV=B((aW=aT[3].charAt(3))+aW,16);R=B((aW=aT[3].charAt(2))+aW,16);E=B((aW=aT[3].charAt(1))+aW,16);}if(aT[4]){aT=aT[4][w](/\s*,\s*/);E=P(aT[0]);R=P(aT[1]);aV=P(aT[2]);}if(aT[5]){aT=aT[5][w](/\s*,\s*/);E=P(aT[0])*2.55;R=P(aT[1])*2.55;aV=P(aT[2])*2.55;}if(aT[6]){aT=aT[6][w](/\s*,\s*/);E=P(aT[0]);R=P(aT[1]);aV=P(aT[2]);return ai.hsb2rgb(E,R,aV);}if(aT[7]){aT=aT[7][w](/\s*,\s*/);E=P(aT[0])*2.55;R=P(aT[1])*2.55;aV=P(aT[2])*2.55;return ai.hsb2rgb(E,R,aV);}aT={r:E,g:R,b:aV};var i=(~~E)[at](16),S=(~~R)[at](16),aU=(~~aV)[at](16);i=i[aI](aM,"0");S=S[aI](aM,"0");aU=aU[aI](aM,"0");aT.hex="#"+i+S+aU;return aT;}return{r:-1,g:-1,b:-1,hex:"none",error:1};},ai);ai.getColor=function(i){var E=this.getColor.start=this.getColor.start||{h:0,s:1,b:i||0.75},e=this.hsb2rgb(E.h,E.s,E.b);E.h+=0.075;if(E.h>1){E.h=0;E.s-=0.2;E.s<=0&&(this.getColor.start={h:0,s:1,b:E.b});}return e.hex;};ai.getColor.reset=function(){delete this.start;};ai.parsePathString=ad(function(e){if(!e){return null;}var E={a:7,c:6,h:1,l:2,m:2,q:4,s:4,t:2,v:1,z:0},i=[];if(ai.is(e,"array")&&ai.is(e[0],"array")){i=ao(e);}if(!i[l]){(e+am)[aI](/([achlmqstvz])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?\s*,?\s*)+)/ig,function(S,R,aU){var aT=[],aS=aR.call(R);aU[aI](/(-?\d*\.?\d*(?:e[-+]?\d+)?)\s*,?\s*/ig,function(aW,aV){aV&&aT[d](+aV);});while(aT[l]>=E[aS]){i[d]([R][aL](aT.splice(0,E[aS])));if(!E[aS]){break;}}});}i[at]=ai._path2string;return i;});var N=ad(function(aY){if(!aY){return{x:0,y:0,width:0,height:0};}aY=C(aY);var aV=0,aU=0,S=[],E=[],R;for(var aS=0,aX=aY[l];aS<aX;aS++){R=aY[aS];if(R[0]=="M"){aV=R[1];aU=R[2];S[d](aV);E[d](aU);}else{var aT=au(aV,aU,R[1],R[2],R[3],R[4],R[5],R[6]);S=S[aL](aT.min.x,aT.max.x);E=E[aL](aT.min.y,aT.max.y);aV=R[5];aU=R[6];}}var e=aB[aO](0,S),aW=aB[aO](0,E);return{x:e,y:aW,width:f[aO](0,S)-e,height:f[aO](0,E)-aW};}),ao=function(aT){var R=[];if(!ai.is(aT,"array")||!ai.is(aT&&aT[0],"array")){aT=ai.parsePathString(aT);}for(var E=0,S=aT[l];E<S;E++){R[E]=[];for(var e=0,aS=aT[E][l];e<aS;e++){R[E][e]=aT[E][e];}}R[at]=ai._path2string;return R;},Y=ad(function(S){if(!ai.is(S,"array")||!ai.is(S&&S[0],"array")){S=ai.parsePathString(S);}var aX=[],aZ=0,aY=0,a2=0,a1=0,R=0;if(S[0][0]=="M"){aZ=S[0][1];aY=S[0][2];a2=aZ;a1=aY;R++;aX[d](["M",aZ,aY]);}for(var aU=R,a3=S[l];aU<a3;aU++){var e=aX[aU]=[],a0=S[aU];if(a0[0]!=aR.call(a0[0])){e[0]=aR.call(a0[0]);switch(e[0]){case"a":e[1]=a0[1];e[2]=a0[2];e[3]=a0[3];e[4]=a0[4];e[5]=a0[5];e[6]=+(a0[6]-aZ).toFixed(3);e[7]=+(a0[7]-aY).toFixed(3);break;case"v":e[1]=+(a0[1]-aY).toFixed(3);break;case"m":a2=a0[1];a1=a0[2];default:for(var aT=1,aV=a0[l];aT<aV;aT++){e[aT]=+(a0[aT]-((aT%2)?aZ:aY)).toFixed(3);}}}else{e=aX[aU]=[];if(a0[0]=="m"){a2=a0[1]+aZ;a1=a0[2]+aY;}for(var aS=0,E=a0[l];aS<E;aS++){aX[aU][aS]=a0[aS];}}var aW=aX[aU][l];switch(aX[aU][0]){case"z":aZ=a2;aY=a1;break;case"h":aZ+=+aX[aU][aW-1];break;case"v":aY+=+aX[aU][aW-1];break;default:aZ+=+aX[aU][aW-2];aY+=+aX[aU][aW-1];}}aX[at]=ai._path2string;return aX;},0,ao),p=ad(function(S){if(!ai.is(S,"array")||!ai.is(S&&S[0],"array")){S=ai.parsePathString(S);}var aW=[],aY=0,aX=0,a1=0,a0=0,R=0;if(S[0][0]=="M"){aY=+S[0][1];aX=+S[0][2];a1=aY;a0=aX;R++;aW[0]=["M",aY,aX];}for(var aU=R,a2=S[l];aU<a2;aU++){var e=aW[aU]=[],aZ=S[aU];if(aZ[0]!=aG.call(aZ[0])){e[0]=aG.call(aZ[0]);switch(e[0]){case"A":e[1]=aZ[1];e[2]=aZ[2];e[3]=aZ[3];e[4]=aZ[4];e[5]=aZ[5];e[6]=+(aZ[6]+aY);e[7]=+(aZ[7]+aX);break;case"V":e[1]=+aZ[1]+aX;break;case"H":e[1]=+aZ[1]+aY;break;case"M":a1=+aZ[1]+aY;a0=+aZ[2]+aX;default:for(var aT=1,aV=aZ[l];aT<aV;aT++){e[aT]=+aZ[aT]+((aT%2)?aY:aX);}}}else{for(var aS=0,E=aZ[l];aS<E;aS++){aW[aU][aS]=aZ[aS];}}switch(e[0]){case"Z":aY=a1;aX=a0;break;case"H":aY=e[1];break;case"V":aX=e[1];break;default:aY=aW[aU][aW[aU][l]-2];aX=aW[aU][aW[aU][l]-1];}}aW[at]=ai._path2string;return aW;},null,ao),aP=function(i,R,e,E){return[i,R,e,E,e,E];},aD=function(i,R,aT,S,e,E){var aS=1/3,aU=2/3;return[aS*i+aU*aT,aS*R+aU*S,aS*e+aU*aT,aS*E+aU*S,e,E];},F=function(a2,bw,bb,a9,a3,aX,aS,a1,bv,a4){var S=W.PI,a8=S*120/180,e=S/180*(+a3||0),bf=[],bc,bs=ad(function(bx,bA,i){var bz=bx*W.cos(i)-bA*W.sin(i),by=bx*W.sin(i)+bA*W.cos(i);return{x:bz,y:by};});if(!a4){bc=bs(a2,bw,-e);a2=bc.x;bw=bc.y;bc=bs(a1,bv,-e);a1=bc.x;bv=bc.y;var E=W.cos(S/180*a3),aZ=W.sin(S/180*a3),bh=(a2-a1)/2,bg=(bw-bv)/2;bb=f(bb,W.abs(bh));a9=f(a9,W.abs(bg));var R=bb*bb,bk=a9*a9,bm=(aX==aS?-1:1)*W.sqrt(W.abs((R*bk-R*bg*bg-bk*bh*bh)/(R*bg*bg+bk*bh*bh))),a6=bm*bb*bg/a9+(a2+a1)/2,a5=bm*-a9*bh/bb+(bw+bv)/2,aW=W.asin(((bw-a5)/a9).toFixed(7)),aV=W.asin(((bv-a5)/a9).toFixed(7));aW=a2<a6?S-aW:aW;aV=a1<a6?S-aV:aV;aW<0&&(aW=S*2+aW);aV<0&&(aV=S*2+aV);if(aS&&aW>aV){aW=aW-S*2;}if(!aS&&aV>aW){aV=aV-S*2;}}else{aW=a4[0];aV=a4[1];a6=a4[2];a5=a4[3];}var a0=aV-aW;if(W.abs(a0)>a8){var a7=aV,ba=a1,aY=bv;aV=aW+a8*(aS&&aV>aW?1:-1);a1=a6+bb*W.cos(aV);bv=a5+a9*W.sin(aV);bf=F(a1,bv,bb,a9,a3,0,aS,ba,aY,[aV,a7,a6,a5]);}a0=aV-aW;var aU=W.cos(aW),bu=W.sin(aW),aT=W.cos(aV),bt=W.sin(aV),bi=W.tan(a0/4),bl=4/3*bb*bi,bj=4/3*a9*bi,br=[a2,bw],bq=[a2+bl*bu,bw-bj*aU],bp=[a1+bl*bt,bv-bj*aT],bn=[a1,bv];bq[0]=2*br[0]-bq[0];bq[1]=2*br[1]-bq[1];if(a4){return[bq,bp,bn][aL](bf);}else{bf=[bq,bp,bn][aL](bf)[ar]()[w](",");var bd=[];for(var bo=0,be=bf[l];bo<be;bo++){bd[bo]=bo%2?bs(bf[bo-1],bf[bo],e).y:bs(bf[bo],bf[bo+1],e).x;}return bd;}},H=ad(function(i,e,R,E,aV,aU,aT,aS,aW){var S=1-aW;return{x:aF(S,3)*i+aF(S,2)*3*aW*R+S*3*aW*aW*aV+aF(aW,3)*aT,y:aF(S,3)*e+aF(S,2)*3*aW*E+S*3*aW*aW*aU+aF(aW,3)*aS};}),av=ad(function(i,e,a6,a4,aS,S,aU,aT,a0){var aY=1-a0,aX=aF(aY,3)*i+aF(aY,2)*3*a0*a6+aY*3*a0*a0*aS+aF(a0,3)*aU,aV=aF(aY,3)*e+aF(aY,2)*3*a0*a4+aY*3*a0*a0*S+aF(a0,3)*aT,a2=i+2*a0*(a6-i)+a0*a0*(aS-2*a6+i),a1=e+2*a0*(a4-e)+a0*a0*(S-2*a4+e),a5=a6+2*a0*(aS-a6)+a0*a0*(aU-2*aS+a6),a3=a4+2*a0*(S-a4)+a0*a0*(aT-2*S+a4),aZ=(1-a0)*i+a0*a6,aW=(1-a0)*e+a0*a4,R=(1-a0)*aS+a0*aU,E=(1-a0)*S+a0*aT;return{x:aX,y:aV,m:{x:a2,y:a1},n:{x:a5,y:a3},start:{x:aZ,y:aW},end:{x:R,y:E}};}),au=ad(function(E,e,S,R,a2,a1,aY,aV){var a0=(a2-2*S+E)-(aY-2*a2+S),aX=2*(S-E)-2*(a2-S),aU=E-S,aT=(-aX+W.sqrt(aX*aX-4*a0*aU))/2/a0,aS=(-aX-W.sqrt(aX*aX-4*a0*aU))/2/a0,aW=[e,aV],aZ=[E,aY],i;W.abs(aT)>1000000000000&&(aT=0.5);W.abs(aS)>1000000000000&&(aS=0.5);if(aT>0&&aT<1){i=H(E,e,S,R,a2,a1,aY,aV,aT);aZ[d](i.x);aW[d](i.y);}if(aS>0&&aS<1){i=H(E,e,S,R,a2,a1,aY,aV,aS);aZ[d](i.x);aW[d](i.y);}a0=(a1-2*R+e)-(aV-2*a1+R);aX=2*(R-e)-2*(a1-R);aU=e-R;aT=(-aX+W.sqrt(aX*aX-4*a0*aU))/2/a0;aS=(-aX-W.sqrt(aX*aX-4*a0*aU))/2/a0;W.abs(aT)>1000000000000&&(aT=0.5);W.abs(aS)>1000000000000&&(aS=0.5);if(aT>0&&aT<1){i=H(E,e,S,R,a2,a1,aY,aV,aT);aZ[d](i.x);aW[d](i.y);}if(aS>0&&aS<1){i=H(E,e,S,R,a2,a1,aY,aV,aS);aZ[d](i.x);aW[d](i.y);}return{min:{x:aB[aO](0,aZ),y:aB[aO](0,aW)},max:{x:f[aO](0,aZ),y:f[aO](0,aW)}};}),C=ad(function(a2,aX){var S=p(a2),aY=aX&&p(aX),aZ={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},e={x:0,y:0,bx:0,by:0,X:0,Y:0,qx:null,qy:null},aT=function(a3,a4){var i,a5;if(!a3){return["C",a4.x,a4.y,a4.x,a4.y,a4.x,a4.y];}!(a3[0] in {T:1,Q:1})&&(a4.qx=a4.qy=null);switch(a3[0]){case"M":a4.X=a3[1];a4.Y=a3[2];break;case"A":a3=["C"][aL](F[aO](0,[a4.x,a4.y][aL](a3.slice(1))));break;case"S":i=a4.x+(a4.x-(a4.bx||a4.x));a5=a4.y+(a4.y-(a4.by||a4.y));a3=["C",i,a5][aL](a3.slice(1));break;case"T":a4.qx=a4.x+(a4.x-(a4.qx||a4.x));a4.qy=a4.y+(a4.y-(a4.qy||a4.y));a3=["C"][aL](aD(a4.x,a4.y,a4.qx,a4.qy,a3[1],a3[2]));break;case"Q":a4.qx=a3[1];a4.qy=a3[2];a3=["C"][aL](aD(a4.x,a4.y,a3[1],a3[2],a3[3],a3[4]));break;case"L":a3=["C"][aL](aP(a4.x,a4.y,a3[1],a3[2]));break;case"H":a3=["C"][aL](aP(a4.x,a4.y,a3[1],a4.y));break;case"V":a3=["C"][aL](aP(a4.x,a4.y,a4.x,a3[1]));break;case"Z":a3=["C"][aL](aP(a4.x,a4.y,a4.X,a4.Y));break;}return a3;},E=function(a3,a4){if(a3[a4][l]>7){a3[a4].shift();var a5=a3[a4];while(a5[l]){a3.splice(a4++,0,["C"][aL](a5.splice(0,6)));}a3.splice(a4,1);a0=f(S[l],aY&&aY[l]||0);}},R=function(a7,a6,a4,a3,a5){if(a7&&a6&&a7[a5][0]=="M"&&a6[a5][0]!="M"){a6.splice(a5,0,["M",a3.x,a3.y]);a4.bx=0;a4.by=0;a4.x=a7[a5][1];a4.y=a7[a5][2];a0=f(S[l],aY&&aY[l]||0);}};for(var aV=0,a0=f(S[l],aY&&aY[l]||0);aV<a0;aV++){S[aV]=aT(S[aV],aZ);E(S,aV);aY&&(aY[aV]=aT(aY[aV],e));aY&&E(aY,aV);R(S,aY,aZ,e,aV);R(aY,S,e,aZ,aV);var aU=S[aV],a1=aY&&aY[aV],aS=aU[l],aW=aY&&a1[l];aZ.x=aU[aS-2];aZ.y=aU[aS-1];aZ.bx=P(aU[aS-4])||aZ.x;aZ.by=P(aU[aS-3])||aZ.y;e.bx=aY&&(P(a1[aW-4])||e.x);e.by=aY&&(P(a1[aW-3])||e.y);e.x=aY&&a1[aW-2];e.y=aY&&a1[aW-1];}return aY?[S,aY]:S;},null,ao),n=ad(function(aW){var aV=[];for(var aS=0,aX=aW[l];aS<aX;aS++){var e={},aU=aW[aS].match(/^([^:]*):?([\d\.]*)/);e.color=ai.getRGB(aU[1]);if(e.color.error){return null;}e.color=e.color.hex;aU[2]&&(e.offset=aU[2]+"%");aV[d](e);}for(var aS=1,aX=aV[l]-1;aS<aX;aS++){if(!aV[aS].offset){var E=P(aV[aS-1].offset||0),R=0;for(var S=aS+1;S<aX;S++){if(aV[S].offset){R=aV[S].offset;break;}}if(!R){R=100;S=aX;}R=P(R);var aT=(R-E)/(S-aS+1);for(;aS<S;aS++){E+=aT;aV[aS].offset=E+"%";}}}return aV;}),aj=function(){var E,i,S,R,e;if(ai.is(arguments[0],"string")||ai.is(arguments[0],"object")){if(ai.is(arguments[0],"string")){E=G.getElementById(arguments[0]);}else{E=arguments[0];}if(E.tagName){if(arguments[1]==null){return{container:E,width:E.style.pixelWidth||E.offsetWidth,height:E.style.pixelHeight||E.offsetHeight};}else{return{container:E,width:arguments[1],height:arguments[2]};}}}else{if(ai.is(arguments[0],ag)&&arguments[l]>3){return{container:1,x:arguments[0],y:arguments[1],width:arguments[2],height:arguments[3]};}}},az=function(e,E){var i=this;for(var R in E){if(E[L](R)&&!(R in e)){switch(typeof E[R]){case"function":(function(S){e[R]=e===i?S:function(){return S[aO](i,arguments);};})(E[R]);break;case"object":e[R]=e[R]||{};az.call(this,e[R],E[R]);break;default:e[R]=E[R];break;}}}},af=function(e,i){e==i.top&&(i.top=e.prev);e==i.bottom&&(i.bottom=e.next);e.next&&(e.next.prev=e.prev);e.prev&&(e.prev.next=e.next);},T=function(e,i){if(i.top===e){return;}af(e,i);e.next=null;e.prev=i.top;i.top.next=e;i.top=e;},j=function(e,i){if(i.bottom===e){return;}af(e,i);e.next=i.bottom;e.prev=null;i.bottom.prev=e;i.bottom=e;},x=function(i,e,E){af(i,E);e==E.top&&(E.top=i);e.next&&(e.next.prev=i);i.next=e.next;i.prev=e;e.next=i;},ak=function(i,e,E){af(i,E);e==E.bottom&&(E.bottom=i);e.prev&&(e.prev.next=i);i.prev=e.prev;e.prev=i;i.next=e;},al=/^r(?:\(([^,]+?)\s*,\s*([^\)]+?)\))?/;if(ai.svg){aJ.svgns="http://www.w3.org/2000/svg";aJ.xlink="http://www.w3.org/1999/xlink";var J=function(e){return +e+(~~e===e)*0.5;},O=function(aS){for(var E=0,R=aS[l];E<R;E++){if(aR.call(aS[E][0])!="a"){for(var e=1,S=aS[E][l];e<S;e++){aS[E][e]=J(aS[E][e]);}}else{aS[E][6]=J(aS[E][6]);aS[E][7]=J(aS[E][7]);}}return aS;},aC=function(E,e){if(e){for(var i in e){if(e[L](i)){E[s](i,e[i]);}}}else{return G.createElementNS(aJ.svgns,E);}};ai[at]=function(){return"Your browser supports SVG.\nYou are running Rapha\xebl "+this.version;};var o=function(e,R){var i=aC("path");R.canvas&&R.canvas[aE](i);var E=new aq(i,R);E.type="path";V(E,{fill:"none",stroke:"#000",path:e});return E;};var b=function(R,a0,e){var aX="linear",aU=0.5,aS=0.5,a2=R.style;a0=(a0+am)[aI](al,function(a4,i,a5){aX="radial";if(i&&a5){aU=P(i);aS=P(a5);var a3=((aS>0.5)*2-1);aF(aU-0.5,2)+aF(aS-0.5,2)>0.25&&(aS=W.sqrt(0.25-aF(aU-0.5,2))*a3+0.5)&&aS!=0.5&&(aS=aS.toFixed(5)-0.00001*a3);}return am;});a0=a0[w](/\s*\-\s*/);if(aX=="linear"){var aT=a0.shift();aT=-P(aT);if(isNaN(aT)){return null;}var S=[0,0,W.cos(aT*W.PI/180),W.sin(aT*W.PI/180)],aZ=1/(f(W.abs(S[2]),W.abs(S[3]))||1);S[2]*=aZ;S[3]*=aZ;if(S[2]<0){S[0]=-S[2];S[2]=0;}if(S[3]<0){S[1]=-S[3];S[3]=0;}}var aW=n(a0);if(!aW){return null;}var E=aC(aX+"Gradient");E.id="r"+(ai._id++)[at](36);aC(E,aX=="radial"?{fx:aU,fy:aS}:{x1:S[0],y1:S[1],x2:S[2],y2:S[3]});e.defs[aE](E);for(var aV=0,a1=aW[l];aV<a1;aV++){var aY=aC("stop");aC(aY,{offset:aW[aV].offset?aW[aV].offset:!aV?"0%":"100%","stop-color":aW[aV].color||"#fff"});E[aE](aY);}aC(R,{fill:"url(#"+E.id+")",opacity:1,"fill-opacity":1});a2.fill=am;a2.opacity=1;a2.fillOpacity=1;return 1;};var I=function(i){var e=i.getBBox();aC(i.pattern,{patternTransform:ai.format("translate({0},{1})",e.x,e.y)});};var V=function(aZ,a8){var a2={"":[0],none:[0],"-":[3,1],".":[1,1],"-.":[3,1,1,1],"-..":[3,1,1,1,1,1],". ":[1,3],"- ":[4,3],"--":[8,3],"- .":[4,3,1,3],"--.":[8,3,1,3],"--..":[8,3,1,3,1,3]},a4=aZ.node,a0=aZ.attrs,aW=aZ.rotate(),aS=function(bf,be){be=a2[aR.call(be)];if(be){var bc=bf.attrs["stroke-width"]||"1",ba={round:bc,square:bc,butt:0}[bf.attrs["stroke-linecap"]||a8["stroke-linecap"]]||0,bd=[];var bb=be[l];while(bb--){bd[bb]=be[bb]*bc+((bb%2)?1:-1)*ba;}aC(a4,{"stroke-dasharray":bd[ar](",")});}};a8[L]("rotation")&&(aW=a8.rotation);var aV=(aW+am)[w](a);if(!(aV.length-1)){aV=null;}else{aV[1]=+aV[1];aV[2]=+aV[2];}P(aW)&&aZ.rotate(0,true);for(var a3 in a8){if(a8[L](a3)){if(!h[L](a3)){continue;}var a1=a8[a3];a0[a3]=a1;switch(a3){case"rotation":aZ.rotate(a1,true);break;case"href":case"title":case"target":var a6=a4.parentNode;if(aR.call(a6.tagName)!="a"){var R=aC("a");a6.insertBefore(R,a4);R[aE](a4);a6=R;}a6.setAttributeNS(aZ.paper.xlink,a3,a1);break;case"cursor":a4.style.cursor=a1;break;case"clip-rect":var i=(a1+am)[w](a);if(i[l]==4){aZ.clip&&aZ.clip.parentNode.parentNode.removeChild(aZ.clip.parentNode);var E=aC("clipPath"),a5=aC("rect");E.id="r"+(ai._id++)[at](36);aC(a5,{x:i[0],y:i[1],width:i[2],height:i[3]});E[aE](a5);aZ.paper.defs[aE](E);aC(a4,{"clip-path":"url(#"+E.id+")"});aZ.clip=a5;}if(!a1){var a7=G.getElementById(a4.getAttribute("clip-path")[aI](/(^url\(#|\)$)/g,am));a7&&a7.parentNode.removeChild(a7);aC(a4,{"clip-path":am});delete aZ.clip;}break;case"path":if(a1&&aZ.type=="path"){a0.path=O(p(a1));aC(a4,{d:a0.path});}break;case"width":a4[s](a3,a1);if(a0.fx){a3="x";a1=a0.x;}else{break;}case"x":if(a0.fx){a1=-a0.x-(a0.width||0);}case"rx":if(a3=="rx"&&aZ.type=="rect"){break;}case"cx":aV&&(a3=="x"||a3=="cx")&&(aV[1]+=a1-a0[a3]);a4[s](a3,J(a1));aZ.pattern&&I(aZ);break;case"height":a4[s](a3,a1);if(a0.fy){a3="y";a1=a0.y;}else{break;}case"y":if(a0.fy){a1=-a0.y-(a0.height||0);}case"ry":if(a3=="ry"&&aZ.type=="rect"){break;}case"cy":aV&&(a3=="y"||a3=="cy")&&(aV[2]+=a1-a0[a3]);a4[s](a3,J(a1));aZ.pattern&&I(aZ);break;case"r":if(aZ.type=="rect"){aC(a4,{rx:a1,ry:a1});}else{a4[s](a3,a1);}break;case"src":if(aZ.type=="image"){a4.setAttributeNS(aZ.paper.xlink,"href",a1);}break;case"stroke-width":a4.style.strokeWidth=a1;a4[s](a3,a1);if(a0["stroke-dasharray"]){aS(aZ,a0["stroke-dasharray"]);}break;case"stroke-dasharray":aS(aZ,a1);break;case"translation":var aT=(a1+am)[w](a);aT[0]=+aT[0]||0;aT[1]=+aT[1]||0;if(aV){aV[1]+=aT[0];aV[2]+=aT[1];}q.call(aZ,aT[0],aT[1]);break;case"scale":var aT=(a1+am)[w](a);aZ.scale(+aT[0]||1,+aT[1]||+aT[0]||1,+aT[2]||null,+aT[3]||null);break;case"fill":var S=(a1+am).match(c);if(S){var E=aC("pattern"),aY=aC("image");E.id="r"+(ai._id++)[at](36);aC(E,{x:0,y:0,patternUnits:"userSpaceOnUse",height:1,width:1});aC(aY,{x:0,y:0});aY.setAttributeNS(aZ.paper.xlink,"href",S[1]);E[aE](aY);var a9=G.createElement("img");a9.style.cssText="position:absolute;left:-9999em;top-9999em";a9.onload=function(){aC(E,{width:this.offsetWidth,height:this.offsetHeight});aC(aY,{width:this.offsetWidth,height:this.offsetHeight});G.body.removeChild(this);aJ.safari();};G.body[aE](a9);a9.src=S[1];aZ.paper.defs[aE](E);a4.style.fill="url(#"+E.id+")";aC(a4,{fill:"url(#"+E.id+")"});aZ.pattern=E;aZ.pattern&&I(aZ);break;}if(!ai.getRGB(a1).error){delete a8.gradient;delete a0.gradient;!ai.is(a0.opacity,"undefined")&&ai.is(a8.opacity,"undefined")&&aC(a4,{opacity:a0.opacity});!ai.is(a0["fill-opacity"],"undefined")&&ai.is(a8["fill-opacity"],"undefined")&&aC(a4,{"fill-opacity":a0["fill-opacity"]});}else{if((({circle:1,ellipse:1})[L](aZ.type)||(a1+am).charAt()!="r")&&b(a4,a1,aZ.paper)){a0.gradient=a1;a0.fill="none";break;}}case"stroke":a4[s](a3,ai.getRGB(a1).hex);break;case"gradient":(({circle:1,ellipse:1})[L](aZ.type)||(a1+am).charAt()!="r")&&b(a4,a1,aZ.paper);break;case"opacity":case"fill-opacity":if(a0.gradient){var e=G.getElementById(a4.getAttribute("fill")[aI](/^url\(#|\)$/g,am));if(e){var aU=e.getElementsByTagName("stop");aU[aU[l]-1][s]("stop-opacity",a1);}break;}default:a3=="font-size"&&(a1=B(a1,10)+"px");var aX=a3[aI](/(\-.)/g,function(ba){return aG.call(ba.substring(1));});a4.style[aX]=a1;a4[s](a3,a1);break;}}}z(aZ,a8);if(aV){aZ.rotate(aV.join(ah));}else{P(aW)&&aZ.rotate(aW,true);}};var g=1.2;var z=function(e,S){if(e.type!="text"||!(S[L]("text")||S[L]("font")||S[L]("font-size")||S[L]("x")||S[L]("y"))){return;}var aW=e.attrs,E=e.node,aY=E.firstChild?B(G.defaultView.getComputedStyle(E.firstChild,am).getPropertyValue("font-size"),10):10;if(S[L]("text")){aW.text=S.text;while(E.firstChild){E.removeChild(E.firstChild);}var R=(S.text+am)[w]("\n");for(var aS=0,aX=R[l];aS<aX;aS++){if(R[aS]){var aU=aC("tspan");aS&&aC(aU,{dy:aY*g,x:aW.x});aU[aE](G.createTextNode(R[aS]));E[aE](aU);}}}else{var R=E.getElementsByTagName("tspan");for(var aS=0,aX=R[l];aS<aX;aS++){aS&&aC(R[aS],{dy:aY*g,x:aW.x});}}aC(E,{y:aW.y});var aT=e.getBBox(),aV=aW.y-(aT.y+aT.height/2);aV&&isFinite(aV)&&aC(E,{y:aW.y+aV});};var aq=function(i,e){var R=0,E=0;this[0]=i;this.id=ai._oid++;this.node=i;i.raphael=this;this.paper=e;this.attrs=this.attrs||{};this.transformations=[];this._={tx:0,ty:0,rt:{deg:0,cx:0,cy:0},sx:1,sy:1};!e.bottom&&(e.bottom=this);this.prev=e.top;e.top&&(e.top.next=this);e.top=this;this.next=null;};aq[aQ].rotate=function(i,e,R){if(this.removed){return this;}if(i==null){if(this._.rt.cx){return[this._.rt.deg,this._.rt.cx,this._.rt.cy][ar](ah);}return this._.rt.deg;}var E=this.getBBox();i=(i+am)[w](a);if(i[l]-1){e=P(i[1]);R=P(i[2]);}i=P(i[0]);if(e!=null){this._.rt.deg=i;}else{this._.rt.deg+=i;}(R==null)&&(e=null);this._.rt.cx=e;this._.rt.cy=R;e=e==null?E.x+E.width/2:e;R=R==null?E.y+E.height/2:R;if(this._.rt.deg){this.transformations[0]=ai.format("rotate({0} {1} {2})",this._.rt.deg,e,R);this.clip&&aC(this.clip,{transform:ai.format("rotate({0} {1} {2})",-this._.rt.deg,e,R)});}else{this.transformations[0]=am;this.clip&&aC(this.clip,{transform:am});}aC(this.node,{transform:this.transformations[ar](ah)});return this;};aq[aQ].hide=function(){!this.removed&&(this.node.style.display="none");return this;};aq[aQ].show=function(){!this.removed&&(this.node.style.display="");return this;};aq[aQ].remove=function(){if(this.removed){return;}af(this,this.paper);this.node.parentNode.removeChild(this.node);for(var e in this){delete this[e];}this.removed=true;};aq[aQ].getBBox=function(){if(this.removed){return this;}if(this.type=="path"){return N(this.attrs.path);}if(this.node.style.display=="none"){this.show();var R=true;}var aU={};try{aU=this.node.getBBox();}catch(aS){}finally{aU=aU||{};}if(this.type=="text"){aU={x:aU.x,y:Infinity,width:0,height:0};for(var E=0,S=this.node.getNumberOfChars();E<S;E++){var aT=this.node.getExtentOfChar(E);(aT.y<aU.y)&&(aU.y=aT.y);(aT.y+aT.height-aU.y>aU.height)&&(aU.height=aT.y+aT.height-aU.y);(aT.x+aT.width-aU.x>aU.width)&&(aU.width=aT.x+aT.width-aU.x);}}R&&this.hide();return aU;};aq[aQ].attr=function(){if(this.removed){return this;}if(arguments[l]==0){var S={};for(var R in this.attrs){if(this.attrs[L](R)){S[R]=this.attrs[R];}}this._.rt.deg&&(S.rotation=this.rotate());(this._.sx!=1||this._.sy!=1)&&(S.scale=this.scale());delete S.translation;S.gradient&&S.fill=="none"&&(S.fill=S.gradient)&&delete S.gradient;return S;}if(arguments[l]==1&&ai.is(arguments[0],"string")){if(arguments[0]=="translation"){return q.call(this);}if(arguments[0]=="rotation"){return this.rotate();}if(arguments[0]=="scale"){return this.scale();}if(arguments[0]=="fill"&&this.attrs.fill=="none"&&this.attrs.gradient){return this.attrs.gradient;}return this.attrs[arguments[0]];}if(arguments[l]==1&&ai.is(arguments[0],"array")){var e={};for(var E in arguments[0]){if(arguments[0][L](E)){e[arguments[0][E]]=this.attrs[arguments[0][E]];}}return e;}if(arguments[l]==2){var aS={};aS[arguments[0]]=arguments[1];V(this,aS);}else{if(arguments[l]==1&&ai.is(arguments[0],"object")){V(this,arguments[0]);}}return this;};aq[aQ].toFront=function(){if(this.removed){return this;}this.node.parentNode[aE](this.node);var e=this.paper;e.top!=this&&T(this,e);return this;};aq[aQ].toBack=function(){if(this.removed){return this;}if(this.node.parentNode.firstChild!=this.node){this.node.parentNode.insertBefore(this.node,this.node.parentNode.firstChild);j(this,this.paper);var e=this.paper;}return this;};aq[aQ].insertAfter=function(i){if(this.removed){return this;}var e=this.paper,E=i.node;if(E.nextSibling){E.parentNode.insertBefore(this.node,E.nextSibling);}else{E.parentNode[aE](this.node);}x(this,i,this.paper);return this;};aq[aQ].insertBefore=function(e){if(this.removed){return this;}var i=e.node;i.parentNode.insertBefore(this.node,i);ak(this,e,this.paper);return this;};var K=function(i,e,aS,S){e=J(e);aS=J(aS);var R=aC("circle");i.canvas&&i.canvas[aE](R);var E=new aq(R,i);E.attrs={cx:e,cy:aS,r:S,fill:"none",stroke:"#000"};E.type="circle";aC(R,E.attrs);return E;};var ay=function(E,e,aU,i,aS,aT){e=J(e);aU=J(aU);var S=aC("rect");E.canvas&&E.canvas[aE](S);var R=new aq(S,E);R.attrs={x:e,y:aU,width:i,height:aS,r:aT||0,rx:aT||0,ry:aT||0,fill:"none",stroke:"#000"};R.type="rect";aC(S,R.attrs);return R;};var ac=function(i,e,aT,aS,S){e=J(e);aT=J(aT);var R=aC("ellipse");i.canvas&&i.canvas[aE](R);var E=new aq(R,i);E.attrs={cx:e,cy:aT,rx:aS,ry:S,fill:"none",stroke:"#000"};E.type="ellipse";aC(R,E.attrs);return E;};var m=function(E,aT,e,aU,i,aS){var S=aC("image");aC(S,{x:e,y:aU,width:i,height:aS,preserveAspectRatio:"none"});S.setAttributeNS(E.xlink,"href",aT);E.canvas&&E.canvas[aE](S);var R=new aq(S,E);R.attrs={x:e,y:aU,width:i,height:aS,src:aT};R.type="image";return R;};var Q=function(i,e,aS,S){var R=aC("text");aC(R,{x:e,y:aS,"text-anchor":"middle"});i.canvas&&i.canvas[aE](R);var E=new aq(R,i);E.attrs={x:e,y:aS,"text-anchor":"middle",text:S,font:h.font,stroke:"none",fill:"#000"};E.type="text";V(E,E.attrs);return E;};var aN=function(i,e){this.width=i||this.width;this.height=e||this.height;this.canvas[s]("width",this.width);this.canvas[s]("height",this.height);return this;};var t=function(){var R=aj[aO](null,arguments),E=R&&R.container,i=R.x,aU=R.y,S=R.width,e=R.height;if(!E){throw new Error("SVG container not found.");}aJ.canvas=aC("svg");var aT=aJ.canvas;aJ.width=S||512;aJ.height=e||342;aC(aT,{xmlns:"http://www.w3.org/2000/svg",version:1.1,width:aJ.width,height:aJ.height});if(E==1){aT.style.cssText="position:absolute;left:"+i+"px;top:"+aU+"px";G.body[aE](aT);}else{if(E.firstChild){E.insertBefore(aT,E.firstChild);}else{E[aE](aT);}}E={canvas:aT};for(var aS in aJ){if(aJ[L](aS)){E[aS]=aJ[aS];}}E.bottom=E.top=null;az.call(E,E,ai.fn);E.clear();E.raphael=ai;return E;};aJ.clear=function(){var e=this.canvas;while(e.firstChild){e.removeChild(e.firstChild);}this.bottom=this.top=null;(this.desc=aC("desc"))[aE](G.createTextNode("Created with Rapha\xebl"));e[aE](this.desc);e[aE](this.defs=aC("defs"));};aJ.remove=function(){this.canvas.parentNode&&this.canvas.parentNode.removeChild(this.canvas);for(var e in this){delete this[e];}};}if(ai.vml){var aA=function(a1){var aY=/[ahqtv]/ig,aT=p;(a1+am).match(aY)&&(aT=C);aY=/[clmz]/g;if(aT==p&&!(a1+am).match(aY)){var E={M:"m",L:"l",C:"c",Z:"x",m:"t",l:"r",c:"v",z:"x"},S=/([clmz]),?([^clmz]*)/gi,aS=/-?[^,\s-]+/g;var aX=(a1+am)[aI](S,function(a2,a4,i){var a3=[];i[aI](aS,function(a5){a3[d](J(a5));});return E[a4]+a3;});return aX;}var aZ=aT(a1),R,aX=[],e;for(var aV=0,a0=aZ[l];aV<a0;aV++){R=aZ[aV];e=aR.call(aZ[aV][0]);e=="z"&&(e="x");for(var aU=1,aW=R[l];aU<aW;aU++){e+=J(R[aU])+(aU!=aW-1?",":am);}aX[d](e);}return aX[ar](ah);};ai[at]=function(){return"Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl "+this.version;};var o=function(e,aS){var R=ab("group");R.style.cssText="position:absolute;left:0;top:0;width:"+aS.width+"px;height:"+aS.height+"px";R.coordsize=aS.coordsize;R.coordorigin=aS.coordorigin;var E=ab("shape"),i=E.style;i.width=aS.width+"px";i.height=aS.height+"px";E.coordsize=this.coordsize;E.coordorigin=this.coordorigin;R[aE](E);var S=new aq(E,R,aS);S.isAbsolute=true;S.type="path";S.path=[];S.Path=am;e&&V(S,{fill:"none",stroke:"#000",path:e});aS.canvas[aE](R);return S;};var V=function(aW,a1){aW.attrs=aW.attrs||{};var aZ=aW.node,a2=aW.attrs,aT=aZ.style,R,a6=aW;for(var aU in a1){if(a1[L](aU)){a2[aU]=a1[aU];}}a1.href&&(aZ.href=a1.href);a1.title&&(aZ.title=a1.title);a1.target&&(aZ.target=a1.target);a1.cursor&&(aT.cursor=a1.cursor);if(a1.path&&aW.type=="path"){a2.path=a1.path;aZ.path=aA(a2.path);}if(a1.rotation!=null){aW.rotate(a1.rotation,true);}if(a1.translation){R=(a1.translation+am)[w](a);q.call(aW,R[0],R[1]);if(aW._.rt.cx!=null){aW._.rt.cx+=+R[0];aW._.rt.cy+=+R[1];aW.setBox(aW.attrs,R[0],R[1]);}}if(a1.scale){R=(a1.scale+am)[w](a);aW.scale(+R[0]||1,+R[1]||+R[0]||1,+R[2]||null,+R[3]||null);}if("clip-rect" in a1){var e=(a1["clip-rect"]+am)[w](a);if(e[l]==4){e[2]=+e[2]+(+e[0]);e[3]=+e[3]+(+e[1]);var aV=aZ.clipRect||G.createElement("div"),a5=aV.style,aS=aZ.parentNode;a5.clip=ai.format("rect({1}px {2}px {3}px {0}px)",e);if(!aZ.clipRect){a5.position="absolute";a5.top=0;a5.left=0;a5.width=aW.paper.width+"px";a5.height=aW.paper.height+"px";aS.parentNode.insertBefore(aV,aS);aV[aE](aS);aZ.clipRect=aV;}}if(!a1["clip-rect"]){aZ.clipRect&&(aZ.clipRect.style.clip=am);}}if(aW.type=="image"&&a1.src){aZ.src=a1.src;}if(aW.type=="image"&&a1.opacity){aZ.filterOpacity=" progid:DXImageTransform.Microsoft.Alpha(opacity="+(a1.opacity*100)+")";aT.filter=(aZ.filterMatrix||am)+(aZ.filterOpacity||am);}a1.font&&(aT.font=a1.font);a1["font-family"]&&(aT.fontFamily='"'+a1["font-family"][w](",")[0][aI](/^['"]+|['"]+$/g,am)+'"');a1["font-size"]&&(aT.fontSize=a1["font-size"]);a1["font-weight"]&&(aT.fontWeight=a1["font-weight"]);a1["font-style"]&&(aT.fontStyle=a1["font-style"]);if(a1.opacity!=null||a1["stroke-width"]!=null||a1.fill!=null||a1.stroke!=null||a1["stroke-width"]!=null||a1["stroke-opacity"]!=null||a1["fill-opacity"]!=null||a1["stroke-dasharray"]!=null||a1["stroke-miterlimit"]!=null||a1["stroke-linejoin"]!=null||a1["stroke-linecap"]!=null){aZ=aW.shape||aZ;var a0=(aZ.getElementsByTagName("fill")&&aZ.getElementsByTagName("fill")[0]),a3=false;!a0&&(a3=a0=ab("fill"));if("fill-opacity" in a1||"opacity" in a1){var i=((+a2["fill-opacity"]+1||2)-1)*((+a2.opacity+1||2)-1);i<0&&(i=0);i>1&&(i=1);a0.opacity=i;}a1.fill&&(a0.on=true);if(a0.on==null||a1.fill=="none"){a0.on=false;}if(a0.on&&a1.fill){var E=a1.fill.match(c);if(E){a0.src=E[1];a0.type="tile";}else{a0.color=ai.getRGB(a1.fill).hex;a0.src=am;a0.type="solid";if(ai.getRGB(a1.fill).error&&(a6.type in {circle:1,ellipse:1}||(a1.fill+am).charAt()!="r")&&b(a6,a1.fill)){a2.fill="none";a2.gradient=a1.fill;}}}a3&&aZ[aE](a0);var S=(aZ.getElementsByTagName("stroke")&&aZ.getElementsByTagName("stroke")[0]),a4=false;!S&&(a4=S=ab("stroke"));if((a1.stroke&&a1.stroke!="none")||a1["stroke-width"]||a1["stroke-opacity"]!=null||a1["stroke-dasharray"]||a1["stroke-miterlimit"]||a1["stroke-linejoin"]||a1["stroke-linecap"]){S.on=true;}(a1.stroke=="none"||S.on==null||a1.stroke==0||a1["stroke-width"]==0)&&(S.on=false);S.on&&a1.stroke&&(S.color=ai.getRGB(a1.stroke).hex);var i=((+a2["stroke-opacity"]+1||2)-1)*((+a2.opacity+1||2)-1),aX=(P(a1["stroke-width"])||1)*0.75;i<0&&(i=0);i>1&&(i=1);a1["stroke-width"]==null&&(aX=a2["stroke-width"]);a1["stroke-width"]&&(S.weight=aX);aX&&aX<1&&(i*=aX)&&(S.weight=1);S.opacity=i;a1["stroke-linejoin"]&&(S.joinstyle=a1["stroke-linejoin"]||"miter");S.miterlimit=a1["stroke-miterlimit"]||8;a1["stroke-linecap"]&&(S.endcap=a1["stroke-linecap"]=="butt"?"flat":a1["stroke-linecap"]=="square"?"square":"round");if(a1["stroke-dasharray"]){var aY={"-":"shortdash",".":"shortdot","-.":"shortdashdot","-..":"shortdashdotdot",". ":"dot","- ":"dash","--":"longdash","- .":"dashdot","--.":"longdashdot","--..":"longdashdotdot"};S.dashstyle=aY[L](a1["stroke-dasharray"])?aY[a1["stroke-dasharray"]]:am;}a4&&aZ[aE](S);}if(a6.type=="text"){var aT=a6.paper.span.style;a2.font&&(aT.font=a2.font);a2["font-family"]&&(aT.fontFamily=a2["font-family"]);a2["font-size"]&&(aT.fontSize=a2["font-size"]);a2["font-weight"]&&(aT.fontWeight=a2["font-weight"]);a2["font-style"]&&(aT.fontStyle=a2["font-style"]);a6.node.string&&(a6.paper.span.innerHTML=(a6.node.string+am)[aI](/</g,"&#60;")[aI](/&/g,"&#38;")[aI](/\n/g,"<br>"));a6.W=a2.w=a6.paper.span.offsetWidth;a6.H=a2.h=a6.paper.span.offsetHeight;a6.X=a2.x;a6.Y=a2.y+J(a6.H/2);switch(a2["text-anchor"]){case"start":a6.node.style["v-text-align"]="left";a6.bbx=J(a6.W/2);break;case"end":a6.node.style["v-text-align"]="right";a6.bbx=-J(a6.W/2);break;default:a6.node.style["v-text-align"]="center";break;}}};var b=function(e,aU){e.attrs=e.attrs||{};var aV=e.attrs,aX=e.node.getElementsByTagName("fill"),aS="linear",aT=".5 .5";e.attrs.gradient=aU;aU=(aU+am)[aI](al,function(aZ,a0,i){aS="radial";if(a0&&i){a0=P(a0);i=P(i);aF(a0-0.5,2)+aF(i-0.5,2)>0.25&&(i=W.sqrt(0.25-aF(a0-0.5,2))*((i>0.5)*2-1)+0.5);aT=a0+ah+i;}return am;});aU=aU[w](/\s*\-\s*/);if(aS=="linear"){var E=aU.shift();E=-P(E);if(isNaN(E)){return null;}}var S=n(aU);if(!S){return null;}e=e.shape||e.node;aX=aX[0]||ab("fill");if(S[l]){aX.on=true;aX.method="none";aX.type=(aS=="radial")?"gradientradial":"gradient";aX.color=S[0].color;aX.color2=S[S[l]-1].color;var aY=[];for(var R=0,aW=S[l];R<aW;R++){S[R].offset&&aY[d](S[R].offset+ah+S[R].color);}aX.colors&&(aX.colors.value=aY[l]?aY[ar](","):"0% "+aX.color);if(aS=="radial"){aX.focus="100%";aX.focussize=aT;aX.focusposition=aT;}else{aX.angle=(270-E)%360;}}return 1;};var aq=function(S,aT,e){var aS=0,E=0,i=0,R=1;this[0]=S;this.id=ai._oid++;this.node=S;S.raphael=this;this.X=0;this.Y=0;this.attrs={};this.Group=aT;this.paper=e;this._={tx:0,ty:0,rt:{deg:0},sx:1,sy:1};!e.bottom&&(e.bottom=this);this.prev=e.top;e.top&&(e.top.next=this);e.top=this;this.next=null;};aq[aQ].rotate=function(i,e,E){if(this.removed){return this;}if(i==null){if(this._.rt.cx){return[this._.rt.deg,this._.rt.cx,this._.rt.cy][ar](ah);}return this._.rt.deg;}i=(i+am)[w](a);if(i[l]-1){e=P(i[1]);E=P(i[2]);}i=P(i[0]);if(e!=null){this._.rt.deg=i;}else{this._.rt.deg+=i;}E==null&&(e=null);this._.rt.cx=e;this._.rt.cy=E;this.setBox(this.attrs,e,E);this.Group.style.rotation=this._.rt.deg;return this;};aq[aQ].setBox=function(a4,E,e){if(this.removed){return this;}var aY=this.Group.style,S=(this.shape&&this.shape.style)||this.node.style;a4=a4||{};for(var a2 in a4){if(a4[L](a2)){this.attrs[a2]=a4[a2];}}E=E||this._.rt.cx;e=e||this._.rt.cy;var a0=this.attrs,aU,aT,aV,a3;switch(this.type){case"circle":aU=a0.cx-a0.r;aT=a0.cy-a0.r;aV=a3=a0.r*2;break;case"ellipse":aU=a0.cx-a0.rx;aT=a0.cy-a0.ry;aV=a0.rx*2;a3=a0.ry*2;break;case"rect":case"image":aU=+a0.x;aT=+a0.y;aV=a0.width||0;a3=a0.height||0;break;case"text":this.textpath.v=["m",J(a0.x),", ",J(a0.y-2),"l",J(a0.x)+1,", ",J(a0.y-2)][ar](am);aU=a0.x-J(this.W/2);aT=a0.y-this.H/2;aV=this.W;a3=this.H;break;case"path":if(!this.attrs.path){aU=0;aT=0;aV=this.paper.width;a3=this.paper.height;}else{var a1=N(this.attrs.path);aU=a1.x;aT=a1.y;aV=a1.width;a3=a1.height;}break;default:aU=0;aT=0;aV=this.paper.width;a3=this.paper.height;break;}E=(E==null)?aU+aV/2:E;e=(e==null)?aT+a3/2:e;var R=E-this.paper.width/2,aX=e-this.paper.height/2;if(this.type=="path"||this.type=="text"){(aY.left!=R+"px")&&(aY.left=R+"px");(aY.top!=aX+"px")&&(aY.top=aX+"px");this.X=this.type=="text"?aU:-R;this.Y=this.type=="text"?aT:-aX;this.W=aV;this.H=a3;(S.left!=-R+"px")&&(S.left=-R+"px");(S.top!=-aX+"px")&&(S.top=-aX+"px");}else{(aY.left!=R+"px")&&(aY.left=R+"px");(aY.top!=aX+"px")&&(aY.top=aX+"px");this.X=aU;this.Y=aT;this.W=aV;this.H=a3;(aY.width!=this.paper.width+"px")&&(aY.width=this.paper.width+"px");(aY.height!=this.paper.height+"px")&&(aY.height=this.paper.height+"px");(S.left!=aU-R+"px")&&(S.left=aU-R+"px");(S.top!=aT-aX+"px")&&(S.top=aT-aX+"px");(S.width!=aV+"px")&&(S.width=aV+"px");(S.height!=a3+"px")&&(S.height=a3+"px");var aS=(+a4.r||0)/aB(aV,a3);if(this.type=="rect"&&this.arcsize.toFixed(4)!=aS.toFixed(4)&&(aS||this.arcsize)){var aZ=ab("roundrect"),a5={},a2=0,aW=this.events&&this.events[l];aZ.arcsize=aS;aZ.raphael=this;this.Group[aE](aZ);this.Group.removeChild(this.node);this[0]=this.node=aZ;this.arcsize=aS;for(var a2 in a0){a5[a2]=a0[a2];}delete a5.scale;this.attr(a5);if(this.events){for(;a2<aW;a2++){this.events[a2].unbind=Z(this.node,this.events[a2].name,this.events[a2].f,this);}}}}};aq[aQ].hide=function(){!this.removed&&(this.Group.style.display="none");return this;};aq[aQ].show=function(){!this.removed&&(this.Group.style.display="block");return this;};aq[aQ].getBBox=function(){if(this.removed){return this;}if(this.type=="path"){return N(this.attrs.path);}return{x:this.X+(this.bbx||0),y:this.Y,width:this.W,height:this.H};};aq[aQ].remove=function(){if(this.removed){return;}af(this,this.paper);this.node.parentNode.removeChild(this.node);this.Group.parentNode.removeChild(this.Group);this.shape&&this.shape.parentNode.removeChild(this.shape);for(var e in this){delete this[e];}this.removed=true;};aq[aQ].attr=function(){if(this.removed){return this;}if(arguments[l]==0){var R={};for(var E in this.attrs){if(this.attrs[L](E)){R[E]=this.attrs[E];}}this._.rt.deg&&(R.rotation=this.rotate());(this._.sx!=1||this._.sy!=1)&&(R.scale=this.scale());delete R.translation;R.gradient&&R.fill=="none"&&(R.fill=R.gradient)&&delete R.gradient;return R;}if(arguments[l]==1&&ai.is(arguments[0],"string")){if(arguments[0]=="translation"){return q.call(this);}if(arguments[0]=="rotation"){return this.rotate();}if(arguments[0]=="scale"){return this.scale();}if(arguments[0]=="fill"&&this.attrs.fill=="none"&&this.attrs.gradient){return this.attrs.gradient;}return this.attrs[arguments[0]];}if(this.attrs&&arguments[l]==1&&ai.is(arguments[0],"array")){var e={};for(var E=0,S=arguments[0][l];E<S;E++){e[arguments[0][E]]=this.attrs[arguments[0][E]];}return e;}var aS;if(arguments[l]==2){aS={};aS[arguments[0]]=arguments[1];}arguments[l]==1&&ai.is(arguments[0],"object")&&(aS=arguments[0]);if(aS){if(aS.text&&this.type=="text"){this.node.string=aS.text;}V(this,aS);if(aS.gradient&&(({circle:1,ellipse:1})[L](this.type)||(aS.gradient+am).charAt()!="r")){b(this,aS.gradient);}(this.type!="path"||this._.rt.deg)&&this.setBox(this.attrs);}return this;};aq[aQ].toFront=function(){!this.removed&&this.Group.parentNode[aE](this.Group);this.paper.top!=this&&T(this,this.paper);return this;};aq[aQ].toBack=function(){if(this.removed){return this;}if(this.Group.parentNode.firstChild!=this.Group){this.Group.parentNode.insertBefore(this.Group,this.Group.parentNode.firstChild);j(this,this.paper);}return this;};aq[aQ].insertAfter=function(e){if(this.removed){return this;}if(e.Group.nextSibling){e.Group.parentNode.insertBefore(this.Group,e.Group.nextSibling);}else{e.Group.parentNode[aE](this.Group);}x(this,e,this.paper);return this;};aq[aQ].insertBefore=function(e){if(this.removed){return this;}e.Group.parentNode.insertBefore(this.Group,e.Group);ak(this,e,this.paper);return this;};var K=function(i,e,aU,aS){var S=ab("group"),aT=ab("oval"),E=aT.style;S.style.cssText="position:absolute;left:0;top:0;width:"+i.width+"px;height:"+i.height+"px";S.coordsize=i.coordsize;S.coordorigin=i.coordorigin;S[aE](aT);var R=new aq(aT,S,i);R.type="circle";V(R,{stroke:"#000",fill:"none"});R.attrs.cx=e;R.attrs.cy=aU;R.attrs.r=aS;R.setBox({x:e-aS,y:aU-aS,width:aS*2,height:aS*2});i.canvas[aE](S);return R;};var ay=function(i,aU,aT,aV,R,e){var S=ab("group"),E=ab("roundrect"),aW=(+e||0)/(aB(aV,R));S.style.cssText="position:absolute;left:0;top:0;width:"+i.width+"px;height:"+i.height+"px";S.coordsize=i.coordsize;S.coordorigin=i.coordorigin;S[aE](E);E.arcsize=aW;var aS=new aq(E,S,i);aS.type="rect";V(aS,{stroke:"#000"});aS.arcsize=aW;aS.setBox({x:aU,y:aT,width:aV,height:R,r:e});i.canvas[aE](S);return aS;};var ac=function(e,aV,aU,E,i){var S=ab("group"),R=ab("oval"),aT=R.style;S.style.cssText="position:absolute;left:0;top:0;width:"+e.width+"px;height:"+e.height+"px";S.coordsize=e.coordsize;S.coordorigin=e.coordorigin;S[aE](R);var aS=new aq(R,S,e);aS.type="ellipse";V(aS,{stroke:"#000"});aS.attrs.cx=aV;aS.attrs.cy=aU;aS.attrs.rx=E;aS.attrs.ry=i;aS.setBox({x:aV-E,y:aU-i,width:E*2,height:i*2});e.canvas[aE](S);return aS;};var m=function(i,e,aV,aU,aW,R){var S=ab("group"),E=ab("image"),aT=E.style;S.style.cssText="position:absolute;left:0;top:0;width:"+i.width+"px;height:"+i.height+"px";S.coordsize=i.coordsize;S.coordorigin=i.coordorigin;E.src=e;S[aE](E);var aS=new aq(E,S,i);aS.type="image";aS.attrs.src=e;aS.attrs.x=aV;aS.attrs.y=aU;aS.attrs.w=aW;aS.attrs.h=R;aS.setBox({x:aV,y:aU,width:aW,height:R});i.canvas[aE](S);return aS;};var Q=function(i,aV,aU,aW){var S=ab("group"),R=ab("shape"),aT=R.style,aX=ab("path"),e=aX.style,E=ab("textpath");S.style.cssText="position:absolute;left:0;top:0;width:"+i.width+"px;height:"+i.height+"px";S.coordsize=i.coordsize;S.coordorigin=i.coordorigin;aX.v=ai.format("m{0},{1}l{2},{1}",J(aV),J(aU),J(aV)+1);aX.textpathok=true;aT.width=i.width;aT.height=i.height;E.string=aW+am;E.on=true;R[aE](E);R[aE](aX);S[aE](R);var aS=new aq(E,S,i);aS.shape=R;aS.textpath=aX;aS.type="text";aS.attrs.text=aW;aS.attrs.x=aV;aS.attrs.y=aU;aS.attrs.w=1;aS.attrs.h=1;V(aS,{font:h.font,stroke:"none",fill:"#000"});aS.setBox();i.canvas[aE](S);return aS;};var aN=function(E,e){var i=this.canvas.style;E==+E&&(E+="px");e==+e&&(e+="px");i.width=E;i.height=e;i.clip="rect(0 "+E+" "+e+" 0)";return this;};G.createStyleSheet().addRule(".rvml","behavior:url(#default#VML)");try{!G.namespaces.rvml&&G.namespaces.add("rvml","urn:schemas-microsoft-com:vml");var ab=function(e){return G.createElement("<rvml:"+e+' class="rvml">');};}catch(aa){var ab=function(e){return G.createElement("<"+e+' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');};}var t=function(){var R=aj[aO](null,arguments),i=R.container,aW=R.height,aX,E=R.width,aV=R.x,aU=R.y;if(!i){throw new Error("VML container not found.");}var aS={},aT=aS.canvas=G.createElement("div"),S=aT.style;E=E||512;aW=aW||342;E==+E&&(E+="px");aW==+aW&&(aW+="px");aS.width=1000;aS.height=1000;aS.coordsize="1000 1000";aS.coordorigin="0 0";aS.span=G.createElement("span");aS.span.style.cssText="position:absolute;left:-9999px;top:-9999px;padding:0;margin:0;line-height:1;display:inline;";aT[aE](aS.span);S.cssText=ai.format("width:{0};height:{1};position:absolute;clip:rect(0 {0} {1} 0);overflow:hidden",E,aW);if(i==1){G.body[aE](aT);S.left=aV+"px";S.top=aU+"px";i={style:{width:E,height:aW}};}else{i.style.width=E;i.style.height=aW;if(i.firstChild){i.insertBefore(aT,i.firstChild);}else{i[aE](aT);}}for(var e in aJ){if(aJ[L](e)){aS[e]=aJ[e];}}az.call(aS,aS,ai.fn);aS.top=aS.bottom=null;aS.raphael=ai;return aS;};aJ.clear=function(){this.canvas.innerHTML=am;this.bottom=this.top=null;};aJ.remove=function(){this.canvas.parentNode.removeChild(this.canvas);for(var e in this){delete this[e];}};}if((/^Apple|^Google/).test(navigator.vendor)&&!(navigator.userAgent.indexOf("Version/4.0")+1)){aJ.safari=function(){var e=this.rect(-99,-99,this.width+99,this.height+99);setTimeout(function(){e.remove();});};}else{aJ.safari=function(){};}var Z=(function(){if(G.addEventListener){return function(S,E,i,e){var R=function(aS){return i.call(e,aS);};S.addEventListener(E,R,false);return function(){S.removeEventListener(E,R,false);return true;};};}else{if(G.attachEvent){return function(aS,R,E,i){var S=function(aT){return E.call(i,aT||an.event);};aS.attachEvent("on"+R,S);var e=function(){aS.detachEvent("on"+R,S);return true;};return e;};}}})();for(var X=A[l];X--;){(function(e){aq[aQ][e]=function(i){if(ai.is(i,"function")){this.events=this.events||[];this.events.push({name:e,f:i,unbind:Z(this.shape||this.node,e,i,this)});}return this;};aq[aQ]["un"+e]=function(R){var E=this.events,i=E[l];while(i--){if(E[i].name==e&&E[i].f==R){E[i].unbind();E.splice(i,1);!E.length&&delete this.events;return this;}}return this;};})(A[X]);}aq[aQ].hover=function(i,e){return this.mouseover(i).mouseout(e);};aq[aQ].unhover=function(i,e){return this.unmouseover(i).unmouseout(e);};aJ.circle=function(e,E,i){return K(this,e||0,E||0,i||0);};aJ.rect=function(e,S,i,E,R){return ay(this,e||0,S||0,i||0,E||0,R||0);};aJ.ellipse=function(e,R,E,i){return ac(this,e||0,R||0,E||0,i||0);};aJ.path=function(e){e&&!ai.is(e,"string")&&!ai.is(e[0],"array")&&(e+=am);return o(ai.format[aO](ai,arguments),this);};aJ.image=function(R,e,S,i,E){return m(this,R||"about:blank",e||0,S||0,i||0,E||0);};aJ.text=function(e,E,i){return Q(this,e||0,E||0,i||am);};aJ.set=function(e){arguments[l]>1&&(e=Array[aQ].splice.call(arguments,0,arguments[l]));return new M(e);};aJ.setSize=aN;function r(){return this.x+ah+this.y;}aq[aQ].scale=function(a2,a1,R,E){if(a2==null&&a1==null){return{x:this._.sx,y:this._.sy,toString:r};}a1=a1||a2;!+a1&&(a1=a2);var a6,a4,a5,a3,bi=this.attrs;if(a2!=0){var aZ=this.getBBox(),aW=aZ.x+aZ.width/2,aS=aZ.y+aZ.height/2,bh=a2/this._.sx,bg=a1/this._.sy;R=(+R||R==0)?R:aW;E=(+E||E==0)?E:aS;var aY=~~(a2/W.abs(a2)),aV=~~(a1/W.abs(a1)),a9=this.node.style,bk=R+(aW-R)*bh,bj=E+(aS-E)*bg;switch(this.type){case"rect":case"image":var aX=bi.width*aY*bh,a8=bi.height*aV*bg,a0=bi.r*aB(bh,bg),aU=bk-aX/2,S=bj-a8/2;this.attr({height:a8,r:a0,width:aX,x:aU,y:S});break;case"circle":case"ellipse":this.attr({rx:bi.rx*aY*bh,ry:bi.ry*aV*bg,r:bi.r*aB(aY*bh,aV*bg),cx:bk,cy:bj});break;case"path":var bc=Y(bi.path),bd=true;for(var bf=0,a7=bc[l];bf<a7;bf++){var ba=bc[bf],be,aT=aG.call(ba[0]);if(aT=="M"&&bd){continue;}else{bd=false;}if(aT=="A"){ba[bc[bf][l]-2]*=bh;ba[bc[bf][l]-1]*=bg;ba[1]*=aY*bh;ba[2]*=aV*bg;ba[5]=+(aY+aV?!!+ba[5]:!+ba[5]);}else{if(aT=="H"){for(be=1,jj=ba[l];be<jj;be++){ba[be]*=bh;}}else{if(aT=="V"){for(be=1,jj=ba[l];be<jj;be++){ba[be]*=bg;}}else{for(be=1,jj=ba[l];be<jj;be++){ba[be]*=(be%2)?bh:bg;}}}}}var e=N(bc),a6=bk-e.x-e.width/2,a4=bj-e.y-e.height/2;bc[0][1]+=a6;bc[0][2]+=a4;this.attr({path:bc});break;}if(this.type in {text:1,image:1}&&(aY!=1||aV!=1)){if(this.transformations){this.transformations[2]="scale("[aL](aY,",",aV,")");this.node[s]("transform",this.transformations[ar](ah));a6=(aY==-1)?-bi.x-(aX||0):bi.x;a4=(aV==-1)?-bi.y-(a8||0):bi.y;this.attr({x:a6,y:a4});bi.fx=aY-1;bi.fy=aV-1;}else{this.node.filterMatrix=" progid:DXImageTransform.Microsoft.Matrix(M11="[aL](aY,", M12=0, M21=0, M22=",aV,", Dx=0, Dy=0, sizingmethod='auto expand', filtertype='bilinear')");a9.filter=(this.node.filterMatrix||am)+(this.node.filterOpacity||am);}}else{if(this.transformations){this.transformations[2]=am;this.node[s]("transform",this.transformations[ar](ah));bi.fx=0;bi.fy=0;}else{this.node.filterMatrix=am;a9.filter=(this.node.filterMatrix||am)+(this.node.filterOpacity||am);}}bi.scale=[a2,a1,R,E][ar](ah);this._.sx=a2;this._.sy=a1;}return this;};aq[aQ].clone=function(){return this.paper[this.type]().attr(this.attr());};ai.easing_formulas={linear:function(e){return e;},"<":function(e){return aF(e,3);},">":function(e){return aF(e-1,3)+1;},"<>":function(e){e=e*2;if(e<1){return aF(e,3)/2;}e-=2;return(aF(e,3)+2)/2;},backIn:function(i){var e=1.70158;return i*i*((e+1)*i-e);},backOut:function(i){i=i-1;var e=1.70158;return i*i*((e+1)*i+e)+1;},elastic:function(E){if(E==0||E==1){return E;}var i=0.3,e=i/4;return aF(2,-10*E)*W.sin((E-e)*(2*W.PI)/i)+1;},bounce:function(R){var i=7.5625,E=2.75,e;if(R<(1/E)){e=i*R*R;}else{if(R<(2/E)){R-=(1.5/E);e=i*R*R+0.75;}else{if(R<(2.5/E)){R-=(2.25/E);e=i*R*R+0.9375;}else{R-=(2.625/E);e=i*R*R+0.984375;}}}return e;}};var D={length:0},aK=function(){var aV=+new Date;for(var a6 in D){if(a6!="length"&&D[L](a6)){var bb=D[a6];if(bb.stop){delete D[a6];D[l]--;continue;}var aT=aV-bb.start,a4=bb.ms,a3=bb.easing,a7=bb.from,a0=bb.diff,R=bb.to,aZ=bb.t,a2=bb.prev||0,aU=bb.el,S=bb.callback,a1={},E;if(aT<a4){var aS=ai.easing_formulas[a3]?ai.easing_formulas[a3](aT/a4):aT/a4;for(var a5 in a7){if(a7[L](a5)){switch(U[a5]){case"number":E=+a7[a5]+aS*a4*a0[a5];break;case"colour":E="rgb("+[y(J(a7[a5].r+aS*a4*a0[a5].r)),y(J(a7[a5].g+aS*a4*a0[a5].g)),y(J(a7[a5].b+aS*a4*a0[a5].b))][ar](",")+")";break;case"path":E=[];for(var a9=0,aY=a7[a5][l];a9<aY;a9++){E[a9]=[a7[a5][a9][0]];for(var a8=1,ba=a7[a5][a9][l];a8<ba;a8++){E[a9][a8]=+a7[a5][a9][a8]+aS*a4*a0[a5][a9][a8];}E[a9]=E[a9][ar](ah);}E=E[ar](ah);break;case"csv":switch(a5){case"translation":var aX=a0[a5][0]*(aT-a2),aW=a0[a5][1]*(aT-a2);aZ.x+=aX;aZ.y+=aW;E=aX+ah+aW;break;case"rotation":E=+a7[a5][0]+aS*a4*a0[a5][0];a7[a5][1]&&(E+=","+a7[a5][1]+","+a7[a5][2]);break;case"scale":E=[+a7[a5][0]+aS*a4*a0[a5][0],+a7[a5][1]+aS*a4*a0[a5][1],(2 in R[a5]?R[a5][2]:am),(3 in R[a5]?R[a5][3]:am)][ar](ah);break;case"clip-rect":E=[];var a9=4;while(a9--){E[a9]=+a7[a5][a9]+aS*a4*a0[a5][a9];}break;}break;}a1[a5]=E;}}aU.attr(a1);aU._run&&aU._run.call(aU);}else{(aZ.x||aZ.y)&&aU.translate(-aZ.x,-aZ.y);R.scale&&(R.scale=R.scale+am);aU.attr(R);delete D[a6];D[l]--;aU.in_animation=null;ai.is(S,"function")&&S.call(aU);}bb.prev=aT;}}ai.svg&&aJ.safari();D[l]&&setTimeout(aK);},y=function(e){return e>255?255:(e<0?0:e);},q=function(e,E){if(e==null){return{x:this._.tx,y:this._.ty,toString:r};}this._.tx+=+e;this._.ty+=+E;switch(this.type){case"circle":case"ellipse":this.attr({cx:+e+this.attrs.cx,cy:+E+this.attrs.cy});break;case"rect":case"image":case"text":this.attr({x:+e+this.attrs.x,y:+E+this.attrs.y});break;case"path":var i=Y(this.attrs.path);i[0][1]+=+e;i[0][2]+=+E;this.attr({path:i});break;}return this;};aq[aQ].animateWith=function(i,E,e,S,R){D[i.id]&&(E.start=D[i.id].start);return this.animate(E,e,S,R);};aq[aQ].onAnimation=function(e){this._run=e||null;return this;};aq[aQ].animate=function(R,e,aX,a3){if(ai.is(aX,"function")||!aX){a3=aX||null;}var aY={},aZ={},a0={};for(var aW in R){if(R[L](aW)){if(U[L](aW)){aY[aW]=this.attr(aW);(aY[aW]==null)&&(aY[aW]=h[aW]);aZ[aW]=R[aW];switch(U[aW]){case"number":a0[aW]=(aZ[aW]-aY[aW])/e;break;case"colour":aY[aW]=ai.getRGB(aY[aW]);var aU=ai.getRGB(aZ[aW]);a0[aW]={r:(aU.r-aY[aW].r)/e,g:(aU.g-aY[aW].g)/e,b:(aU.b-aY[aW].b)/e};break;case"path":var E=C(aY[aW],aZ[aW]);aY[aW]=E[0];aZ[aW]=E[1];a0[aW]=[];for(var aT=0,a2=aY[aW][l];aT<a2;aT++){a0[aW][aT]=[0];for(var S=1,aV=aY[aW][aT][l];S<aV;S++){a0[aW][aT][S]=(aZ[aW][aT][S]-aY[aW][aT][S])/e;}}break;case"csv":var a1=(R[aW]+am)[w](a),aS=(aY[aW]+am)[w](a);switch(aW){case"translation":aY[aW]=[0,0];a0[aW]=[a1[0]/e,a1[1]/e];break;case"rotation":aY[aW]=(aS[1]==a1[1]&&aS[2]==a1[2])?aS:[0,a1[1],a1[2]];a0[aW]=[(a1[0]-aY[aW][0])/e,0,0];break;case"scale":R[aW]=a1;aY[aW]=(aY[aW]+am)[w](a);a0[aW]=[(a1[0]-aY[aW][0])/e,(a1[1]-aY[aW][1])/e,0,0];break;case"clip-rect":aY[aW]=(aY[aW]+am)[w](a);a0[aW]=[];var aT=4;while(aT--){a0[aW][aT]=(a1[aT]-aY[aW][aT])/e;}break;}aZ[aW]=a1;}}}}this.stop();this.in_animation=1;D[this.id]={start:R.start||+new Date,ms:e,easing:aX,from:aY,diff:a0,to:aZ,el:this,callback:a3,t:{x:0,y:0}};++D[l]==1&&aK();return this;};aq[aQ].stop=function(){D[this.id]&&D[l]--;delete D[this.id];return this;};aq[aQ].translate=function(e,i){return this.attr({translation:e+" "+i});};aq[aQ][at]=function(){return"Rapha\xebl\u2019s object";};ai.ae=D;var M=function(e){this.items=[];this[l]=0;if(e){for(var E=0,R=e[l];E<R;E++){if(e[E]&&(e[E].constructor==aq||e[E].constructor==M)){this[this.items[l]]=this.items[this.items[l]]=e[E];this[l]++;}}}};M[aQ][d]=function(){var S,e;for(var E=0,R=arguments[l];E<R;E++){S=arguments[E];if(S&&(S.constructor==aq||S.constructor==M)){e=this.items[l];this[e]=this.items[e]=S;this[l]++;}}return this;};M[aQ].pop=function(){delete this[this[l]--];return this.items.pop();};for(var v in aq[aQ]){if(aq[aQ][L](v)){M[aQ][v]=(function(e){return function(){for(var E=0,R=this.items[l];E<R;E++){this.items[E][e][aO](this.items[E],arguments);}return this;};})(v);}}M[aQ].attr=function(E,aT){if(E&&ai.is(E,"array")&&ai.is(E[0],"object")){for(var e=0,aS=E[l];e<aS;e++){this.items[e].attr(E[e]);}}else{for(var R=0,S=this.items[l];R<S;R++){this.items[R].attr[aO](this.items[R],arguments);}}return this;};M[aQ].animate=function(aS,E,aV,aU){(ai.is(aV,"function")||!aV)&&(aU=aV||null);var e=this.items[l],R=e,aT=this,S;aU&&(S=function(){!--e&&aU.call(aT);});this.items[--R].animate(aS,E,aV||S,S);while(R--){this.items[R].animateWith(this.items[e-1],aS,E,aV||S,S);}return this;};M[aQ].insertAfter=function(E){var e=this.items[l];while(e--){this.items[e].insertAfter(E);}return this;};M[aQ].getBBox=function(){var e=[],aT=[],E=[],S=[];for(var R=this.items[l];R--;){var aS=this.items[R].getBBox();e[d](aS.x);aT[d](aS.y);E[d](aS.x+aS.width);S[d](aS.y+aS.height);}e=aB[aO](0,e);aT=aB[aO](0,aT);return{x:e,y:aT,width:f[aO](0,E)-e,height:f[aO](0,S)-aT};};ai.registerFont=function(i){if(!i.face){return i;}this.fonts=this.fonts||{};var R={w:i.w,face:{},glyphs:{}},E=i.face["font-family"];for(var aT in i.face){if(i.face[L](aT)){R.face[aT]=i.face[aT];}}if(this.fonts[E]){this.fonts[E][d](R);}else{this.fonts[E]=[R];}if(!i.svg){R.face["units-per-em"]=B(i.face["units-per-em"],10);for(var S in i.glyphs){if(i.glyphs[L](S)){var aS=i.glyphs[S];R.glyphs[S]={w:aS.w,k:{},d:aS.d&&"M"+aS.d[aI](/[mlcxtrv]/g,function(aU){return{l:"L",c:"C",x:"z",t:"m",r:"l",v:"c"}[aU]||"M";})+"z"};if(aS.k){for(var e in aS.k){if(aS[L](e)){R.glyphs[S].k[e]=aS.k[e];}}}}}}return i;};aJ.getFont=function(aV,aW,E,S){S=S||"normal";E=E||"normal";aW=+aW||{normal:400,bold:700,lighter:300,bolder:800}[aW]||400;var aS=ai.fonts[aV];if(!aS){var R=new RegExp("(^|\\s)"+aV[aI](/[^\w\d\s+!~.:_-]/g,am)+"(\\s|$)","i");for(var e in ai.fonts){if(ai.fonts[L](e)){if(R.test(e)){aS=ai.fonts[e];break;}}}}var aT;if(aS){for(var aU=0,aX=aS[l];aU<aX;aU++){aT=aS[aU];if(aT.face["font-weight"]==aW&&(aT.face["font-style"]==E||!aT.face["font-style"])&&aT.face["font-stretch"]==S){break;}}}return aT;};aJ.print=function(S,R,e,aU,aV,a4){a4=a4||"middle";var a0=this.set(),a3=(e+am)[w](am),a1=0,aX=am,a5;ai.is(aU,"string")&&(aU=this.getFont(aU));if(aU){a5=(aV||16)/aU.face["units-per-em"];var E=aU.face.bbox.split(a),aT=+E[0],aW=+E[1]+(a4=="baseline"?E[3]-E[1]+(+aU.face.descent):(E[3]-E[1])/2);for(var aZ=0,aS=a3[l];aZ<aS;aZ++){var aY=aZ&&aU.glyphs[a3[aZ-1]]||{},a2=aU.glyphs[a3[aZ]];a1+=aZ?(aY.w||aU.w)+(aY.k&&aY.k[a3[aZ]]||0):0;a2&&a2.d&&a0[d](this.path(a2.d).attr({fill:"#000",stroke:"none",translation:[a1,0]}));}a0.scale(a5,a5,aT,aW).translate(S-aT,R-aW);}return a0;};ai.format=function(E){var i=ai.is(arguments[1],"array")?[0][aL](arguments[1]):arguments,e=/\{(\d+)\}/g;E&&ai.is(E,"string")&&i[l]-1&&(E=E[aI](e,function(S,R){return i[++R]==null?am:i[R];}));return E||am;};ai.ninja=function(){var E=an.Raphael,i;if(k.was){an.Raphael=k.is;}else{try{delete an.Raphael;}catch(R){an.Raphael=i;}}return E;};ai.el=aq[aQ];return ai;})();

var Diagram = function()
{
	this.rad = Math.PI / 180;
	
	this.oldBalloon = false,
	this.oldBalloonIndex = -1;
	
	this.colors = ["#FF3300", "#FF9900", "#CCFF00", "#33CC00", "#33CCCC", "#66CCFF", "#0066FF", "#CC33FF", "#CC0066", "#FF6633", "#CCFF66", "#33FF33", "#00CCCC", "#0099FF", "#0033CC", "#9933FF", "#CC3399", "#990033", "#FF9933", "#99CC00", "#33CC99", "#33CCFF", "#006699", "#660099"];
	this.colorCounter = 0;
}

Diagram.prototype.draw = function(parent, width, height)
{
	var graphID = 'graph' + Math.random();
	
	_(parent, [_div([_div(null,[['attr','id',graphID],['css','width',width + 'px'],['css','height',height + 'px']])])]);

	return Raphael(graphID, width, height);
}

Diagram.prototype.getNextColor = function()
{
	var color = this.colors[this.colorCounter % this.colors.length];
	
	++this.colorCounter;
	
	return color;
}

Diagram.prototype.resetColor = function()
{
	this.colorCounter = 0;
}

Diagram.prototype.createPieDiagram = function(parent, width, height, data)
{
	var graph = this.draw(parent, width, height),
		_this = this;
	
	this.resetColor()
	
	// определяем суммарное значение для масштабирования
	var countGraphValue = 0;
	for (var layer in data)
			countGraphValue += Number(data[layer]);
	
	// отсупы и размеры
	var cx = width / 2,
		cy = height / 2,
		r = height / 3.5;
	
	function sector(cx, cy, r, startAngle, endAngle, params)
	{
		if (Math.abs(endAngle - startAngle - 360) < 180 / (Math.PI * r))
			return graph.circle(cx, cy, r).attr(params);
		
		var x1 = cx + r * Math.cos(-startAngle * _this.rad),
			x2 = cx + r * Math.cos(-endAngle * _this.rad),
			y1 = cy + r * Math.sin(-startAngle * _this.rad),
			y2 = cy + r * Math.sin(-endAngle * _this.rad);
		
		return graph.path(["M", cx, cy, "L", x1, y1, "A", r, r, 0, +(endAngle - startAngle > 180), 0, x2, y2, "z"]).attr(params);
	}
	
	var angle = 0,
		startColor = 0,
		littleAngle = 0,
		littleValue = 0,
		delta = 20,
		ms = 300,
		startOpacity = 1,
		maxScale = 1.05,
		textTemplate = "text\nvalue (proc%)",
		process = function(layer)
		{
			var textData = layer,
				value = Number(data[layer]),
				proc = Number(100 * value / countGraphValue).toFixed(1),
	            angleplus = 360 * value / countGraphValue;
	        
	        if (angleplus < 180 / (Math.PI * r))
			{
				littleValue += value;
				littleAngle += angleplus;
				
				return;
			}
	        
	        var	popangle = angle + (angleplus / 2),
				bcolor = _diagram.getNextColor(),
				hsbBcolor = Raphael.rgb2hsb(bcolor),
				color = Raphael.hsb2rgb(hsbBcolor.h, hsbBcolor.s, hsbBcolor.b * 0.6).hex,
				p = sector(cx, cy, r, angle, angle + angleplus, {gradient: Math.abs(Math.round(angle + angleplus - 90)) + "-" + bcolor + "-" + color, stroke: color, "stroke-width": 1}).attr({id:layer}),
				txt = graph.text(cx + (r + delta) * Math.cos(-popangle * _this.rad), cy + (r + delta) * Math.sin(-popangle * _this.rad), textTemplate.replace(/text/g,textData).replace(/value/g, value).replace(/proc/g, proc))
	        					.attr({fill: "#153069", stroke: "none", opacity: startOpacity, "font-family": '"Arial"', "font-size": "13px", "text-anchor": (angle + angleplus /2 > 90 && angle + angleplus / 2 < 270) ? "end" : "start"});
	        
	        p.mouseover(function()
	        {
	        	p.animate({scale: [maxScale, maxScale, cx, cy]}, ms, "elastic");
				
			//	txt.animate({opacity: 1}, ms, "elastic");
				txt.node.setAttribute("fill","#FC830B")
	        }).mouseout(function()
	        {
	        	p.animate({scale: [1, 1, cx, cy]}, ms, "elastic");
	        	
			//	txt.animate({opacity: startOpacity}, ms);
				txt.node.setAttribute("fill","#153069")
	        });
	        angle += angleplus;
	        startColor += .1;
	        
	        if (startColor > 1)
	        	startColor = 0.1;
		},
		processLittle = function()
		{
			var textData = 'Остальное',
		    	value = littleValue,
				angleplus = littleAngle,
				popangle = angle + (angleplus / 2),
				color = "#CCCCCF",
				bcolor = "#99999B";
		       
			var p = sector(cx, cy, r, angle, angle + angleplus, {gradient: Math.abs(Math.round(angle + angleplus - 90)) + "-" + bcolor + "-" + color, stroke: color, "stroke-width": 1}).attr({id:data}),
			    txt = graph.text(cx + (r + delta) * Math.cos(-popangle * _this.rad), cy + (r + delta) * Math.sin(-popangle * _this.rad), textTemplate.replace(/text/g,textData).replace(/value/g, value))
			                                       .attr({fill: "#4970AC", stroke: "none", opacity: startOpacity, "font-family": '"Arial"', "font-size": "10px"});
		       
		//	txt.node.setAttribute("angle", -popangle)
		//	p.node.setAttribute("angle", 0)

			p.mouseover(function()
			{
				p.animate({scale: [maxScale, maxScale, cx, cy]}, ms, "elastic");
				       
				txt.animate({opacity: 1}, ms, "elastic");
			}).mouseout(function()
			{
				p.animate({scale: [1, 1, cx, cy]}, ms, "elastic");

				txt.animate({opacity: startOpacity}, ms);
			});
		}
	
	Raphael.getColor.reset();
	
	for (var layer in data)
		process(layer);
	
	if (littleAngle > 0)
		processLittle();	
}

Diagram.prototype.createDateTimeDiagram = function(parent, width, height, data)
{
	var graph = this.draw(parent, width, height);

	var dateTimeData = [],
		minValue = Number.MAX_VALUE,
		maxValue = -Number.MAX_VALUE,
		_this = this;
	
	for (var propName in data)
	{
		dateTimeData.push({date:Number(propName), value:data[propName]});
		
		if (data[propName] < minValue)
			minValue = data[propName];
		
		if (data[propName] > maxValue)
			maxValue = data[propName];
	}
	
	Raphael.getColor.reset();
	
	dateTimeData = dateTimeData.sort(function(a,b)
	{
		return a.date - b.date;
	});
	
	var cx = width - 50,
		cy = height - 40,
		firstDate = dateTimeData[0].date,
		lastDate = dateTimeData[dateTimeData.length - 1].date,
		scaleX = lastDate - firstDate,
		scaleY = maxValue - minValue != 0 ? maxValue - minValue : 1,
		firstDate = dateTimeData[0].date,
		funcPath = [],
		leaveTimer,
		isLabelVisible = false
		processPath = function(data, i)
		{
			var xCoord = 40 + cx * (data.date - firstDate) / scaleX,
				yCoord = 10 + cy - cy * (data.value - minValue) / scaleY;
			
			if (i == 0)
				funcPath = funcPath.concat(['M', xCoord, yCoord]);
			else
				funcPath = funcPath.concat(['L', xCoord, yCoord]);
		},
		process = function(data, i)
		{
			var xCoord = 40 + cx * (data.date - firstDate) / scaleX,
				yCoord = 10 + cy - cy * (data.value - minValue) / scaleY;
			
			var dot = graph.circle(xCoord, yCoord, 3).attr({fill: '#33AB33', stroke: '#88CB99'});
			
			dot.mouseover(function()
	        {
	            dot.attr("r", 5);

                var newWidth = String(data.value).length * 7 + 12 + 55,
					newcoord = {x: xCoord + 20, y: yCoord > 10 + cy - 24 ? 10 + cy - 24 : yCoord};
                
                if (newcoord.x + newWidth > cx + 40) 
                    newcoord.x -= (newWidth + 40);
				
				if (!$.browser.msie)
				{
		            clearTimeout(leaveTimer);
	                ttFrame.show().animate({x: newcoord.x, y: newcoord.y, width:newWidth}, 200 * isLabelVisible);
	                ttText.attr({text: stringDate(data.date) + ': ' + String(data.value)}).show().animate({x: newcoord.x + 6, y: newcoord.y + 9}, 200 * isLabelVisible);
	                isLabelVisible = true;
	                graph.safari();
	            }
	            else
	            {
   	               	ttFrame.show().attr({x: newcoord.x, y: newcoord.y, width:newWidth});
                	ttText.show().attr({text: stringDate(data.date) + ': ' + String(data.value),x: newcoord.x + 6, y: newcoord.y + 12});
	            }
	            
	        }).mouseout(function()
	        {
	            dot.attr("r", 3);
	            
	            if (!$.browser.msie)
				{
	                graph.safari();
	                leaveTimer = setTimeout(function ()
	                {
	                    ttFrame.hide();
	                    ttText.hide();
	                    isLabelVisible = false;
	                    graph.safari();
	                }, 1);
	            }
	            else
	            {
            		ttFrame.hide();
                    ttText.hide();
	            }
	        });
		};

	graph.path(["M", 40, 10, "L", 40, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 2, opacity: 0.7});
	graph.path(["M", 40, cy + 10, "L", cx + 40, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 2, opacity: 0.7});
	
	if (lastDate - firstDate > 2 * 1000 * 86400 * 365)
	{
		// разбивка по годам
		var year = new Date(firstDate).getFullYear() + 1,
			lastXYear = -1;
		
		while (new Date(year, 0, 1) < lastDate)
		{
			var xYear = 40 + cx * (new Date(year, 0, 1).valueOf() - firstDate) / scaleX;
			
			if (lastXYear < 0 || (xYear - lastXYear) > 40)
			{
				graph.path(["M", xYear, 10, "L", xYear, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 1, opacity: 0.2});
				graph.text(xYear, cy + 25, String(year)).attr({"font": '12px "Arial"', stroke: "none", fill: "#153069", "text-anchor": "middle"});
				
				lastXYear = xYear;
			}
			
			year++;
		}
	}
	else if (lastDate - firstDate > 2 * 1000 * 86400 * 30)
	{
		// разбивка по месяцам
		var year = new Date(firstDate).getFullYear(),
			month = new Date(firstDate).getMonth() + 1,
			monthNames = {'0':'январь','1':'февраль','2':'март','3':'апрель','4':'май','5':'июнь','6':'июль','7':'август','8':'сентябрь','9':'октябрь','10':'ноябрь','11':'декабрь'},
			lastXYear = -1;
		
		if (month > 11)
		{
			month = 0;
			year++;
		}
		
		while (new Date(year, month, 1) < lastDate)
		{
			var xYear = 40 + cx * (new Date(year, month, 1).valueOf() - firstDate) / scaleX;
			
			if (lastXYear < 0 || (xYear - lastXYear) > 40)
			{
				graph.path(["M", xYear, 10, "L", xYear, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 1, opacity: 0.2});
				graph.text(xYear, cy + 25, String(monthNames[month] + '\n' + year)).attr({"font": '12px "Arial"', stroke: "none", fill: "#153069", "text-anchor": "middle"});
				
				lastXYear = xYear;
			}
			
			month++;
			
			if (month > 11)
			{
				month = 0;
				year++;
			}
		}
	}
	else
	{
		// разбивка по дням
		var currDate = firstDate + 24 * 3600 * 1000,
			monthNames = {'0':'января','1':'февраля','2':'марта','3':'апреля','4':'мая','5':'июня','6':'июля','7':'августа','8':'сентября','9':'октября','10':'ноября','11':'декабря'},
			lastXYear = -1;
		
		if (new Date(currDate).getDate() == new Date(firstDate).getDate())
			currDate = firstDate + 25 * 3600 * 1000;
		
		currDate = new Date(currDate);
		currDate.setHours(0);
		currDate = currDate.valueOf();

		while (currDate < lastDate)
		{
			var xYear = 40 + cx * (currDate - firstDate) / scaleX;
			
			if (lastXYear < 0 || (xYear - lastXYear) > 40)
			{
				graph.path(["M", xYear, 10, "L", xYear, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 1, opacity: 0.2});
				graph.text(xYear, cy + 25, String(String(new Date(currDate).getDate()) + ' ' + monthNames[new Date(currDate).getMonth()] + '\n' + String(new Date(currDate).getFullYear()))).attr({"font": '12px "Arial"', stroke: "none", fill: "#153069", "text-anchor": "middle"});
				
				lastXYear = xYear;
			}
			
			var oldCurrDate = new Date(currDate).getDate();
			
			currDate = currDate + 24 * 3600 * 1000;
			
			if (new Date(currDate).getDate() == oldCurrDate)
				currDate = currDate + 25 * 3600 * 1000;
			
			currDate = new Date(currDate);
			currDate.setHours(0);
			currDate = currDate.valueOf();
		}

	}
	
	var yLabels = [],
		labelIndex = -1;;
	
	// "красивые метки" на ось y
	for (var i = 0; i < 13; i++)
	{
		yLabels.push(1 * Math.pow(10, i - 5));
		yLabels.push(2 * Math.pow(10, i - 5));
		yLabels.push(5 * Math.pow(10, i - 5));
	}
	
	for (var i = 0; i < yLabels.length; i++)
	{
		if (scaleY / yLabels[i] > cy / 100 &&
			scaleY / yLabels[i] < cy / 50)
		{
			labelIndex = i;
			
			break;
		}
	}
	
	if (labelIndex > 0)
	{
		var labelCount = Math.floor(scaleY / yLabels[labelIndex]),
			firstYLabel = (Math.floor(minValue / yLabels[labelIndex]) + 1) * yLabels[labelIndex];
		
		while (firstYLabel < maxValue)
		{
			var yLabel = 10 + cy - cy * (firstYLabel - minValue) / scaleY;
		
			graph.path(["M", 40, yLabel, "L", cx + 40, yLabel]).attr({stroke: "#ABABAB", "stroke-width": 1, opacity: 0.2});
			graph.text(35, yLabel, String(firstYLabel)).attr({"font": '12px "Arial"', stroke: "none", fill: "#153069", "text-anchor": "end"});
			
			firstYLabel += yLabels[labelIndex]
		}
	}
	
	for (var i = 0; i < dateTimeData.length; i++)
		processPath(dateTimeData[i], i);

	graph.path(funcPath).attr({stroke: '#88CB99', 'stroke-width':2})
		
	var ttFrame = graph.rect(10, 10, 120, 20, 5).attr({fill: "#CBCBEA", stroke: "#ABABFA", "stroke-width": 2, opacity: 1}).hide(),
		ttText = graph.text(60, 10, String(minValue)).attr({"font": '12px "Arial"', stroke: "none", fill: "#FFF", "text-anchor": "start"}).hide();

	for (var i = 0; i < dateTimeData.length; i++)
		process(dateTimeData[i], i);
	
	ttFrame = graph.rect(10, 10, 120, 20, 5).attr({fill: "#CBCBEA", stroke: "#ABABFA", "stroke-width": 2, opacity: 1}).hide(),
	ttText = graph.text(60, 10, String(minValue)).attr({"font": '12px "Arial"', stroke: "none", fill: "#FFF", "text-anchor": "start"}).hide();
}

// data: {'legend1':[], 'legend2':[], ..}
// dataColumns: "Октябрь, Ноябрь, .."

Diagram.prototype.createMultiLinesDiagram = function(parent, width, height, data, dataColumns, legendFlag)
{
	var graph = this.draw(parent, width, height);
	
	this.resetColor();
	
	var chartId = String(Math.random()).substr(2,12),
		minValue = Number.MAX_VALUE,
		maxValue = -Number.MAX_VALUE,
		layerNames = [],
		layerColors = {},
		curPosition = 0,
		legendCellHeight = 20,
		startColor = 0;
		
	for (var label in data)
	{
		layerNames.push(label.replace(/\s/g, ''));

		layerColors[label] = _diagram.getNextColor();

		for (var j = 0; j < data[label].length; j++)
		{
			if (data[label][j] > maxValue)
				maxValue = data[label][j];

			if (data[label][j] < minValue)
				minValue = data[label][j];
		}
		
		startColor += 0.1 * (1 + Math.random());
		
		if (startColor > 1)
	    	startColor = 0.1 * (1 + Math.random());
	}
	
	var cx = width - 55 - (legendFlag > 0 ? 130 : 0),
		cy = height - 40,
		namesByPage = Math.floor((cy - 40) / legendCellHeight),
		scaleY = maxValue - minValue != 0 ? maxValue - minValue : 1;
	
	// оси
	graph.path(["M", 40, 10, "L", 40, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 2, opacity: 0.7});
	graph.path(["M", 40, cy + 10, "L", cx + 40, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 2, opacity: 0.7});
	
	// "красивые метки" на ось x
	var columnTextLengths = [];
	
	for (var i = 0; i < dataColumns.length; i++)
	{
		var strs = dataColumns[i].split("\n"),
			maxLen = strs[0].length;
		
		for (var j = 1; j < strs.length; j++)
			if (strs[j].length > maxLen)
				maxLen = strs[j].length;
		
		columnTextLengths.push(maxLen * 7)
	}
	
	var lastTextCoord = -1;
	
	for (var i = 0; i < dataColumns.length; i++)
	{
		var currXCoord = 40 + cx * i / (dataColumns.length - 1);
		
		if (lastTextCoord < 0 || (currXCoord - lastTextCoord) > 10 + columnTextLengths[i] / 2)
		{
			graph.path(["M", currXCoord, 10, "L", currXCoord, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 1, opacity: 0.2});
			graph.text(currXCoord, cy + 25, String(dataColumns[i])).attr({"font": '12px "Arial"', stroke: "none", fill: "#153069", "text-anchor": "middle"});
			
			lastTextCoord = currXCoord + columnTextLengths[i] / 2;
		}
	}
	
	var yLabels = [],
		labelIndex = -1;;
	
	// "красивые метки" на ось y
	for (var i = 0; i < 13; i++)
	{
		yLabels.push(1 * Math.pow(10, i - 5));
		yLabels.push(2 * Math.pow(10, i - 5));
		yLabels.push(5 * Math.pow(10, i - 5));
	}
	
	for (var i = 0; i < yLabels.length; i++)
	{
		if (scaleY / yLabels[i] > cy / 200 &&
			scaleY / yLabels[i] < cy / 20)
		{
			labelIndex = i;
			
			break;
		}
	}
	
	if (labelIndex > 0)
	{
		var labelCount = Math.floor(scaleY / yLabels[labelIndex]),
			firstYLabel = (Math.floor(minValue / yLabels[labelIndex]) + 1) * yLabels[labelIndex];
		
		while (firstYLabel <= maxValue)
		{
			var yLabel = 10 + cy - cy * (firstYLabel - minValue) / scaleY;
		
			graph.path(["M", 40, yLabel, "L", cx + 40, yLabel]).attr({stroke: "#ABABAB", "stroke-width": 1, opacity: 0.2});
			graph.text(35, yLabel, String(firstYLabel)).attr({"font": '12px "Arial"', stroke: "none", fill: "#153069", "text-anchor": "end"});
			
			firstYLabel += yLabels[labelIndex]
		}
	}
	
	// сам график
	var	leaveTimer,
		isLabelVisible = false,
		process = function(label)
		{
			var values = data[label],
				funcPath = [];
			
			for (var i = 0; i < dataColumns.length; i++)
			{
				var xCoord = 40 + cx * i / (dataColumns.length - 1),
					yCoord = 10 + cy - cy * (values[i] - minValue) / scaleY;
			
				if (i == 0)
					funcPath = funcPath.concat(['M', xCoord, yCoord]);
				else
					funcPath = funcPath.concat(['L', xCoord, yCoord]);
			}
			
			var line = graph.path(funcPath).attr({stroke: layerColors[label], 'stroke-width':2});
			line.node.setAttribute('id', chartId + 'line_' + label);
			
			for (var i = 0; i < dataColumns.length; i++)
			{
				(function(i)
				{
					var xCoord = 40 + cx * i / (dataColumns.length - 1),
					yCoord = 10 + cy - cy * (values[i] - minValue) / scaleY;
					
					var dot = graph.circle(xCoord, yCoord, 3).attr({fill: layerColors[label], stroke: layerColors[label]});
					dot.node.setAttribute('id', chartId + 'dot_' + label + '_' + i);
					
					dot.mouseover(function()
			        {
			            dot.attr("r", 5);
			            
		                var newWidth = String(values[i]).length * 7 + 12,
		                	newcoord = {x: xCoord + 20, y: yCoord > 10 + cy - 24 ? 10 + cy - 24 : yCoord};
                		
                		if (newcoord.x + newWidth > cx + 40) 
                    		newcoord.x -= (newWidth + 40);
						
						if (!$.browser.msie)
						{
				            clearTimeout(leaveTimer);
			                ttFrame.show().animate({x: newcoord.x, y: newcoord.y, width:newWidth}, 200 * isLabelVisible);
			                ttText.attr({text: String(values[i])}).show().animate({x: newcoord.x + 6, y: newcoord.y + 9}, 200 * isLabelVisible);
			                isLabelVisible = true;
			                graph.safari();
			            }
			            else
			            {
		   	               	ttFrame.show().attr({x: newcoord.x, y: newcoord.y, width:newWidth});
		                	ttText.show().attr({text: String(values[i]),x: newcoord.x + 6, y: newcoord.y + 12});
			            }
			            
			        }).mouseout(function()
			        {
			            dot.attr("r", 3);
			            
			            if (!$.browser.msie)
						{
			                graph.safari();
			                leaveTimer = setTimeout(function ()
			                {
			                    ttFrame.hide();
			                    ttText.hide();
			                    isLabelVisible = false;
			                    graph.safari();
			                }, 1);
			            }
			            else
			            {
		            		ttFrame.hide();
		                    ttText.hide();
			            }
			        });
		        })(i);
			}
		},
		_this = this;

	var ttFrame = graph.rect(10, 10, 120, 20, 5).attr({fill: "#CBCBEA", stroke: "#ABABFA", "stroke-width": 2, opacity: 1}).hide(),
		ttText = graph.text(60, 10, String(minValue)).attr({"font": '12px "Arial"', stroke: "none", fill: "#FFF", "text-anchor": "start"}).hide();
	
	for (var label in data)
		process(label)
	
	ttFrame = graph.rect(10, 10, 120, 20, 5).attr({fill: "#CBCBEA", stroke: "#ABABFA", "stroke-width": 2, opacity: 1}).hide(),
	ttText = graph.text(60, 10, String(minValue)).attr({"font": '12px "Arial"', stroke: "none", fill: "#FFF", "text-anchor": "start"}).hide();
	
	// легенда
	if (legendFlag > 0)
	{
		var width = 130,
			height = Math.min(namesByPage, objLength(data)) * legendCellHeight + 40;
		
		graph.rect(cx + 50, 10, width, height, 5)
			.attr('fill','#FAFAFE')
			.attr('stroke','#BABABE')
			.attr('stroke-width',1);
		
		var up = graph.path(["M", cx + 50 + 5, 10 + 15, "L", cx + 50 + width - 5, 10 + 15, "L", cx + 50 + width / 2, 10 + 5, "L", cx + 50 + 5,  10 + 15,"Z"]).attr({fill: '#ABCDEF', opacity: 0.5}),
			down = graph.path(["M", cx + 50 + 5, 10 + height - 15, "L", cx + 50 + width - 5, 10 + height - 15, "L", cx + 50 + width / 2,  10 + height - 5, "L",cx + 50 + 5,  10 + height - 15, "Z"]).attr({fill: '#ABCDEF', opacity: 0.5});
		
		up.node.style.cursor = "pointer";
		down.node.style.cursor = "pointer";
		
		var drawCurrentPage = function(position, count, names)
		{
			var length = count,
				endPosition = (names.length < position + length) ? names.length : position + length;
			
			var attachEvent = function(elem, name)
			{
				$(elem.node).mousedown(function()
				{
					if (elem.attr('opacity') == 1)
					{
						for (var i = 0; i < dataColumns.length; i++)
						{
							var bar = $('#' + chartId + 'dot_' + name + '_' + i)[0];
							$(bar).hide();
						}
						
						$('#' + chartId + 'line_' + name).hide();
						$('#' + chartId + 'legRect_' + name).attr('fill','#999999');
						
						elem.attr('opacity', 0.2);
					}
					else
					{
						for (var i = 0; i < dataColumns.length; i++)
						{
							var bar = $('#' + chartId + 'dot_' + name + '_' + i)[0];
							$(bar).show();
						}
						
						$('#' + chartId + 'line_' + name).show();
						$('#' + chartId + 'legRect_' + name).attr('fill','#153069');
						
						elem.attr('opacity', 1);
					}
				})
			}
			
			if (position == 0)
				$(up.node).hide()
			else
				$(up.node).show()
				
			if (position + count >= names.length)
				$(down.node).hide()
			else
				$(down.node).show()

			for (var i = position; i < endPosition; i++)
			{
				var xCoord = cx + 50 + 50,
					yCoord = 14 + /*(height - 40) / length*/ legendCellHeight * (i - position) + 20,
					layerName = names[i],
					area = $('#' + chartId + 'dot_' + layerName + '_0')[0],
					opacity = area.style.display == 'none' ? 0.2 : 1,
					shownName = layerName.length > 12 ? layerName.substring(0, 12) + '...' : layerName;
				
				var txt = graph.text(xCoord - 20, yCoord + 5, shownName)
							.attr({fill: '#153069', stroke: "none", "font-family": '"Arial"',
									"font-size": "12px", "text-anchor": "start"});
				
				txt.node.setAttribute('id', chartId + 'legRect_' + layerName)
				
				var rect = graph.rect(xCoord - 45, yCoord, 20, 10)
									.attr({fill: layerColors[layerName], opacity: opacity, stroke: layerColors[layerName]});
				
				rect.node.setAttribute('id', chartId + 'legTxt_' + layerName)
									
				rect.node.style.cursor = "pointer";
				attachEvent(rect, layerName);
			}
		}
		
		$(up.node).mousedown(function()
		{
			if (curPosition == 0)
				return;
			
			for (var i = 0; i < layerNames.length; i++)
			{
				$('#' + chartId + 'legRect_' + layerNames[i]).remove();
				$('#' + chartId + 'legTxt_' + layerNames[i]).remove();
			}

			curPosition -= namesByPage;
			drawCurrentPage(curPosition, namesByPage, layerNames);
		})
		$(down.node).mousedown(function()
		{
			if (curPosition + namesByPage >= layerNames.length)
				return;
				
			for (var i = 0; i < layerNames.length; i++)
			{
				$('#' + chartId + 'legRect_' + layerNames[i]).remove();
				$('#' + chartId + 'legTxt_' + layerNames[i]).remove();
			}
			
			curPosition += namesByPage;
			drawCurrentPage(curPosition, namesByPage, layerNames);
		})
		
		drawCurrentPage(0, namesByPage, layerNames);
	}
}

Diagram.prototype.createBarsDiagram = function(parent, width, height, data, dataColumns, legendFlag, multipleFlag)
{
	var graph = this.draw(parent, width, height);
	
	this.resetColor();
	
	var chartId = String(Math.random()).substr(2,12),
		minValue = 0,
		maxValue = -Number.MAX_VALUE,
		layerNames = [],
		layerColors = {},
		curPosition = 0,
		legendCellHeight = 20,
		startColor = 0;
		
	for (var label in data)
	{
		layerNames.push(label);

		layerColors[label] = _diagram.getNextColor();

		for (var j = 0; j < data[label].length; j++)
		{
			if (data[label][j] > maxValue)
				maxValue = data[label][j];
		}
		
		startColor += 0.1 * (1 + Math.random());
		
		if (startColor > 1)
	    	startColor = 0.1 * (1 + Math.random());
	}
	
	var cx = width - 55 - (legendFlag > 0 ? 130 : 0),
		cy = height - 40,
		namesByPage = Math.floor((cy - 40) / legendCellHeight),
		scaleY = maxValue - minValue != 0 ? maxValue - minValue : 1;
	
	// оси
	graph.path(["M", 40, 10, "L", 40, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 2, opacity: 0.7});
	graph.path(["M", 40, cy + 10, "L", cx + 40, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 2, opacity: 0.7});
	
	// "красивые метки" на ось x
	var columnTextLengths = [];
	
	for (var i = 0; i < dataColumns.length; i++)
	{
		var strs = dataColumns[i].split("\n"),
			maxLen = strs[0].length;
		
		for (var j = 1; j < strs.length; j++)
			if (strs[j].length > maxLen)
				maxLen = strs[j].length;
		
		columnTextLengths.push(maxLen * 7)
	}
	
	var lastTextCoord = -1;
	
	for (var i = 0; i < dataColumns.length; i++)
	{
		var barWidth = 0.9 * cx / dataColumns.length,
			size = cx / dataColumns.length,
			currXCoord = 40 + size * i + size / 2 + 10;
		
		if (lastTextCoord < 0 || (currXCoord - lastTextCoord) > 10 + columnTextLengths[i] / 2)
		{
			graph.path(["M", currXCoord, 10, "L", currXCoord, cy + 10]).attr({stroke: "#ABABAB", "stroke-width": 1, opacity: 0.2});
			graph.text(currXCoord, cy + 25, String(dataColumns[i])).attr({"font": '12px "Arial"', stroke: "none", fill: "#153069", "text-anchor": "middle"});
			
			lastTextCoord = currXCoord + columnTextLengths[i] / 2;
		}
	}
	
	var yLabels = [],
		labelIndex = -1;;
	
	// "красивые метки" на ось y
	for (var i = 0; i < 13; i++)
	{
		yLabels.push(1 * Math.pow(10, i - 5));
		yLabels.push(2 * Math.pow(10, i - 5));
		yLabels.push(5 * Math.pow(10, i - 5));
	}
	
	for (var i = 0; i < yLabels.length; i++)
	{
		if (scaleY / yLabels[i] > cy / 200 &&
			scaleY / yLabels[i] < cy / 20)
		{
			labelIndex = i;
			
			break;
		}
	}
	
	if (labelIndex > 0)
	{
		var labelCount = Math.floor(scaleY / yLabels[labelIndex]),
			firstYLabel = (Math.floor(minValue / yLabels[labelIndex]) + 1) * yLabels[labelIndex];
		
		while (firstYLabel <= maxValue)
		{
			var yLabel = 10 + cy - cy * (firstYLabel - minValue) / scaleY;
		
			graph.path(["M", 40, yLabel, "L", cx + 40, yLabel]).attr({stroke: "#ABABAB", "stroke-width": 1, opacity: 0.2});
			graph.text(35, yLabel, String(firstYLabel)).attr({"font": '12px "Arial"', stroke: "none", fill: "#153069", "text-anchor": "end"});
			
			firstYLabel += yLabels[labelIndex]
		}
	}
	
	// сам график
	
	var	leaveTimer,
		isLabelVisible = false,
		process = function(i)
		{
			var barValues = [],
				size = cx / dataColumns.length;
			
			for (var label in data)
				barValues.push({label: label, value: data[label][i], color:layerColors[label]})
			
			if (!multipleFlag)	
				barValues = barValues.sort(function(a, b){return b.value - a.value});
			
			for (var j = 0; j < barValues.length; j++)
			{
				(function(i,j)
				{
					var barHeight = barValues[j].value / maxValue * cy,
						barWidth = multipleFlag ? Math.floor((0.9 * cx / dataColumns.length) / layerNames.length) : Math.floor(0.9 * cx / dataColumns.length),
						maxBarWidth = Math.floor(0.9 * cx / dataColumns.length),
						color = barValues[j].color,
						hsbFillColor = Raphael.rgb2hsb(color),
						xCoord = Math.floor(40 + size * i + size / 2 - maxBarWidth / 2 + 10 + (multipleFlag ? barWidth * j : 0)),
						yCoord =  cy + 10 - barHeight;
					
					var rect = graph.rect(xCoord, yCoord, barWidth, barHeight)
							.attr({stroke: Raphael.hsb2rgb(hsbFillColor.h, hsbFillColor.s, hsbFillColor.b * 0.75).hex, 'stroke-width': 1, fill : color, opacity: 1});
					
					rect.node.setAttribute('id',chartId + 'rect_' + barValues[j].label + '_' + i);

					rect.mouseover(function()
			        {
			            rect.attr("stroke", color);
			            
		                var newWidth = String(barValues[j].value).length * 7 + 12,
		                	newcoord = {x: xCoord + barWidth + 5, y: yCoord > 10 + cy - 24 ? 10 + cy - 24 : yCoord};
	            		
	            		if (newcoord.x + newWidth > cx + 40) 
	                		newcoord.x -= (newWidth + barWidth + 5);
						
						if (!$.browser.msie)
						{
				            clearTimeout(leaveTimer);
			                ttFrame.show().animate({x: newcoord.x, y: newcoord.y, width:newWidth}, 200 * isLabelVisible);
			                ttText.attr({text: String(barValues[j].value)}).show().animate({x: newcoord.x + 6, y: newcoord.y + 9}, 200 * isLabelVisible);
			                isLabelVisible = true;
			                graph.safari();
			            }
			            else
			            {
		   	               	ttFrame.show().attr({x: newcoord.x, y: newcoord.y, width:newWidth});
		                	ttText.show().attr({text: String(barValues[j].value),x: newcoord.x + 6, y: newcoord.y + 12});
			            }
			            
			        }).mouseout(function()
			        {
			            rect.attr("stroke", Raphael.hsb2rgb(hsbFillColor.h, hsbFillColor.s, hsbFillColor.b * 0.75).hex);
			            
			            if (!$.browser.msie)
						{
			                graph.safari();
			                leaveTimer = setTimeout(function ()
			                {
			                    ttFrame.hide();
			                    ttText.hide();
			                    isLabelVisible = false;
			                    graph.safari();
			                }, 1);
			            }
			            else
			            {
		            		ttFrame.hide();
		                    ttText.hide();
			            }
			        });
				})(i,j) 
			}
		},
		_this = this;
	
	var ttFrame = graph.rect(10, 10, 120, 20, 5).attr({fill: "#CBCBEA", stroke: "#ABABFA", "stroke-width": 2, opacity: 1}).hide(),
		ttText = graph.text(60, 10, String(minValue)).attr({"font": '12px "Arial"', stroke: "none", fill: "#FFF", "text-anchor": "start"}).hide();
	
	for (var i = 0; i < dataColumns.length; i++)
		process(i)
	
	ttFrame = graph.rect(10, 10, 120, 20, 5).attr({fill: "#CBCBEA", stroke: "#ABABFA", "stroke-width": 2, opacity: 1}).hide(),
	ttText = graph.text(60, 10, String(minValue)).attr({"font": '12px "Arial"', stroke: "none", fill: "#FFF", "text-anchor": "start"}).hide();
	
	// легенда
	if (legendFlag > 0)
	{
		var width = 130,
			height = Math.min(namesByPage, objLength(data)) * legendCellHeight + 40;
		
		graph.rect(cx + 50, 10, width, height, 5)
			.attr('fill','#FAFAFE')
			.attr('stroke','#BABABE')
			.attr('stroke-width',1);
		
		var up = graph.path(["M", cx + 50 + 5, 10 + 15, "L", cx + 50 + width - 5, 10 + 15, "L", cx + 50 + width / 2, 10 + 5, "L", cx + 50 + 5,  10 + 15,"Z"]).attr({fill: '#ABCDEF', opacity: 0.5}),
			down = graph.path(["M", cx + 50 + 5, 10 + height - 15, "L", cx + 50 + width - 5, 10 + height - 15, "L", cx + 50 + width / 2,  10 + height - 5, "L",cx + 50 + 5,  10 + height - 15, "Z"]).attr({fill: '#ABCDEF', opacity: 0.5});
		
		up.node.style.cursor = "pointer";
		down.node.style.cursor = "pointer";
		
		var drawCurrentPage = function(position, count, names)
		{
			var length = count,
				endPosition = (names.length < position + length) ? names.length : position + length;
			
			var attachEvent = function(elem, name)
			{
				$(elem.node).mousedown(function()
				{
					if (elem.attr('opacity') == 1)
					{
						for (var i = 0; i < dataColumns.length; i++)
						{
							var bar = $('#' + chartId + 'rect_' + name + '_' + i)[0];
							$(bar).hide();
						}
						
						$('#' + chartId + 'legRect_' + name).attr('fill','#999999');
						
						elem.attr('opacity', 0.2);
					}
					else
					{
						for (var i = 0; i < dataColumns.length; i++)
						{
							var bar = $('#' + chartId + 'rect_' + name + '_' + i)[0];
							$(bar).show();
						}
						
						$('#' + chartId + 'legRect_' + name).attr('fill','#153069');
						
						elem.attr('opacity', 1);
					}
				})
			}
			
			if (position == 0)
				$(up.node).hide()
			else
				$(up.node).show()
				
			if (position + count >= names.length)
				$(down.node).hide()
			else
				$(down.node).show()

			for (var i = position; i < endPosition; i++)
			{
				var xCoord = cx + 50 + 50,
					yCoord = 14 + legendCellHeight * (i - position) + 20,
					layerName = names[i],
					area = $('#' + chartId + 'rect_' + layerName + '_0')[0],
					opacity = area.style.display == 'none' ? 0.2 : 1,
					shownName = layerName.length > 12 ? layerName.substring(0, 12) + '...' : layerName;
				
				var txt = graph.text(xCoord - 20, yCoord + 5, shownName)
							.attr({fill: '#153069', stroke: "none", "font-family": '"Arial"',
									"font-size": "12px", "text-anchor": "start"});
				
				txt.node.setAttribute('id', chartId + 'legRect_' + layerName)
				
				var rect = graph.rect(xCoord - 45, yCoord, 20, 10)
									.attr({fill: layerColors[layerName], opacity: opacity, stroke: layerColors[layerName]});
				
				rect.node.setAttribute('id', chartId + 'legTxt_' + layerName)
									
				rect.node.style.cursor = "pointer";
				attachEvent(rect, layerName);
			}
		}
		
		$(up.node).mousedown(function()
		{
			if (curPosition == 0)
				return;
			
			for (var i = 0; i < layerNames.length; i++)
			{
				$('#' + chartId + 'legRect_' + layerNames[i]).remove();
				$('#' + chartId + 'legTxt_' + layerNames[i]).remove();
			}

			curPosition -= namesByPage;
			drawCurrentPage(curPosition, namesByPage, layerNames);
		})
		$(down.node).mousedown(function()
		{
			if (curPosition + namesByPage >= layerNames.length)
				return;
				
			for (var i = 0; i < layerNames.length; i++)
			{
				$('#' + chartId + 'legRect_' + layerNames[i]).remove();
				$('#' + chartId + 'legTxt_' + layerNames[i]).remove();
			}
			
			curPosition += namesByPage;
			drawCurrentPage(curPosition, namesByPage, layerNames);
		})
		
		drawCurrentPage(0, namesByPage, layerNames);
	}
}

Diagram.prototype.createBalloon = function(obj, htmlContent)
{
	if (this.oldBalloon)
		this.oldBalloon.remove();
	
	if (this.oldBalloonIndex == obj.objectId)
	{
		this.oldBalloonIndex = -1;
		
		this.oldBalloon = false;
		
		return false;
	}
	
	var coords = obj.getGeometry().coordinates,
		_this = this;
		
	this.oldBalloon = globalFlashMap.addBalloon();
	
	this.oldBalloon.setPoint(coords[0], coords[1]);
	
	_(this.oldBalloon.div, [htmlContent]);
	
	var remove = makeImageButton("img/close.png", "img/close_orange.png");
	remove.onclick = function()
	{
		_this.oldBalloon.remove();
		
		_this.oldBalloonIndex = -1;
		
		_this.oldBalloon = false;
	}
	
	remove.style.position = 'absolute';
	remove.style.right = '9px';
	remove.style.top = '5px';
	remove.style.cursor = 'pointer';
	
	_(this.oldBalloon.div, [remove])
	
	this.oldBalloon.resize();
	
	this.oldBalloonIndex = obj.objectId;
	
	return true;
}

Diagram.prototype.createDateTimeDiagramByAttrs = function(parent, width, height, attrs, regexp)
{
	var graphDataFunc;
	
	if (regexp.indexOf("%") > -1)
	{
		var replaceIndex = {},
			currReplaceIndex = 0;
		
		regexp = regexp.replace(/%y%y%y%y/, function(){currReplaceIndex++; replaceIndex['y'] = currReplaceIndex; return "(\\d\\d\\d\\d)"})
						.replace(/%m%m/, function(){currReplaceIndex++; replaceIndex['m'] = currReplaceIndex; return "(\\d\\d)"})
						.replace(/%d%d/, function(){currReplaceIndex++; replaceIndex['d'] = currReplaceIndex; return "(\\d\\d)"});
						
		graphDataFunc = function(x, reResult)
		{
			var year = reResult[replaceIndex['y']],
				month = reResult[replaceIndex['m']] - 1,
				date = reResult[replaceIndex['d']];
			
			return String(new Date(year, month, date).valueOf());
		};
	}
	else
		return false;
	
	var re = new RegExp(regexp),
		graphData = {};
	
	for (var prop in attrs)
	{
		var res = re.exec(prop);
		
		if (res && res.length == 4)
			graphData[graphDataFunc(prop, res)] = Number(attrs[prop]);
	}
	
	if (objLength(graphData) > 0)
	{
		_diagram.createDateTimeDiagram(parent, width, height, graphData);
		
		return true;
	}
	
	return false
}

Diagram.prototype.createDateTimeDiagramByAttrsText = function(width, height, attrs, regexp)
{
	var id = String(Math.random()).substr(2, 12),
		text = "<div style=\"width:" + width + "px;height:" + height + "px\">";
		
	text += "<div><div id=\"balloonGraph" + id + "\" style=\"width:" + width + "px;height:" + height + "px\"></div></div>";
	
	text += "<iframe src=\"blank.html\" onload=\"javascript:_diagram.createDateTimeDiagramByAttrs($$('balloonGraph" + id + "'), " + width + ", " + height + ", " + JSON.stringify(attrs).replace(/\"/g, "'") + ", '" + regexp + "')\" style=\"display:none\"/>";
	
	text += "</div>";
	
	return text;
}

Diagram.prototype.createPieDiagramByAttrs = function(parent, width, height, attrs, regexp)
{
	var graphDataFunc;
	
	if (regexp.indexOf("%") > -1)
	{
		var replaceIndex = {},
			currReplaceIndex = 0;
		
		regexp = regexp.replace(/%y%y%y%y/, function(){currReplaceIndex++; replaceIndex['y'] = currReplaceIndex; return "(\\d\\d\\d\\d)"})
						.replace(/%m%m/, function(){currReplaceIndex++; replaceIndex['m'] = currReplaceIndex; return "(\\d\\d)"})
						.replace(/%d%d/, function(){currReplaceIndex++; replaceIndex['d'] = currReplaceIndex; return "(\\d\\d)"});
						
		graphDataFunc = function(x, reResult)
		{
			var year = reResult[replaceIndex['y']],
				month = reResult[replaceIndex['m']] - 1,
				date = reResult[replaceIndex['d']];
			
			return stringDate(new Date(year, month, date).valueOf());
		};
	}
	
	var re = new RegExp(regexp),
		graphData = {};
	
	for (var prop in attrs)
	{
		var res = re.exec(prop);
		
		if (res)
		{
			if (res.length == 4)
				graphData[graphDataFunc(prop, res)] = Number(attrs[prop]);
			else
				graphData[prop] = Number(attrs[prop]);
		}
	}
	
	if (objLength(graphData) > 0)
	{
		_diagram.createPieDiagram(parent, width, height, graphData);
		
		return true;
	}
	
	return false
}

Diagram.prototype.createPieDiagramByAttrsText = function(width, height, attrs, regexp)
{
	var id = String(Math.random()).substr(2, 12),
		text = "<div style=\"width:" + width + "px;height:" + height + "px\">";
		
	text += "<div><div id=\"balloonGraph" + id + "\" style=\"width:" + width + "px;height:" + height + "px\"></div></div>";
	
	text += "<iframe src=\"blank.html\" onload=\"javascript:_diagram.createPieDiagramByAttrs($$('balloonGraph" + id + "'), " + width + ", " + height + ", " + JSON.stringify(attrs).replace(/\"/g, "'") + ", '" + regexp + "')\" style=\"display:none\"/>";
	
	text += "</div>";
	
	return text;
}

/*
	layersFilters :
	{
		'layerName1' : 'regexp1',
		'layerName2' : 'regexp2',
		...
	}
*/
Diagram.prototype.createMultiLinesDiagramText = function(width, height, data, dataColumns, legendFlag)
{
	var id = String(Math.random()).substr(2, 12),
		text = "<div style=\"width:" + width + "px;height:" + height + "px\">";
		
	text += "<div><div id=\"balloonGraph" + id + "\" style=\"width:" + width + "px;height:" + height + "px\"></div></div>";
	
	text += "<iframe src=\"blank.html\" onload=\"javascript:_diagram.createMultiLinesDiagram($$('balloonGraph" + id + "'), " + width + ", " + height + ", " + JSON.stringify(data).replace(/\"/g, "'") + ", " + JSON.stringify(dataColumns).replace(/\"/g, "'") + ", " + legendFlag + ")\" style=\"display:none\"/>";
	
	text += "</div>";
	
	return text;
}

Diagram.prototype.createBarsDiagramText = function(width, height, data, dataColumns, legendFlag, multipleFlag)
{
	var id = String(Math.random()).substr(2, 12),
		text = "<div style=\"width:" + width + "px;height:" + height + "px\">";
		
	text += "<div><div id=\"balloonGraph" + id + "\" style=\"width:" + width + "px;height:" + height + "px\"></div></div>";
	
	text += "<iframe src=\"blank.html\" onload=\"javascript:_diagram.createBarsDiagram($$('balloonGraph" + id + "'), " + width + ", " + height + ", " + JSON.stringify(data).replace(/\"/g, "'") + ", " + JSON.stringify(dataColumns).replace(/\"/g, "'") + ", " + legendFlag + ", " + multipleFlag + ")\" style=\"display:none\"/>";
	
	text += "</div>";
	
	return text;
}


var _diagram = new Diagram();

/*
var data = {'label1':[3,4,-1,2,3], 'label2': [2,-2,1,4,1],'label3':[1, -1, 3,3,4],'label4':[-2,4,1,-2,1],'label5':[1,0,-1,1,1],'label6':[-4,2,1,6,2],'label7':[-3,-2,5,1,-2],'label8':[-1,-3,4,1,0],'label9':[1,2,-5,-4,5],'label10':[1,1,-3,4,4],'label11':[0,0,-3,3,1]}
var dataColumns = ['Октябрь\n2009','Ноябрь\n2009','Декабрь\n2009','Январь\n2010','Февраль\n2010']

var div = _div()
showDialog("Graphics", div, 640, 340, false, false)

_diagram.createMultiLinesDiagram(div, 600, 300, data, dataColumns, 5)
*/

/*
function(map)
{
	var layer = map.layers["9A38F34E16FF446DA667FFAA55117C22"];

	layer.filters[0].enableHoverBalloon(function(o)
	{
		return _diagram.createDateTimeDiagramByAttrsText(500,300,o.properties,'D%y%y%y%y%m%m%d%d')
	});
	
	layer.filters[1].enableHoverBalloon(function(o)
	{
		var props = {};
			
		$.extend(props, o.properties);
		
		for (var name in props)
			if (!/D(1993)/.test(name))
				delete props[name];
			
		return _diagram.createPieDiagramByAttrsText(300,300,props,'D%y%y%y%y%m%m%d%d')
	});
	
	layer.filters[2].enableHoverBalloon(function(o)
	{
		var dataColumns = ['1992','1993','1995','1996','1997','1999','2000'],
			data = {'Слой1': [], 'Слой2': []};
		
		for (var i = 0; i < dataColumns.length; i++)
		{
			data['Слой1'].push(Number(o.properties['V_' + String(dataColumns[i])]));
			data['Слой2'].push(Number(o.properties['VSTD_' + String(dataColumns[i])]));
		}
		
		return _diagram.createMultiLinesDiagramText(500,300,data,dataColumns,1);
	});
	
	layer.filters[3].enableHoverBalloon(function(o)
	{
		var dataColumns = ['1995','1996','1997','1999','2000'],
			data = {'Слой1': [], 'Слой2': []};
		
		for (var i = 0; i < dataColumns.length; i++)
		{
			data['Слой1'].push(50 + Number(o.properties['V_' + String(dataColumns[i])]));
			data['Слой2'].push(50 + Number(o.properties['VSTD_' + String(dataColumns[i])]));
		}
		
		return _diagram.createBarsDiagramText(500,300,data,dataColumns,1,0);
	});
	
	layer.filters[4].enableHoverBalloon(function(o)
	{
		var dataColumns = ['1995','1996','1997','1999','2000'],
			data = {'Слой1': [], 'Слой2': []};
		
		for (var i = 0; i < dataColumns.length; i++)
		{
			data['Слой1'].push(50 + Number(o.properties['V_' + String(dataColumns[i])]));
			data['Слой2'].push(50 + Number(o.properties['VSTD_' + String(dataColumns[i])]));
		}
		
		return _diagram.createBarsDiagramText(500,300,data,dataColumns,1,1);
	});
	
	layer.filters[5].enableHoverBalloon(function(o)
	{
		var dataColumns = ['1992','1993','1995','1996'],
			data = {'Слой1': [], 'Слой2': []};
		
		for (var i = 0; i < dataColumns.length; i++)
		{
			data['Слой1'].push(50 + Number(o.properties['V_' + String(dataColumns[i])]));
			data['Слой2'].push(50 + Number(o.properties['VSTD_' + String(dataColumns[i])]));
		}
		
		return _diagram.createBarsDiagramText(400,300,data,dataColumns,0,1);
	});
}
*/


!(function(_) {
var KML = {
	KML: {}
}

var queryKML = function()
{
	this.parentCanvas = null;
    this._loadedKML = [];
    this._uniqueID = 0;
}

queryKML.prototype = new leftMenu();

queryKML.prototype.newID = function()
{
    var newID = "id" + this._uniqueID;
    this._uniqueID++;
    return newID;
}

queryKML.prototype.load = function()
{
	var inputField = _input(null, [['dir','className','inputStyle'],['css','width','200px']]),
		_this = this;
	
	this.parentCanvas = _div(null, [['dir','className','drawingObjectsCanvas']]);
	
	var goButton = makeButton(_gtxt("Загрузить")),
		_this = this;
	
	goButton.onclick = function()
	{
		if (inputField.value != '')
		{
			if (!nsGmx.AuthManager.isLogin())
			{
				nsGmx.widgets.authWidget.showLoginDialog();
				
				return;
			}
            
			var kmlURL = strip(inputField.value);
			gmxAPI._kmlParser.get(kmlURL, function(resp)
			{
				var info = gmxAPI._kmlParser.draw(resp.vals, globalFlashMap.addObject());
				
                var kmlInfo = {
                    id: _this.newID(), 
                    url: kmlURL, 
                    name: resp.name,
                    isVisible: true
                };
                _this._loadedKML.push(kmlInfo);
                
				_this.addFile(info, resp.name, true, kmlInfo.id);
			})
				
			inputField.value = '';
		}
		else
			inputError(inputField);
	}
	
	$(inputField).on('keydown', function(e)
	{
		if (e.keyCode === 13)
	  	{	
			if (inputField.value != '')
			{
				if (!nsGmx.AuthManager.isLogin())
				{
					nsGmx.widgets.authWidget.showLoginDialog();
					
					return;
				}
				
                var kmlURL = strip(inputField.value);
				gmxAPI._kmlParser.get(kmlURL, function(resp)
				{
					var info = gmxAPI._kmlParser.draw(resp.vals, globalFlashMap.addObject());
				
                    var kmlInfo = {
                        id: _this.newID(), 
                        url: kmlURL, 
                        name: resp.name,
                        isVisible: true
                    };
                    _this._loadedKML.push(kmlInfo);
					_this.addFile(info, resp.name, true, kmlInfo.id);
				})
					
				inputField.value = '';
			}
			else
				inputError(inputField);
	  		
	  		return false;
	  	}
	})
	
    
    
	var canvas = _div([_div([_span([_t(_gtxt("URL файла"))])], [['css','marginBottom','3px']]),_table([_tbody([_tr([_td([inputField],[['css','width','220px']]),_td([goButton])])])], [['css','marginBottom','5px']])],[['css','margin','3px 0px 0px 10px']])

	var attach = _input(null,[['attr','type','file'],['dir','name','rawdata'],['css','width','220px']]);
    var formFile = _form([attach], [['attr', 'method', 'POST'], ['attr', 'encoding', 'multipart/form-data'], ['attr', 'enctype', 'multipart/form-data'], ['attr', 'id', 'upload_shapefile_form']]);
    formFile.style.width = '200px';
	formFile.style.marginLeft = '3px';
	
	var loadButton = makeButton(_gtxt("Загрузить"));
	loadButton.onclick = function()
	{
        //если пользователь может загружать файлы и сохранять карту, то будем загружать KML к нему на диск и хранить в карте её адрес
        //иначе просто прокачаем через наш сервер без сохранения
		if (nsGmx.AuthManager.canDoAction(nsGmx.ACTION_UPLOAD_FILES) && nsGmx.AuthManager.canDoAction(nsGmx.ACTION_SAVE_MAP) && _queryMapLayers.currentMapRights() === "edit")
		{
        
            var shareKMLFolder = nsGmx.AuthManager.getUserFolder() + "\\share\\kml";
            sendCrossDomainJSONRequest(serverBase + 'FileBrowser/CreateFolder.ashx?WrapStyle=func&FullName=' + shareKMLFolder, function(response)
            {
                if (!parseResponse(response))
                    return;
                    
                var randomFilename = String(Math.random()).slice(2) + '.kml';
                sendCrossDomainPostRequest(serverBase + "FileBrowser/Upload.ashx", {WrapStyle: "window", ParentDir: shareKMLFolder, name: randomFilename}, function(response)
                {
                    var kmlURL = serverBase + "GetFile.ashx?nickname=" + encodeURIComponent(nsGmx.AuthManager.getNickname()) + "&file=" + encodeURIComponent("kml\\" + randomFilename);
                    sendCrossDomainJSONRequest(serverBase + 'ApiSave.ashx?get=' + encodeURIComponent(kmlURL), function(response)
                    {
                        if (!parseResponse(response))
                            return;
                        
                        var resp = gmxAPI._kmlParser.parse(response.Result);

                        var info = gmxAPI._kmlParser.draw(resp.vals, globalFlashMap.addObject());
                        
                        var kmlInfo = {
                            id: _this.newID(), 
                            url: kmlURL, 
                            name: resp.name,
                            isVisible: true
                        };
                        _this._loadedKML.push(kmlInfo);
                        _this.addFile(info, resp.name, true, kmlInfo.id);
                    });
                }, formFile)
            })
        }
        else
        {
            sendCrossDomainPostRequest(serverBase + "ApiSave.ashx", {WrapStyle: "window"}, function(response)
            {
                if (!parseResponse(response))
                    return;
                
                var resp = gmxAPI._kmlParser.parse(response.Result);

                var info = gmxAPI._kmlParser.draw(resp.vals, globalFlashMap.addObject());
                
                _this.addFile(info, resp.name, true)
            }, formFile);
        }
	}
	
	_(this.workCanvas, [canvas, _table([_tbody([_tr([_td([formFile],[['css','width','220px']]), _td([loadButton])])])],[['css','margin','5px 0px 10px 10px']]), this.parentCanvas])
}

queryKML.prototype.addFile = function(info, name, isVisible, kmlID)
{
	var canvas = _div(null, [['dir','className','canvas']]),
		title = makeLinkButton(name.length > 45 ? name.substr(0, 45) + '...' : name),
		remove = makeImageButton('img/closemin.png','img/close_orange.png'),
		box = _checkbox(isVisible, 'checkbox'),
		_this = this;
	
	_title(title, name);
    info.parent.setVisible(isVisible);
	
	box.onclick = function()
	{
		info.parent.setVisible(this.checked);
        
        for (var k = 0; k < _this._loadedKML.length; k++)
            if (_this._loadedKML[k].id == kmlID)
            {
                _this._loadedKML[k].isVisible = this.checked;
                break;
            }
	}
	
	title.onclick = function()
	{
		info.parent.setVisible(true);
		
		globalFlashMap.zoomToExtent(info.bounds.minX, info.bounds.minY, info.bounds.maxX, info.bounds.maxY);
		
		box.checked = true;
	}
	
	title.style.marginLeft = '5px';
	
	remove.onclick = function()
	{
		info.parent.remove();
        
        if (typeof kmlID !== 'undefined')
        {
            for (var k = 0; k < _this._loadedKML.length; k++)
                if (_this._loadedKML[k].id == kmlID)
                {
                    _this._loadedKML.splice(k, 1);
                    break;
                }
        }
		
		canvas.removeNode(true);
	}
	
	remove.className = 'remove';
	
	_(canvas, [_div([box, title], [['dir','className','item']]), remove])
	
	_(this.parentCanvas, [canvas]);
}

var _queryKML = new queryKML();

KML.KML.load = function()
{
	var alreadyLoaded = _queryKML.createWorkCanvas(arguments[0]);
	
	if (!alreadyLoaded)
		_queryKML.load()
}

KML.KML.unload = function()
{
}

nsGmx.userObjectsManager.addDataCollector('kml', {
    collect: function()
    {
        if (_queryKML.parentCanvas == null || _queryKML._loadedKML.length == 0)
            return null;
            
        var res = [];
        for (var k = 0; k < _queryKML._loadedKML.length; k++)
            res.push({url: _queryKML._loadedKML[k].url, isVisible: _queryKML._loadedKML[k].isVisible});
            
        return res;
    },
    
    load: function(data)
    {
        if (!data)
            return;
        
        KML.KML.load('kml');
        
        _queryKML._loadedKML = [];
        var loadedCount = 0;
        var allInfo = [];
        
        var showKML = function()
        {
            for (var k = 0; k < _queryKML._loadedKML.length; k++)
                _queryKML.addFile(allInfo[k], _queryKML._loadedKML[k].name, _queryKML._loadedKML[k].isVisible, _queryKML._loadedKML[k].id);
        }
        
        for (var k = 0; k < data.length; k++)
        (function(curKMLData, index)
        {
            gmxAPI._kmlParser.get(curKMLData.url, function(resp)
			{
				var info = gmxAPI._kmlParser.draw(resp.vals, globalFlashMap.addObject());
				
                _queryKML._loadedKML[index] = {id: _queryKML.newID(), url: curKMLData.url, name: resp.name, isVisible: curKMLData.isVisible};
                allInfo[index] = info;
                
                loadedCount++;
                
                //когда всё загрузили, можно показать пользователям
                if (loadedCount == data.length)
                    showKML();
			})
        })(data[k], k)
    }
});

window.KML = KML;
window.queryKML = queryKML;
window._queryKML = _queryKML;

})(nsGmx.Utils._);
var nsGmx = nsGmx || {};

(function() {

'use strict';

var SHARE_TYPES = ['public', 'private'];

nsGmx.Translations.addText('rus', {security: {
    ownerName: 'Владелец',
    defAccess: 'Доступ для всех',
    access: {
        empty: ' ',
        no: 'нет доступа',
        view: 'просмотр',
        linkview: 'просмотр по ссылке',
        edit: 'редактирование',
        editrows: 'редактирование объектов',
        preview: 'предпросмотр'
    },
    share: {
        'public': 'публичный',
        'private': 'частный'
    },
    addHeaderLabel: 'Введите пользователя или группу',
    addOkText: 'Добавить',
    select: {
        'selectedLayers': 'Выделено слоев для назначения прав: '
    }
}});

nsGmx.Translations.addText('eng', {security: {
    ownerName: 'Owner',
    defAccess: 'Public access',
    access: {
        empty: ' ',
        no: 'no access',
        view: 'view only',
        linkview: 'direct link view only',
        edit: 'edit',
        editrows: 'edit objects',
        preview: 'preview'
    },
    share: {
        'public': 'public',
        'private': 'private'
    },
    addHeaderLabel: 'Enter user or group',
    addOkText: 'Add',
    select: {
        'selectedLayers': 'Selected'
    }
}});

var usersHash = {};

var autocompleteLabelTemplate = Handlebars.compile(
    '<a class="security-autocomplete-item">' +
    '{{#if showIcon}}<span class="{{#if IsGroup}}security-group-icon{{else}}security-user-icon{{/if}}"></span>{{/if}}' +
        '<span>{{Nickname}}{{#if Login}}\u00A0({{Login}}){{/if}}</span>' +
    '</a>'
);

//на input вешается autocomplete со списком пользователей.
//кроме того, по нажатию enter происходит генерация события enterpress
var wrapUserListInput = function(input, options) {
    input.on('keydown', function(event) {
        if (event.keyCode === 13) {
            //setTimeout нужен чтобы autocomplete не дописывал выбранное значение в input после того, как мы его очистим
            setTimeout(function() {
                $(this).trigger('enterpress');
            }.bind(this), 0);
        }
    });
    input.autocomplete({
        source: function(request, cbResponse) {
            security.findUsers(request.term, {maxRecords: 7, type: options && options.type}).then(function(userInfos) {
                cbResponse(userInfos.map(function(userInfo) {
                    usersHash[userInfo.Nickname] = userInfo;
                    return {value: userInfo.Nickname, label: ''};
                }));
            }, cbResponse.bind(null, []));
        }
    });

    $(input).data("ui-autocomplete")._renderItem = function(ul, item) {
        var userInfo = usersHash[item.value],
            templateParams = $.extend({showIcon: options && options.showIcon}, userInfo);
        return $('<li></li>')
            .append($(autocompleteLabelTemplate(templateParams)))
            .appendTo(ul);
    }
}

var SecurityOwnerWidget = function(securityInfo, container) {
    var ui = $(SecurityOwnerWidget._template({
        ownerName: securityInfo.Owner
    })).appendTo(container);

    $('.security-owner-cancel', ui).click(function() {
        $('.changeOwnerLink', ui).click();
    });

    $('.changeOwnerLink', ui).click(function() {
        $(this).toggle();
        $('.security-owner-container', ui).toggle();
        $('.security-owner-input', ui).val('').focus();
    });

    var ownerAddInput = $('.security-owner-input', ui);
    ownerAddInput.on('enterpress', function() {
        $('.security-owner-ok', ui).click();
    });

    wrapUserListInput(ownerAddInput, {type: 'User'});

    $('.security-owner-ok', ui).click(function() {
        var input = $('.security-owner-input', ui),
            name = input.val();

        var doChangeUser = function(user) {
            $('.changeOwnerLink', ui).text(user.Nickname);
            securityInfo.NewOwnerID = user.UserID;
            $('.changeOwnerLink', ui).click();
        }

        if (name in usersHash) {
            doChangeUser(usersHash[name]);
        } else {
            security.findUsers(name, {maxRecords: 1}).then(function(userInfos) {
                if (userInfos[0] && userInfos[0].Nickname.toLowerCase() === name.toLowerCase()) {
                    doChangeUser(userInfos[0]);
                } else {
                    inputError(input[0]);
                }
            }, inputError.bind(null, input[0]));
        }
    });
}

SecurityOwnerWidget._template = Handlebars.compile(
    '<div class = security-owner>' +
        '<span>{{i "security.ownerName"}}: </span>' +
        '<span class="buttonLink changeOwnerLink security-owner-change">{{ownerName}}</span>' +
        '<div class="security-owner-container ui-front" style="display:none">' +
            '<input class="security-owner-input inputStyle">' +
            '<button class="security-owner-ok">Сменить</button>' +
            '<button class="security-owner-cancel">Отмена</button>' +
        '</div>' +
    '</div>');

// @param {String[]} options.accessTypes массив прав доступа
var SecurityUserListWidget = function(securityInfo, container, options) {
    var _this = this;

    this.options = options;

    var ui = $(SecurityUserListWidget._template()).appendTo(container);

    var sortFuncs = {};

    var genSortFunction = function(field)
    {
        return [
            function(a,b){if (a[field] > b[field]) return 1; else if (a[field] < b[field]) return -1; else return 0},
            function(a,b){if (a[field] < b[field]) return 1; else if (a[field] > b[field]) return -1; else return 0}
        ];
    }

    sortFuncs[_gtxt('Псевдоним')]  = genSortFunction('Nickname');
    sortFuncs[_gtxt('Полное имя')] = genSortFunction('FullName');
    sortFuncs[_gtxt('Доступ')]     = genSortFunction('Access');

    var fieldNames   = [_gtxt("Псевдоним"), _gtxt("Полное имя"), /*_gtxt("Роль"),*/ _gtxt("Доступ"), ""];
    var fieldWidthes = ['35%', '35%', '25%','5%'];

    this._securityTable = new nsGmx.ScrollTable({limit: 500, showFooter: false});
    this.securityUsersProvider = new nsGmx.ScrollTable.StaticDataProvider();

    this.securityUsersProvider.setSortFunctions(sortFuncs);
    this._securityTable.setDataProvider(this.securityUsersProvider);
    this._securityTable.createTable($('.access-table-placeholder', ui)[0], 'securityTable', 0, fieldNames, fieldWidthes, function(arg){
        return SecurityUserListWidget._drawMapUsers.call(this, arg, _this);
    }, sortFuncs);

    var addInput = $('.security-add-input', ui);
    addInput.on('enterpress', function() {
        $('.security-add-ok', ui).click();
    })
    wrapUserListInput(addInput, {showIcon: true});

    $('.security-add-ok', ui).click(function() {
        var input = $('.security-add-input', ui),
            name = input.val();

        var addedUsers = _this.securityUsersProvider.getOriginalItems();
        if (_.findWhere(addedUsers, {Nickname: name})) {
            inputError(input[0]);
            return;
        }

        var doAddUser = function(user) {
            _this._addMapUser(user);
            input.val('').focus();
        }

        if (name in usersHash) {
            doAddUser(usersHash[name]);
        } else {
            security.findUsers(name, {maxRecords: 1}).then(function(userInfos) {
                //TODO: обработать ситуацию, когда пользователь вводит email
                if (userInfos[0] && userInfos[0].Nickname.toLowerCase() === name.toLowerCase()) {
                    doAddUser(userInfos[0]);
                } else {
                    inputError(input[0]);
                }
            }, inputError.bind(null, input[0]));
        }
    });

    this.securityUsersProvider.setOriginalItems( securityInfo.Users );
}

SecurityUserListWidget.DEFAULT_ACCESS = 'view';

SecurityUserListWidget.prototype._addMapUser = function(user) {
    var existedUser = $.extend( {Access: SecurityUserListWidget.DEFAULT_ACCESS}, user );
    this.securityUsersProvider.addOriginalItem(existedUser);
}

SecurityUserListWidget.prototype.updateHeight = function(height) {
    this._securityTable.updateHeight(height);
}

SecurityUserListWidget._userRowTemplate = Handlebars.compile(
    '<tr>' +
        '<td class="security-row-nickname">' +
            '<span class="{{#if IsGroup}}security-group-icon{{else}}security-user-icon{{/if}}"></span>' +
            '<span title="{{Nickname}}">{{Nickname}}</span>' +
        '</td>' +
        '<td><div class="security-row-fullname" title="{{Fullname}}">{{Fullname}}</div></td>' +
        '<td><select class="selectStyle security-row-access">{{#access}}' +
            '<option value = "{{value}}"{{#if selected}} selected{{/if}}>{{title}}</option>' +
        '{{/access}}</select></td>' +
        '<td class="security-row-remove-cell"><div class="gmx-icon-recycle"></div></td>' +
    '</tr>'
);

SecurityUserListWidget._drawMapUsers = function(user, securityScope)
{
    var ui = $(SecurityUserListWidget._userRowTemplate({
        Nickname: user.Nickname,
        Fullname: user[user.IsGroup ? 'Description' : 'FullName'],
        IsGroup: user.IsGroup,
        access: securityScope.options.accessTypes
            .filter(function(type) {return type !== 'no';})
            .map(function(type) {
                return {
                    title: _gtxt('security.access.' + type),
                    value: type,
                    selected: type === user.Access
                }
            })
    }));

    var tr = ui[0];

    ui.find('.gmx-icon-recycle').click(function() {
        // уберем пользователя из списка
        securityScope.securityUsersProvider.filterOriginalItems(function(elem) {
            return elem.Nickname !== user.Nickname;
        });
    });

    ui.find('.security-row-access').change(function() {
        user.Access = this.value;
    });

    for (var i = 0; i < tr.childNodes.length; i++)
        tr.childNodes[i].style.width = this._fields[i].width;

    attachEffects(tr, 'hover');

    return tr;
}

SecurityUserListWidget._template = Handlebars.compile(
    '<div class = "security-userlist">' +
        '<div class="security-add-container ui-front">' +
            '<span class="security-access-label">{{i "security.addHeaderLabel"}}: </span>' +
            '<input class="security-add-input inputStyle">' +
            '<button class="security-add-ok">{{i "security.addOkText"}}</button>' +
        '</div>' +
        '<div class="access-table-placeholder"></div>' +
    '</div>');


var security = function()
{
    this.mapTypeSel = null;
    this.mapAccessSel = null;

    this.defaultAccess = null;

    this.getSecurityName = null;
    this.updateSecurityName = null;

    this.propertyValue = null;
    this.title = null;
}

var mapSecurity = function()
{
    this.getSecurityName = "Map/GetSecurity.ashx";
    this.updateSecurityName = "Map/UpdateSecurity.ashx";

    this.propertyName = "MapID";
    this.dialogTitle = "Редактирование прав доступа карты [value0]";

    this.accessTypes = ['no', 'view', 'linkview', 'edit'];
}

mapSecurity.prototype = new security();
mapSecurity.prototype.constructor = mapSecurity;

var layerSecurity = function(layerType)
{
    this.getSecurityName = "Layer/GetSecurity.ashx";
    this.updateSecurityName = "Layer/UpdateSecurity.ashx";

    this.propertyName = "LayerID";
    this.dialogTitle = "Редактирование прав доступа слоя [value0]";

    this.accessTypes = layerType === 'Raster' ? ['no', 'preview', 'view', 'edit'] : ['no', 'preview', 'view', 'editrows', 'edit'];
}

layerSecurity.prototype = new security();
layerSecurity.prototype.constructor = layerSecurity;

var multiLayerSecurity = function()
{
    this.getSecurityName = 'MultiLayer/GetSecurity.ashx';
    this.updateSecurityName = 'MultiLayer/UpdateSecurity.ashx';

    this.propertyName = 'MultiLayerID';
    this.dialogTitle = 'Редактирование прав доступа слоя [value0]';

    this.accessTypes = ['no', 'view', 'edit'];
}

multiLayerSecurity.prototype = new security();
multiLayerSecurity.prototype.constructor = multiLayerSecurity;

var layersGroupSecurity = function()
{
    this.getSecurityName = 'Map/GetSecurity.ashx';
    this.getGroupSecurityName = 'Layer/GetSecurity.ashx';
    this.updateSecurityName = 'Layer/LayersGroupUpdateSecurity';

    this.propertyName = 'MapID';
    this.groupPropertyName = 'Layers';

    this.mapLayers = [];
    this.mapLayersSecurityArray = [];
    this.selectedLayersSecurityArray = [];
    this.originalItems = [];

    this.dialogTitle = 'Редактирование прав доступа слоев карты [value0]';

    this.accessTypes = ['no', 'view', 'edit'];
}

layersGroupSecurity.prototype = new security();
layersGroupSecurity.prototype.constructor = layersGroupSecurity;

security.prototype.getSecurityFromServer = function(id) {
    var def = $.Deferred();

    sendCrossDomainJSONRequest(serverBase + this.getSecurityName + '?WrapStyle=func&IncludeAdmin=true&' + this.propertyName + '=' + id, function(response)
    {
        if (!parseResponse(response)) {
            def.reject(response);
            return;
        }
        def.resolve(response.Result);
    })

    return def;
}

// запрос security группы слоев
security.prototype.getGroupSecurityFromServer = function(postParams) {
    var def = $.Deferred();

    sendCrossDomainPostRequest(serverBase + this.getGroupSecurityName, postParams, function(response) {
        if (!parseResponse(response)) {
            def.reject(response);
            return;
        }
        def.resolve(response.Result);
    })

    return def;
}

security.prototype.getRights = function(value, title)
{
    var _this = this;

    this.propertyValue = value;
    this.title = title;

    this.getSecurityFromServer(value).then(this.createSecurityDialog.bind(this));
}

//ф-ция выделена из-за различий между диалогами прав слоёв и диалога состава группы
security.prototype.addCustomUI = function(ui, securityInfo) {
    var defAccessTemplate = Handlebars.compile(
        '<div class="security-def-access">{{i "security.defAccess"}}: ' +
            '<select class="security-defaccess-select selectStyle">' +
                '{{#defAccessTypes}}' +
                    '<option value="{{value}}"{{#isSelected}} selected{{/isSelected}}>{{title}}</option>' +
                '{{/defAccessTypes}}' +
            '</select>' +
        '</div>'
    );

    $(defAccessTemplate({
        defAccessTypes: this.accessTypes.map(function(type) {
            return {
                value: type,
                title: _gtxt('security.access.' + type),
                isSelected: type === securityInfo.SecurityInfo.DefAccess
            };
        })
    })).appendTo(ui.find('.security-custom-ui'));
}

//ф-ция выделена из-за различий между диалогами прав слоёв и диалога состава группы
security.prototype.saveCustomParams = function() {
    this._securityInfo.SecurityInfo.DefAccess = this._ui.find('.security-defaccess-select').val();
}

security.prototype._save = function() {
    var si = this._securityInfo;
    si.SecurityInfo.Users = this.securityUserListWidget.securityUsersProvider.getOriginalItems();

    nsGmx.widgets.notifications.startAction('securitySave');
    var postParams = {WrapStyle: 'window'};

    if (this.saveCustomParams()) {
        return;
    }

    postParams.SecurityInfo = JSON.stringify(si.SecurityInfo);

    postParams[this.propertyName] = this.propertyValue;
    sendCrossDomainPostRequest(serverBase + this.updateSecurityName, postParams, function(response) {
        if (!parseResponse(response)) {
            nsGmx.widgets.notifications.stopAction('securitySave');
            return;
        }

        nsGmx.widgets.notifications.stopAction('securitySave', 'success', _gtxt('Сохранено'));

        $(this).trigger('savedone', si);
    })
}

security.prototype.createSecurityDialog = function(securityInfo, options)
{
    options = $.extend({showOwner: true}, options);
    var _this = this;

    this._securityInfo = securityInfo;

    var uiTemplate = '<div id="securityDialog" class="security-canvas">' +
        '<div class="security-header">' +
            '<button class="security-save">{{i "Сохранить"}}</button>' +
                '{{#if showOwner}}<div class="security-owner-placeholder"></div>{{/if}}' +
        '</div>' +

        '<div class="security-custom-ui"></div>' +

        '<div class="security-userlist-placeholder"></div>' +
    '</div>';

    var canvas = this._ui = $(Handlebars.compile(uiTemplate)({
        showOwner: options.showOwner
    }));

    this.addCustomUI(canvas, securityInfo);

    $('.security-save', canvas).click(function(){
        _this._save();
    });

    if (options.showOwner) {
        new SecurityOwnerWidget(securityInfo.SecurityInfo, $('.security-owner-placeholder', canvas));
    }

    this.securityUserListWidget = new SecurityUserListWidget(securityInfo.SecurityInfo, $('.security-userlist-placeholder', canvas), {accessTypes: this.accessTypes});

    var resize = function()
    {
        var mapTableHeight;
        var dialogWidth = canvas[0].parentNode.parentNode.offsetWidth;

        var nonTableHeight =
            $('.security-header', canvas).height() +
            $('.security-custom-ui', canvas).height() +
            $('.security-add-container', canvas).height() + 15;

        mapTableHeight = canvas[0].parentNode.offsetHeight - nonTableHeight - 10;

        _this.securityUserListWidget.updateHeight(mapTableHeight);
    }

    this._dialogDiv = showDialog(_gtxt(this.dialogTitle, this.title), canvas[0], 571, 370, false, false, resize);

    resize();
}

//делает запрос на сервер и возвращает список пользователей по запросу query
//options = {maxRecords, type}; type: All / User / Group
security.findUsers = function(query, options) {
    var def = new L.gmx.Deferred();
    var maxRecordsParamStr = options && options.maxRecords ? '&maxRecords=' + options.maxRecords : '';
    var typeParamStr = '&type=' + (options && options.type || 'All');
    sendCrossDomainJSONRequest(serverBase + 'User/FindUser?query=' + encodeURIComponent(query) + maxRecordsParamStr + typeParamStr, function(response) {
        if (!parseResponse(response)) {
            def.reject(response);
            return;
        }

        def.resolve(response.Result);
    })

    return def;
}


layersGroupSecurity.prototype._save = function(originalItems) {
    var _this = this;

    if (!_this.selectedLayersSecurityArray.length) {
        return;
    }

    var si = _this._securityInfo,
        addedUsers = _this.securityUserListWidget.securityUsersProvider.getOriginalItems();

    si.SecurityInfo = {
        // Users: [],
        UsersAdd: addedUsers,
        UsersRemove: findRemovedUsers(originalItems, addedUsers)
    };

    nsGmx.widgets.notifications.startAction('securitySave');
    var postParams = {WrapStyle: 'window'};

    if (this.saveCustomParams()) {                                              // DefAccess: ''
        return;
    }

    postParams.SecurityInfo = JSON.stringify(si.SecurityInfo);

    postParams[this.groupPropertyName] = this.propertyValue;                    // Layers: {}

    sendCrossDomainPostRequest(serverBase + this.updateSecurityName, postParams, function(response) {
        if (!parseResponse(response)) {
            nsGmx.widgets.notifications.stopAction('securitySave');
            return;
        }
        originalItems = [];
        for (var i = 0; i < addedUsers.length; i++) {
            originalItems[i] = addedUsers[i];
        }
        // обновляем перечень общих пользователей
        _this.originalItems = originalItems;

        // обновляем права всех выделенных слоев
        updateselectedLayersSecurity(_this.selectedLayersSecurityArray);

        nsGmx.widgets.notifications.stopAction('securitySave', 'success', _gtxt('Сохранено'));
        $(this).trigger('savedone', si);
    })

    // обновляет массив выделенных слоев с правами после нажатия кнопки "сохранить",
    // затем обновляет массив всех слоев
    function updateselectedLayersSecurity(array) {
        var postParams = {
            WrapStyle: 'window',
            Layers: array.map(function(obj) {
                return obj.ID;
            })
        };

        _this.getGroupSecurityFromServer(postParams).then(updateSecurity);
    }
    // обновляет права на слои

    function updateSecurity(res) {
        var array = _this.selectedLayersSecurityArray;
        for (var i = 0; i < array.length; i++) {
            for (var j = 0; j < res.length; j++) {
                if (array[i].ID === res[j].ID) {
                    var options = {
                        type: array[i].type,
                        multiLayer: !!array[i].MultiLayerID
                    }
                    array.splice(i, 1, $.extend(res[j], options));
                }
            }
        }

        for (var k = 0; k < array.length; k++) {
            for (var l = 0; l < _this.mapLayersSecurityArray.length; l++) {
                if (array[k].ID === _this.mapLayersSecurityArray[l].ID) {
                    _this.mapLayersSecurityArray.splice(l, 1, array[k])
                }
            }
        }
    };

    // возвращает массив удаленных пользователей
    function findRemovedUsers(original, changed) {
        return _.difference(original, changed);
    }
}

// кастомный интерфейс - виджет группового редактирования слоев карты
layersGroupSecurity.prototype.createSecurityDialog = function(securityInfo, options)
{
    var _this = this,
        selectedLayersSecurityArray = this.selectedLayersSecurityArray;

    options = $.extend({showOwner: true}, options);
    this._securityInfo = securityInfo;

    var uiTemplate = '<div id="securityDialog" class="security-canvas">' +
        '<div class="security-header">' +
            '<button class="security-save">{{i "Сохранить"}}</button>' +
                '{{#if showOwner}}<div class="security-owner-placeholder"></div>{{/if}}' +
        '</div>' +
        '<div class="security-custom-ui"></div>' +
        '<div class="security-counter"></div>' +
        '<div class="security-default-access"></div>' +

        '<div class="security-userlist-placeholder"></div>' +

    '</div>';

    var canvas = this._ui = $(Handlebars.compile(uiTemplate)({
        showOwner: options.showOwner
    }));

    this.addCustomUI(canvas, resize);

    $('.security-save', canvas).click(function(){
        if (_this.groupPropertyName) {
            _this.propertyValue = selectedLayersSecurityArray.map(function(item){
                return item.ID;
            });
        }
        _this._save(_this.originalItems);
    });

    if (options.showOwner) {
        new SecurityOwnerWidget(securityInfo.SecurityInfo, $('.security-owner-placeholder', canvas));
    }

    this._dialogDiv = showDialog(_gtxt(this.dialogTitle, this.title), canvas[0], 571, 455, false, false, resize);
    function resize()
    {
        var mapTableHeight,
            nonTableHeight =
            $('.security-header', canvas).height() +
            $('.security-custom-ui', canvas).height() +
            $('.security-counter', canvas).height() +
            $('.security-default-access', canvas).height() +
            $('.security-add-container', canvas).height() + 25;

        mapTableHeight = canvas[0].parentNode.offsetHeight - nonTableHeight - 10;
        if (_this.securityUserListWidget) {
            _this.securityUserListWidget.updateHeight(mapTableHeight);
        }
    }

    resize();
}

// кастомный интерфейс - отдельная функция - дерево слоев для виджета группового редактирования слоев
layersGroupSecurity.prototype.addCustomUI = function(ui, resizeFunc) {
    var _this = this,
        mapLayers = _this.mapLayers,
        mapLayersSecurityArray = _this.mapLayersSecurityArray,
        selectedLayersSecurityArray = _this.selectedLayersSecurityArray,
        counter = 0,
        actualCounter = {counter: counter},
        countDiv = $('.security-counter', ui),
        countTemplate = Handlebars.compile(
            '<table class="security-count-table">' +
                '<tbody>' +
                    '<tr>' +
                        '<td>{{i "security.select.selectedLayers"}}</td>' +
                        '<td>{{counter}}</td>' +
                    '</tr>' +
                '</tbody>' +
            '</table>'
        ),
        templateSecurityInfo = {
            Users: []
        },
        tree,
        rawTree,
        drawnTree,
        defAccessDiv = $('.security-default-access', ui),
        defAccessTemplate = Handlebars.compile(
            '<div class="security-def-access">{{i "security.defAccess"}}: ' +
                '<select class="security-defaccess-select selectStyle">' +
                    '{{#defAccessTypes}}' +
                        '<option value="{{value}}"{{#isSelected}} selected{{/isSelected}}>{{title}}</option>' +
                    '{{/defAccessTypes}}' +
                '</select>' +
            '</div>'
        ),
        userList = $('.security-userlist-placeholder', ui),
        getMapLayersRights = function (callback) {
            var postParams = {
                WrapStyle: 'window',
                Layers: mapLayers.map(function(layer){
                    return layer.LayerID || layer.MultiLayerID;
                })
            };
            _this.getGroupSecurityFromServer(postParams).then(callback);
        },

        // сохраняем права слоев карты
        saveMapLayersRights = function (res) {
            for (var i = 0; i < res.length; i++) {
                for (var j = 0; j < mapLayers.length; j++) {
                    if (res[i].ID === mapLayers[j].LayerID || res[i].ID === mapLayers[j].MultiLayerID) {
                        var options = {
                            type: mapLayers[j].type,
                            multiLayer: !!mapLayers[j].MultiLayerID
                        };
                        mapLayersSecurityArray.push($.extend(res[i], options));
                    }
                }
            }
        };

    // модификация исходного дерева - остаются только слои с правами на редактирование
    rawTree = window._layersTree.treeModel.cloneRawTree(function(node) {
        var props = node.content.properties;
        props.visible = false;
        if (node.type === 'layer') {
            if (props.Access !== 'edit') {
                return null;
            }
            mapLayers.push(props);
            return node;
        }
        if (node.type === 'group') {
            var children = node.content.children;
            if (!children.length) {
                return null;
            }
            return node;
        }
    });

    // создание дерева слоев
    tree = new layersTree({
        showVisibilityCheckbox: true,
        allowActive: true,
        allowDblClick: false,
        showStyle: false,

        // обработка различных вариаций прав в группе слоев
        // если выделен один слой, рисуются его права
        // если у выделенных слоев есть юзеры с одинаковыми правами, то рисуются только эти юзеры
        // если у выделенных слоев разные права, рисуется пустой диалог
        // если у выделенных слоев разные дефолтные права, в выпадающий список выбора дефолтных прав проставляется пустое поле
        visibilityFunc: function(props, isVisible) {
            if (isVisible) {
                counter++;
                for (var i = 0; i < mapLayersSecurityArray.length; i++) {
                    if (mapLayersSecurityArray[i].ID === props.LayerID || mapLayersSecurityArray[i].ID === props.MultiLayerID) {
                        selectedLayersSecurityArray.push(mapLayersSecurityArray[i]);
                    }
                }
                addLayer();
            }

            if (!isVisible) {
                counter--;
                for (var i = 0; i < selectedLayersSecurityArray.length; i++) {
                    if (selectedLayersSecurityArray[i].ID === props.LayerID || selectedLayersSecurityArray[i].ID === props.MultiLayerID) {
                        selectedLayersSecurityArray.splice(i, 1);
                    }
                }
                removeLayer();
            }

            // показываем счетчик выделенных слоев под деревом
            actualCounter.counter = counter;
            $(countDiv).html(countTemplate(actualCounter));

            // добавляет слой в дерево слоев
            function addLayer() {
                drawAccess();
                resizeFunc();
            }

            // убирает слой из дерева слоев
            function removeLayer() {
                if (counter > 0 && selectedLayersSecurityArray.length) {
                    drawAccess();
                } else {
                    $(defAccessDiv).empty();
                        userList.empty();
                }
                resizeFunc();
            }

            // рисует оба виджета - доступа по умолчанию и списка пользователей для каждого слоя
            function drawAccess() {
                drawDefaultAccess(selectedLayersSecurityArray, defAccessDiv);
                drawUsersList(selectedLayersSecurityArray, userList);
            }

            // рисует доступ по умолчанию
            function drawDefaultAccess(array, container) {
                var accessTypes,
                    defTemplateJSON;

                if (checkSameLayersType(array)) {
                    accessTypes = array[0].type === 'Raster' ? ['no', 'preview', 'view', 'edit'] : ['no', 'preview', 'view', 'editrows', 'edit'];
                } else {
                    accessTypes = ['no', 'preview', 'view', 'edit'];
                }

                defTemplateJSON = {
                    defAccessTypes: accessTypes.map(function(type) {
                        return {
                            value: type,
                            title: _gtxt('security.access.' + type),
                            isSelected: undefined
                        };
                    })
                };

                $(container).empty();

                // протавляем значение в выпадающем списке прав по умолчанию
                if (checkSameDefaultAccess(array)) {
                    var types = defTemplateJSON.defAccessTypes;
                    for (var i = 0; i < types.length; i++) {
                        if (types[i].value === array[0].SecurityInfo.DefAccess) {
                            types[i].isSelected = true;
                        }
                    }
                    $(defAccessTemplate(defTemplateJSON)).appendTo(ui.find('.security-default-access'));
                } else {
                    accessTypes.unshift('empty');
                    defTemplateJSON = {
                        defAccessTypes: accessTypes.map(function(type) {
                            return {
                                value: type,
                                title: _gtxt('security.access.' + type),
                                isSelected: type === 'empty'
                            };
                        })
                    };
                    $(defAccessTemplate(defTemplateJSON)).appendTo(ui.find('.security-default-access'));
                }
            }

            // рисует список пользователей для каждого слоя
            function drawUsersList(array, container) {
                checkSameUsersAccess(array);
                var accessTypes;

                // запомним пересечения пользовательских прав для слоев,
                // в случае удаления / добавления пользователей, последующее состояние будет сравниваться с этим
                _this.originalItems = [];

                if (templateSecurityInfo.Users.length) {
                    accessTypes = array[0].type === 'Raster' ? ['no', 'preview', 'view', 'edit'] : ['no', 'preview', 'view', 'editrows', 'edit'];

                    for (var i = 0; i < templateSecurityInfo.Users.length; i++) {
                        _this.originalItems.push(templateSecurityInfo.Users[i]);
                    }
                } else {
                    accessTypes = ['no', 'preview', 'view', 'edit'];
                }

                container.empty();
                _this.securityUserListWidget = new SecurityUserListWidget(templateSecurityInfo, container, {accessTypes: accessTypes});
            }

            // проверяет, совпадают ли дефолтные права для всех выделенных слоев
            function checkSameDefaultAccess(array) {
                var first = array[0].SecurityInfo.DefAccess;
                return array.every(function(element) {
                    return element.SecurityInfo.DefAccess === first;
                });
            }

            // проверяет, совпадают ли отдельные права для всех выделенных слоев и создает массив пересечений
            function checkSameUsersAccess(array) {
                var userArray = array.map(function(obj){
                    return obj.SecurityInfo.Users;
                });

                templateSecurityInfo.Users = findCommonUsers(userArray);

                // нахождение одинаковых значений {пользователь: права} во всех слоях
                function findCommonUsers(array) {
                    var a = array.sort(sortArraysByLength),
                        first = a[0];

                    if (first.length) {
                        for (var i = 1; i < a.length; i++) {
                            first = first.filter(function (obj) {
                                return a[i].find(function (obj2) {
                                    return _.isEqual(obj, obj2)
                                })
                            })
                        }
                    } else {
                        first = [];
                    }
                    return first;
                }

                // сортировка массивов пользователей по длине для оптимизации времени
                function sortArraysByLength(a, b) {
                    return a.length - b.length;
                }
            }

            // проверяет, совпадают ли типы для всех выделенных слоев (вектор/растр)
            function checkSameLayersType(array) {
                var first = array[0].type;
                return array.every(function(element) {
                    return element.type === first;
                });
            }

        }
    });

    drawnTree = tree.drawTree(rawTree, 2);

    getMapLayersRights(saveMapLayersRights);

    $(drawnTree).treeview().appendTo(ui.find('.security-custom-ui'));
    $(countDiv).html(countTemplate(actualCounter));

}

nsGmx.mapSecurity = mapSecurity;
nsGmx.security = security;
nsGmx.layerSecurity = layerSecurity;
nsGmx.multiLayerSecurity = multiLayerSecurity;
nsGmx.layersGroupSecurity = layersGroupSecurity;

})();

!(function(_){

//для отслеживания того, что не открыли диалог редактирования одного и того же объекта несколько раз
var EditObjectControlsManager = {
    _editControls: [],
    _paramsHooks: [],
    
    find: function(layerName, oid)
    {
        for (var iD = 0; iD < this._editControls.length; iD++)
            if ( layerName == this._editControls[iD].layer && oid == this._editControls[iD].oid )
                return this._editControls[iD].control;
    },
    
    add: function(layerName, oid, control)
    {
        for (var iD = 0; iD < this._editControls.length; iD++)
            if ( layerName == this._editControls[iD].layer && oid == this._editControls[iD].oid )
            {
                this._editControls[iD].control = control;
                return;
            }
        this._editControls.push({ layer: layerName, oid: oid, control: control });
    },
    
    remove: function(layerName, oid)
    {
        for (var iD = 0; iD < this._editControls.length; iD++)
            if ( layerName == this._editControls[iD].layer && oid == this._editControls[iD].oid )
            {
                this._editControls.splice(iD, 1);
                return;
            }
    },
    
    addParamsHook: function(paramsHook) {
        this._paramsHooks.push(paramsHook);
    },
    
    applyParamsHook: function(layerName, objectId, params) {
        for (var h = 0; h < this._paramsHooks.length; h++) {
            params = this._paramsHooks[h](layerName, objectId, params);
        }
        
        return params;
    }
}

var getInputElement = function(type)
{
    var input = _input(null, [['dir','className','inputStyle edit-obj-input']]);
    
    if (type == 'date')
    {
        $(input).datepicker({
            changeMonth: true,
            changeYear: true,
            dateFormat: "dd.mm.yy"
        });
    }
    else if ( type == 'datetime' )
    {
        $(input).datetimepicker(
        {
            changeMonth: true,
            changeYear: true,
            dateFormat: "dd.mm.yy",
            timeFormat: "HH:mm:ss",
            showSecond: true,
            timeOnly: false
        })
    }
    else if ( type == "time" )
    {
        $(input).timepicker({
            timeOnly: true,
            timeFormat: "HH:mm:ss",
            showSecond: true
        });
    }
    
    return input;
}

//Коллекция полей с информацией для создания диалога редактирования
var FieldsCollection = function() {
    var _asArray = [];
    var _asHash = {};
    
    this.append = function(field) {
        if (field.name && _asHash[field.name]) {
            var origIndex = _asHash[field.name].origIndex;
            $.extend(true, _asHash[field.name], field);
            _asHash[field.name].origIndex = origIndex;
        } else {
            field.origIndex = _asArray.length;
            _asArray.push(field);
            if (field.name) {
                _asHash[field.name] = field;
            }
        }
    }
    
    this.get = function(name) {
        return _asHash[name];
    }
    
    this.each = function(callback) {
        _asArray.forEach(callback);
    }
    
    this.updateValue = function(name) {
        var field = _asHash[name];
        if (field && field.view) {
            field.value = field.view.getValue();
        }
        return field && field.value;
    }
    
    //Сначала isRequired, потом identityField, потом в порядке добавления
    this.sort = function() {
        _asArray = _asArray.sort(function(a, b) {
            if (!!a.isRequired !== !!b.isRequired) {
                return Number(!!b.isRequired) - Number(!!a.isRequired);
            }
            
            if (!!a.identityField !== !!b.identityField) {
                return Number(!!b.identityField) - Number(!!a.identityField);
            }
            
            var userZIndexDelta = (b.index || 0) - (a.index || 0);
            return userZIndexDelta || (b.origIndex - a.origIndex);
        })
    }
}

/** Объект, описывающий один атрибут слоя
 * @typedef {Object} nsGmx.EditObjectControl.FieldInfo
 * @property {String} name имя атрибута (обязательно)
 * @property {String|int} [value] значение атрибута в формате сервера
 * @property {bool} [constant=false] можно ли редактировать атрибут
 * @property {bool} [hide=false] совсем не показыавать этот атрибут
 * @property {String} [title=<совпадает с name>] что показывать вместо имени атрибута
 * @property {function(val):bool} [validate] ф-ция для валидации результата. На вход получает введённое пользователем значение 
*      (до преобразования в серверный формат), должна вернуть валидно ли это значение.
 * @property {String} [isRequired=false] является ли значение атрибута обязательным. Обязательные атрибуты показываются выше всех остальных и выделяются жирным шрифтом.
 * @property {Number} [index=0] индекс для сортировки. Влияет на порядок показа полей в диалоге. Больше - выше.
*/

/** Контрол, который показывает диалог редактирования существующего или добавления нового объекта в слой.
* 
* @memberOf nsGmx
* @class
* @param {String}   layerName ID слоя
* @param {Number}   objectId ID объекта (null для нового объекта)
* @param {Object}   [params] Дополнительные параметры контрола
* @param {gmxAPI.drawingObject} [params.drawingObject] Пользовательский объект для задании геометрии или null, если геометрия не задана
* @param {function} [params.onGeometrySelection] Внешняя ф-ция для выбора геометрии объекта. 
         Сигнатура: function(callback), параметр callback(gmxAPI.drawingObject|geometry) должен быть вызван когда будет выбрана геометрия.
* @param {HTMLNode} [params.geometryUI] HTML элемент, который нужно использовать вместо стандартных контролов для выбора геометрии (надпись + иконка)
* @param {nsGmx.EditObjectControl.FieldInfo[]} [params.fields] массив с описанием характеристик атрибутов для редактирования . Должен содержать только атрибуты, которые есть в слое.
* @param {bool} [params.allowDuplicates=<depends>] Разрешать ли несколько диалогов для редактирования/создания этого объекта. 
         По умолчанию для редактирования запрещено, а для создания нового разрешено.
* @param {HTMLNode | function(nsGmx.EditObjectControl): HTMLNode} [params.afterPropertiesControl] HTML элемент, который нужно поместить после списка атрибутов или ф-ция, которая возвращает этот элемент
*/
var EditObjectControl = function(layerName, objectId, params)
{
    /** Объект был изменён/добавлен
     * @event nsGmx.EditObjectControl#modify
     */
     
    /** Генерируется перед изменением/добавлением объекта. Может быть использован для сохранения в свойствах объекта каких-то внешних данных.
     * @event nsGmx.EditObjectControl#premodify
     */
     
    /** Закрытие диалога редактирования
     * @event nsGmx.EditObjectControl#close
     */

    if (_queryMapLayers.layerRights(layerName) !== 'edit' && _queryMapLayers.layerRights(layerName) !== 'editrows') {
        showErrorMessage(_gtxt('Недостаточно прав для редактирования объектов слоя'), true);
        return;
    }

    var isNew = objectId == null;
    var _params = $.extend({
            drawingObject: null, 
            fields: [], 
            validate: {},
            allowDuplicates: isNew,
            afterPropertiesControl: _span()
        }, params);
        
    _params = EditObjectControlsManager.applyParamsHook(layerName, objectId, _params);
        
    var _this = this;
    if (!_params.allowDuplicates && EditObjectControlsManager.find(layerName, objectId))
        return EditObjectControlsManager.find(layerName, objectId);
    
    EditObjectControlsManager.add(layerName, objectId, this);
    
    var lmap = nsGmx.leafletMap,
        layersByID = nsGmx.gmxMap.layersByID;
    var layer = layersByID[layerName];
    var geometryInfoContainer = _div(null, [['css','color','#215570'], ['css','fontSize','12px']]);
    
    var originalGeometry = null;
    var drawingBorderDialog = null;
    var identityField = layer._gmx.properties.identityField;
    
    var geometryInfoRow = null;

    var drawingObjectLeafletID = null;
    var bindDrawingObject = function(obj)
    {
        geometryInfoRow && geometryInfoRow.RemoveRow();

        if (!obj) return;
        
        var InfoRow = gmxCore.getModule('DrawingObjects').DrawingObjectInfoRow;
        geometryInfoRow = new InfoRow(
            lmap, 
            geometryInfoContainer, 
            obj, 
            { editStyle: false, allowDelete: false }
        );
        drawingObjectLeafletID = obj._leaflet_id;
    }
    
    var bindGeometry = function(geom) {
        if (geom) {
            var geojson = new L.GeoJSON(geom),
                arr = lmap.gmxDrawing.addGeoJSON(geojson);
            for (var i = 0, len = arr.length; i < len; i++) {
                bindDrawingObject(arr[i]);
            }
        }
    }

    var canvas = null;
    var fieldsCollection = new FieldsCollection();
    
    var createDialog = function()
    {
        var createButton = makeLinkButton(isNew ? _gtxt("Создать") : _gtxt("Изменить")),
            removeButton = makeLinkButton(_gtxt("Удалить")),
            trs = [],
            isSaving = false;
            
        var canvas = _div(null, [['dir', 'className', 'edit-obj']]);
        
        $(canvas).bind('dragover', function() {
            return false;
        });
        
        $(canvas).bind('drop', function(e) {
            var files = e.originalEvent.dataTransfer.files;
            nsGmx.Utils.parseShpFile(files[0]).done(function(objs) {
                bindGeometry(nsGmx.Utils.joinPolygons(nsGmx._.pluck(objs, 'geometry')));
            });
            return false;
        });
        
        removeButton.onclick = function()
        {
            _mapHelper.modifyObjectLayer(layerName, [{action: 'delete', id: objectId}]).done(function()
            {
                removeDialog(dialogDiv);
                closeFunc();
            })
        }
        
        removeButton.style.marginLeft = '10px';
        
        isNew && $(removeButton).hide();
	
        createButton.onclick = function()
        {
            if (isSaving) {
                return;
            }
                        
            $(_this).trigger('premodify');
            
            var properties = {};
            var anyErrors = false;
            
            fieldsCollection.each(function(field) {
                var name = field.name;
                if (!name) {
                    return;
                }
                
                var isValid = field.view.checkValue();
                if (isValid) {
                    properties[name] = fieldsCollection.updateValue(name);
                }
                anyErrors = anyErrors || !isValid;
            })
            
            if (anyErrors) return;
            
            var obj = { properties: properties };
            
            var selectedGeom = _this.getGeometry();
            
            if (!selectedGeom)
            {
                showErrorMessage("Геометрия для объекта не задана", true, "Геометрия для объекта не задана");
                return;
            }
            
            if (!isNew)
            {
                obj.id = objectId;

                var curGeomString = JSON.stringify(selectedGeom);
                var origGeomString = JSON.stringify(originalGeometry);
                
                if (origGeomString !== curGeomString) {
                    obj.geometry = selectedGeom;
                }
            }
            else
            {
                obj.geometry = selectedGeom;
            }
            
            isSaving = true;
            
            _mapHelper.modifyObjectLayer(layerName, [obj], 'EPSG:4326').done(function()
            {
                $(_this).trigger('modify');
                removeDialog(dialogDiv);
                closeFunc();
            })
        }
    
        var resizeFunc = function(event, ui)
        {
            if (!isNew && $(canvas).children("[loading]").length)
                return;
            
            canvas.firstChild.style.height = canvas.parentNode.offsetHeight - 25 - 10 - 10 + 'px';
        }
        
        var closeFunc = function()
        {
            // search for opened styles editing dialog
            if (drawingObjectLeafletID) {
                var styleEditingDialog = $('.drawing-object-leaflet-id-' + drawingObjectLeafletID);
            }

            geometryInfoRow && geometryInfoRow.getDrawingObject() && nsGmx.leafletMap.gmxDrawing.remove(geometryInfoRow.getDrawingObject());
                
            originalGeometry = null;

            if (styleEditingDialog) {
                removeDialog(styleEditingDialog);
            }

            if (drawingBorderDialog)
                removeDialog(drawingBorderDialog);
            
            EditObjectControlsManager.remove(layerName, objectId);
            
            $(_this).trigger('close');
        }

        var drawAttrList = function(fields)
        {
            var trs = [],
                firstInput;
            
            //сначала идёт геометрия
            var geomTitleTmpl = Handlebars.compile('<span>' +
                '<span class="edit-obj-geomtitle">{{i "Геометрия"}}</span>' +
                '<span id = "choose-geom" class="gmx-icon-choose"></span>' +
            '</span>');
            
            var geometryUI = _params.geometryUI || $(geomTitleTmpl())[0];
            $('#choose-geom', geometryUI).click(function() {
                if (_params.onGeometrySelection) {
                    _params.onGeometrySelection(bindGeometry);
                } else {
                    nsGmx.Controls.chooseDrawingBorderDialog(
                        'editObject',
                        bindDrawingObject,
                        { geomType: layer.getGmxProperties().GeometryType }
                    );
                }
            })
            
            trs.push(_tr([_td([geometryUI],[['css','height','20px']]), _td([geometryInfoContainer])]));
            
            fields.sort();
            
            //потом все остальные поля
            fields.each(function(field) {
                var td = _td();
                if (field.constant)
                {
                    field.view = field.view || {
                        getUI: function() {
                            var span = _span(null,[['dir', 'className', 'edit-obj-constant-value']]);
                            span.rowName = field.name;
                            span.rowType = field.type;
                            if ('value' in field) {
                                _(span, [_t(nsGmx.Utils.convertFromServer(field.type, field.value))]);
                            }
                            return span;
                        },
                        getValue: function() {return field.value},
                        setValue: function() {},
                        checkValue: function() { return true; }
                    }
                }
                else
                {
                    field.view = field.view || {
                        getUI: function() {
                            if (!this._input) {                            
                                var input = this._input = getInputElement(field.type);
                                input.rowName = field.name;
                                input.rowType = field.type;
                                
                                firstInput = firstInput || input;
                                
                                if ('value' in field)
                                    input.value = nsGmx.Utils.convertFromServer(field.type, field.value);
                            }
                            return this._input;
                        },
                        getValue: function() {
                            return nsGmx.Utils.convertToServer(field.type, this._input.value);
                        },
                        setValue: function(value) {
                            this._input.value = nsGmx.Utils.convertFromServer(field.type, value);
                        },
                        checkValue: function() {
                            var validationFunc = field.validate || _params.validate[field.name];
                            var isValid = !validationFunc || validationFunc(this._input.value);
                            if (!isValid) {
                                inputError(this._input);
                            }
                            return isValid;
                        },
                        _input: null
                    }
                }
                
                _(td, [field.view.getUI(_this)]);
                
                var fieldHeader = _span([_t(field.title || field.name)],[['css','fontSize','12px']]);
                if (field.isRequired) {
                    fieldHeader.style.fontWeight = 'bold';
                }
                var tr = _tr([_td([fieldHeader]), td], [['css', 'height', '22px']]);
                
                field.hide && $(tr).hide();
                
                trs.push(tr);
            })
            
            var afterPropUI = typeof _params.afterPropertiesControl === 'function' ? _params.afterPropertiesControl(_this) : _params.afterPropertiesControl;
            
            _(canvas, [_div([_table([_tbody(trs)], [['dir', 'className', 'obj-edit-proptable']]), afterPropUI],[['dir', 'className', 'obj-edit-canvas'], ['css','overflow','auto']])]);
            
            _(canvas, [_div([createButton, removeButton],[['css','margin','10px 0px'],['css','height','20px']])]);

            firstInput && firstInput.focus();
            
            resizeFunc();
        }
var prop = layer._gmx.properties;
        
        var dialogDiv = showDialog(isNew ? _gtxt("Создать объект слоя [value0]", prop.title) : _gtxt("Редактировать объект слоя [value0]", prop.title), canvas, 520, 300, false, false, resizeFunc, closeFunc);
        
        if (!isNew)
        {
            var loading = _div([_img(null, [['attr','src','img/progress.gif'],['css','marginRight','10px']]), _t(_gtxt('загрузка...'))], [['css','margin','3px 0px 3px 20px'],['attr','loading',true]]);
        
            _(canvas, [loading])
            
            //получаем геометрию объекта
            sendCrossDomainJSONRequest(serverBase + "VectorLayer/Search.ashx?WrapStyle=func&layer=" + layerName + "&page=0&pagesize=1&orderby=" + identityField + "&geometry=true&query=[" + identityField + "]=" + objectId, function(response)
            {
                if (!parseResponse(response))
                    return;
                    
                $(canvas).children("[loading]").remove();
                
                var columnNames = response.Result.fields;
                var drawingObject = null;
                var geometryRow = response.Result.values[0];
                var types = response.Result.types;
                
                for (var i = 0; i < geometryRow.length; ++i)
                {
                    if (columnNames[i] === 'geomixergeojson')
                    {
                        var geom = L.gmxUtil.geometryToGeoJSON(geometryRow[i], true);
                        if (geom) {
                            bindGeometry(geom);
                            originalGeometry = $.extend(true, {}, geom);
                        }
                    }
                    else
                    {
                        var field = {
                            value: geometryRow[i],
                            type: types[i], 
                            name: columnNames[i],
                            constant: columnNames[i] === identityField,
                            identityField: columnNames[i] === identityField,
                            isRequired: false
                        };
                        
                        fieldsCollection.append(field);
                    }
                }
                
                _params.fields.forEach(fieldsCollection.append);
                
                drawAttrList(fieldsCollection);
                
                _this.initPromise.resolve();
            })
        }
        else
        {
            for (var i = 0; i < prop.attributes.length; ++i)
            {
                fieldsCollection.append({type: prop.attrTypes[i], name: prop.attributes[i]})
            }
            
            _params.fields.forEach(fieldsCollection.append);
            
            if (_params.drawingObject) {
                bindDrawingObject(_params.drawingObject);
            }
            
            drawAttrList(fieldsCollection);
            
            _this.initPromise.resolve();
        }
    }
    
    /** Promise для отслеживания момента полной инициализации диалога. Только после полной инициализации можно полноценно пользоваться методами get/set
      * @memberOf nsGmx.EditObjectControl.prototype
      * @member {jQuery.Deferred} initPromise
    */
    this.initPromise = $.Deferred();
    
    /** Получить текущее значение атрибута из контрола
      @memberOf nsGmx.EditObjectControl.prototype
      @param {String} fieldName Имя атрибута
      @method get
    */
    this.get = function(fieldName) {
        return fieldsCollection.updateValue(fieldName);
    }
    
    this.getAll = function() {
        var res = {};
        fieldsCollection.each(function(field) {
            res[field.name] = fieldsCollection.updateValue(field.name);
        })
        
        return res;
    }
    
    /** Задать значение атрибута объекта из контрола
      @memberOf nsGmx.EditObjectControl.prototype
      @method set
      @param {String} fieldName Имя атрибута
      @param {String|Integer} value Значение в клиентском формате, который нужно установить для этого атрибута
    */
    this.set = function(fieldName, value) {
        var field = fieldsCollection.get(fieldName);
        if (field) {
            field.view.setValue(value);
        }
    }
    
    /** Задать геометрию для редактируемого объекта
      @memberOf nsGmx.EditObjectControl.prototype
      @method setGeometry
      @param {gmxAPI.DrawingObject|geometry} geometry Геометрия в виде drawing объекта или просто описание геометрии
    */
    this.setGeometry = function(geometry) {
        bindGeometry(geometry);
    }
    
    this.getGeometryObj = function() {
        return geometryInfoRow ? geometryInfoRow.getDrawingObject() : null;
    }
    
    this.getGeometry = function() {
        if (geometryInfoRow) {
            var geom = geometryInfoRow.getDrawingObject();
            var geojson = geom.toGeoJSON();
            return geojson.geometry;
        } else {
            return null;
        }
    }
    
    this.getLayer = function() { return layer; };
    
    this.add = function(field) {
        fieldsCollection.append(field);
    }
    
    createDialog();
}

nsGmx.EditObjectControl = EditObjectControl;

/** Добавить "хук" для модификации параметров при всех вызовах ф-ции {@link nsGmx.EditObjectControl}
    @function
    @param {function(Object): Object} {paramsHook} Ф-ция, которая принимает на вход параметры ф-ции {@link nsGmx.EditObjectControl} 
        и возвращает модифицируемые параметры (возможна замена in place)
*/
nsGmx.EditObjectControl.addParamsHook = EditObjectControlsManager.addParamsHook.bind(EditObjectControlsManager);

})(nsGmx.Utils._);
!(function () {

nsGmx.SuggestWidget = function(attrNames, textarea, textTemplate, func, valuesArr, addValueFlag) {

    if (valuesArr && !(valuesArr instanceof nsGmx.ILazyAttributeValuesProvider)) {
        valuesArr = new nsGmx.LazyAttributeValuesProviderFromArray(valuesArr);
    }

    var canvas = this.el = nsGmx.Utils._div(null, [['dir', 'className', 'suggest-helper']]);
    canvas.style.display = 'none';

    canvas.onmouseout = function(e) {
        var evt = e || window.event,
            target = evt.srcElement || evt.target,
            relTarget = evt.relatedTarget || evt.toElement;

        if (canvas.getAttribute('arr')) {
            try {
                while (relTarget) {
                    if (relTarget === canvas) { return; }
                    relTarget = relTarget.parentNode;
                }
                $(canvas).fadeOut(300, function() {$(this).remove();});
            } catch (ev) {
                if (target === canvas) {
                    $(canvas).fadeOut(300, function() {$(this).remove();});
				}
            }
        }
    };

    attrNames.forEach(function(name) {
        var div = nsGmx.Utils._div([nsGmx.Utils._t(String(name))], [['dir', 'className', 'suggest-helper-elem']]);

        div.onmouseover = function() {
            var _curDiv = this;
            $(this.parentNode).children('.suggest-helper-hover').removeClass('suggest-helper-hover');
            $(this).addClass('suggest-helper-hover');

            if (!valuesArr) { return; }

            $(canvas.parentNode).children('[arr]').each(function() {
                if (this.getAttribute('arr') !== name) {
                    $(this).fadeOut(300, function() {
                        $(this).remove();
                    });
                }
            });

            if (!valuesArr.isAttributeExists(name)) { return; }

            if (!$(canvas.parentNode).children('[arr=\'' + name + '\']').length) {
                this.timer = setTimeout(function() {
                    valuesArr.getValuesForAttribute(name, function(attrValues) {

                        if (!attrValues || !$(_curDiv).hasClass('suggest-helper-hover')) { return; }

                        var arrSuggestCanvas = new nsGmx.SuggestWidget(attrValues, textarea, 'suggest', function()
                            {
                                func && func();

                                $(canvasArr.parentNode.childNodes[1]).fadeOut(300);

                                canvasArr.removeNode(true);
                            }, false, addValueFlag);

                        var canvasArr = arrSuggestCanvas.el;

                        canvasArr.style.left = '105px';
                        canvasArr.style.height = '70px';
                        canvasArr.style.width = '100px';

                        $(canvasArr).children().css('width', '80px');

                        canvasArr.setAttribute('arr', name);

                        $(canvas.parentNode).append(canvasArr);

                        $(canvasArr).fadeIn(300);
                    });

                }, 300);
            }
        };

        div.onmouseout = function(e) {
            var evt = e || window.event,
                target = evt.srcElement || evt.target,
                relTarget = evt.relatedTarget || evt.toElement;

            if ($(target).hasClass('suggest-helper-hover') && relTarget === this.parentNode) {
                $(this).removeClass('suggest-helper-hover');
			}

            if (this.timer) {
                clearTimeout(this.timer);
			}
        };

        div.onclick = function(e) {
            var val = textTemplate.replace(/suggest/g, name);
            if (this.parentNode.getAttribute('arr') != null)
            {
                if (isNaN(Number(val))) {
                    val = '\'' + val + '\'';
				}

                if (addValueFlag) {
                    val = '"' + this.parentNode.getAttribute('arr') + '" = ' + val;
				}
            }

            insertAtCursor(textarea, val, this.parentNode.sel);

            $(canvas).fadeOut(300);

            if (this.timer) {
                clearTimeout(this.timer);
			}

            $(canvas.parentNode).children('[arr]').fadeOut(300, function()
            {
                $(this).remove();
            });

            func && func();

            stopEvent(e);
        };

        window._title(div, name);

        $(canvas).append(div);
    });
};

var template = Handlebars.compile('<div class="suggest-container">' +
    '<table><tbody><tr>' +
        '<td><div class="suggest-link-container suggest-attr">{{i "Атрибут >"}}</div></td>' +
        '<td><div class="suggest-link-container suggest-value">{{i "Значение >"}}</div></td>' +
        '<td><div class="suggest-link-container suggest-op">{{i "Операция >"}}</div></td>' +
    '</tr></tbody></table>' +
'</div>');

nsGmx.AttrSuggestWidget = function(targetTextarea, attrNames, attrValuesProvider, changeCallback) {
    var ui = this.el = $(template());

    var attrsSuggest = new nsGmx.SuggestWidget(attrNames, targetTextarea, '"suggest"', changeCallback, attrValuesProvider, true),
        valuesSuggest = new nsGmx.SuggestWidget(attrNames, targetTextarea, '"suggest"', changeCallback, attrValuesProvider),
        opsSuggest = new nsGmx.SuggestWidget(['=', '>', '<', '>=', '<=', '<>', 'AND', 'OR', 'NOT', 'IN', 'LIKE', '()'], targetTextarea, ' suggest ', changeCallback);

    ui.find('.suggest-attr').append(attrsSuggest.el);
    ui.find('.suggest-value').append(valuesSuggest.el);
    ui.find('.suggest-op').append(opsSuggest.el);

    var clickFunc = function(div) {
        if (document.selection) {
            targetTextarea.focus();
            var sel = document.selection.createRange();
            div.sel = sel;
            targetTextarea.blur();
        }

        ui.find('.attrsHelperCanvas').children('[arr]').fadeOut(300, function() {
            $(this).remove();
        });
    };

    ui.find('.suggest-link-container').click(function() {
        var placeholder = $(this).children('.suggest-helper');
        clickFunc(placeholder[0]);

        ui.find('.suggest-helper').fadeOut(300);
        placeholder.fadeIn(300);
    });

    $(targetTextarea).click(function() {
        ui.find('.suggest-helper').fadeOut(300);
        return true;
    });
};

})();

/** Параметры мультивременного слоя, связанные со временем
  @class
  @extends Backbone.Model
  @prop {number} [minPeriod=1] Минимальный период создания тайлов
  @prop {number} [maxPeriod=1] Максимальный период создания тайлов
  @prop {number} [columnName=null]  Название мультивременной колонки
  @prop {number} [isTemporal=false] Является ли слой мультивременным
*/
nsGmx.TemporalLayerParams = Backbone.Model.extend(
/** @lends nsGmx.TemporalLayerParams.prototype */
{
    defaults: {
        isTemporal: false,
        maxShowPeriod: 0,
        minPeriod: 1,
        maxPeriod: 64,
        columnName: null
    },

    /** Возвращает строчку с перечислением временнЫх периодов (для передачи серверу) */
    getPeriodString: function() {
        var minPeriod = this.attributes.minPeriod,
            maxPeriod = this.attributes.maxPeriod,
            curPeriod = minPeriod,
            periods = [];

        while (curPeriod <= maxPeriod)
        {
            periods.push(curPeriod);
            curPeriod *= nsGmx.TemporalLayerParams.PERIOD_STEP;
        }
        return periods.join(',');
    }
}, {PERIOD_STEP: 4});

/** Связанные с квиклуками параметры векторных слоёв. Умеет сериализовать/десериализовать себя в строку для хранения на сервере.
 * @class
 * @memberOf nsGmx
 * @extends Backbone.Model
 * @property {String} template Шаблон URL квиклука
 * @property {Number} minZoom Минимальный зум показа квиклуков
 * @property {Number} X1-X4,Y1-Y4 Названия полей слоя, в которых хранятся координаты привязки 4 углов изображения. Если не указаны, будут использованы значения по умолчанию (поля "X1"-"X4", "Y1"-"Y4" или их аналоги в нижнем регистре)
 */
nsGmx.QuicklookParams = Backbone.Model.extend({
    /** Загружает параметры из строки с сервера.
     * @param {String} quicklookString Строка с параметрами с сервера
     */
    fromServerString: function(quicklookString) {
        if (quicklookString) {
            //раньше это была просто строка с шаблоном квиклука, а теперь стало JSON'ом
            if (quicklookString[0] === '{') {
                var p = JSON.parse(quicklookString);
                this.set({
                    template: p.template,
                    minZoom: p.minZoom,
                    X1: p.X1, Y1: p.Y1,
                    X2: p.X2, Y2: p.Y2,
                    X3: p.X3, Y3: p.Y3,
                    X4: p.X4, Y4: p.Y4
                });
            } else {
                this.set({
                    template: quicklookString
                });
            }
        }
    },
    /** Сохраняет все параметры в строку, которую можно передать серверу.
     * @return {String}
     */
    toServerString: function() {
        //$.extend чтобы удалить undefined поля
        return this.attributes.template ? JSON.stringify($.extend({}, this.attributes)) : '';
    }
});

(function() {

function capitaliseFirstLetter(str)
{
    return str.charAt(0).toUpperCase() + str.slice(1);
}

//events: newAttribute, delAttribute, updateAttribute, moveAttribute, change
nsGmx.ManualAttrModel = function(isRCLayer) {
    var _attributes = [];

    this.addAttribute = function(type, name)
    {
        _attributes.push({
            type: type,
            name: name,
            IsPrimary: false,
            IsIdentity: false,
            IsComputed: false
        });

        $(this).triggerHandler('newAttribute');
        $(this).triggerHandler('change');

        return _attributes.length - 1;
    };

    this.changeName = function(idx, newName)
    {
        _attributes[idx].name = newName;
        $(this).triggerHandler('updateAttribute');
        $(this).triggerHandler('change');
    };

    this.changeType = function(idx, newType)
    {
        _attributes[idx].type = newType;
        $(this).triggerHandler('updateAttribute');
        $(this).triggerHandler('change');
    };

    this.deleteAttribute = function(idx)
    {
        _attributes.splice(idx, 1);
        $(this).triggerHandler('delAttribute');
        $(this).triggerHandler('change');
    };

    this.getAttribute = function(idx) { return _attributes[idx]; };
    this.getCount = function() { return _attributes.length; };
    this.each = function(callback, addInternalColumns) {
        for (var k = 0; k < _attributes.length; k++) {
            var column = _attributes[k];
            var isInternal = column.IsPrimary || column.IsIdentity || column.IsComputed ||
                             column.type.server === 'geometry' || (isRCLayer && column.name === 'GMX_RasterCatalogID');

            if (!isInternal || addInternalColumns) {
                callback(column, k);
            }
        }
    };

    this.moveAttribute = function(oldIdx, newIdx) {
        if (newIdx > oldIdx) {
            newIdx--;
        }

        if (oldIdx !== newIdx) {
            _attributes.splice(newIdx, 0, _attributes.splice(oldIdx, 1)[0]);
            $(this).triggerHandler('moveAttribute');
            $(this).triggerHandler('change');
        }
    };

    this.initFromServerFormat = function(serverColumns) {
        _attributes = [];
        $.each(serverColumns || [], function(i, column) {
            var type = window._.find(nsGmx.ManualAttrModel.TYPES, function(elem) {return elem.server === column.ColumnSimpleType.toLowerCase();});
            _attributes.push({
                type: type || {server: column.ColumnSimpleType.toLowerCase()},
                name: column.Name,
                oldName: column.Name,
                IsPrimary: column.IsPrimary,
                IsIdentity: column.IsIdentity,
                IsComputed: column.IsComputed
            });
        });
        $(this).triggerHandler('newAttribute');
        $(this).triggerHandler('change');
    };

    this.toServerFormat = function() {
        var res = [];
        $.each(_attributes, function(i, attr) {
            res.push({
                Name: attr.name,
                OldName: attr.oldName,
                ColumnSimpleType: capitaliseFirstLetter(attr.type.server),
                IsPrimary: attr.IsPrimary,
                IsIdentity: attr.IsIdentity,
                IsComputed: attr.IsComputed});
        });

        return res;
    };
};

nsGmx.ManualAttrModel.TYPES = {
    DOUBLE:   {user: 'Float',    server: 'float'},
    INTEGER:  {user: 'Integer',  server: 'integer'},
    STRING:   {user: 'String',   server: 'string'},
    TIME:     {user: 'Time',     server: 'time'},
    DATE:     {user: 'Date',     server: 'date'},
    DATETIME: {user: 'DateTime', server: 'datetime'},
    BOOL:     {user: 'Boolean',  server: 'boolean'}
};

})();

(function() {
var utils = nsGmx.Utils;
_translationsHash.addtext('rus', {ManualAttrView: {
    headerName: 'Название',
    headerType: 'Тип'
}});

_translationsHash.addtext('eng', {ManualAttrView: {
    headerName: 'Name',
    headerType: 'Type'
}});


var selectorTemplate = Handlebars.compile('<select class="selectStyle customAttr-typesselect">' +
        '{{#each types}}' +
            '<option value="{{server}}" id="{{server}}"{{#if @root.isSelected}} selected{{/if}}>{{user}}</option>' +
        '{{/each}}' +
    '</select>'
);

nsGmx.ManualAttrView = function()
{
    var _parent = null;
    var _model = null;
    var _trs = [];
    var _isActive = true;
    var _this = this;
    var isAddingNew = false;

    var createTypeSelector = function(selectedType)
    {
        return $(selectorTemplate({
            types: nsGmx.ManualAttrModel.TYPES,
            isSelected: function() {
                return this.server === selectedType;
            }
        }));
    };

    var createRow = function(attr, i) {
        var typeSelector = createTypeSelector(attr.type.server)[0];
        $(typeSelector).data('idx', i);

        $(typeSelector).change(function() {
            var serverType = $('option:selected', this).val(),
                attrType = window._.findWhere(nsGmx.ManualAttrModel.TYPES, {server: serverType});

            _model.changeType($(this).data('idx'), attrType);
        });

        var nameSelector = utils._input(null, [['attr', 'class', 'customAttrNameInput inputStyle'], ['css', 'width', '120px']]);

        $(nameSelector).data('idx', i).val(attr.name);

        var deleteIcon = utils.makeImageButton('img/recycle.png', 'img/recycle_a.png');
        var tr = utils._tr([utils._td([nameSelector]), utils._td([typeSelector]), utils._td([deleteIcon])]);
        $(nameSelector).on('keyup', function()
        {
            var idx = $(this).data('idx');
            var name = $(this).val();

            if (idx >= 0) {
                _model.changeName(idx, name);
            } else if (name) {
                isAddingNew = true;
                $(tr).find('td:gt(0)').show();
                $(tr).removeClass('customAttributes-new');
                var newIdx = _model.addAttribute(nsGmx.ManualAttrModel.TYPES.STRING, name);
                $([nameSelector, typeSelector, deleteIcon]).data('idx', newIdx);
                isAddingNew = false;
            }
        });

        $(deleteIcon).addClass('removeIcon').data('idx', i);
        deleteIcon.onclick = function()
        {
            _model.deleteAttribute($(this).data('idx'));
        };

        return tr;
    };

    var redraw = function()
    {
        if (!_model || isAddingNew) { return; }

        $(_parent).empty();
        _trs = [];

        _model.each(function(attr, i) {
            _trs.push(createRow(attr, i));
        });

        var newAttr = createRow({name: '', type: nsGmx.ManualAttrModel.TYPES.STRING}, -1);
        $(newAttr).find('td:gt(0)').hide();
        $(newAttr).addClass('customAttributes-new');

        _trs.push(newAttr);

        var tbody = nsGmx.Utils._tbody(_trs);
        var theader = $(Handlebars.compile('<thead><tr><th>{{i "ManualAttrView.headerName"}}</th><th>{{i "ManualAttrView.headerType"}}</th></tr></thead>')());

        $(_parent).append($('<fieldset/>').css('border', 'none').append(nsGmx.Utils._table([theader[0], tbody], [['dir', 'className', 'customAttributes']])));
        _this.setActive(_isActive);
    };

    this.setActive = function(isActive) {
        _isActive = isActive;
        var fieldset = $(_parent).children('fieldset');
        if (isActive) {
            fieldset.removeAttr('disabled');
        } else {
            fieldset.attr('disabled', 'disabled');
        }
        $('.removeIcon, .customAttributes-new', fieldset).toggle(isActive);
    };

    this.init = function(parent, model)
    {
        _parent = parent;
        _model = model;
        $(_model).on('newAttribute delAttribute moveAttribute', redraw);

        $(_model).on('newAttribute', function() {
            if (!$(_parent).find('.customAttributes-new').length) {
                var newAttr = createRow({name: '', type: nsGmx.ManualAttrModel.TYPES.STRING}, -1);
                $(newAttr).find('td:gt(0)').hide();
                $(newAttr).addClass('customAttributes-new');
                $(_parent).find('tbody').append(newAttr);
            }
        });
        redraw();
    };
};

})();

(function() {

Handlebars.registerPartial('TemporalLayerWidgetOptions',
    '{{#periods}}<option name="{{.}}">{{.}}</option>{{/periods}}'
);

_translationsHash.addtext('rus', {
    'Макс. период на экране': 'На экране не более',
    'Тайлы с': 'Тайлы с',
    'Тайлы до': 'Тайлы до',
    'дней': 'дней'
});

_translationsHash.addtext('eng', {
    'Макс. период на экране': 'Max period to show',
    'Тайлы с': 'Tiles from',
    'Тайлы до': 'Tiles till',
    'дней': 'days'
});

/** Создаёт виджет для задания мультивременных параметров слоя
* @class
* @param {HTMLNode} parentDiv контейнер для размещения виджета
* @param {nsGmx.TemporalLayerParams} paramsModel начальные параметры
* @param {String[]} columns массив имён колонок, из которых можно выбрать врменнУю
*/
nsGmx.TemporalLayerParamsWidget = function(parentDiv, paramsModel, columns)
{
    var PERIODS = [1, 4, 16, 64];
    // var optionsHtml = '{{#periods}}<option name="{{.}}">{{.}}</option>{{/periods}}';

    var template = Handlebars.compile(
        '<table><tbody>' +
            '<tr>' +
                '<td>{{i "Макс. период на экране"}}</td>' +
                '<td><input id="maxShownPeriod" class="inputStyle temporal-maxshow"></input> <span>{{i "дней"}}</span> </td>' +
            '</tr>' +
            '<tr class="temporal-columns">' +
                '<td>{{i "Колонка даты"}}</td>' +
                '<td><select id="columnSelect" class="selectStyle"></select></td>' +
            '</tr>' +
            '<tr class="temporal-advanced">' +
                '<td>{{i "Тайлы с"}}</td>' +
                '<td><select id="minPeriod" class="selectStyle">{{>TemporalLayerWidgetOptions}}</select></td>' +
            '</tr>' +
            '<tr class="temporal-advanced">' +
                '<td>{{i "Тайлы до"}}</td>' +
                '<td><select id="maxPeriod" class="selectStyle">{{>TemporalLayerWidgetOptions}}</select></td>' +
            '</tr>' +
        '</tbody></table>' +
        '<span class="buttonLink RCCreate-advanced-link">{{i "LayerRCControl.advancedLink"}}</span>');

    $(parentDiv).html(template({periods: PERIODS}));

    var _columns = columns;
    var isAdvancedMode =
            paramsModel.get('minPeriod') !== paramsModel.defaults.minPeriod ||
            paramsModel.get('maxPeriod') !== paramsModel.defaults.maxPeriod;

    var wasInAdvancedMode = isAdvancedMode;
    var updateVisibility = function() {
        // var isTemporal = paramsModel.get('isTemporal');
        $('.temporal-advanced', parentDiv).toggle(isAdvancedMode);
        $('.RCCreate-advanced-link', parentDiv).toggle(!isAdvancedMode);
        $('.temporal-columns', parentDiv).toggle(_columns.length > 1);
    };

    var updateColumnsSelect = function()
	{
        var selectDateColumn = $('#columnSelect', parentDiv);
		var curColumn = paramsModel.get('columnName');
		var foundOption = null;

		selectDateColumn.empty();
		for (var i = 0; i < _columns.length; i++) {
			var option = $('<option></option>').text(_columns[i]);
			selectDateColumn.append(option);
			if (curColumn === _columns[i]) {
				foundOption = option;
			}
		}

		if (foundOption) {
			foundOption.attr('selected', 'selected');
		} else if (_columns.length) {
			paramsModel.set('columnName', _columns[0]);
		}
	};

    updateVisibility();

    $('.RCCreate-advanced-link', parentDiv).click(function() {
        isAdvancedMode = !isAdvancedMode;
        wasInAdvancedMode = true;
        updateVisibility();
    });

    paramsModel.on('change:isTemporal', updateVisibility);

    updateColumnsSelect();
    $('#columnSelect', parentDiv).change(function()
    {
        paramsModel.set('columnName', $('option:selected', this).val());
    });

    $('#minPeriod>option[name=' + paramsModel.get('minPeriod') + ']', parentDiv).attr('selected', 'selected');
    $('#minPeriod', parentDiv).change(function()
    {
        paramsModel.set('minPeriod', $('option:selected', this).val());
    });

    $('#maxPeriod>option[name=' + paramsModel.get('maxPeriod') + ']', parentDiv).attr('selected', 'selected');
    $('#maxPeriod', parentDiv).change(function()
    {
        paramsModel.set('maxPeriod', $('option:selected', this).val());
    });

    $('#maxShownPeriod', parentDiv).val(paramsModel.get('maxShownPeriod') || '').bind('keyup', function()
    {
        var val = parseInt(this.value) || 0;

        var paramsToSet = {maxShownPeriod: Math.max(0, val)};

        if (!wasInAdvancedMode) {
            if (val > 0) {
                var index = Math.ceil(Math.log(val) / Math.log(4));
                paramsToSet.maxPeriod = PERIODS[Math.min(PERIODS.length - 1, index)];
            } else {
                paramsToSet.maxPeriod = paramsModel.defaults.maxPeriod;
            }
            $('#maxPeriod>option[name=' + paramsToSet.maxPeriod + ']', parentDiv).attr('selected', 'selected');
        }

        paramsModel.set(paramsToSet);
    });

    /**
        Обновляет список доступных для выбора колонок даты
        @param {String[]} columns массив имён колонок
    */
	this.updateColumns = function(columns)
	{
		_columns = columns;
		updateColumnsSelect();
        updateVisibility();
	};
};

})();

!function($) {
    _translationsHash.addtext('rus', {LayerRCControl: {
        minZoom         : 'Мин. зум',
        titleTemplate   : 'Шаблон имени',
        pathTemplate    : 'Шаблон тайлов',
        advancedLink    : 'Дополнительно',
        layerTagTitle   : 'Параметр слоя',
        attributeTitle  : 'Атрибут объекта'
    }});

    _translationsHash.addtext('eng', {LayerRCControl: {
        minZoom         : 'Min zoom',
        titleTemplate   : 'Title template',
        pathTemplate    : 'Path template',
        advancedLink    : 'Advanced',
        layerTagTitle   : 'Layer parameter',
        attributeTitle  : 'Object Attribute'
    }});

    nsGmx.LayerRCProperties = Backbone.Model.extend({
        defaults: {
            IsRasterCatalog: false,
            RCMinZoomForRasters: 0,
            RCMaskForRasterTitle: '',
            RCMaskForRasterPath: '',
            ColumnTagLinks: {}
        },
        isAnyLinks: function() {
            return window._.size(this.attributes.ColumnTagLinks) > 0;
        }
    });

    /**
    Контрол для задания параметров каталогов растров
    @memberOf nsGmx
    @class
    */
    nsGmx.LayerRasterCatalogWidget = function(container, rcProperties)
    {
        var advancedMode = !!(
                rcProperties.get('RCMaskForRasterPath') ||
                rcProperties.get('RCMaskForRasterTitle') ||
                rcProperties.isAnyLinks()
            );

        var updateVisibility = function()
        {
            // var isRasterCatalog = rcProperties.get('IsRasterCatalog');
            $('.RCCreate-advanced', container).toggle(advancedMode);
            $('.RCCreate-advanced-link', container).toggle(!advancedMode);
            $('.RCCreate-tagContainer', container).toggle(advancedMode);
        };

        rcProperties.on('change:IsRasterCatalog', updateVisibility);

        var RCCheckbox = $('<input/>', {type: 'checkbox', 'class': 'RCCreate-checkbox'}).change(function() {
            rcProperties.set('IsRasterCatalog', RCCheckbox[0].checked);
        });

        var advancedParamsLink = $(window.makeLinkButton(_gtxt('LayerRCControl.advancedLink'))).addClass('RCCreate-advanced-link').click(function()
        {
            advancedMode = !advancedMode;
            updateVisibility();
        });

        RCCheckbox[0].checked = rcProperties.get('IsRasterCatalog');

        var minZoomInput = $('<input/>', {'class': 'inputStyle RCCreate-zoom-input'}).val(rcProperties.get('RCMinZoomForRasters') || '').bind('keyup change', function() {
            rcProperties.set('RCMinZoomForRasters', parseInt(this.value));
        });

        var titleInput = $('<input/>', {'class': 'inputStyle'}).val(rcProperties.get('RCMaskForRasterTitle') || '').bind('keyup change', function() {
            rcProperties.set('RCMaskForRasterTitle', this.value);
        });

        var pathInput = $('<input/>', {'class': 'inputStyle'}).val(rcProperties.get('RCMaskForRasterPath') || '').bind('keyup change', function() {
            rcProperties.set('RCMaskForRasterPath', this.value);
        });

        // var RCParamsTable =
            $('<table/>', {'class': 'RCCreate-params'})
                .append($('<tr/>')
                    .append($('<td/>').text(_gtxt('LayerRCControl.minZoom')).css('padding-right', '6px'))
                    .append($('<td/>').append(minZoomInput)))
                .append($('<tr/>', {'class': 'RCCreate-advanced'})
                    .append($('<td/>').text(_gtxt('LayerRCControl.titleTemplate')))
                    .append($('<td/>').append(titleInput)))
                .append($('<tr/>', {'class': 'RCCreate-advanced'})
                    .append($('<td/>').text(_gtxt('LayerRCControl.pathTemplate')))
                    .append($('<td/>').append(pathInput)))
                .appendTo(container);

        nsGmx.TagMetaInfo.loadFromServer(function(realTagInfo)
        {
            var realTagsInfo = realTagInfo.getTagArrayExt();
            var fakeTagsInfo = {};
            for (var iT = 0; iT < realTagsInfo.length; iT++)
            {
                var info = realTagsInfo[iT];
                fakeTagsInfo[info.name] = {Type: 'String', Description: info.descr};
            }
            var fakeTagManager = new nsGmx.TagMetaInfo(fakeTagsInfo);

            var initTags = {};

            var columnTagLinks = rcProperties.get('ColumnTagLinks');

            for (var iP in columnTagLinks)
                initTags[columnTagLinks[iP]] = {Value: iP};

            var layerTags = new nsGmx.LayerTagsWithInfo(fakeTagManager, initTags);

            var tagContainer = $('<div/>', {'class': 'RCCreate-tagContainer RCCreate-advanced'}).addClass().appendTo(container);
            var tagsControl = new nsGmx.LayerTagSearchControl(layerTags, tagContainer, {
                inputWidth: 100,
                tagHeader: _gtxt('LayerRCControl.layerTagTitle'),
                valueHeader: _gtxt('LayerRCControl.attributeTitle')
            });

            $(layerTags).change(function() {
                var columnTagLinks = {};
                layerTags.eachValid(function(id, tag, value) { columnTagLinks[value] = tag;});
                rcProperties.set('ColumnTagLinks', columnTagLinks);
            });

            advancedParamsLink.appendTo(container);

            updateVisibility();
        });
    };
}(jQuery);

!function($) {
    _translationsHash.addtext('rus', {LayerQuicklookWidget: {
        minZoom: 'Мин. зум',
        regTitle: 'Атрибуты привязки',
        title: 'Показать'
    }});

    _translationsHash.addtext('eng', {LayerQuicklookWidget: {
        minZoom: 'Min zoom',
        regTitle: 'Registration fields',
        title: 'Expand'
    }});

    var template = Handlebars.compile('<div>' +
        '{{#if isMinimized}}<span class="lqw-title buttonLink">{{i "LayerQuicklookWidget.title"}}</span>{{/if}}' +
        '<div class="lqw-container" {{#if isMinimized}}style="display:none"{{/if}}>' +
            '<div>{{i "LayerQuicklookWidget.minZoom"}}<input class="lqw-minzoom-input inputStyle" value="{{minZoom}}"></div>' +
            '<textarea class="inputStyle lqw-textarea">{{quicklook}}</textarea>' +
            '<div class="suggest-link-container">{{i "Атрибут >"}}</div>' +
            '<div class="lqw-registration-link">{{i "LayerQuicklookWidget.regTitle"}}</div>' +
            '<table class="lqw-registration-container">' +
                '{{#points}}' +
                    '<tr><td>X{{idx}}{{../regSelect "X"}}</td><td>Y{{idx}}{{../regSelect "Y"}}</td></tr>' +
                '{{/points}}' +
            '</table>' +
        '</div>' +
    '</div>');

    var selectTemplate = Handlebars.compile('<select data-name="{{targetName}}" class="lqw-point-select selectStyle">' +
        '{{#opts}}' +
            '<option value="{{name}}"{{#if isDefault}} selected{{/if}}>{{name}}</option>' +
        '{{/opts}}' +
    '</select>');

    /**
    Виджет для задания параметров слоя, связанных с показом квиклуков
    @memberOf nsGmx
    @class
    */
    nsGmx.LayerQuicklookWidget = function(container, layerProperties) {
        var DEFAULT_OPTION = {name: '', isDefault: false};

        var layerColumns = window._.pluck(layerProperties.get('Columns'), 'Name'),
            quicklookParams = layerProperties.get('Quicklook');

        var ui = $(template({
            isMinimized: !quicklookParams.get('template'),
            minZoom: quicklookParams.get('minZoom'),
            quicklook: quicklookParams.get('template'),
            points: Array.apply(null, {length: 4}).map(function(elem, index) { return {idx: index + 1};}),
            regSelect: function(label) {
                var targetName = (label + this.idx),
                    initValue = (quicklookParams.get(targetName) || targetName).toLowerCase();
                return new Handlebars.SafeString(selectTemplate({
                    targetName: targetName,
                    opts: [].concat(DEFAULT_OPTION, layerColumns.map(function(column) {
                        return {
                            name: column,
                            isDefault: column.toLowerCase() === initValue
                        };
                    }))
                }));
            }
        }));

        ui.find('.lqw-title').click(function() {
            ui.find('.lqw-title').hide();
            ui.find('.lqw-container').show();
        });

        var updateRegistrationStatus = function() {
            ui.find('td').each(function(index, td) {
                $(td).toggleClass('lqw-reg-error', !$(td).find('option:selected').val());
            });
        };

        ui.find('.lqw-minzoom-input').on('change keyup', function() {
            var minZoom = Number(this.value);
            quicklookParams.set('minZoom', minZoom);
        });

        ui.find('select').change(function() {
            updateRegistrationStatus();
            var name = $(this).data('name');
            quicklookParams.set(name, this.value || undefined);
        });

        updateRegistrationStatus();

        if (ui.find('.lqw-reg-error').length === 0) {
            ui.find('.lqw-registration-container').hide();
            ui.find('.lqw-registration-link').addClass('buttonLink').click(function() {
                $(this).removeClass('buttonLink');
                ui.find('.lqw-registration-container').show();
            });
        }

        var quicklookText = ui.find('.lqw-textarea');

        var setQuicklook = function() {
            layerProperties.get('Quicklook').set('template', quicklookText.val());
        };

        var suggestWidget = new nsGmx.SuggestWidget(layerProperties.get('Attributes') || [], quicklookText[0], '[suggest]', setQuicklook);

        quicklookText.on('focus', function() {
            $(suggestWidget.el).hide();
        });

        ui.find('.suggest-link-container')
            .append(suggestWidget.el)
            .click(function() {
                if (suggestWidget.el.style.display === 'none') {
                    $(suggestWidget.el).fadeIn(500);
                }
            });

        quicklookText.on('keyup change', setQuicklook);

        ui.appendTo(container);
    };
}(jQuery);

!(function() {

'use strict';

nsGmx.AttrTable = nsGmx.AttrTable || {};

var attrsTable = function(layerName, layerTitle)
{
	this.layerName = layerName;
	this.layerTitle = layerTitle || '';

	this.filterData = null;

	this.activeColumns = null;

	this.resizeFunc = function() {};

    this._updateVersionHandler = null;

    this._isLayerOnMap = this.layerName in nsGmx.gmxMap.layersByID;

    this.tableFields = {
        fieldsAsArray: [],
        fieldsAsHash: {},
        titleToField: {},
        init: function(fieldParams, info) {
            var _this = this;
            this.fieldsAsHash = {};
            this.titleToField = {};
            this.fieldsAsArray = [];
            if (!fieldParams) {
                this.fieldsAsArray = [info.identityField].concat(info.attributes);
                this.fieldsAsArray.forEach(function(name) {
                    _this.fieldsAsHash[name] = true;
                    _this.titleToField[name] = name;
                });
            } else {
                fieldParams.forEach(function(field) {
                    _this.fieldsAsArray.push(field.title);
                    _this.fieldsAsHash[field.title] = true;
                    _this.titleToField[field.title] = field.name;
                });
            }
        }
    };
};

attrsTable.prototype.getLayerInfo = function()
{
    return this._layerInfo;
};

attrsTable.prototype.getInfo = function(origCanvas, outerSizeProvider, params)
{
	if (!origCanvas && $('#attrsTableDialog' + this.layerName).length) {
		return;
	}

    origCanvas && $(origCanvas).empty();

	var canvas = origCanvas || nsGmx.Utils._div(null, [['attr', 'id', 'attrsTableDialog' + this.layerName], ['css', 'overflow', 'hidden']]),
		loading = nsGmx.Utils._div([nsGmx.Utils._img(null, [['attr', 'src', 'img/progress.gif'], ['css', 'marginRight', '10px']]), nsGmx.Utils._t(_gtxt('загрузка...'))], [['css', 'margin', '3px 0px 3px 20px']]),
		_this = this;

	nsGmx.Utils._(canvas, [loading]);

    if (!origCanvas)
    {
        outerSizeProvider = function() {
            return {
                width: canvas.parentNode.parentNode.offsetWidth,
                height: canvas.parentNode.offsetHeight
            };
        };

        nsGmx.Utils.showDialog(_gtxt('Таблица атрибутов слоя [value0]', this.layerTitle), canvas,
            {
                width: 800,
                height: 500,
                resizeFunc: function()
                {
                    this.resizeFunc.apply(this, arguments);
                }.bind(this),
                closeFunc: function()
                {
                    if (_this._updateVersionHandler !== null && _this._isLayerOnMap) {
                        nsGmx.gmxMap.layersByID[_this.layerName].off('versionchange', _this._updateVersionHandler);
                    }
                },
                setMinSize: false
            }
        );
    }

	sendCrossDomainJSONRequest(window.serverBase + 'Layer/GetLayerJson.ashx?WrapStyle=func&LayerName=' + this.layerName, function(response)
	{
		if (!window.parseResponse(response)) {
			return;
		}

		loading.removeNode(true);

        _this._layerInfo = response.Result.properties;

        _this._layerColumns = [
            {Value: 'GeomIsEmpty([geomixergeojson])', Alias: '__GeomIsEmpty__'},
            {Value: '[' + response.Result.properties.identityField + ']'}
        ];

        var attrs = response.Result.properties.attributes;
        for (var k = 0; k < attrs.length; k++) {
            _this._layerColumns.push({Value: '[' + attrs[k] + ']'});
        }

		_this.drawDialog(response.Result.properties, canvas, outerSizeProvider, params);
	});
};

attrsTable.prototype._updateSearchString = function(query) {
    this._serverDataProvider.setRequests(
        window.serverBase + 'VectorLayer/Search.ashx', {layer: this.layerName, query: query, count: true},
        window.serverBase + 'VectorLayer/Search.ashx', {layer: this.layerName, query: query, columns: JSON.stringify(this._layerColumns)}
    );
};

attrsTable.prototype.drawDialog = function(info, canvas, outerSizeProvider, params)
{
    var _params = $.extend({
        hideDownload: false,
        hideActions: false,
        hideRowActions: false,
        hideSearchParams: false,
        onClick: null,
        searchParamsManager: new nsGmx.AttrTable.DefaultSearchParamsManager()
        /*attributes: [] */
    }, params);

	var paramsWidth = 300,
		tdParams = nsGmx.Utils._td(null, [['css', 'width', paramsWidth + 'px'], ['attr', 'vAlign', 'top']]),
		tdTable = nsGmx.Utils._td(null, [['attr', 'vAlign', 'top']]),
		paramsButton = nsGmx.Utils.makeLinkButton(_gtxt('Показать параметры поиска')),
		addObjectButton = nsGmx.Utils.makeLinkButton(_gtxt('Добавить объект')),
		oldCanvasWidth = false,
		_this = this;

    var downloadSection = $(Handlebars.compile('<div>' +
        '<span class="buttonLink attrsDownloadLink" data-format="Shape">{{i "Скачать shp"}}</span>' +
        '{{#unless isPolygon}}' +
		'<span class="buttonLink attrsDownloadLink" data-format="gpx">{{i "Скачать gpx"}}</span>' +
		'{{/unless}}' +
        '<span class="buttonLink attrsDownloadLink" data-format="csv">{{i "Скачать csv"}}</span>' +
        '<span class="buttonLink attrsDownloadLink" data-format="geojson">{{i "Скачать geojson"}}</span>' +
        '<span class="buttonLink createLayerLink">{{i "Создать слой"}}</span>' +
        '{{#if isPolygon}}<span class="buttonLink attrs-table-square-link">{{i "Рассчитать площадь"}}</span>{{/if}}' +
    '</div>')({
        isPolygon: info.GeometryType === 'polygon'
    }));

    downloadSection.find('.attrsDownloadLink').click(function() {
        downloadLayer($(this).data('format'));
    });

	// создание слоя из выборки (из атрибутивной таблицы)
    downloadSection.find('.createLayerLink').click(function() {

		sendCrossDomainJSONRequest(serverBase + "Layer/GetLayerInfo.ashx?WrapStyle=func&NeedAttrValues=false&LayerName=" + info.name, function(response) {
			if (!parseResponse(response)) {
				return;
			}

			createEditorFromSelection(response.Result);

			function createEditorFromSelection(props) {
				var query = _params.searchParamsManager.getQuery(),
					activeColumns = _params.searchParamsManager.getActiveColumns(),
					filteredColumns = [];

				// get columns list from search filter
				props.Columns.forEach(function(col) {
					if (col.Name in activeColumns && activeColumns[col.Name]) {
						filteredColumns.push(col);
					}
				})

				var parent = nsGmx.Utils._div(null, [['attr','id','new' + 'Vector' + 'Layer'], ['css', 'height', '100%']]),
					properties = {
						Title:  props.Title + ' ' + _gtxt('копия'),
						Copyright: props.Copyright,
						Description: props.Description,
						Date: props.Date,
						MetaProperties: props.MetaProperties,
						TilePath: {
							Path: ''
						},
						ShapePath: props.ShapePath,
						Columns: filteredColumns,
						IsRasterCatalog: props.IsRasterCatalog,
						SourceType: "file",
						Quicklook: props.Quicklook
					},
					dialogDiv = nsGmx.Utils.showDialog(_gtxt('Создать векторный слой'), parent, 340, 340, false, false),
					params = {
						copy: true,
						sourceLayerName: info.name,
						query: query,
						doneCallback: function(res) {
							nsGmx.Utils.removeDialog(dialogDiv);
						}
					};

				nsGmx.createLayerEditor(false, 'Vector', parent, properties, params);
			}
		});

    });


    this.tableFields.init(_params.attributes, info);

    this._serverDataProvider = new nsGmx.AttrTable.ServerDataProvider({titleToParams: $.extend(this.tableFields.titleToField, {'': '__GeomIsEmpty__'})});

    var squareLink = downloadSection.find('.attrs-table-square-link');

    new nsGmx.AttrTable.SquareCalc(squareLink, this.layerName, this._serverDataProvider, _params.searchParamsManager);

    var hostName = window.serverBase.match(/^https?:\/\/(.*)\/$/)[1];

    if (!_params.hideSearchParams) {
        var searchParamsManager = _params.searchParamsManager;
        searchParamsManager.render(tdParams, this);
        $(searchParamsManager).on({
            queryChange: function() {
                _this.offset = 0;
                _this._updateSearchString(searchParamsManager.getQuery());
            },
            columnsChange: function() {
                var columns = searchParamsManager.getActiveColumns ? searchParamsManager.getActiveColumns() : _this.tableFields.fieldsAsHash;
                for (var k in columns) {
                    _this.table2.activateField(k, columns[k]);
                }
            }
        });
    }

    this._updateSearchString('');

    var downloadLayer = function(format) {
        var activeColumns = searchParamsManager.getActiveColumns ? searchParamsManager.getActiveColumns() : _this.tableFields.fieldsAsHash,
            columnsForServer = [];

        for (var c in activeColumns) {
            if (activeColumns[c]) {
                columnsForServer.push({
                    Value: '[' + _this.tableFields.titleToField[c] + ']',
                    Alias: c
                });
            }
        }

        _mapHelper.downloadVectorLayer({
            name: _this.layerName,
            host: hostName,
            format: format,
            query: _params.searchParamsManager.getQuery(),
            columns: columnsForServer
        });
    };

	paramsButton.onclick = function()
	{
		oldCanvasWidth = outerSizeProvider().width;

		if (tdParams.style.display === 'none')
		{
			this.innerHTML = _gtxt('Скрыть параметры поиска');
			tdParams.style.display = '';
		}
		else
		{
			this.innerHTML = _gtxt('Показать параметры поиска');
			tdParams.style.display = 'none';
		}

		resizeFunc();
	};

   _params.hideSearchParams && $(paramsButton).hide();

	addObjectButton.onclick = function()
	{
        new nsGmx.EditObjectControl(_this.layerName);
	};

	addObjectButton.style.marginLeft = '20px';

    if (_params.hideActions) {
        $(addObjectButton).hide();
	}

	tdParams.style.display = 'none';

	var name = 'attrsTable' + info.name;

    var attrNames = this.tableFields.fieldsAsArray;
    var fielsWidth = new Array(_params.hideRowActions ? attrNames.length : attrNames.length + 1).join('0').split('0');
    var attrNamesHash = this.tableFields.fieldsAsHash;

    _params.hideDownload && downloadSection.hide();

    this.divTable2 = nsGmx.Utils._div(null, [['css', 'overflow', 'auto'], ['dir', 'className', 'attrsTableBody']]);
    var selectAllItems = nsGmx.Utils._checkbox(false, 'checkbox'),
		selectedCount = nsGmx.Utils._span([], [['attr', 'class', 'selectedCount']]),
		selectedDelete = nsGmx.Utils.makeLinkButton(_gtxt('Удалить')),
		// selectedCopy = nsGmx.Utils.makeLinkButton(_gtxt('Скопировать')),
		// selectedDownload = nsGmx.Utils.makeLinkButton(_gtxt('Скачать')),
		selectedCont = nsGmx.Utils._span([
			nsGmx.Utils._t('Выбрано объектов:'),
			selectedCount,
			selectedDelete,
			// selectedCopy,
			// selectedDownload
		], [['attr', 'class', 'hiddenCommands']]),
		groupBox = nsGmx.Utils._div([
			selectAllItems,
			nsGmx.Utils._span([nsGmx.Utils._t('Выделить все на странице')], [['css', 'marginLeft', '5px'], ['css', 'verticalAlign', 'top']]),
			selectedCont
		], [
			['attr', 'class', 'attrsSelectedCont']
		]);

	selectAllItems.onchange = function() {
		var table2 = _this.table2;
		table2.getVisibleItems().forEach(function(it) {
			var id = it.values[1];
			if (selectAllItems.checked) { _this._selected[id] = true; }
			else  { delete _this._selected[id]; }
		});
		chkSelectedCount();
		table2.repaint();
	};
	selectedCount.innerHTML = 0;
    this._selected = {};

	selectedDelete.onclick = function() {
		var remove = nsGmx.Utils.makeButton(_gtxt('Удалить'));
		remove.onclick = function() {
            var arr = Object.keys(_this._selected).reduce(function(p, c) {
                p.push({action: 'delete', id: c});
                return p;
            }, []);
			_mapHelper.modifyObjectLayer(_this.layerName, arr).done(function() {
				nsGmx.Utils.removeDialog(jDialog);
				clearSelected();
			});
		};

		var offset = $(selectedDelete).offset();
		var jDialog = nsGmx.Utils.showDialog(_gtxt('Удалить отмеченные объекты?'), nsGmx.Utils._div([remove], [['css', 'textAlign', 'center']]), 280, 75, offset.left + 20, offset.top - 30);
	};

    var tdTable2 = nsGmx.Utils._td([groupBox, this.divTable2, downloadSection[0]], [['attr', 'vAlign', 'top']]);
    this.table2 = new nsGmx.ScrollTable({pagesCount: 10, limit: 20});

	this.prevLimit = this.table2.limit;
    var chkSelectedCount = function() {
		var cnt = Object.keys(_this._selected).length;
		if (cnt) {
			L.DomUtil.removeClass(selectedCont, 'hiddenCommands');
		} else {
			L.DomUtil.addClass(selectedCont, 'hiddenCommands');
		}
		selectedCount.innerHTML = cnt;
    };
    var clearSelected = function() {
		_this._selected = {};
		chkSelectedCount();
		selectAllItems.checked = false;
    };

	var drawTableItem2 = function(elem, curIndex, activeHeaders)
    {
        var tds = [];

        if (this.limit !== _this.prevLimit) {
            _this.prevLimit = this.limit;
			clearSelected();
		}

		var id = elem.values[elem.fields[info.identityField].index],
			showButton = nsGmx.Utils.makeImageButton('img/choose.png', 'img/choose_a.png'),
            editButton = nsGmx.Utils.makeImageButton('img/edit.png'),
            deleteItem = nsGmx.Utils._checkbox(_this._selected[id], 'checkbox'),
            tdControl;

        if (info.Access !== 'edit' && info.Access !== 'editrows') {
            tdControl = nsGmx.Utils._td([nsGmx.Utils._div([showButton], [['css', 'width', '45px']])], [['css', 'width', '45px']]);
        } else {
            tdControl = nsGmx.Utils._td([nsGmx.Utils._div([deleteItem, showButton, editButton], [['css', 'width', '47px']])], [['css', 'width', '47px']]);
        }

        editButton.style.marginLeft = showButton.style.marginLeft = '5px';
        editButton.style.width = '12px';

        deleteItem.onchange = function() {
			if (deleteItem.checked) { _this._selected[id] = true; }
			else  {
				delete _this._selected[id];
				selectAllItems.checked = false;
			}
			chkSelectedCount();
        };

        editButton.onclick = function()
        {
            var id = elem.values[elem.fields[info.identityField].index];
            new nsGmx.EditObjectControl(_this.layerName, id);
        };

        showButton.onclick = function()
        {
            var id = elem.values[elem.fields[info.identityField].index];
            sendCrossDomainJSONRequest(window.serverBase + 'VectorLayer/Search.ashx?WrapStyle=func&layer=' + _this.layerName + '&page=0&pagesize=1&geometry=true&query=' + encodeURIComponent('[' + info.identityField + ']=' + id), function(response) {
                if (!window.parseResponse(response)) {
                    return;
				}

                var columnNames = response.Result.fields;
                var row = response.Result.values[0];
                for (var i = 0; i < row.length; ++i)
                {
                    if (columnNames[i] === 'geomixergeojson' && row[i])
                    {
                        var layer = nsGmx.gmxMap.layersByID[_this.layerName];

                        var fitBoundsOptions = layer ? {maxZoom: layer.options.maxZoom} : {};

                        var geom = L.gmxUtil.geometryToGeoJSON(row[i], true);
                        var bounds = L.gmxUtil.getGeometryBounds(geom);
                        nsGmx.leafletMap.fitBounds([
                            [bounds.min.y, bounds.min.x],
                            [bounds.max.y, bounds.max.x]
                        ], fitBoundsOptions);
                    }
                }
            });
        };

        nsGmx.Utils._title(deleteItem, _gtxt('Удалить'));
        nsGmx.Utils._title(editButton, _gtxt('Редактировать'));
        nsGmx.Utils._title(showButton, _gtxt('Показать'));

        $(showButton).toggle(!elem.values[elem.fields['__GeomIsEmpty__'].index]);

        if (!_params.hideRowActions) {
            tds.push(tdControl);
		}

        for (var j = 0; j < activeHeaders.length; ++j)
        {
            if (activeHeaders[j] === '') {
                continue;
			}

            var fieldName = _this.tableFields.titleToField[activeHeaders[j]];

            if (fieldName in elem.fields)
            {
                var valIndex = elem.fields[fieldName].index,
                    td = nsGmx.Utils._td();

                nsGmx.Utils._(td, [nsGmx.Utils._t(nsGmx.Utils.convertFromServer(elem.fields[fieldName].type, elem.values[valIndex]))]);

                if (elem.fields[fieldName].type === 'integer') {
                    td.style.textAlign = 'right';
				}

                tds.push(td);
            }
            else
            {
                tds.push(nsGmx.Utils._td());
            }
        }

        var tr = nsGmx.Utils._tr(tds);

        if (curIndex % 2 !== 0) {
            tr.className = 'odd';
		}

        if (_params.onClick) {
            tr.onclick = function()
            {
                _params.onClick(elem);
            };
            tr.style.cursor = 'pointer';
        }

        return tr;
    };

    var tableFields = _params.hideRowActions ? attrNames : [''].concat(attrNames);

    this.table2.setDataProvider(this._serverDataProvider);
    this.table2.createTable(this.divTable2, 'attrs', 0, tableFields, fielsWidth, drawTableItem2, $.extend(attrNamesHash, {'': true}), true);

	nsGmx.Utils._(canvas, [nsGmx.Utils._div([paramsButton, addObjectButton], [['css', 'margin', '10px 0px 10px 1px']])]);
	nsGmx.Utils._(canvas, [nsGmx.Utils._table([nsGmx.Utils._tbody([nsGmx.Utils._tr([tdParams, tdTable2])])], ['css', 'width', '100%'])]);

	var resizeFunc = function()
	{
		var dialogWidth = oldCanvasWidth || outerSizeProvider().width;

		oldCanvasWidth = false;

		canvas.childNodes[1].style.width = dialogWidth - 21 - 10 + 'px';
		tdTable2.style.width = dialogWidth - tdParams.offsetWidth - 21 - 10 + 'px';
		_this.divTable2.style.width = dialogWidth - tdParams.offsetWidth - 21 - 10 + 'px';

        var dialogHeight = outerSizeProvider().height;
		_this.divTable2.style.height = dialogHeight - canvas.firstChild.offsetHeight - 25 - 10 - 30 + 'px';

        _this.table2.updateHeight(parseInt(_this.divTable2.style.height));
        _params.searchParamsManager.resize && _params.searchParamsManager.resize({
            width: tdParams.offsetWidth,
            height: _this.divTable2.offsetHeight
        });
	};

	this.resizeFunc = resizeFunc;

	resizeFunc();

    if (this._isLayerOnMap)
    {
        this._updateVersionHandler = function() {
            _this._serverDataProvider.serverChanged();
        };

        nsGmx.gmxMap.layersByID[this.layerName].on('versionchange', this._updateVersionHandler);
    }
};

var attrsTableHash = function()
{
	this.hash = {};
    this.hooks = [];
    this._hookID = 0;
};

attrsTableHash.prototype.create = function(name, canvas, outerSizeProvider, params)
{
    params = params || {};
    this.hooks.forEach(function(hookInfo) {
        params = hookInfo.hook(params, name) || params;
    });

	if (name in this.hash)
	{
        this.hash[name].getInfo(canvas, outerSizeProvider, params);
	}
	else
	{
        var title = nsGmx.gmxMap.layersByID[name] ? nsGmx.gmxMap.layersByID[name].getGmxProperties().title : '';
        var newAttrsTable = new attrsTable(name, title);
		newAttrsTable.getInfo(canvas, outerSizeProvider, params);

		this.hash[name] = newAttrsTable;
	}

    return this.hash[name];
};

attrsTableHash.prototype.addHook = function(paramsHook) {
    var id = 'id' + this._hookID++;
    this.hooks.push({id: id, hook: paramsHook});
    return id;
};

attrsTableHash.prototype.removeHook = function(hookID) {
    for (var i = 0; i < this.hooks.length; i++) {
        if (this.hooks[i].id === hookID) {
            this.hooks.splice(i, 1);
            return;
        }
    }
};

window.nsGmx = window.nsGmx || {};

window._attrsTableHash = new attrsTableHash();

/** Менеджер поискового интерфейса таблицы атрибутов.
    Используется в таблице атрибутов для задания кастомизированного интерфейса поиска объектов слоя.
    Генерирует события queryChange и columnsChange
  @typedef IAttrTableSearchManager
  @memberOf nsGmx
  @prop {function(container, attrTable)} render Ф-ция для отрисовки кастомизированного интерфейса в контейнере. Параметры: container, attrTable
  @prop {function(): String} getQuery Получить SQL запрос за данными
  @prop {function(): Object} getActiveColumns Получить хеш с описанием активности колонок (имя колонки -> true/false)
  @prop {function(dims)} resize Ф-ция для реакции на изменения размера диалога. dims - целевые размеры контейнера (width, height)
*/

/** Показать таблицу атрибутов векторного слоя
  @func createAttributesTable
  @memberOf nsGmx
  @param {String} layerName ID слоя
  @param {DOMElement} canvas Контейнер, куда поместить таблицу атрибутов. Если не указано, будет создан новый диалог
  @param {function} outerSizeProvider Ф-ция для определения текущих размеров контейнера. Должна возвращать объект с полями width и height. Применяется только если указан canvas.
  @param {Object} params Дополнительные параметры
  @param {Boolean} [params.hideDownload=false] Скрыть секцию с вариантами скачивания данных
  @param {Boolean} [params.hideActions=false] Скрыть секцию с добавлением объекта
  @param {Boolean} [params.hideRowActions=false] Скрыть столбец таблицы с действиями над отдельными объектами
  @param {Boolean} [params.hideSearchParams=false] Скрыть секцию с параметрами поиска
  @param {function} [params.onClick] Ф-ция, которая будет вызываться при клике на строчке таблицы. Первым параметром передаётся объект, по которому кликнули
  @param {Array} [params.attributes] Массив, определяющий, какие атрибуты показывать. Каждый элемент - объект с полями "name" (исходное название атрибута) и title (как отображать в таблице).
                 Если атрибута нет в массиве, он не будет показан в таблице. Если массив не указан, показываются все атрибуты
  @param {nsGmx.IAttrTableSearchManager} [params.searchParamsManager] Менеджер UI для поиска в таблице атрибутов
  @return Интерфейс для управления таблицей атрибутов
*/

window.nsGmx.createAttributesTable = window._attrsTableHash.create.bind(window._attrsTableHash);


/** Добавить хук для изменения параметров при вызове таблицы атрибутов
  @func addAttributesTableHook
  @memberOf nsGmx
  @param {function(params, layerName):Object} paramsHook Хук, который вызывается при каждом вызове диалога редактирования.
         Первый параметр - параметры диалога (можно модифицировать), второй - ID слоя).
  @return {String} ID добавленного хука
*/
window.nsGmx.addAttributesTableHook = function(paramsHook) {
    return window._attrsTableHash.addHook(paramsHook);
};

/** Удаляет хук параметров
  @func removeAttributesTableHook
  @memberOf nsGmx
  @param {String} hookID ID хука для удаления
*/
window.nsGmx.removeAttributesTableHook = function(hookID) {
    window._attrsTableHash.removeHook(hookID);
};

})();

!(function() {

/** Провайдер данных для {@link nsGmx.ScrollTable}. Получает данные от сервера в формате ГеоМиксера
* @alias nsGmx.AttrTable.ServerDataProvider
* @class
* @extends nsGmx.ScrollTable.IDataProvider
*/
var ServerDataProvider = function(params)
{
    var _params = $.extend({
            defaultSortParam: 'ogc_fid',
            titleToParams: {}
        }, params);
    var _countURL = null,
        _dataURL = null,
        _countParams = null,
        _dataParams = null;

    var _lastCountResult;

    //IDataProvider interface
    this.getCount = function(callback)
    {
        if (!_countURL)
        {
            callback();
            return;
        }

        sendCrossDomainPostRequest(_countURL, _countParams, function(response)
        {
            if (!window.parseResponse(response))
            {
                callback();
                return;
            }
            _lastCountResult = response.Result;
            callback(response.Result);
        });
    };

    this.getItems = function(page, pageSize, sortParam, sortDec, callback)
    {
        if (!_dataURL)
        {
            callback();
            return;
        }

        var explicitSortParam = (sortParam || sortParam === '') ? (_params.titleToParams[sortParam] || sortParam) : _params.defaultSortParam;

        var params = $.extend({
            page: page,
            pagesize: pageSize,
            orderby: explicitSortParam,
            orderdirection: sortDec ? 'DESC' : 'ASC'
        }, _dataParams);

        sendCrossDomainPostRequest(_dataURL, params, function(response)
        {
            if (!window.parseResponse(response))
            {
                callback();
                return;
            }

            var fieldsSet = {};

            if (response.Result.fields)
            {
                for (var f = 0; f < response.Result.fields.length; f++) {
                    fieldsSet[response.Result.fields[f]] = {index: f, type: response.Result.types[f]};
				}
            }

            var res = [];
            for (var i = 0; i < response.Result.values.length; i++) {
                res.push({
                    fields: fieldsSet,
                    values: response.Result.values[i]
                });
			}

            callback(res);
        });
    };

    /** Задать endpoint для получения от сервера данных об объекта и их количестве
     * @param {String} countURL URL скрипта для запроса общего количества объектов
     * @param {Object} countParams Параметры запроса для количеством объектов
     * @param {String} dataURL URL скрипта для запроса самих объектов
     * @param {Object} dataParams Параметры запроса самих объектов. К этим параметрам будут добавлены параметры для текущей страницы в формате запросов ГеоМиксера
    */
    this.setRequests = function(countURL, countParams, dataURL, dataParams)
    {
        _countURL = countURL;
        _countParams = countParams || {};
        _countParams.WrapStyle = 'message';

        _dataURL = dataURL;
        _dataParams = dataParams || {};
        _dataParams.WrapStyle = 'message';

        $(this).change();
    };

    this.serverChanged = function()
    {
        $(this).change();
    };

    this.getLastCountResult = function() {
        return _lastCountResult;
    };
};

window.nsGmx.AttrTable.ServerDataProvider = ServerDataProvider;

})();

!(function() {

var template = Handlebars.compile('<div class="attrs-table-square-popover">' +
    '<div class="attrs-table-square-toomuch">Слишком много объектов</div>' +
    '<div class="attrs-table-square-process">Подсчитываем...</div>' +
    '<div class="attrs-table-square-result">Площадь: ' +
        '<span class="attrs-table-square"></span>' +
    '</div>' +
'</div>');

nsGmx.AttrTable.SquareCalc = function(container, layerName, dataProvider, searchParamsManager) {
    var popoverUI = $(template());

    popoverUI.find('.attrs-table-square-toomuch').hide();
    popoverUI.find('.attrs-table-square-result').hide();

    $(container).popover({
        content: popoverUI[0],
        placement: 'left',
        html: true
    });

    $(container).on('shown.bs.popover', function() {
        if (dataProvider.getLastCountResult() > 10000) {
            popoverUI.find('.attrs-table-square-toomuch').show();
            popoverUI.find('.attrs-table-square-process').hide();
            popoverUI.find('.attrs-table-square-result').hide();
            return;
        } else {
            popoverUI.find('.attrs-table-square-toomuch').hide();
            popoverUI.find('.attrs-table-square-process').show();
            popoverUI.find('.attrs-table-square-result').hide();
        }

        sendCrossDomainPostRequest(window.serverBase + 'VectorLayer/Search.ashx', {
            layer: layerName,
            query: searchParamsManager.getQuery(),
            columns: '[{value: "[GeomixerGeoJson]"}]',
            WrapStyle: 'message'
        }, function(response) {
            if (!window.parseResponse(response)) {
                return;
            }

            popoverUI.find('.attrs-table-square-process').hide();
            popoverUI.find('.attrs-table-square-result').show();

            var items = response.Result.values;
            var totalSquare = 0;
            for (var g = 0; g < items.length; g++) {
                totalSquare += L.gmxUtil.geoArea(items[g][0]);
            }

            popoverUI.find('.attrs-table-square').text(L.gmxUtil.prettifyArea(totalSquare));
        });
    });
};

})();

!(function() {

// events: queryChange, columnsChange
var DefaultSearchParamsManager = function() {
    this._activeColumns = null;
    this._queryTextarea = null;
    this._container = null;
};

/*var template = Handlebars.compile('<div>' +
    '<div>' +
        '<div class="attr-table-query-title">{{i "SQL-условие WHERE"}}</div>' +
        '<textarea class="inputStyle attr-table-query"></textarea>' +
        '<table class="attr-table-query-suggest"></table>' +
    '</div>' +
    '<div class="attr-table-fields-header">{{i "Показывать столбцы"}}:</div>' +
    '<div class="attr-table-columns-container">' +
    '</div>' +
    '<div class="attr-table-params-buttons">' +
        '<input class="btn attr-table-params-clear" type="submit" value="{{i "Очистить поиск"}}">' +
        '<input class="btn attr-table-params-find" type="submit" value="{{i "Найти"}}">' +
    '</div>' +
'</div>');*/

DefaultSearchParamsManager.prototype.render = function(container, attributesTable) {
    var info = attributesTable.getLayerInfo(),
        paramsWidth = 300,
        searchButton = makeButton(_gtxt('Найти')),
        cleanButton = makeButton(_gtxt('Очистить поиск')),
        _this = this;

    var columnsList = this._columnsList = nsGmx.Utils._div(null, [['dir', 'className', 'attrsColumnsList'], ['css', 'overflowY', 'auto'], ['css', 'width', paramsWidth - 21 + 'px']]);

    this._container = container;

    searchButton.onclick = function()
    {
        $(_this).trigger('queryChange');
    };

    cleanButton.onclick = function()
    {
        _this._queryTextarea.value = '';
        _this._geometryInfoRow && _this._geometryInfoRow.RemoveRow();
        _this._geometryInfoRow = null;

        $(_this).trigger('queryChange');
    };

    this._queryTextarea = nsGmx.Utils._textarea(null, [['dir', 'className', 'inputStyle'], ['css', 'overflow', 'auto'], ['css', 'width', '280px'], ['css', 'height', '70px']]);

    var attrNames = [info.identityField].concat(info.attributes);
    var attrHash = {};
    for (var a = 0; a < attrNames.length; a++) {
        attrHash[attrNames[a]] = [];
	}

    var attrProvider = new nsGmx.LazyAttributeValuesProviderFromServer(attrHash, info.name);

    var attrSuggestWidget = new nsGmx.AttrSuggestWidget(this._queryTextarea, attrNames, attrProvider);

    var suggestCanvas = attrSuggestWidget.el[0];

    this._geometryInfoRow = null;

    var geomUI = $(Handlebars.compile('<span>' +
        '<span class="attr-table-geomtitle">{{i "Искать внутри полигона"}}</span>' +
        '<span class="gmx-icon-choose"></span>' +
        '<span class="attr-table-geom-placeholder"></span>' +
    '</span>')());

    geomUI.find('.gmx-icon-choose').click(function() {
        nsGmx.Controls.chooseDrawingBorderDialog(
            'attrTable',
            function(drawingObject) {
                _this._geometryInfoRow && _this._geometryInfoRow.RemoveRow();
                var InfoRow = gmxCore.getModule('DrawingObjects').DrawingObjectInfoRow;
                _this._geometryInfoRow = new InfoRow(
                    nsGmx.leafletMap,
                    geomUI.find('.attr-table-geom-placeholder')[0],
                    drawingObject,
                    {
                        editStyle: false,
                        allowDelete: true
                    }
                );

                $(_this._geometryInfoRow).on('onRemove', function() {
                    _this._geometryInfoRow && _this._geometryInfoRow.RemoveRow();
                    _this._geometryInfoRow = null;
                });
            },
            {geomType: 'POLYGON'}
        );
    });

    $(container).append(geomUI);

    nsGmx.Utils._(container, [nsGmx.Utils._div([nsGmx.Utils._div([nsGmx.Utils._t(_gtxt('SQL-условие WHERE'))], [['css', 'fontSize', '12px'], ['css', 'margin', '7px 0px 3px 1px']]), this._queryTextarea, suggestCanvas], [['dir', 'className', 'attr-query-container'], ['attr', 'filterTable', true]])]);

    nsGmx.Utils._(container, [nsGmx.Utils._div([nsGmx.Utils._t(_gtxt('Показывать столбцы') + ':')], [['css', 'fontSize', '12px'], ['css', 'margin', '7px 0px 3px 1px']])]);

    var attrTitles = attributesTable.tableFields.fieldsAsArray;
    if (!this._activeColumns)
    {
        this._activeColumns = {};

        for (var i = 0; i < attrTitles.length; ++i) {
            this._activeColumns[attrTitles[i]] = true;
		}
    }

    var rowTemplate =
        '<label title="{{name}}" class="attrs-table-active-row">' +
            '<input type="checkbox" class="box attrs-table-active-checkbox" {{#active}}checked{{/active}}></input>' +
            '{{name}}' +
        '</label>';

    attrTitles.forEach(function(columnName) {
        var rowUI = $(Handlebars.compile(rowTemplate)({
            active: _this._activeColumns[columnName],
            name: columnName
        })).appendTo(columnsList);

        $('input', rowUI).click(function() {
            _this._activeColumns[columnName] = this.checked;
            $(_this).trigger('columnsChange');
        });
    });

    nsGmx.Utils._(container, [columnsList]);

    searchButton.style.marginRight = '17px';
    cleanButton.style.marginRight = '3px';
    nsGmx.Utils._(container, [nsGmx.Utils._div([cleanButton, searchButton], [['css', 'textAlign', 'right'], ['css', 'margin', '5px 0px 0px 0px'], ['css', 'width', paramsWidth + 'px']])]);
};

DefaultSearchParamsManager.prototype.getQuery = function() {
    var query = this._queryTextarea && this._queryTextarea.value,
        drawingObject = this._geometryInfoRow && this._geometryInfoRow.getDrawingObject(),
        geom = drawingObject && drawingObject.toGeoJSON().geometry,
        geomStr = geom ? 'intersects([geomixergeojson], GeometryFromGeoJson(\'' + JSON.stringify(geom) + '\', 4326))' : '',
        resQuery = (query && geomStr) ? '(' + query + ') AND ' + geomStr : (query || geomStr);

    return resQuery;
};

DefaultSearchParamsManager.prototype.getActiveColumns = function() {
    return this._activeColumns;
};

DefaultSearchParamsManager.prototype.resize = function(dims) {
    if (this._columnsList) {
        var container = this._container,
            height = dims.height - container.childNodes[0].offsetHeight - container.childNodes[1].offsetHeight - 25 + 'px';
        $(this._container).find('.attrsColumnsList')[0].style.height = height;
    }
};

nsGmx.AttrTable.DefaultSearchParamsManager = DefaultSearchParamsManager;

})();

var nsGmx = nsGmx || {};

(function() {
    window._translationsHash.addtext('rus', {
        gridPlugin: {
            gridSettings: 'Настройка координатной сетки',
            gridColorSettings: 'цвет',
            gridStepSettings: 'шаг',
            gridUnitsSettings: 'единицы',
            gridFormatSettings: 'формат вывода',
            set : 'установить',
            reset : 'сбросить',
            unitsKilometers : 'км',
            unitsDegrees : 'градусы',
            formatDecimal : 'десятичные градусы',
            formatDM : 'градусы, минуты',
            formatDMS : 'градусы, минуты, секунды',
            latitude : 'по широте',
            longitude : 'по долготе'
        }
    });
    window._translationsHash.addtext('eng', {
        gridPlugin: {
            gridSettings : 'Coordinate grid settings',
            gridColorSettings : 'color',
            gridStepSettings : 'step',
            gridUnitsSettings: 'units',
            gridFormatSettings: 'format',
            set : 'set',
            reset : 'reset',
            unitsKilometers : 'km',
            unitsDegrees : 'degrees',
            formatDecimal: 'decimal degrees',
            formatDM: 'degrees minutes',
            formatDMS : 'degrees minutes seconds',
            latitude : 'latitude',
            longitude: 'longitude'
        }
    });

    // создает левое меню с параметрами координатной сетки
    var ConfigureGridMenu = function (manager) {
        var control = manager.gridControl,
            tempStyle = {
                outline: {
                    color: control.options.color
                }
            },
            lm = new window.leftMenu();

        // заполняем левое меню
        function createGridLeftMenu() {
            var gridConfigLeftMenu = nsGmx.Utils._div(null, [['dir','className','gridConfigLeftMenu']]);
            createGridConfig(gridConfigLeftMenu);

            return gridConfigLeftMenu;
        }

        // создание элементов отображения настроек сетки
        function createGridConfig(menu) {
            var gridConfigCanvas = nsGmx.Utils._div(null, [['dir','className','gridSettings']]),
                gridConfigTitle = nsGmx.Utils._span(null, [['dir','className','gridSettingsTitle']]),
                gridConfigIcon = CreateGridConfigIcon(tempStyle, 'linestring');

            $(gridConfigIcon).find('.borderIcon')[0].style.borderColor = tempStyle.outline.color;
            $(gridConfigTitle).append(window._gtxt('gridPlugin.gridSettings'));
            $(gridConfigCanvas).append(gridConfigIcon, gridConfigTitle);
            $(menu).append(gridConfigCanvas);

            gridConfigIcon.onclick = function () {
                createConfigDialog(this);
            };
        }

        // диалоговое окно для редактирования координатной сетки
        function createConfigDialog(elem) {
            if (manager.configDialog) {
                return;
            }
            var map = nsGmx.leafletMap,
                gridConfigEditor = nsGmx.Utils._div(null, [['dir','className','gridConfigEditor']]);

            // редактирование цвета сетки - колорпикер
            var fcp = nsGmx.Controls.createColorPicker(tempStyle.outline.color,
                function (colpkr) {
                    $(colpkr).fadeIn(500);
                    return false;
                },
                function (colpkr) {
                    $(colpkr).fadeOut(500);
                    $(this).change();
                    return false;
                },
                function (hsb, hex) {
                    tempStyle.outline.color = '#' + hex;
                    fcp.style.backgroundColor = tempStyle.outline.color;
                    control.setColor(tempStyle.outline.color);
                    $(elem).find('.borderIcon')[0].style.borderColor = tempStyle.outline.color;
                    manager.saveOptions();
                    $(this).ColorPickerSetColor(tempStyle.outline.color);
                    $(this).change();
                }
            );

            $(fcp).ColorPickerSetColor(tempStyle.outline.color);
            $(fcp).css('background-color', tempStyle.outline.color);

            // редактирования шага сетки
            var gridStepYInputPanel = nsGmx.Utils._span(null, [['dir','className','gridStepConfig']]),
                gridStepXInputPanel = nsGmx.Utils._span(null, [['dir','className','gridStepConfig']]),
                gridStepYInput = nsGmx.Utils._input(null, [['dir','className','gridStepInput']]),
                gridStepXInput = nsGmx.Utils._input(null, [['dir','className','gridStepInput']]),
                gridUnitsConfig = nsGmx.Utils._span(null, [['dir','className','gridStepConfig']]),
                gridStepConfig = nsGmx.Utils._span(null, [['dir','className','gridStepConfig']]),
                gridFormatConfig = nsGmx.Utils._span(null, [['dir','className','gridFormatConfig']]),
                gridStepUnitsDegrees = nsGmx.Utils._input(null, [
                    ['dir','id','gridStepUnitsDegrees'],
                    ['attr', 'type', 'radio'],
                    ['attr', 'id', 'gridStepUnitsDegrees'],
                    ['attr', 'name', 'gridStepUnits'],
                    ['attr', 'value', 'degrees']
                ]),
                gridStepUnitsKilometers = nsGmx.Utils._input(null, [
                    ['dir','id','gridStepUnitsKilometers'],
                    ['attr', 'type', 'radio'],
                    ['attr', 'name', 'gridStepUnits'],
                    ['attr', 'value', 'kilometers']
                ]),
                gridFormatDD = nsGmx.Utils._input(null, [
                    ['dir','id','gridFormatDD'],
                    ['attr', 'type', 'radio'],
                    ['attr', 'name', 'gridFormat'],
                    ['attr', 'value', 0],
                    control.options.units === 'kilometers' ? ['attr', 'disabled', true] : []
                ]),
                gridFormatDM = nsGmx.Utils._input(null, [
                    ['dir','id','gridFormatDM'],
                    ['attr', 'type', 'radio'],
                    ['attr', 'name', 'gridFormat'],
                    ['attr', 'value', 1],
                    control.options.units === 'kilometers' ? ['attr', 'disabled', true] : []
                ]),
                gridFormatDMS = nsGmx.Utils._input(null, [
                    ['dir','id','gridFormatDMS'],
                    ['attr', 'type', 'radio'],
                    ['attr', 'name', 'gridFormat'],
                    ['attr', 'value', 2],
                    control.options.units === 'kilometers' ? ['attr', 'disabled', true] : []
                ]),
                gridSetStepButton = nsGmx.Utils._button([nsGmx.Utils._t(window._gtxt('gridPlugin.set'))], [['dir', 'className', 'gridStepButton']]),
                gridResetStepButton = nsGmx.Utils._button([nsGmx.Utils._t(window._gtxt('gridPlugin.reset'))], [['dir', 'className', 'gridStepButton']]);

            $(gridStepYInputPanel).append(
                gridStepYInput,
                nsGmx.Utils._t(window._gtxt('gridPlugin.latitude'))
            );

            $(gridStepXInputPanel).append(
                gridStepXInput,
                nsGmx.Utils._t(window._gtxt('gridPlugin.longitude'))
            );

            $(gridUnitsConfig).append(
              nsGmx.Utils._label(
                  [gridStepUnitsDegrees, nsGmx.Utils._t(window._gtxt('gridPlugin.unitsDegrees'))],
                  [['dir', 'className', 'gridUnitsLabel'], ['attr', 'for', 'gridStepUnitsDegrees']]

              ),
              nsGmx.Utils._label(
                  [gridStepUnitsKilometers, nsGmx.Utils._t(window._gtxt('gridPlugin.unitsKilometers'))],
                  [['dir', 'className', 'gridUnitsLabel'], ['attr', 'for', 'gridStepUnitsKilometers']]
              )
            );

            $(gridFormatConfig).append(
                nsGmx.Utils._label(
                    [gridFormatDD, nsGmx.Utils._t(window._gtxt('gridPlugin.formatDecimal'))],
                    [
                        ['dir', 'className', control.options.units === 'kilometers' ? 'gridFormatLabel disabledLabel' : 'gridFormatLabel'],
                        ['attr', 'for', 'gridFormatDD']
                    ]
                ),
                $('<br></br>'),
                nsGmx.Utils._label(
                    [gridFormatDM, nsGmx.Utils._t(window._gtxt('gridPlugin.formatDM'))],
                    [
                        ['dir', 'className', control.options.units === 'kilometers' ? 'gridFormatLabel disabledLabel' : 'gridFormatLabel'],
                        ['attr', 'for', 'gridFormatDM']
                    ]
                ),
                $('<br></br>'),
                nsGmx.Utils._label(
                    [gridFormatDMS, nsGmx.Utils._t(window._gtxt('gridPlugin.formatDMS'))],
                    [
                        ['dir', 'className', control.options.units === 'kilometers' ? 'gridFormatLabel disabledLabel' : 'gridFormatLabel'],
                        ['attr', 'for', 'gridFormatDMS']
                    ]
                )
            );

            $(gridStepConfig).append(
                gridSetStepButton,
                gridResetStepButton
            );

            $(gridConfigEditor).append(nsGmx.Utils._table([
                nsGmx.Utils._tbody([
                    nsGmx.Utils._tr([
                        nsGmx.Utils._td([nsGmx.Utils._t(window._gtxt('gridPlugin.gridColorSettings'))], [['css','width','70px']]),
                        nsGmx.Utils._td([fcp])
                    ]),
                    nsGmx.Utils._tr(
                        null, [['dir', 'className', 'bigEmptyTableRow']]
                    ),
                    nsGmx.Utils._tr([
                        nsGmx.Utils._td([nsGmx.Utils._t(window._gtxt('gridPlugin.gridStepSettings'))], [['attr', 'rowspan', '2'], ['css','width','70px']]),
                        nsGmx.Utils._td([gridStepYInputPanel])
                    ]),
                    nsGmx.Utils._tr([
                        nsGmx.Utils._td([gridStepXInputPanel])
                    ]),
                    nsGmx.Utils._tr(
                      null, [['dir', 'className', 'bigEmptyTableRow']]
                    ),
                    nsGmx.Utils._tr([
                        nsGmx.Utils._td([nsGmx.Utils._t(window._gtxt('gridPlugin.gridUnitsSettings'))], [['css','width','70px']]),
                        nsGmx.Utils._td([gridUnitsConfig])
                    ]),
                    nsGmx.Utils._tr(
                        null, [['dir', 'className', 'bigEmptyTableRow']]
                    ),
                    nsGmx.Utils._tr([
                        nsGmx.Utils._td([nsGmx.Utils._t(window._gtxt('gridPlugin.gridFormatSettings'))], [
                            ['css','width','70px'], ['css', 'vertical-align', 'middle']]),
                        nsGmx.Utils._td([gridFormatConfig])
                    ]),
                    nsGmx.Utils._tr(
                      null, [['dir', 'className', 'bigEmptyTableRow']]
                    ),
                    nsGmx.Utils._tr([
                        nsGmx.Utils._td(null, [['css','width','70px']]),
                        nsGmx.Utils._td([gridStepConfig])
                    ])
                ])
            ], [['dir', 'className', 'gridConfigTable']]));

            if (control.options.units === 'degrees') {
                gridStepUnitsDegrees.checked = true;
                enableFormats();
            } else if (control.options.units === 'kilometers') {
                gridStepUnitsKilometers.checked = true;
                disableFormats();
            }

            gridStepUnitsDegrees.onclick = handleUnits;
            gridStepUnitsKilometers.onclick = handleUnits;

            gridFormatDD.onclick = handleFormats;
            gridFormatDM.onclick = handleFormats;
            gridFormatDMS.onclick = handleFormats;

            gridSetStepButton.onclick = function () {
                control.setStep(gridStepXInput.value, gridStepYInput.value);
                updateInputsValues();
            };

            gridResetStepButton.onclick = function () {
                control.setTitleFormat(0);
                control.clearStep();
                enableFormats();
                gridStepUnitsDegrees.checked = true;
                gridFormatDD.checked = true;
                updateInputsValues();
            };

            gridStepUnitsDegrees.checked = true;
            gridFormatDD.checked = true;
            updateInputsValues();
            handleFormats();

            map.on('zoomend', function () {
                control.repaint();
                updateInputsValues();
            });

            var pos = nsGmx.Utils.getDialogPos(elem, false, 0);

            var closeFunc = function () {
                $(gridConfigEditor).find('.colorSelector').each(function() {
                    $('#' + $(this).data('colorpickerId')).remove();
                });
                manager.configDialog = null;
                control.options.units  === 'degrees' ? enableFormats() : disableFormats();

                // control.clearStep();
            };

            var params = {
                width: 280,
                height: 280,
                posX: pos.left,
                posY: pos.top,
                resizeFunc: false,
                closeFunc: closeFunc
            };

            manager.configDialog = nsGmx.Utils.showDialog(window._gtxt('gridPlugin.gridSettings'), gridConfigEditor, params);

            function updateInputsValues() {
                gridStepXInput.value = control.options.customStep.x ? Math.round(control.options.customStep.x * 100) / 100 : control.options.defaultStep.x;
                gridStepYInput.value = control.options.customStep.y ? Math.round(control.options.customStep.y * 100) / 100 : control.options.defaultStep.y;
            }

            function handleUnits() {
                var value = this.value;
                if (control.options.units !== value) {
                    control.setUnits(value);
                }
                value === 'degrees' ? enableFormats() : disableFormats();
                        updateInputsValues();
            }

            function handleFormats() {
                var value = this.value;
                if (control.options.titleFormat !== value) {
                    control.setTitleFormat(value);
                }
            }

            function disableFormats() {
                $('#gridFormatDD').prop('disabled', true);
                $('#gridFormatDM').prop('disabled', true);
                $('#gridFormatDMS').prop('disabled', true);

                $('.gridFormatLabel').addClass('disabledLabel');
            }

            function enableFormats() {
                $('#gridFormatDD').prop('disabled', false);
                $('#gridFormatDM').prop('disabled', false);
                $('#gridFormatDMS').prop('disabled', false);

                $('.gridFormatLabel').removeClass('disabledLabel');
            }
        }

        // создание иконки редактирования стиля
        function CreateGridConfigIcon(style, type) {
            var icon = nsGmx.Controls.createGeometryIcon(style, type);
            nsGmx.Utils._title(icon, window._gtxt('gridPlugin.gridSettings'));
            return icon;
        }

        this.Load = function () {
            if (lm != null){
                var alreadyLoaded = lm.createWorkCanvas('mapGrid', function () {
                    if (manager.state) {
                        manager.setState({isActive: false});
                    } else {
                        this.Unload();
                    }
                });
                if (!alreadyLoaded) {
                    $(lm.workCanvas).append(createGridLeftMenu());
                    control.setColor(tempStyle.outline.color);
                    manager.saveOptions();
                }
            }
        }
        this.Unload = function () {
            $(manager.configDialog).remove();
            manager.configDialog = null;
            $(lm.parentWorkCanvas).hide();
        };
    }

    var publicInterface = {
        pluginName: 'GridPlugin',
        ConfigureGridMenu: ConfigureGridMenu
  };

    window.gmxCore.addModule('GridPlugin',
        publicInterface
    );
})();

var nsGmx = window.nsGmx || {};

(function() {

    var MAX_SIZE = 10000;

    // мы не хотим, чтобы рамка фигурировала в списке пользовательских объектов
    nsGmx.DrawingObjectCustomControllers.addDelegate({
        isHidden: function(obj) {
            if (obj.options.exportRect) {
                return true;
            }
            return false;
        }
    });

    window._translationsHash.addtext('rus', {
        mapExport: {
            settings: {
                settings: 'Настройки экспорта карты:',
                zoom: 'масштаб (зум)',
                size: 'размер',
                format: 'формат растра',
                fileType: 'тип файла',
                width: 'ширина (пк)',
                height: 'высота (пк)',
                name: 'имя файла'
            },
            formats: {
                jpeg: 'JPEG',
                png: 'PNG'
            },
            filetypes: {
                raster: 'растр',
                mbTiles: 'MBTiles',
                kmz: 'kmz'
            },
            select: 'Выделить область карты',
            unselect: 'Снять выделение',
            zoomToBox: 'Перейти к выделенному',
            zoomToLevel: 'Перейти на зум',
            exportMap: 'Экспорт',
            cancel: 'Отмена',
            sizeWarn: 'максимальный размер - 10000 пикселей',
            valueWarn: 'недопустимое значение',
            inQueue: 'в очереди',
            inProcess: 'файл формируется',
            exportError: 'ошибка экспорта'
        }
    });
    window._translationsHash.addtext('eng', {
        mapExport: {
            exportTooltip: 'Select area',
            settings: {
                settings: 'Map export settings:',
                zoom: 'zoom',
                size: 'size',
                format: 'raster format',
                fileType: 'file type',
                width: 'width (px)',
                height: 'height (px)',
                name: 'file name'
            },
            formats: {
                jpeg: 'JPEG',
                png: 'PNG'
            },
            filetypes: {
                raster: 'raster',
                mbTiles: 'MBTiles',
                kmz: 'kmz'
            },
            select: 'Select',
            unselect: 'Clear selection',
            zoomToBox: 'Zoom to selected',
            zoomToLevel: 'Zoom to level',
            exportMap: 'Export',
            cancel: 'Cancel',
            sizeWarn: 'incorrect size',
            valueWarn: 'incorrect value',
            inQueue: 'waiting',
            inProcess: 'processing file',
            exportError: 'export error'
        }
    });

    var formatTypes = [
        'jpeg',
        'png'
    ];

    var view;

    var MapExportMenu = function () {
        var canvas = nsGmx.Utils._div(null, [['dir','className','mapExportConfigLeftMenu']]);

        var ExportModel = window.Backbone.Model.extend({
            defaults: {
                lm: new window.leftMenu(),
                lmap: nsGmx.leafletMap,
                selArea: null,
                exportMode: true,
                width: 0,
                height: 0,
                widthValueErr: false,
                heightValueErr: false,
                widthSizeErr: false,
                heightSizeErr: false,
                format: null,
                fileType: null,
                x: null,
                y: null,
                z: null,
                latLng: null,
                coords: null,
                zoomLevels: getZoomLevels(),
                formatTypes: getTypes(formatTypes),
                fileTypes: null,
                name: '',
                taskInfo: null,
                exportErr: false
            }
        });

        var model = new ExportModel();

        var ExportView = window.Backbone.View.extend({
            el: $(canvas),
            model: model,
            template: window.Handlebars.compile(
                '<div class="selectButtons">' +
                        '<span class="buttonLink areaButton mapExportSelectButton"> {{i "mapExport.select"}}</span>' +
                        '<span class="zoomToBoxButton" style="display:none">' +
                        '</span>' +
                '</div>' +
                '<div class="exportSettings">' +
                    '<span>' +
                        '{{i "mapExport.settings.settings"}}' +
                    '</span>' +
                '</div>' +
                '<table class="settings">' +
                    '<tbody>' +
                        '<tr class="zoomSelect">' +
                            '<td class="eLabel">{{i "mapExport.settings.zoom"}}</td>' +
                            '<td class="eInput">' +
                                '<select class="zoomLevel">' +
                                    '{{#each this.zoomLevels}}' +
                                    '<option value="{{this.zoom}}"' +
                                        '{{#if this.current}} selected="selected"{{/if}}>' +
                                        '{{this.zoom}}' +
                                    '</option>' +
                                    '{{/each}}' +
                                '</select>' +
                            '</td>' +
                            '<td class="zoomToLevel">' +
                                '<span class="zoomToLevelButtonWrap" style="display:none">' +
                                '</span>' +
                            '</td>' +
                        '</tr>' +
                        '<tr class="dims">' +
                            '<td class="eLabel">{{i "mapExport.settings.width"}}</td>' +
                            '<td class="eInput">' +
                                '<input type="text" class="mapExportWidth" value="{{width}}"/>' +
                            '</td>' +
                            '<td class="mapExportWarn" rowspan=2></td>' +
                        '</tr>' +
                        '<tr class="dims">' +
                            '<td class="eLabel">{{i "mapExport.settings.height"}}</td>' +
                            '<td class="eInput">' +
                                '<input type="text" class="mapExportHeight" value="{{height}}"/>' +
                            '</td>' +
                        '</tr>' +
                        '<tr class="formatSelect">' +
                            '<td class="eLabel">{{i "mapExport.settings.format"}}</td>' +
                            '<td class="eInput">' +
                                '<select class="formatTypes">' +
                                    '{{#each this.formatTypes}}' +
                                    '<option value="{{this.type}}"' +
                                        '{{#if this.current}} selected="selected" {{/if}}>' +
                                        '{{this.type}}' +
                                    '</option>' +
                                    '{{/each}}' +
                                '</select>' +
                            '</td>' +
                        '</tr>' +
                        '<tr class="typeSelect">' +
                            '<td class="eLabel">{{i "mapExport.settings.fileType"}}</td>' +
                            '<td class="eInput">' +
                                '<select class="fileTypes">' +
                                    '{{#each this.fileTypes}}' +
                                    '<option value="{{this.type}}"' +
                                        '{{#if this.current}} selected="selected" {{/if}}>' +
                                        '{{this.type}}' +
                                    '</option>' +
                                    '{{/each}}' +
                                '</select>' +
                            '</td>' +
                        '</tr>' +
                        '<tr class="nameSelect">' +
                            '<td class="eLabel">{{i "mapExport.settings.name"}}</td>' +
                            '<td class="eInput">' +
                                '<input type="text" class="mapExportName" value=""/>' +
                            '</td>' +
                        '</tr>' +
                    '</tbody>' +
                '</table>' +
                '<div class="exportWrap">' +
                    '<div class="export">' +
                        '<span class="buttonLink mapExportButton"> {{i "mapExport.exportMap"}}</span>' +
                        '<span class="buttonLink cancelButton" style="display:none"> {{i "mapExport.cancel"}}</span>' +
                        '<span class="spinHolder" style="display:none">' +
                            // '<img src="img/progress.gif"/>' +
                            '<span class="spinMessage"></span>' +
                            '</span>' +
                        '<span class="exportErrorMessage" style="display:none">{{i "mapExport.exportError"}}</span>' +
                    '</div>' +
                    '<div class="export-progress-container" style="display:none">' +
                        '<div class="export-progressbar"></div>' +
                    '</div>' +
                '</div>'
            ),
            events: {
                'click .mapExportSelectButton': 'selectArea',
                'click .mapExportUnselectButton': 'unselectArea',
                'click .zoomToBoxButton': 'zoomToBox',
                'click .zoomToLevelButtonWrap': 'zoomToLevel',
                'input .mapExportWidth': 'resize',
                'input .mapExportHeight': 'resize',
                'change .zoomLevel': 'setZoom',
                'change .formatTypes': 'setFormat',
                'change .fileTypes': 'setFileType',
                'input .mapExportName': 'setName',
                'click .mapExportButton': 'exportMap',
                'click .cancelButton': 'cancelExport'
            },

            initialize: function () {
                var attrs = this.model.toJSON(),
                    currentZoom = attrs.lmap.getZoom(),
                    zoomLevels = attrs.zoomLevels,
                    formatTypes = attrs.formatTypes,

                    // объявление типов файлов происходит здесь, так как необходима обработка смены языка
                    // типы файлов хранятся в текущем языке
                    fileTypes = [
                        window._gtxt('mapExport.filetypes.raster'),
                        window._gtxt('mapExport.filetypes.mbTiles'),
                        window._gtxt('mapExport.filetypes.kmz')
                    ];
                    updatedFileTypes = getTypes(fileTypes);

                this.listenTo(this.model, 'change:selArea', this.updateArea);
                this.listenTo(this.model, 'change:width', this.updateSize);
                this.listenTo(this.model, 'change:height', this.updateSize);
                this.listenTo(this.model, 'change:widthValueErr', this.handleValueError);
                this.listenTo(this.model, 'change:heightValueErr', this.handleValueError);
                this.listenTo(this.model, 'change:widthSizeErr', this.handleSizeError);
                this.listenTo(this.model, 'change:heightSizeErr', this.handleSizeError);
                this.listenTo(this.model, 'change:name', this.updateName);
                this.listenTo(this.model, 'change:z', this.updateZoom);
                this.listenTo(this.model, 'change:exportErr', this.handleExportError);

                for (var i = attrs.lmap.getMinZoom(); i < zoomLevels.length; i++) {
                    zoomLevels[i].current = false;

                    if (i === currentZoom) {
                        zoomLevels[i].current = true;
                    }
                }

                for (var j = 0; j < formatTypes.length; j++) {
                    if (formatTypes[j].current === true) {
                        this.model.set('format', formatTypes[j].type);
                    }
                }

                for (var j = 0; j < updatedFileTypes.length; j++) {
                    if (updatedFileTypes[j].current === true) {
                        this.model.set('fileType', updatedFileTypes[j].type);
                    }
                }

                this.model.set({
                    z: currentZoom,
                    zoomLevels: zoomLevels,
                    formatTypes: formatTypes,
                    fileTypes: updatedFileTypes,
                    name: nsGmx.gmxMap.properties.title
                });

                this.updateArea();

                this.render();
            },

            render: function () {
                var zoomToBoxButton,
                    zoomToLevelButton;

                this.$el.html(this.template(this.model.toJSON()));
                this.$('.zoomLevel').prop('disabled', true)
                this.$('.mapExportWidth').prop('disabled', true);
                this.$('.mapExportHeight').prop('disabled', true);
                this.$('.formatTypes').prop('disabled', true);
                this.$('.fileTypes').prop('disabled', true);
                this.$('.mapExportName').val(this.model.get('name'));
                this.$('.mapExportName').prop('disabled', true);
                this.$('.mapExportButton').addClass('gmx-disabled');

                zoomToBoxButton = nsGmx.Utils.makeImageButton('img/zoom_to_box_tool_small.png', 'img/zoom_to_box_tool_small.png');
                nsGmx.Utils._title(zoomToBoxButton, window._gtxt('mapExport.zoomToBox'));

                this.$('.zoomToBoxButton').append(zoomToBoxButton);

                zoomToLevelButton = nsGmx.Utils.makeImageButton('img/zoom_to_level_tool_small.png', 'img/zoom_to_level_tool_small.png');
                $(zoomToLevelButton).addClass('zoomToLevelButton');
                nsGmx.Utils._title(zoomToLevelButton, (window._gtxt('mapExport.zoomToLevel') + ' ' + this.model.get('z')));

                this.$('.zoomToLevelButtonWrap').append(zoomToLevelButton);

                return this;
            },

            updateArea: function () {
                var attrs = this.model.toJSON(),
                    areaButton = this.$('.areaButton'),
                    zoomToBoxButton = this.$('.zoomToBoxButton'),
                    zoomToLevelButton = this.$('.zoomToLevelButtonWrap'),
                    zoomSelect = this.$('.zoomLevel'),
                    widthInput = this.$('.mapExportWidth'),
                    heightInput = this.$('.mapExportHeight'),
                    formatSelect = this.$('.formatTypes'),
                    fileSelect = this.$('.fileTypes'),
                    exportNameInput = this.$('.mapExportName'),
                    exportButton = this.$('.mapExportButton'),
                    inputs = [
                        zoomSelect,
                        widthInput,
                        heightInput,
                        formatSelect,
                        fileSelect,
                        exportNameInput,
                        exportButton
                    ];

                for (var i = 0; i < inputs.length; i++) {
                    if (!attrs.selArea) {
                        $(inputs[i]).prop('disabled', true);
                    } else {
                        $(inputs[i]).prop('disabled', false);
                    }
                }
                if (attrs.selArea) {
                    $(areaButton).removeClass('mapExportSelectButton');
                    $(areaButton).addClass('mapExportUnselectButton');
                    $(areaButton).text(window._gtxt('mapExport.unselect'));
                    $(zoomToBoxButton).show();
                    $(zoomToLevelButton).show();
                    if (!attrs.widthValueErr    &&
                        !attrs.widthSizeErr     &&
                        !attrs.heightValueErr   &&
                        !attrs.heightSizeErr    &&
                        attrs.name !== '') {
                            $(exportButton).removeClass('gmx-disabled');
                    }
                } else {
                    $(areaButton).removeClass('mapExportUnselectButton');
                    $(areaButton).addClass('mapExportSelectButton');
                    $(areaButton).text(window._gtxt('mapExport.select'));
                    $(zoomToBoxButton).hide();
                    $(zoomToLevelButton).hide();
                    $(exportButton).addClass('gmx-disabled');
                }
            },

            updateSize: function () {
                var attrs = this.model.toJSON(),
                    widthInput = this.$('.mapExportWidth'),
                    width = Number(attrs.width).toFixed(0),
                    heightInput = this.$('.mapExportHeight'),
                    height = Number(attrs.height).toFixed(0);

                if (!attrs.widthValueErr) {
                    $(widthInput).val((width));
                }

                if (!attrs.heightValueErr) {
                    $(heightInput).val((height));
                }
            },

            handleValueError: function () {
                var attrs = this.model.toJSON(),
                    widthInput = this.$('.mapExportWidth'),
                    heightInput = this.$('.mapExportHeight'),
                    exportButton = this.$('.mapExportButton'),
                    warn = this.$('.mapExportWarn');

                if (attrs.widthValueErr) {
                    $(widthInput).addClass('error');
                } else {
                    if (!attrs.widthSizeErr) {
                        $(widthInput).removeClass('error');
                    }
                }

                if (attrs.heightValueErr) {
                    $(heightInput).addClass('error');
                } else {
                    if (!attrs.heightSizeErr) {
                        $(heightInput).removeClass('error');
                    }
                }

                if (attrs.widthValueErr || attrs.heightValueErr) {
                    $(exportButton).addClass('gmx-disabled');
                    $(warn).html(window._gtxt('mapExport.valueWarn'));
                } else {
                    if (attrs.selArea && attrs.name) {
                        $(exportButton).removeClass('gmx-disabled');
                    }
                    if (attrs.widthSizeErr || attrs.heightSizeErr) {
                        $(warn).html(window._gtxt('mapExport.sizeWarn'));
                    } else {
                        $(warn).html('');
                    }
                }
            },

            handleSizeError: function () {
                var attrs = this.model.toJSON(),
                    widthInput = this.$('.mapExportWidth'),
                    heightInput = this.$('.mapExportHeight'),
                    exportButton = this.$('.mapExportButton'),
                    warn = this.$('.mapExportWarn');

                if (attrs.widthSizeErr) {
                    $(widthInput).addClass('error');
                } else {
                    if (!attrs.widthValueErr) {
                        $(widthInput).removeClass('error');
                    }
                }

                if (attrs.heightSizeErr) {
                    $(heightInput).addClass('error');
                } else {
                    if (!attrs.heightValueErr) {
                        $(heightInput).removeClass('error');
                    }
                }

                if (attrs.widthSizeErr || attrs.heightSizeErr) {
                    $(exportButton).addClass('gmx-disabled');
                    if (!attrs.widthValueErr && !attrs.heightValueErr) {
                        $(warn).html(window._gtxt('mapExport.sizeWarn'));
                    }
                } else {
                    if (!attrs.widthValueErr && !attrs.heightValueErr) {
                        if (attrs.selArea && attrs.name) {
                            $(exportButton).removeClass('gmx-disabled');
                        }
                        $(warn).html('');
                    }
                }
            },

            handleExportError: function () {
                var attrs = this.model.toJSON(),
                    exportButton = this.$('.mapExportButton'),
                    progressBarContainer = this.$('.export-progress-container'),
                    spinHolder = this.$('.spinHolder'),
                    cancelButton = this.$('.cancelButton'),
                    exportErrorMessage = this.$('.exportErrorMessage');

                if (attrs.selArea) {
                    $(exportButton).removeClass('gmx-disabled');
                } else {
                    $(exportButton).addClass('gmx-disabled');
                }

                if (attrs.exportErr) {
                    $(spinHolder).toggle();
                    $(progressBarContainer).toggle();
                    $(exportButton).toggle();
                    $(cancelButton).toggle();
                    $(exportErrorMessage).toggle();
                } else {
                    $(exportErrorMessage).toggle();
                }
            },

            updateName: function () {
                var attrs = this.model.toJSON(),
                    exportNameInput = this.$('.mapExportName'),
                    exportButton = this.$('.mapExportButton');

                if (attrs.name === '') {
                    $(exportNameInput).addClass('error');
                    $(exportButton).addClass('gmx-disabled');
                } else {
                    if (
                        attrs.selArea           &&
                        !attrs.widthValueErr    &&
                        !attrs.widthSizeErr     &&
                        !attrs.heightValueErr   &&
                        !attrs.heightSizeErr
                        ) {
                        $(exportButton).removeClass('gmx-disabled');
                    }

                    $(exportNameInput).removeClass('error');
                }
            },

            updateZoom: function () {
                var attrs = this.model.toJSON(),
                    levels = this.$('.zoomLevel'),
                    list = $(levels).find('option'),
                    zoomToLevelButton = this.$('.zoomToLevelButton')[0];

                for (var i = 0; i < list.length; i++) {
                    var el = list[i];

                    if (el.tagName === 'OPTION') {

                        if (Number($(el).val()) === attrs.z) {
                            $(el).prop('selected', true);
                        } else {
                            $(el).prop('selected', false);
                        }

                    }
                }

                if (zoomToLevelButton) {
                    nsGmx.Utils._title(zoomToLevelButton, (window._gtxt('mapExport.zoomToLevel') + ' ' + attrs.z));
                }
            },

            setZoom: function (e) {
                var attrs = this.model.toJSON(),
                    selectedZoom = Number(e.target.value),
                    zoomLevels = attrs.zoomLevels;

                for (var i = attrs.lmap.getMinZoom(); i < zoomLevels.length; i++) {
                    zoomLevels[i].current = false;

                    if (i === selectedZoom) {
                        zoomLevels[i].current = true;
                    }
                }

                this.model.set({
                    zoomLevels: zoomLevels,
                    z: selectedZoom
                });

                this._updateCoords();
            },

            setFormat: function (e) {
                var attrs = this.model.toJSON(),
                    formatTypes = attrs.formatTypes,
                    selectedFormat = e.target.value;

                for (var i = 0; i < formatTypes.length; i++) {
                    formatTypes[i].current = false;

                    if (formatTypes[i].type === selectedFormat) {
                        formatTypes[i].current = true;
                    }
                }

                this.model.set({
                    formatTypes: formatTypes,
                    format: selectedFormat
                });
            },

            setFileType: function (e) {
                var attrs = this.model.toJSON(),
                    fileTypes = attrs.fileTypes,
                    selectedFileType = e.target.value;

                for (var i = 0; i < fileTypes.length; i++) {
                    fileTypes[i].current = false;

                    if (fileTypes[i].type === selectedFileType) {
                        fileTypes[i].current = true;
                    }
                }

                this.model.set({
                    fileTypes: fileTypes,
                    fileType: selectedFileType
                });
            },

            setName: function (e) {
                this.model.set('name', e.target.value)
            },

            selectArea: function () {
                var attrs = this.model.toJSON();

                if (!attrs.lmap || attrs.selArea) {
                    return;
                }

                var currentZoom = attrs.lmap.getZoom(),
                    zoomLevels = attrs.zoomLevels,
                    mapBounds = attrs.lmap.getBounds(),
                    latLngs = [
                        mapBounds.getSouthWest(),
                        mapBounds.getNorthWest(),
                        mapBounds.getNorthEast(),
                        mapBounds.getSouthEast()
                    ],
                    n = mapBounds.getNorth(),
                    e = mapBounds.getEast(),
                    s = mapBounds.getSouth(),
                    w = mapBounds.getWest(),
                    mapHeight = n - s,
                    mapWidth = e - w,

                    // какую часть экрана отсекать с краев первоначальной рамки
                    scale = 4,
                    converted = this._convertFromLatLngs(latLngs, attrs.z),
                    dims = this._getDimensions(converted),
                    xx = [converted[0].x, converted[1].x, converted[2].x, converted[3].x],
                    yy = [converted[0].y, converted[1].y, converted[2].y, converted[3].y],
                    bottomLeft =    L.point(this._getMin(xx) + dims.width / scale,  this._getMax(yy) - dims.height / scale),
                    topLeft =       L.point(this._getMin(xx) + dims.width / scale,  this._getMin(yy) + dims.height / scale),
                    topRight =      L.point(this._getMax(xx) - dims.width / scale,  this._getMin(yy) + dims.height / scale),
                    bottomRight =   L.point(this._getMax(xx) - dims.width / scale,  this._getMax(yy) - dims.height / scale),
                    initialBounds = this._convertToLantLngs([bottomLeft, topLeft, topRight, bottomRight], attrs.z);

                for (var i = attrs.lmap.getMinZoom(); i < zoomLevels.length; i++) {
                    zoomLevels[i].current = false;

                    if (i === currentZoom) {
                        zoomLevels[i].current = true;
                    }
                }

                // прямоугольная рамка
                var rect = L.rectangle(initialBounds);

                this.model.set({
                    z: currentZoom,
                    zoomLevels: zoomLevels
                });

                this._createFrame(rect);

                this._updateCoords();
            },

            unselectArea: function () {
                var attrs = this.model.toJSON();
                this._removeFrame();

                this.model.set({
                    width: 0,
                    height: 0,
                    z: attrs.lmap.getZoom(),
                    widthValueErr: false,
                    widthSizeErr: false,
                    heightValueErr: false,
                    heightSizeErr: false,
                    exportErr: false
                });
            },

            zoomToBox: function () {
                var attrs = this.model.toJSON();

                attrs.lmap.fitBounds(attrs.selArea.getBounds());
            },

            zoomToLevel: function () {
                var attrs = this.model.toJSON(),
                    initialCoords = attrs.selArea.rings[0].ring.points._latlngs,
                    converted = this._convertFromLatLngs(initialCoords, attrs.z),
                    dims = this._getDimensions(converted);

                attrs.lmap.setView(dims.latLng, attrs.z);
            },

            exportMap: function () {
                var _this = this,
                    attrs = this.model.toJSON(),
                    initialCoords = attrs.selArea.rings[0].ring.points._latlngs,
                    screenCoords = !attrs.coords ? this._convertFromLatLngs(initialCoords, attrs.z) : this._convertFromLatLngs(attrs.coords, attrs.z),
                    dimensions = this._getDimensions(screenCoords),
                    mapStateParams = {
                        exportMode: true,
                        isFullScreen: true,
                        width: Math.floor(Number(attrs.width)) + 'px',
                        height: Math.floor(Number(attrs.height)) + 'px',
                        position: {
                            x: dimensions.mercCenter.x,
                            y: dimensions.mercCenter.y,
                            z: attrs.z ? 17 - attrs.z : 17 - attrs.lmap.getZoom()
                        },
                        latLng: dimensions.latLng,
                        exportBounds: attrs.selArea.getBounds(),
                        grid: attrs.fileType === window._gtxt('mapExport.filetypes.raster') ? nsGmx.gridManager.state : false
                    },
                    exportParams = {
                        width: Math.floor(Number(attrs.width)),
                        height: Math.floor(Number(attrs.height)),
                        filename: attrs.name,
                        container: attrs.fileType === window._gtxt('mapExport.filetypes.raster') ? 'grimage' : attrs.fileType,
                        format: attrs.format
                    },
                    exportButton = this.$('.mapExportButton'),
                    cancelButton = this.$('.cancelButton'),
                    progressBarContainer = this.$('.export-progress-container'),
                    progressBar = this.$('.export-progressbar'),
                    spinHolder = this.$('.spinHolder'),
                    spinMessage = this.$('.spinMessage'),
                    def;

                $(exportButton).toggle();
                $(cancelButton).toggle();

                window._mapHelper.createExportPermalink(mapStateParams, processLink);

                function processLink(id){
                    var url = window.serverBase + 'Map/Render?' + $.param(exportParams) + '&uri=' + 'http://' + window.location.host + window.location.pathname + '?permalink=' + id;

                    _this.model.set({
                        exportErr: false
                    });

                    $(exportButton).addClass('gmx-disabled');

                    $(progressBarContainer).toggle();
                    $(spinHolder).toggle();

                    $(progressBar).progressbar({
                        max: 100,
                        value: 0
                    });

                    def = nsGmx.asyncTaskManager.sendGmxPostRequest(url);

                    def.done(function(taskInfo){
                        var url2 = window.serverBase + taskInfo.Result.downloadFile,
                            selArea = _this.model.get('selArea');

                        if (selArea) {
                            $(exportButton).removeClass('gmx-disabled');
                        } else {
                            $(exportButton).addClass('gmx-disabled');
                        }

                        $(exportButton).toggle();
                        $(cancelButton).toggle();
                        $(spinHolder).toggle();
                        $(progressBarContainer).toggle();

                        downloadFile(url2);

                    }).fail(function(taskInfo){
                        if (taskInfo.ErrorInfo.ErrorMessage !== 'Task is canceled') {
                            $(exportButton).removeClass('gmx-disabled');

                            _this.model.set({
                                exportErr: true
                            });
                        }
                    }).progress(function(taskInfo){
                        _this.model.set({
                            taskInfo: taskInfo
                        });

                        if (taskInfo.Status === 'queue') {
                            $(spinMessage).html(window._gtxt('mapExport.inQueue'));
                        } else if (taskInfo.Status === 'progress') {
                            $(spinMessage).html(window._gtxt('mapExport.inProcess'));

                            $(progressBar).progressbar('value', taskInfo.Progress);
                        }
                    });

                    function downloadFile(url) {
                        var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1,
                            isSafari = navigator.userAgent.toLowerCase().indexOf('safari') > -1;

                        if (isChrome || isSafari) {
                            var link = document.createElement('a');
                            link.href = url;
                            link.download = attrs.name;

                            if (document.createEvent) {
                                var e = document.createEvent('MouseEvents');
                                e.initEvent('click', true, true);
                                link.dispatchEvent(e);
                                return true;
                            }
                        } else {
                            window.open(url, '_self');
                        }
                    }
                }
            },

            cancelExport: function() {
                var attrs = this.model.toJSON(),
                    taskInfo = this.model.get('taskInfo'),
                    exportButton = this.$('.mapExportButton'),
                    cancelButton = this.$('.cancelButton'),
                    progressBarContainer = this.$('.export-progress-container'),
                    spinHolder = this.$('.spinHolder'),
                    spinMessage = this.$('.spinMessage'),
                    url;


                url = window.serverBase + 'AsyncTaskCancel?' + $.param({TaskID: taskInfo.TaskID});

                sendCrossDomainJSONRequest(url, function(response) {
                    if (!parseResponse(response))
                        return;

                    if (response.Result) {
                        if (attrs.selArea) {
                            $(exportButton).removeClass('gmx-disabled');
                        };

                        $(exportButton).toggle();
                        $(cancelButton).toggle();
                        $(spinMessage).empty();
                        $(spinHolder).toggle();
                        $(progressBarContainer).toggle();
                    }
                })
            },

            resize: function(e) {
                var attrs = this.model.toJSON(),
                    start = e.target.selectionStart,
                    end = e.target.selectionEnd,
                    initialCoords,
                    scale,
                    screenCoords,
                    width, height,
                    bottomLeft, bottomRight,
                    topLeft, topRight,
                    newBounds,
                    value, valueErr, sizeErr;

                if (!attrs.lmap || !attrs.selArea) {
                    return;
                }

                initialCoords = attrs.selArea.rings[0].ring.points._latlngs;

                // разница между целевым и текущим зумом
                scale = Math.pow(2, (attrs.z - attrs.lmap.getZoom()));

                screenCoords = !attrs.coords ? this._revertCoords(this._convertFromLatLngs(initialCoords, attrs.z)) : this._revertCoords(this._convertFromLatLngs(attrs.coords, attrs.z));

                value = Number(e.target.value);
                valueErr = value <= 0 || isNaN(value);
                sizeErr = value > MAX_SIZE;

                // обработка инпута ширины
                if (e.target.className === 'mapExportWidth' || e.target.className === 'mapExportWidth error') {
                    if (valueErr) {
                        this.model.set('widthValueErr', true)
                    } else {
                        this.model.set('widthValueErr', false)
                        this.model.set('width', e.target.value);

                        if (sizeErr) {
                            this.model.set('widthSizeErr', true);
                        } else {
                            this.model.set('widthSizeErr', false);
                        }
                    }
                }

                // обработка инпута высоты
                if (e.target.className === 'mapExportHeight' || e.target.className === 'mapExportHeight error') {
                    if (valueErr) {
                        this.model.set('heightValueErr', true)
                    } else {
                        this.model.set('heightValueErr', false)
                        this.model.set('height', e.target.value);

                        if (sizeErr) {
                            this.model.set('heightSizeErr', true);
                        } else {
                            this.model.set('heightSizeErr', false);
                        }
                    }
                }

                attrs = this.model.toJSON();

                if (attrs.widthValueErr || attrs.heightValueErr) return;

                width = e.target.className === 'mapExportWidth' || e.target.className === 'mapExportWidth error' ? Number(e.target.value) : Number(attrs.width);
                height = e.target.className === 'mapExportHeight' || e.target.className === 'mapExportHeight error' ? Number(e.target.value) : Number(attrs.height);

                newBounds = [];

                // изменяем координаты объекта, учитывая изменившуюся ширину или высоту
                // геометрия изменяется в соответствии с введенными значениями
                // topLeft остается неизменным
                bottomLeft = screenCoords[0];
                topLeft = screenCoords[1];
                topRight = screenCoords[2];
                bottomRight = screenCoords[3];

                topRight.x = (topLeft.x + width);
                topRight.y = topLeft.y;

                bottomLeft.x = topLeft.x;
                bottomLeft.y = (topLeft.y + height);

                bottomRight.x = (topLeft.x + width);
                bottomRight.y = (topLeft.y + height);

                topLeft.x = topLeft.x;
                topLeft.y = topLeft.y;

                newBounds.push(
                    [attrs.lmap.unproject([bottomLeft.x / scale, bottomLeft.y / scale])],
                    [attrs.lmap.unproject([topRight.x / scale, topRight.y / scale])]
                );

                // измененная прямоугольная рамка
                var newRect = L.rectangle(newBounds);
                this.model.set('coords', newRect._latlngs);

                attrs.lmap.gmxDrawing.remove(attrs.selArea);

                this._createFrame(newRect);
                this._updateCoords();

                // восстановим позицию курсора
                e.target.setSelectionRange(start, end);
            },

            _createFrame: function(rectangle) {
                var attrs = this.model.toJSON(),
                    options = {
                        editable: true,
                        map: true,
                        lineStyle: {
                            dashArray: '5 5',
                            color: '#f57c00',
                            weight: 3.5
                        },
                        pointStyle: {
                            size: L.Browser.mobile ? 40 : 8,
                            color: '#f57c00'
                        }
                    };

                this.model.set({
                    selArea: attrs.lmap.gmxDrawing.add(rectangle, L.extend(options, {
                        exportRect: true
                    }))
                });

                // навешивает обработчики на рамку выделения
                var frame = this.model.get('selArea'),
                    _this = this;

                frame.on('edit', _this._resizeFrame.bind(_this));
                frame.on('remove', function () {
                    var attrs = _this.model.toJSON();

                    _this.model.set({
                        width: 0,
                        height: 0,
                        widthValueErr: false,
                        widthSizeErr: false,
                        heightValueErr: false,
                        heightSizeErr: false,
                        exportErr: false
                    });
                });

            },

            _resizeFrame: function () {
                var attrs = this.model.toJSON(),
                    initialCoords,
                    screenCoords,
                    dimensions,
                    w, h;

                initialCoords = attrs.selArea.rings[0].ring.points._latlngs;
                screenCoords = this._convertFromLatLngs(initialCoords, attrs.z);
                dimensions = this._getDimensions(screenCoords);

                w = Math.abs(dimensions.width);
                h = Math.abs(dimensions.height);

                if (w > MAX_SIZE) {
                    this.model.set('widthSizeErr', true)
                } else {
                    this.model.set('widthSizeErr', false)
                }

                if (h > MAX_SIZE) {
                    this.model.set('heightSizeErr', true)
                } else {
                    this.model.set('heightSizeErr', false)
                }

                this.model.set({
                    coords: initialCoords,
                    width: String(w),
                    height: String(h)
                });
            },

            _removeFrame: function () {
                var attrs = this.model.toJSON();

                if (!attrs.selArea) {
                    return;
                }

                attrs.lmap.gmxDrawing.remove(attrs.selArea);

                this.model.set({
                    selArea: null,
                    coords: null
                });
            },

            _updateCoords: function () {
                var attrs = this.model.toJSON(),
                    initialCoords,
                    screenCoords,
                    dimensions,
                    w, h;

                if (!attrs.selArea) {
                    return;
                }

                initialCoords = attrs.selArea.rings[0].ring.points._latlngs;
                screenCoords = !attrs.coords ? this._convertFromLatLngs(initialCoords, attrs.z) : this._convertFromLatLngs(attrs.coords, attrs.z);
                dimensions = this._getDimensions(screenCoords);

                w = Math.abs(dimensions.width);
                h = Math.abs(dimensions.height);

                if (!attrs.coords) {
                    this.model.set('coords', initialCoords)
                }

                if (w > MAX_SIZE) {
                    this.model.set('widthSizeErr', true)
                } else {
                    this.model.set('widthSizeErr', false)
                }

                if (h > MAX_SIZE) {
                    this.model.set('heightSizeErr', true)
                } else {
                    this.model.set('heightSizeErr', false)
                }

                this.model.set({
                    width: String(w),
                    height: String(h)
                });
            },

            _revertCoords: function (coords) {
                var xx,
                    yy,
                    bottomLeft, topLeft,
                    topRight, bottomRight;

                xx = [coords[0].x, coords[1].x, coords[2].x, coords[3].x];
                yy = [coords[0].y, coords[1].y, coords[2].y, coords[3].y];
                bottomLeft = L.point(this._getMin(xx), this._getMax(yy));
                topLeft = L.point(this._getMin(xx), this._getMin(yy));
                topRight = L.point(this._getMax(xx), this._getMin(yy));
                bottomRight = L.point(this._getMax(xx), this._getMax(yy));

                return [bottomLeft, topLeft, topRight, bottomRight];

            },

            _convertFromLatLngs: function (latlngs, zoom) {
                var attrs = this.model.toJSON(),
                    converted = latlngs.map(function(ll) {
                        return attrs.lmap.project([ll.lat, ll.lng], zoom);
                    });

                return converted;
            },

            _convertToLantLngs: function (points, zoom) {
                var attrs = this.model.toJSON(),
                    converted = points.map(function(point) {
                        return attrs.lmap.unproject([point.x, point.y], zoom);
                    });

                return converted;
            },

            _getDimensions: function(points) {
                var attrs = this.model.toJSON(),
                    bottomLeft, topRight,
                    width, height,
                    x, y;

                points = this._revertCoords(points);
                bottomLeft = points[0];
                topRight = points[2];
                width = Math.abs(topRight.x - bottomLeft.x);
                height = Math.abs(bottomLeft.y - topRight.y);
                x = bottomLeft.x + width / 2;
                y = topRight.y + height / 2;

                return {
                    bottomLeft: bottomLeft,
                    topRight: topRight,
                    width: width,
                    height: height,
                    mercCenter: L.Projection.Mercator.project(attrs.lmap.unproject([x, y], attrs.z)),
                    latLng: attrs.lmap.unproject([x, y], attrs.z)
                }
            },

            _getMax: function(arr) {
                return Math.max.apply(null, arr);
            },

            _getMin: function(arr) {
                return Math.min.apply(null, arr);
            }
        });

        view = new ExportView();

        function getZoomLevels() {
            var zoomLevels = [],
                lmap = nsGmx.leafletMap,
                min = lmap.getMinZoom(),
                max = lmap.getMaxZoom(),
                currentZoom = lmap.getZoom();

            for (var i = min; i <= max; i++) {
                zoomLevels[i] = {zoom: i, current: false};

                if (i === currentZoom) {
                    zoomLevels[i].current = true;
                }
            }
            return zoomLevels;
        }

        function getTypes(types) {
            var arr = [];

            for (var i = 0; i < types.length; i++) {
                arr[i] = {type: types[i], current: false};

                if (i === 0) {
                    arr[i].current = true;
                }
            }
            return arr;
        }

        this.Load = function () {
            var lm = model.get('lm');

            if (lm != null) {
                var alreadyLoaded = lm.createWorkCanvas('export', this.Unload);
                if (!alreadyLoaded) {
                    $(lm.workCanvas).append(view.el);
                }
            }
        }
        this.Unload = function () {
            var attrs = model.toJSON();
            attrs.lmap.gmxDrawing.remove(attrs.selArea);
            model.set({
                selArea: null,
                width: 0,
                height: 0,
                widthValueErr: false,
                heightValueErr: false,
                widthSizeErr: false,
                heightSizeErr: false,
                format: null,
                x: null,
                z: attrs.lmap.getZoom(),
                y: null,
                latLng: null,
                coords: null,
                zoomLevels: getZoomLevels(),
                formatTypes: getTypes(formatTypes),
                fileTypes: null,
                exportErr: false
            });
        };
    }

    var publicInterface = {
        pluginName: 'MapExport',
        MapExportMenu: MapExportMenu
  };

    window.gmxCore.addModule('MapExport',
        publicInterface
    );
})();

var nsGmx = window.nsGmx || {};

(function() {

    var MAX_INDEX_COUNT = 10000;
    var KM_PER_DEGREE = 111.31949;

    nsGmx.DrawingObjectCustomControllers.addDelegate({
        isHidden: function(obj) {
            if (obj.options.exportRect) {
                return true;
            }
            return false;
        }
    });

    window._translationsHash.addtext('rus', {
        indexGrid: {
            settings: 'Настройки индексной сетки',
            select: 'Выделить область карты',
            unselect: 'Снять выделение',
            coordinates: 'координаты',
            lat: 'широта',
            lng: 'долгота',
            min: 'мин',
            max: 'макс',
            step: 'шаг (км)',
            onLat: 'по широте',
            onLng: 'по долготе',
            count: 'количество идексов',
            name: 'имя слоя',
            create: 'Создать слой индексной сетки',
            valueWarn: 'недопустимое значение',
            indexCountWarn: 'превышено допустимое число ячеек (10 000)',
            nameWarn: 'имя слоя не должно быть пустым'
        }
    });
    window._translationsHash.addtext('eng', {
        indexGrid: {
            settings: 'Index grid settings',
            select: 'Select',
            unselect: 'Clear selection',
            coordinates: 'coordinates',
            lat: 'latitude',
            lng: 'longitude',
            max: 'max',
            min: 'min',
            step: 'Step (km)',
            onLat: 'on latitude',
            onLng: 'on longitude',
            count: 'index count',
            name: 'layer name',
            create: 'Create index grid layer',
            valueWarn: 'incorrect value',
            valueWarn: 'incorrect value',
            indexCountWarn: 'max ceils number exceeded (10 000)',
            nameWarn: 'layer name cannot be empty'
        }
    });

    var view;

    var IndexGridMenu = function () {
        var canvas = nsGmx.Utils._div(null, [['dir','className','indexGridConfigLeftMenu']]);

        var IndexGridModel = window.Backbone.Model.extend({
            defaults: {
                lm: new window.leftMenu(),
                lmap: nsGmx.leafletMap,
                selArea: null,
                xStep: 1,
                yStep: 1,
                xCount: null,
                yCount: null,
                xStepErr: false,
                yStepErr: false,
                indexCount: null,
                indexCountErr: false,
                maxLat: null,
                maxLng: null,
                minLat: null,
                minLng: null,
                maxLatErr: false,
                maxLngErr: false,
                minLatErr: false,
                minLngErr: false,
                z: null,
                coords: null,
                name: '',
                nameErr: true
            }
        });

        var model = new IndexGridModel();

        var IndexGridView = window.Backbone.View.extend({
            el: $(canvas),
            model: model,
            template: window.Handlebars.compile(
                '<div class="selectButtons">' +
                        '<span class="buttonLink areaButton indexGridSelectButton"> {{i "indexGrid.select"}}</span>' +
                        '</span>' +
                '</div>' +
                '<div class="indexgridsettings">' +
                    '<span>' +
                        '{{i "indexGrid.settings"}}' +
                    '</span>' +
                '</div>' +
                '<table class="settings">' +
                    '<tbody>' +
                        // Широта / Долгота
                        '<tr class="dims">' +
                            '<td class="eLabel">{{i "indexGrid.coordinates"}}</td>' +
                            '<td class="eLabel colname">{{i "indexGrid.lat"}}</td>' +
                            '<td class="eLabel colname">{{i "indexGrid.lng"}}</td>' +
                        '</tr>' +
                        // Макс
                        '<tr class="dims">' +
                            '<td class="eLabel">{{i "indexGrid.max"}}</td>' +
                            '<td class="eInput">' +
                                '<input type="text" class="maxLat" value="{{maxLat}}"/>' +
                            '</td>' +
                            '<td class="eInput">' +
                                '<input type="text" class="maxLng" value="{{maxLng}}"/>' +
                            '</td>' +
                        '</tr>' +
                        // Мин
                        '<tr class="dims">' +
                            '<td class="eLabel">{{i "indexGrid.min"}}</td>' +
                            '<td class="eInput">' +
                                '<input type="text" class="minLat" value="{{minLat}}"/>' +
                            '</td>' +
                            '<td class="eInput">' +
                                '<input type="text" class="minLng" value="{{minLng}}"/>' +
                            '</td>' +
                        '</tr>' +
                        // Шаг
                        '<tr class="dims">' +
                            '<td class="eLabel" rowspan=2>{{i "indexGrid.step"}}</td>' +
                            '<td class="eLabel">{{i "indexGrid.onLat"}}</td>' +
                            '<td class="eInput">' +
                            '<input type="text" class="yStep" value="{{yStep}}"/>' +
                            '</td>' +
                        '</tr>' +
                        '<tr class="dims">' +
                            '<td class="eLabel">{{i "indexGrid.onLng"}}</td>' +
                            '<td class="eInput">' +
                            '<input type="text" class="xStep" value="{{xStep}}"/>' +
                            '</td>' +
                        '</tr>' +
                        // Количество индексов
                        '<tr class="dims">' +
                            '<td class="eLabel">{{i "indexGrid.count"}}</td>' +
                            '<td class="eLabel"></td>' +
                            '<td class="eLabel indexCount">{{indexCount}}</td>' +
                        '</tr>' +
                        // Имя
                        '<tr class="nameSelect">' +
                            '<td class="eLabel">{{i "indexGrid.name"}}</td>' +
                            '<td class="eInput" colspan=2>' +
                                '<input type="text" class="name" value=""/>' +
                            '</td>' +
                        '</tr>' +
                    '</tbody>' +
                '</table>' +
                '<div class="createWrap">' +
                    '<div class="create">' +
                        '<span class="buttonLink createIndexGridButton"> {{i "indexGrid.create"}}</span>' +
                        '<span class="spinHolder" style="display:none">' +
                            '<img src="img/progress.gif"/>' +
                            '<span class="spinMessage"></span>' +
                            '</span>' +
                        '<br/>' +
                        '<span class="warnMessage errorMessage" style="display:none"></span>' +
                    '</div>' +
                '</div>'
            ),
            events: {
                'click .indexGridSelectButton': 'selectArea',
                'click .indexGridUnelectButton': 'unselectArea',
                'input .minLat': 'resize',
                'input .maxLat': 'resize',
                'input .minLng': 'resize',
                'input .maxLng': 'resize',
                'input .xStep': 'setStep',
                'input .yStep': 'setStep',
                'input .name': 'setName',
                'click .createIndexGridButton': 'createIndexGrid'
            },

            initialize: function () {
                var attrs = this.model.toJSON(),
                    currentZoom = attrs.lmap.getZoom();

                this.listenTo(this.model, 'change:selArea', this.updateArea);
                this.listenTo(this.model, 'change:selArea', this.updateStepInput.bind(this, 'xStep'));
                this.listenTo(this.model, 'change:selArea', this.updateStepInput.bind(this, 'yStep'));

                this.listenTo(this.model, 'change:minLat', this.updateLatLngInput.bind(this, 'minLat'));
                this.listenTo(this.model, 'change:maxLat', this.updateLatLngInput.bind(this, 'maxLat'));
                this.listenTo(this.model, 'change:maxLng', this.updateLatLngInput.bind(this, 'maxLng'));
                this.listenTo(this.model, 'change:minLng', this.updateLatLngInput.bind(this, 'minLng'));

                this.listenTo(this.model, 'change:minLatErr', this.handleInputErr.bind(this, 'minLat'));
                this.listenTo(this.model, 'change:maxLatErr', this.handleInputErr.bind(this, 'maxLat'));
                this.listenTo(this.model, 'change:maxLngErr', this.handleInputErr.bind(this, 'maxLng'));
                this.listenTo(this.model, 'change:minLngErr', this.handleInputErr.bind(this, 'minLng'));

                this.listenTo(this.model, 'change:xStep', this.updateStepInput.bind(this, 'xStep'));
                this.listenTo(this.model, 'change:yStep', this.updateStepInput.bind(this, 'yStep'));

                this.listenTo(this.model, 'change:xStepErr', this.handleInputErr.bind(this, 'xStep'));
                this.listenTo(this.model, 'change:yStepErr', this.handleInputErr.bind(this, 'yStep'));
                this.listenTo(this.model, 'change:indexCount', this.updateIndexCount);
                this.listenTo(this.model, 'change:indexCountErr', this.handleIndexCountErr);
                this.listenTo(this.model, 'change:name', this.updateName);
                this.listenTo(this.model, 'change:nameErr', this.handleInputErr.bind(this, 'name'));

                this.model.set({
                    z: currentZoom,
                    name: nsGmx.gmxMap.properties.title,
                    nameErr: false
                });

                this.updateArea();

                this.render();
            },

            render: function () {
                this.$el.html(this.template(this.model.toJSON()));
                this.$('.minLat').prop('disabled', true);
                this.$('.maxLat').prop('disabled', true);
                this.$('.maxLng').prop('disabled', true);
                this.$('.minLng').prop('disabled', true);
                this.$('.xStep').prop('disabled', true);
                this.$('.yStep').prop('disabled', true);
                this.$('.name').val(this.model.get('name'));
                this.$('.name').prop('disabled', true);
                this.$('.createIndexGridButton').addClass('gmx-disabled');

                return this;
            },

            updateArea: function () {
                var attrs = this.model.toJSON(),
                    minLatInput = this.$('.minLat'),
                    maxLatInput = this.$('.maxLat'),
                    maxLngInput = this.$('.maxLng'),
                    minLngInput = this.$('.minLng'),
                    xStepInput = this.$('.xStep'),
                    yStepInput = this.$('.yStep'),
                    areaButton = this.$('.areaButton'),
                    nameInput = this.$('.name'),
                    createIndexGridButton = this.$('.createIndexGridButton'),
                    inputs = [
                        minLatInput,
                        maxLatInput,
                        maxLngInput,
                        minLngInput,
                        xStepInput,
                        yStepInput,
                        nameInput,
                        createIndexGridButton
                    ];

                for (var i = 0; i < inputs.length; i++) {
                    if (!attrs.selArea) {
                        $(inputs[i]).prop('disabled', true);
                    } else {
                        $(inputs[i]).prop('disabled', false);
                    }
                }
                if (attrs.selArea) {
                    $(areaButton).removeClass('indexGridSelectButton');
                    $(areaButton).addClass('indexGridUnelectButton');
                    $(areaButton).text(window._gtxt('indexGrid.unselect'));

                    if (
                        !attrs.minLatErr        &&
                        !attrs.maxLatErr        &&
                        !attrs.maxLngErr        &&
                        !attrs.minLngErr        &&
                        !attrs.xStepErr         &&
                        !attrs.yStepErr         &&
                        !attrs.indexCountErr    &&
                        attrs.name !== ''
                    ) {
                            $(createIndexGridButton).removeClass('gmx-disabled');
                    }
                } else {
                    $(areaButton).removeClass('indexGridUnelectButton');
                    $(areaButton).addClass('indexGridSelectButton');
                    $(areaButton).text(window._gtxt('indexGrid.select'));
                    $(createIndexGridButton).addClass('gmx-disabled');
                }
            },

            updateLatLngInput: function (latLng) {
                var attrs = this.model.toJSON(),
                    input = this.$('.' + latLng),
                    value = this.model.get(latLng);

                $(input).val(value !== null ? this._roundInputNumber(value) : '');
            },

            handleInputErr: function (inputName) {
                var input = this.$('.' + inputName);

                $(input).toggleClass('error', this.model.get(inputName + 'Err'));
                this.setCreateButtonStatus();
                this.setWarnMessage();
            },

            updateStepInput: function (inputName) {
                var attrs = this.model.toJSON(),
                    input = this.$('.' + inputName),
                    value = this.model.get(inputName);

                $(input).val(value);
            },

            updateXStep: function () {
                var attrs = this.model.toJSON(),
                    xStepInput = this.$('.xStep');

                $(xStepInput).val(attrs.xStep);
            },

            updateYStep: function () {
                var attrs = this.model.toJSON(),
                    yStepInput = this.$('.yStep');

                $(yStepInput).val(attrs.yStep);
            },

            updateIndexCount: function () {
                var attrs = this.model.toJSON(),
                    indexCount = this.$('.indexCount');

                $(indexCount).html(attrs.indexCount ? attrs.indexCount : '');
            },

            handleIndexCountErr: function () {
                var attrs = this.model.toJSON(),
                    indexCount = this.$('.indexCount');

                $(indexCount).toggleClass('errorMessage', attrs.indexCountErr);
                this.setCreateButtonStatus();
                this.setWarnMessage();
            },

            updateName: function () {
                var attrs = this.model.toJSON(),
                    nameInput = this.$('.name');

                $(nameInput).val(attrs.name);
            },

            setCreateButtonStatus: function () {
                var attrs = this.model.toJSON(),
                    createIndexGridButton = this.$('.createIndexGridButton'),
                    err = attrs.minLatErr
                        || attrs.maxLatErr
                        || attrs.maxLngErr
                        || attrs.minLngErr
                        || attrs.xStepErr
                        || attrs.yStepErr
                        || attrs.indexCountErr;

                    $(createIndexGridButton).toggleClass('gmx-disabled', err);
            },

            setWarnMessage: function () {
                var attrs = this.model.toJSON(),
                    warnMessage = this.$('.warnMessage'),
                    err = attrs.minLatErr
                        || attrs.maxLatErr
                        || attrs.maxLngErr
                        || attrs.minLngErr
                        || attrs.xStepErr
                        || attrs.yStepErr
                        || attrs.indexCountErr
                        || attrs.nameErr;

                    $(warnMessage).toggle(err);

                if (
                       attrs.minLatErr
                    || attrs.maxLatErr
                    || attrs.maxLngErr
                    || attrs.minLngErr
                    || attrs.xStepErr
                    || attrs.yStepErr
                ) {
                    $(warnMessage).text(window._gtxt('indexGrid.valueWarn'));
                } else if (attrs.indexCountErr) {
                    $(warnMessage).text(window._gtxt('indexGrid.indexCountWarn'));
                } else if (attrs.nameErr) {
                    $(warnMessage).text(window._gtxt('indexGrid.nameWarn'));
                } else {
                    $(warnMessage).text('');
                }
            },

            setName: function (e) {
                var value,
                    valueErr;

                value = e.target.value;
                valueErr = value === '';

                if (valueErr) {
                    this.model.set('nameErr', true);
                } else {
                    this.model.set('nameErr', false);
                    this.model.set('name', value)
                }
            },

            selectArea: function () {
                var attrs = this.model.toJSON();

                if (!attrs.lmap || attrs.selArea) {
                    return;
                }

                var currentZoom = attrs.lmap.getZoom(),
                    mapBounds = attrs.lmap.getBounds(),
                    latLngs = [
                        mapBounds.getSouthWest(),
                        mapBounds.getNorthWest(),
                        mapBounds.getNorthEast(),
                        mapBounds.getSouthEast()
                    ],
                    n = mapBounds.getNorth(),
                    e = mapBounds.getEast(),
                    s = mapBounds.getSouth(),
                    w = mapBounds.getWest(),
                    mapHeight = n - s,
                    mapWidth = e - w,

                    // какую часть экрана отсекать с краев первоначальной рамки
                    scale = 4,
                    converted = this._convertFromLatLngs(latLngs, attrs.z),
                    dims = this._getDimensions(converted),
                    xx = [converted[0].x, converted[1].x, converted[2].x, converted[3].x],
                    yy = [converted[0].y, converted[1].y, converted[2].y, converted[3].y],
                    bottomLeft =    L.point(this._getMin(xx) + dims.width / scale,  this._getMax(yy) - dims.height / scale),
                    topLeft =       L.point(this._getMin(xx) + dims.width / scale,  this._getMin(yy) + dims.height / scale),
                    topRight =      L.point(this._getMax(xx) - dims.width / scale,  this._getMin(yy) + dims.height / scale),
                    bottomRight =   L.point(this._getMax(xx) - dims.width / scale,  this._getMax(yy) - dims.height / scale),
                    initialBounds = this._convertToLantLngs([bottomLeft, topLeft, topRight, bottomRight], attrs.z);

                // прямоугольная рамка
                var rect = L.rectangle(initialBounds);

                this.model.set({
                    z: currentZoom
                });

                this._createFrame(rect);

                this._updateCoords();
                this._updateCorners();
                this._countIndex();
            },

            unselectArea: function () {
                var attrs = this.model.toJSON();
                this._removeFrame();

                this.model.set({
                    width: 0,
                    height: 0,
                    z: attrs.lmap.getZoom(),
                    xStep: 1,
                    yStep: 1,
                    xCount: null,
                    yCount: null,
                    xStepErr: false,
                    yStepErr: false,
                    indexCount: null,
                    indexCountErr: false,
                    minLat: null,
                    minLng: null,
                    maxLat: null,
                    maxLng: null,
                    minLatErr: false,
                    maxLatErr: false,
                    maxLngErr: false,
                    minLngErr: false
                });
            },

            createIndexGrid: function () {
                var attrs = this.model.toJSON(),
                    name = attrs.name,
                    columns = [
                        {
                            Name:"gmx_id",
                            ColumnSimpleType:"Integer",
                            IsIdentity:true,
                            IsComputed:false,
                            IsPrimary:true
                        },
                        {
                            Name:"index",
                            ColumnSimpleType:"String",
                            IsIdentity:false,
                            IsComputed:false,
                            IsPrimary:false
                        }
                    ],
                    layerParams = {
                        Title: name,
                        geometrytype: 'polygon',
                        Columns: JSON.stringify(columns),
                    },
                    indexes = this.generatePolygons(),
                    spinHolder = this.$('.spinHolder'),
                    def = nsGmx.asyncTaskManager.sendGmxPostRequest(window.serverBase + "VectorLayer/CreateVectorLayer.ashx", layerParams),
                    promise,
                    _this = this;

                def.done(function(response) {
                    var layerName = response.Result.properties.name;
                        mapProperties = _layersTree.treeModel.getMapProperties(),
                        targetDiv = $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0],
                        gmxProperties = {type: 'layer', content: response.Result},
                        def2 = _mapHelper.modifyObjectLayer(layerName, indexes, 'EPSG:4326');

                    gmxProperties.content.properties.mapName = mapProperties.name;
                    gmxProperties.content.properties.hostName = mapProperties.hostName;
                    gmxProperties.content.properties.visible = true;

                    gmxProperties.content.properties.styles = [{
                        MinZoom: gmxProperties.content.properties.VtMaxZoom,
                        MaxZoom:21,
                        RenderStyle:_mapHelper.defaultStyles[gmxProperties.content.properties.GeometryType]
                    }];

                    $(spinHolder).show();

                    def2.always(function(res) {
                        _layersTree.copyHandler(gmxProperties, targetDiv, false, true);
                        $(spinHolder).hide();
                        _this.unselectArea();
                    })
                });

            },

            generatePolygons: function () {
                var attrs = this.model.toJSON(),
                    xStep = this._convertXStep(attrs.xStep),
                    yStep = this._convertYStep(attrs.yStep),
                    xCount = attrs.xCount,
                    yCount = attrs.yCount,
                    proj = L.Projection.Mercator,
                    north = attrs.maxLat,
                    south = attrs.minLat,
                    west = attrs.minLng,
                    east = attrs.maxLng,
                    indexes = [],
                    index,
                    letterIndexes = this._getLetterIndexes(xCount),
                    letter,
                    n, s, e, w;

                for (var i = 0; i < yCount; i++) {
                    n = north - yStep * i;
                    s = north - yStep * (i+1);

                    for (var j = 0; j < xCount; j++) {
                        letter = letterIndexes[j];
                        w = west + xStep * j;
                        e = west + xStep * (j+1);

                        index = {
                            geometry: L.polygon(
                                [
                                    L.latLng(s, w),
                                    L.latLng(n, w),
                                    L.latLng(n, e),
                                    L.latLng(s, e)
                                ]
                            ).toGeoJSON(),
                            properties: {
                                index: letter + (i+1)
                            }
                        };
                        indexes.push(index);
                    }
                }

                return indexes;
            },

            setStep: function (e) {
                var value,
                    valueErr;

                value = Number(e.target.value);
                valueErr = value <= 0 || isNaN(value);

                // обработка xStep
                if (e.target.className === 'xStep' || e.target.className === 'xStep error') {
                    if (valueErr) {
                        this.model.set('xStepErr', true);
                    } else {
                        this.model.set('xStepErr', false);
                        this.model.set('xStep', value);
                    }
                }

                // обработка yStep
                if (e.target.className === 'yStep' || e.target.className === 'yStep error') {
                    if (valueErr) {
                        this.model.set('yStepErr', true);
                    } else {
                        this.model.set('yStepErr', false);
                        this.model.set('yStep', value);
                    }
                }

                this._countIndex();

            },

            resize: function (e) {
                var attrs = this.model.toJSON(),
                    initialCoords,
                    coords,
                    bounds,
                    scale,
                    screenCoords,
                    newBounds,
                    value, valueErr;

                if (!attrs.lmap || !attrs.selArea) {
                    return;
                }

                // разница между целевым и текущим зумом
                scale = Math.pow(2, (attrs.z - attrs.lmap.getZoom()));
                initialCoords = attrs.selArea.rings[0].ring.points._latlngs;
                coords = attrs.coords ? attrs.coords : initialCoords;

                value = Number(e.target.value);

                valueErr = !value || isNaN(value);

                // обработка ввода значений с плавающей точкой
                if (e.target.value.indexOf(".") === e.target.value.length - 1) {
                    valueErr = true;
                }
                // обработка minLat
                if (e.target.className === 'minLat' || e.target.className === 'minLat error') {
                    if (valueErr) {
                        this.model.set('minLatErr', true);
                    } else {
                        var north = this._getBounds(coords).getNorth();

                        if (value < north) {
                            this.model.set('minLatErr', false);

                            this.model.set('minLat', value);
                        } else {
                            this.model.set('minLatErr', true);
                        }
                    }
                }

                // обработка minLng
                if (e.target.className === 'minLng' || e.target.className === 'minLng error') {
                    if (valueErr) {
                        this.model.set('minLngErr', true);
                    } else {
                        var east = this._getBounds(coords).getEast();

                        if (value < east) {
                            this.model.set('minLngErr', false);
                            this.model.set('minLng', value);
                        } else {
                            this.model.set('minLngErr', true);
                        }
                    }
                }

                // обработка maxLat
                if (e.target.className === 'maxLat' || e.target.className === 'maxLat error') {
                    if (valueErr) {
                        this.model.set('maxLatErr', true);
                    } else {
                        var south = this._getBounds(coords).getSouth();

                        if (value > south) {
                            this.model.set('maxLatErr', false);
                            this.model.set('maxLat', value);
                        } else {
                            this.model.set('maxLatErr', true);
                        }
                    }
                }

                // обработка maxLng
                if (e.target.className === 'maxLng' || e.target.className === 'maxLng error') {
                    if (valueErr) {
                        this.model.set('maxLngErr', true);
                    } else {
                        var west = this._getBounds(coords).getWest();

                        if (value > west) {
                            this.model.set('maxLngErr', false);
                            this.model.set('maxLng', value);
                        } else {
                            this.model.set('maxLngErr', true);
                        }
                    }
                }

                attrs = this.model.toJSON();

                if (attrs.maxLngErr || attrs.minLngErr || attrs.minLatErr || attrs.maxLatErr) return;

                var newRect = L.rectangle([L.latLng(attrs.minLat, attrs.minLng), L.latLng(attrs.maxLat, attrs.maxLng)]);

                this.model.set({
                    'coords': newRect._latlngs
                });

                this._removeFrame();

                this._createFrame(newRect);
                // restore model attributes
                this.model.set({
                    xStep:          attrs.xStep,
                    yStep:          attrs.yStep,
                    xStepErr:       attrs.xStepErr,
                    yStepErr:       attrs.yStepErr,
                    minLatErr:      attrs.minLatErr,
                    maxLatErr:      attrs.maxLatErr,
                    maxLngErr:      attrs.maxLngErr,
                    minLngErr:      attrs.minLngErr
                });

                this._updateCoords();
                this._updateCorners();
                this._countIndex();

            },

            _createFrame: function(rectangle) {
                var attrs = this.model.toJSON(),
                    options = {
                        editable: true,
                        map: true,
                        lineStyle: {
                            dashArray: '5 5',
                            color: '#f57c00',
                            weight: 3.5
                        },
                        pointStyle: {
                            size: L.Browser.mobile ? 40 : 8,
                            color: '#f57c00'
                        }
                    };

                this.model.set({
                    selArea: attrs.lmap.gmxDrawing.add(rectangle, L.extend(options, {
                        exportRect: true
                    }))
                });

                // навешивает обработчики на рамку выделения
                var frame = this.model.get('selArea'),
                    _this = this;

                frame.on('edit', _this._resizeFrame.bind(_this));
                frame.on('remove', _this.unselectArea.bind(_this));

            },

            _resizeFrame: function () {
                var attrs = this.model.toJSON(),
                    initialCoords = attrs.selArea.rings[0].ring.points._latlngs,
                    bounds = this._getBounds(initialCoords),
                    err = attrs.minLatErr
                        || attrs.maxLatErr
                        || attrs.maxLngErr
                        || attrs.minLngErr;

                if (err) {
                    return;
                }

                this.model.set({
                    coords: initialCoords,
                    minLat: bounds.getSouth(),
                    minLng: bounds.getWest(),
                    maxLat: bounds.getNorth(),
                    maxLng: bounds.getEast()
                });

                // this.model.set({
                //     minLatErr: false,
                //     maxLatErr: false,
                //     minLngErr: false,
                //     maxLngErr: false
                // });


                this._countIndex();
            },

            _countIndex: function () {
                var attrs = this.model.toJSON();
                    initialCoords = attrs.selArea.rings[0].ring.points._latlngs;
                    coords = attrs.coords ? attrs.coords : initialCoords;
                    dims = this._getLatLngDimensions(coords);

                if (attrs.xStep && attrs.yStep) {
                    xCount = Math.ceil(dims.width / this._convertXStep(attrs.xStep));
                    yCount = Math.ceil(dims.height / this._convertYStep(attrs.yStep));
                    indexCount = xCount * yCount;

                    if (!attrs.xStepErr && !attrs.yStepErr) {
                        if (indexCount > MAX_INDEX_COUNT) {
                            this.model.set('indexCountErr', true);
                        } else {
                            this.model.set('indexCountErr', false);
                        }
                    this.model.set('xCount', xCount);
                    this.model.set('yCount', yCount);
                    this.model.set('indexCount', indexCount);
                    }
                } else {
                    this.model.set('xCount', null);
                    this.model.set('yCount', null);
                    this.model.set('indexCount', null);
                }
            },

            _getBounds: function (latLngs) {
                var lats,
                    lngs,
                    bottomLeft,
                    topRight;

                lats = [latLngs[0].lat, latLngs[1].lat, latLngs[2].lat, latLngs[3].lat];
                lngs = [latLngs[0].lng, latLngs[1].lng, latLngs[2].lng, latLngs[3].lng];
                bottomLeft = L.latLng(this._getMin(lats), this._getMin(lngs));
                topRight = L.latLng(this._getMax(lats), this._getMax(lngs));

                return L.latLngBounds(bottomLeft, topRight);
            },

            _removeFrame: function () {
                var attrs = this.model.toJSON();

                if (!attrs.selArea) {
                    return;
                }

                attrs.lmap.gmxDrawing.remove(attrs.selArea);

                this.model.set({
                    selArea: null,
                    coords: null
                });
            },

            _updateCoords: function () {
                var attrs = this.model.toJSON(),
                    initialCoords,
                    screenCoords,
                    dimensions,
                    bounds;

                if (!attrs.selArea) {
                    return;
                }

                initialCoords = attrs.selArea.rings[0].ring.points._latlngs;

                if (!attrs.coords) {
                    this.model.set('coords', initialCoords);
                }
            },

            _updateCorners: function () {
                var attrs = this.model.toJSON(),
                    initialCoords = attrs.selArea.rings[0].ring.points._latlngs,
                    bounds = this._getBounds(initialCoords);

                this.model.set({
                    minLat: bounds.getSouth(),
                    minLng: bounds.getWest(),
                    maxLat: bounds.getNorth(),
                    maxLng: bounds.getEast()
                });
            },

            _revertCoords: function (coords) {
                var xx,
                    yy,
                    bottomLeft, topLeft,
                    topRight, bottomRight;

                xx = [coords[0].x, coords[1].x, coords[2].x, coords[3].x];
                yy = [coords[0].y, coords[1].y, coords[2].y, coords[3].y];
                bottomLeft = L.point(this._getMin(xx), this._getMax(yy));
                topLeft = L.point(this._getMin(xx), this._getMin(yy));
                topRight = L.point(this._getMax(xx), this._getMin(yy));
                bottomRight = L.point(this._getMax(xx), this._getMax(yy));

                return [bottomLeft, topLeft, topRight, bottomRight];

            },

            _revertLatLngs: function (latlngs) {
                var lats,
                    lngs,
                    bottomLeft, topLeft,
                    topRight, bottomRight;

                lats = [latlngs[0].lat, latlngs[1].lat, latlngs[2].lat, latlngs[3].lat];
                lngs = [latlngs[0].lng, latlngs[1].lng, latlngs[2].lng, latlngs[3].lng];
                bottomLeft = L.latLng(this._getMin(lats), this._getMin(lngs));
                topLeft = L.latLng(this._getMax(lats), this._getMin(lngs));
                topRight = L.latLng(this._getMax(lats), this._getMax(lngs));
                bottomRight = L.latLng(this._getMin(lats), this._getMax(lngs));

                return [bottomLeft, topLeft, topRight, bottomRight];
            },

            _convertFromLatLngs: function (latlngs, zoom) {
                var attrs = this.model.toJSON(),
                    converted = latlngs.map(function(ll) {
                        return attrs.lmap.project([ll.lat, ll.lng], zoom);
                    });

                return converted;
            },

            _convertToLantLngs: function (points, zoom) {
                var attrs = this.model.toJSON(),
                    converted = points.map(function(point) {
                        return attrs.lmap.unproject([point.x, point.y], zoom);
                    });

                return converted;
            },

            _convertToMercator: function (latlngs) {
                var attrs = this.model.toJSON(),
                    converted = latlngs.map(function(ll) {
                        return attrs.lmap.options.crs.project(ll);
                    });

                return converted;
            },

            _convertYStep: function (value) {
                return value / KM_PER_DEGREE;
            },

            _convertXStep: function (value) {
                var attrs = this.model.toJSON(),
                    centerLat = attrs.minLat + ((attrs.maxLat - attrs.minLat) / 2),
                    centerY = (centerLat * Math.PI) / 180;

                return (value / KM_PER_DEGREE) / Math.cos(centerY);
            },

            _getLatLngDimensions: function (latlngs) {
                var bottomLeft, topRight,
                    width, height;

                latlngs = this._revertLatLngs(latlngs);

                bottomLeft = latlngs[0];
                topRight = latlngs[2];
                width = Math.abs(topRight.lng - bottomLeft.lng);
                height = Math.abs(topRight.lat - bottomLeft.lat);

                return {
                    width: width,
                    height: height
                }
            },

            // get array of string letters (['A'...'Z', 'AA'...'ZZ'...])
            _getLetterIndexes: function (number) {
                var convert = function(srcNum, scrDict, targetDict) {
                   var targetNum = "";
                   for (var idx in srcNum) {
                      var srcDictIdx = scrDict.search(srcNum[idx]);
                      targetNum += targetDict[srcDictIdx]
                   }
                   return targetNum;
                }

                var buildLettersArray = function (num) {
                    var xlsDict = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                        jsDict  = "0123456789abcdefghijklmnop",
                        radix = xlsDict.length,
                        numStart = 0,
                        numEnd = num,
                        rnt = [];

                    for (var col = numStart; col <= numEnd; col++) {
                       // Unfortunately, the situation is not ideal, we have A...Z and then
                       // AA ... AZ, while A represents the zero digit, so in numbers it is
                       // like having 0..9 and then 00..09 and only then 10...19
                       // so we artificially emulate 00...09 situation here
                       var prefix = "";
                       var numb = col;
                       if (col >= radix) {
                           numb = col - radix;
                       }
                       if (col >= radix && col < radix*2) {
                           prefix = "A";
                       }
                       var jsNum = Number(numb).toString(radix);
                       rnt.push(prefix + convert(jsNum, jsDict, xlsDict));
                    }
                    return rnt;
                };

                return buildLettersArray(number);
            },

            _getDimensions: function(points) {
                var attrs = this.model.toJSON(),
                    bottomLeft, topRight,
                    width, height,
                    x, y;

                points = this._revertCoords(points);
                bottomLeft = points[0];
                topRight = points[2];
                width = Math.abs(topRight.x - bottomLeft.x);
                height = Math.abs(bottomLeft.y - topRight.y);

                return {
                    width: width,
                    height: height
                }
            },

            _getMax: function(arr) {
                return Math.max.apply(null, arr);
            },

            _getMin: function(arr) {
                return Math.min.apply(null, arr);
            },

            _roundInputNumber: function (value) {
                value = (typeof(value) === 'String') ? value : String(value);
                if (value.indexOf(".") != '-1') {
                    value = value.substring(0,value.indexOf(".") + 5);
                }
                return value;
            }
        });

        view = new IndexGridView();

        this.Load = function () {
            var lm = model.get('lm');

            if (lm != null) {
                var alreadyLoaded = lm.createWorkCanvas('mapIndexGrid', this.Unload);
                if (!alreadyLoaded) {
                    $(lm.workCanvas).append(view.el);
                }
            }
        }
        this.Unload = function () {
            var attrs = model.toJSON();
            attrs.lmap.gmxDrawing.remove(attrs.selArea);
            model.set({
                selArea: null,
                xStep: 1,
                yStep: 1,
                xCount: null,
                yCount: null,
                xStepErr: false,
                yStepErr: false,
                indexCount: null,
                indexCountErr: false,
                maxLat: null,
                maxLng: null,
                minLat: null,
                minLng: null,
                maxLatErr: false,
                minLatErr: false,
                maxLngErr: false,
                minLngErr: false,
                z: attrs.lmap.getZoom(),
                coords: null
            });
        };
    }

    var publicInterface = {
        pluginName: 'IndexGrid',
        IndexGridMenu: IndexGridMenu
  };

    window.gmxCore.addModule('IndexGrid',
        publicInterface
    );
})();

var nsGmx = window.nsGmx || {},
    _gtxt = window._gtxt,
    Handlebars = window.Handlebars;

(function($) {

    window._translationsHash.addtext('rus', {
        photoLayer: {
            catalog: "Каталог",
            newCatalog: "в новый каталог",
            existingCatalog: "в существующий каталог",
            placeholder: "Введите имя каталога",
            name: "Имя каталога",
            available: "доступные каталоги",
            load: "Загрузить фотографии",
            loadShort: "ЗАГРУЗИТЬ",
            processing: "обработка изображений",
            error: "ошибка",
            successResult: "загружено фотографий",
            exifError: "ошибка чтения координат",
            ok: "готово"
        }
    });

    window._translationsHash.addtext('eng', {
        photoLayer: {
            catalog: "Catalog",
            newCatalog: "into new catalog",
            existingCatalog: "into existing catalog",
            placeholder: "Type catalog name",
            name: "name",
            available: "available catalogs",
            load: "Load photos",
            loadShort: "LOAD",
            processing: "image processing",
            error: "error",
            successResult: "images uploaded",
            exifError: "coordinates error",
            ok: "done"
        }
    });

    var PhotoLayer = function () {
        var dialog;

    var PhotoLayerModel = window.Backbone.Model.extend({
        defaults: {
            fileName: null,
            photoLayersFlag: false,
            currentPhotoLayer: null,
            photoLayers: [],
            sandbox: ''
        }
    });


    var PhotoLayerView = window.Backbone.View.extend({
        tagName: 'div',
        model: new PhotoLayerModel(),
        template: Handlebars.compile('' +
            '<div class="photolayer-ui-container photolayer-properties-container">' +
                '<div class="photolayer-ui-container photolayer-catalog-selector-container">' +
                    '{{#if photoLayersFlag}}' +
                    '<span class="select-catalog-button existing-catalog-button">{{i "photoLayer.existingCatalog"}}</span>' +
                    '{{/if}}' +
                    '<span class="select-catalog-button new-catalog-button">{{i "photoLayer.newCatalog"}}</span>' +
                '</div>' +
                '<div class="photolayer-ui-container photolayer-newlayer-input-container"' +
                '{{#if photoLayersFlag}}' +
                'style="display:none"' +
                '{{/if}}' +
                '>' +
                    '<span class="photolayer-title photolayer-name-title">{{i "photoLayer.name"}}</span>' +
                    '<input type="text" class="photolayer-name-input photolayer-newlayer-input minInputStyle"/>' +
                '</div>' +
                '<div class="photolayer-ui-container photolayer-existinglayer-input-container" ' +
                '{{#unless photoLayersFlag}}' +
                'style="display:none"' +
                '{{/unless}}' +
                '>' +
                    '<span class="photolayer-title photolayer-name-title">{{i "photoLayer.name"}}</span>' +
                    '<select class="photolayer-name-input photolayer-existinglayer-input">' +
                        '{{#each this.photoLayers}}' +
                        '<option value="{{this.layer}}"' +
                            '{{#if this.current}} selected="selected"{{/if}}>' +
                            '{{this.layer}}' +
                        '</option>' +
                        '{{/each}}' +
                    '</select>' +
                '</div>' +
                '<div class="photolayer-ui-block photolayer-loader-block">' +
                        '<label class="photo-uploader-label">' +
                        '<span class="photo-uploader-button">{{i "photoLayer.loadShort"}}</span>' +
                            '<form id="photo-uploader-form" name="photouploader" enctype="multipart/form-data" method="post">' +
                                '<input type="file" name="file" id="photo-uploader" accept="image/*" multiple></input>' +
                            '</form>' +
                        '</label>' +
                    '<span class="photolayer-progress-container">' +
                        '<span class="progressbar"></span>' +
                    '</span>' +
                    '<span class="photolayer-spin-container" style="display:none">' +
                        '<img src="img/progress.gif"/>' +
                        '<span class="spin-message">{{i "photoLayer.processing"}}</span>' +
                    '</span>' +
                    '<span class="photolayer-ui-container photolayer-ok-button-container" style="display:none">' +
                        '<span class="ok-button">{{i "photoLayer.ok"}}</span>' +
                    '</span>' +
                    '<span class="photolayer-error-message" style="display:none"></span>' +
                '</div>' +
                '<div class="photo-upload-result photo-upload-result-uploaded" style="display:none">' +
                '</div>' +
                '<div class="photo-upload-result photo-upload-result-error" style="display:none">' +
                '</div>' +
            '</div>'
        ),

        events: {
            'click .select-catalog-button': 'setCatalogType',
            'keyup .photolayer-newlayer-input': 'setName',
            'change .photolayer-existinglayer-input': 'setCurrentLayer',
            'change #photo-uploader': 'selectFile'
        },

        initialize: function () {
            this.getPhotoLayers();
            this.createSandbox();
            this.render();

            this.listenTo(this.model, 'change:fileName', this.updateName);
            this.listenTo(this.model, 'change:photoLayers', this.updatePhotoLayersList);
        },

        render: function () {
            var attrs = this.model.toJSON();

            this.$el.html(this.template(this.model.toJSON()));
            this.updatePhotoLayersList();

            var firstButton = this.$('.select-catalog-button')[0],
                uploadBlock = this.$('.photo-uploader-label').add(this.$('.photo-uploader-button'));

            $(firstButton).addClass('active');

            $(uploadBlock).toggleClass('gmx-disabled', !attrs.photoLayersFlag);
            this.$('.photolayer-newlayer-input').prop('placeholder', _gtxt('photoLayer.placeholder'))
        },

        getPhotoLayers: function (layers) {
            var layers = layers || nsGmx.gmxMap.layers,
                attrs = this.model.toJSON(),
                photoLayersFlag = attrs.photoLayersFlag,
                currentPhotoLayer,
                photoLayers = [];

            for (var i = 0; i < layers.length; i++) {
                var layer = layers[i],
                    props = layer.getGmxProperties(),
                    isPhotoLayer;

                if (props) {
                    isPhotoLayer = props.IsPhotoLayer;

                    if (isPhotoLayer && props.Access === 'edit') {
                        photoLayersFlag = true;

                        photoLayers.push({layer: props.title, LayerID: props.LayerID, current: false});
                    }
                }

                for (var j = 0; j < photoLayers.length; j++) {
                    photoLayers[j].current = j === 0;

                    if (j === 0) {
                        currentPhotoLayer = nsGmx.gmxMap.layersByID[photoLayers[j].LayerID];
                    }
                }
            }

            this.model.set({
                photoLayersFlag: photoLayersFlag,
                photoLayers: photoLayers,
                currentPhotoLayer: currentPhotoLayer
            });
        },

        setCatalogType: function (e) {
            var attrs = this.model.toJSON(),
                newCatalog = $(e.target).hasClass('new-catalog-button'),
                newContainer = $('.photolayer-newlayer-input-container'),
                existingContainer = $('.photolayer-existinglayer-input-container'),
                newLayerInput = this.$('.photolayer-newlayer-input'),
                uploadBlock = this.$('.photo-uploader-label').add(this.$('.photo-uploader-button'));

            if (newCatalog) {
                $(uploadBlock).toggleClass('gmx-disabled', !attrs.fileName);
                $(newContainer).toggle(true);
                $(existingContainer).toggle(false);
                $(e.target).toggleClass('active', true);
                $('.existing-catalog-button').toggleClass('active', false);
                $(newLayerInput).focus();

                this.model.set({
                    photoLayers: [],
                    fileName: null,
                    currentPhotoLayer: null
                });

                this.createSandbox();
            } else {
                this.getPhotoLayers();
                $(uploadBlock).toggleClass('gmx-disabled', false);
                $(existingContainer).toggle(true);
                $(newContainer).toggle(false);
                $(e.target).toggleClass('active', true);
                $('.new-catalog-button').toggleClass('active', false);
            }
        },

        createSandbox: function () {
            var _this = this;

            window.sendCrossDomainJSONRequest(window.serverBase + 'Sandbox/CreateSandbox', function(response) {
                if (parseResponse(response) && response.Result) {
                    _this.model.set('sandbox', response.Result.sandbox);
                }
            });
        },

        setName: function (e) {
            var layers = layers || nsGmx.gmxMap.layers,
                attrs = this.model.toJSON(),
                start = e.target.selectionStart,
                end = e.target.selectionEnd,
                matchingLayer;

            for (var i = 0; i < layers.length; i++) {
                var layer = layers[i],
                    props = layer.getGmxProperties();

                if (props) {
                    if (e.target.value === props.title) {
                        matchingLayer = layer;
                    }
                }
            }

            this.model.set('fileName', e.target.value);

            this.model.set('currentPhotoLayer', matchingLayer ? matchingLayer : null);

            // восстановим позицию курсора
            e.target.setSelectionRange(start, end);
        },

        setCurrentLayer: function (e) {
            var layers = nsGmx.gmxMap.layers,
                currentPhotoLayer;


            for (var i = 0, len = layers.length; i < len; i++) {
                var layer = layers[i],
                    props = layer.getGmxProperties();

                if (props && props.title === e.target.value) {
                    currentPhotoLayer = layer;
                    break;
                }
            }

            this.model.set({
                currentPhotoLayer: currentPhotoLayer
            });
        },

        updateName: function () {
            var attrs = this.model.toJSON(),
                newLayerInput = this.$('.photolayer-newlayer-input'),
                uploadBlock = this.$('.photo-uploader-label').add(this.$('.photo-uploader-button'));

            $(newLayerInput).val(attrs.fileName);
            $(uploadBlock).toggleClass('gmx-disabled', !attrs.fileName);
        },

        updatePhotoLayersList: function () {
            var attrs = this.model.toJSON(),
                photoLayers = attrs.photoLayers,
                currentPhotoLayerName = attrs.currentPhotoLayer && attrs.currentPhotoLayer.getGmxProperties().title,
                str = '',
                select = this.$('.photolayer-existinglayer-input');

            if (photoLayers.length) {
                for (var i = 0; i < photoLayers.length; i++) {
                    str += '<option>' + photoLayers[i].layer + '</option>';
                }
            }
            $(select).html(str);

            $('.photolayer-existinglayer-input option[value="' + currentPhotoLayerName + '"]').prop('selected', true);
        },

        selectFile: function (e) {
            var files = e.target.files,
                form = this.$('#photo-uploader-form'),
                arr = [],
                newLayerInput = this.$('.photolayer-newlayer-input'),
                uploadLabel = this.$('.photo-uploader-label'),
                uploadButton = this.$('.photo-uploader-button'),
                progressBarContainer = this.$('.photolayer-progress-container'),
                progressBar = this.$('.progressbar'),
                spinContainer = this.$('.photolayer-spin-container'),
                okButton = this.$('.photolayer-ok-button-container'),
                uploadResSuccess = this.$('.photo-upload-result-uploaded'),
                uploadResError = this.$('.photo-upload-result-error'),
                errorMessage = this.$('.photolayer-error-message');

            for (var key in files) {
                if (files.hasOwnProperty(key)) {
                    arr.push(files[key]);
                }
            }

            $(progressBarContainer).hide();
            $(spinContainer).hide();
            $(okButton).hide();
            $(errorMessage).hide();
            $(uploadResSuccess).hide();
            $(uploadResError).hide();

            var attrs = this.model.toJSON(),
                _this = this,
                files = e.target.files,
                sandbox,
                uploadParams = {
                    sandbox: attrs.sandbox
                },
                params,
                url, def;

                if (attrs.currentPhotoLayer) {
                    params = {
                        LayerID: attrs.currentPhotoLayer.getGmxProperties().LayerID,
                        PhotoSource: JSON.stringify({sandbox: attrs.sandbox})
                    }
                } else {
                    params = {
                        Columns: "[]",
                        Copyright: "",
                        Description: "",
                        SourceType: "manual",
                        title: attrs.fileName,
                        IsPhotoLayer: true,
                        PhotoSource: JSON.stringify({sandbox: attrs.sandbox})
                    }
                };

                $(form).prop('action', window.serverBase + 'Sandbox/Upload' + '?' + $.param(uploadParams));

                var formData = new FormData($(form)[0]);

                formData.append("sandbox", attrs.sandbox);

                for (var i = 0; i < files.length; i++) {
                    formData.append(i, files[i]);
                }

                $(progressBar).progressbar({
                    max: 100,
                    value: 0
                });

                $(progressBarContainer).show();
                var xhr = new XMLHttpRequest();

                xhr.upload.addEventListener("progress", function(e) {
                        $(progressBar).progressbar('option', 'value', e.loaded / e.total * 100);
                }, false);

                xhr.open('POST', window.serverBase + 'Sandbox/Upload');
                $(uploadButton).toggleClass('gmx-disabled', true);
                $(uploadLabel).toggleClass('gmx-disabled', true);
                xhr.withCredentials = true;
                xhr.onload = function () {
                    if (xhr.status === 200) {
                        var response = xhr.responseText;

                        if (!(response)) {
                            return;
                        }

                        $(progressBarContainer).hide();
                        $(spinContainer).show();

                        if (attrs.currentPhotoLayer) {
                            url = window.serverBase + 'Photo/AppendPhoto' + '?' + $.param(params);
                        } else {
                            url = window.serverBase + 'VectorLayer/Insert.ashx' + '?' + $.param(params);
                        }
                        def = nsGmx.asyncTaskManager.sendGmxPostRequest(url);

                        def.done(function(taskInfo){
                            if (!attrs.currentPhotoLayer) {
                                var mapProperties = window._layersTree.treeModel.getMapProperties(),
                                    targetDiv = $(window._queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0],
                                    gmxProperties = {type: 'layer', content: taskInfo.Result},
                                    imageUrlParams = {
                                        LayerID: gmxProperties.content.properties.LayerID,
                                        size: 'M'
                                    },
                                    bigImageUrlParams = {
                                        LayerID: gmxProperties.content.properties.LayerID,
                                        size: 'Native'
                                    },
                                    imageUrl = window.serverBase + 'rest/ver1/photo/getimage.ashx' + '?' + $.param(imageUrlParams) + '&rowId=[gmx_id]',
                                    bigImageUrl = window.serverBase + 'rest/ver1/photo/getimage.ashx' + '?' + $.param(bigImageUrlParams) + '&rowId=[gmx_id]',
                                    balloonString = '' +
                                        '<div style="min-width: 300px;">' +
                                            '<div style="width: 100%; text-align: center;">' +
                                                '<a href="' + bigImageUrl + '" target="_blank">' +
                                                    '<img class="popupImage" src="' + imageUrl + '" alt=""/>' +
                                                '</a>' +
                                            '</div>' +
                                            '<div>' +
                                                '<b>' + window._gtxt("Имя") + ':</b> ' + '[GMX_Filename]' +
                                            '</div>' +
                                            '<div>' +
                                                '<b>' + window._gtxt("Момент съемки") + ':</b> ' + '[GMX_Date]' +
                                            '</div>' +
                                            '<div>' +
                                                '[SUMMARY]' +
                                            '</div>' +
                                        '</div>';

                                gmxProperties.content.properties.mapName = mapProperties.name;
                                gmxProperties.content.properties.hostName = mapProperties.hostName;
                                gmxProperties.content.properties.visible = true;

                                gmxProperties.content.properties.styles = [{
                                    MinZoom: gmxProperties.content.properties.VtMaxZoom,
                                    MaxZoom:21,
                                    Balloon: balloonString,
                                    RenderStyle: _mapHelper.defaultPhotoIconStyles[gmxProperties.content.properties.GeometryType]
                                }];

                                // вставляем фотослой на карту
                                var modifyMapObjects = [{
                                        Action: 'insert',
                                        index: 'top',
                                        LayerName: gmxProperties.content.properties.LayerID,
                                        Styles: gmxProperties.content.properties.styles
                                    }],
                                    modifyMapParams = {
                                        MapName: mapProperties.MapID,
                                        Objects: JSON.stringify(modifyMapObjects)
                                    }
                                    modifyMapUrl = window.serverBase + 'Map/ModifyMap.ashx' + '?' + $.param(modifyMapParams);

                                // вставляем фотографии в пустой слой
                                var photoAppendParams = {
                                        LayerID: gmxProperties.content.properties.LayerID,
                                        PhotoSource: JSON.stringify({sandbox: attrs.sandbox})
                                    },
                                    photoAppendUrl = window.serverBase + 'Photo/AppendPhoto' + '?' + $.param(photoAppendParams);

                                window.sendCrossDomainJSONRequest(modifyMapUrl, function (res) {
                                    var def = nsGmx.asyncTaskManager.sendGmxPostRequest(photoAppendUrl);

                                    def.done(function(taskInfo) {

                                        parseGeometry(taskInfo, gmxProperties);

                                        window._layersTree.copyHandler(gmxProperties, targetDiv, false, true);

                                        var newLayer = nsGmx.gmxMap.layersByID[gmxProperties.content.properties.LayerID];

                                        newLayer.bindClusters({
                                            iconCreateFunction: function(cluster) {
                                                var photoClusterIcon = L.divIcon({
                                                    html: '<img src="http://maps.kosmosnimki.ru/api/img/camera18.png" class="photo-icon"/><div class="marker-cluster-photo">' + cluster.getChildCount() + '</div>',
                                                    className: 'photo-div-icon',
                                                    iconSize: [14, 12],
                                                    iconAnchor: [0, 0]
                                                });
                                                return photoClusterIcon;
                                            },
                                            maxClusterRadius: 40,
                                            spiderfyOnMaxZoom: true,
                                            spiderfyDistanceMultiplier: 1.2,
                                            disableClusteringAtZoom: 19,
                                            maxZoom: 19
                                        });

                                        // newLayer.updateVersion(gmxProperties.content);

                                        _this.model.set({
                                            currentPhotoLayer: newLayer
                                        });

                                        afterLoad(taskInfo);
                                    })
                                    .fail(function(taskInfo) {
                                        var message = taskInfo.ErrorInfo && taskInfo.ErrorInfo.ErrorMessage;

                                        $(errorMessage).html(message in _mapHelper.customErrorsHash  ? _gtxt(_mapHelper.customErrorsHash[message]) : _gtxt('photoLayer.error'));
                                        $(errorMessage).show();
                                        afterLoad(taskInfo);
                                    }).progress(function(taskInfo){
                                    });
                                });

                            $(newLayerInput).focus();

                            } else {
                                var curName = attrs.currentPhotoLayer.getGmxProperties().name;
                                // parseGeometry(taskInfo, gmxProperties);
                                // window.sendCrossDomainJSONRequest(window.serverBase + "Layer/GetLayerJson.ashx?WrapStyle=func&LayerName=" + curName, function(response) {
                                //     if (!parseResponse(response)) {
                                //         return;
                                //     }
                                //     debugger;
                                //     console.log(response);
                                //     // L.gmx.layersVersion.chkVersion(response.Result, null);
                                //     attrs.currentPhotoLayer.updateVersion(response.Result);
                                // });
                                // L.gmx.layersVersion.chkVersion(gmxProperties.content);
                                // attrs.currentPhotoLayer.updateVersion(gmxProperties.content);

                                afterLoad(taskInfo);
                            }

                        }).fail(function(taskInfo){
                            var message = taskInfo.ErrorInfo && taskInfo.ErrorInfo.ErrorMessage;

                            $(errorMessage).html(message in _mapHelper.customErrorsHash  ? _gtxt(_mapHelper.customErrorsHash[message]) : _gtxt('photoLayer.error'));
                            $(errorMessage).show();
                            afterLoad(taskInfo);

                        }).progress(function(taskInfo){
                        });
                    };

                    function parseGeometry(info, properties) {
                        var coords = [],
                            appended = info.Result.Appended,
                            updated = info.Result.Updated,
                            addCoords = function (objects, coordinates) {
                                for (var a = 0; a < objects.length; a++) {
                                    if (objects[a].longitude && objects[a].latitude) {
                                        var point = nsGmx.leafletMap.options.crs.project(L.latLng(objects[a].longitude, objects[a].latitude));
                                        coordinates.push([point.x, point.y]);
                                    }
                                }
                            };

                        addCoords(appended, coords);
                        addCoords(updated, coords);

                        if (!coords.length) {
                            properties.content.geometry = null;
                        } else {
                            properties.content.geometry.coordinates = coords.length === 1 ? coords[0] : coords;
                            properties.content.geometry.type = coords.length === 1 ? 'POINT' : 'POLYGON';
                        }
                    }

                    function afterLoad(taskInfo) {
                        var resObj = taskInfo.Result;

                        if (resObj) {
                            if (resObj.Appended.length) {
                                $(uploadResSuccess).html(_gtxt('photoLayer.successResult') + ": " + resObj.Appended.length);
                                $(uploadResSuccess).show();
                            }
                            if (resObj.NoCoords.length) {
                                $(uploadResError).html(_gtxt('photoLayer.exifError') + ": " + resObj.NoCoords.length);
                                $(uploadResError).show();
                            }
                        }

                        $(spinContainer).hide();

                        $(uploadButton).toggleClass('gmx-disabled', false);
                        $(uploadLabel).toggleClass('gmx-disabled', false);
                        _this.createSandbox();
                    }
                };

            xhr.send(formData);
        }
    });

    this.Load = function () {
        var view = new PhotoLayerView(),
            resizeFunc = function () {
            },
            closeFunc = function () {
                view.model.set({
                    photoLayersFlag: false,
                    photoLayers: [],
                    currentPhotoLayer: null,
                    photoLayers: []
                });
            };

        dialog = nsGmx.Utils.showDialog(_gtxt('photoLayer.load'), view.el, 340, 220, null, null, resizeFunc, closeFunc);
    }

    this.Unload = function () {
        $(dialog).remove();
    };
};

var publicInterface = {
    pluginName: 'PhotoLayer',
    PhotoLayer: PhotoLayer
};

window.gmxCore.addModule('PhotoLayer',
    publicInterface
);

})(jQuery);

var nsGmx = nsGmx || {};

(function($){

/**
Фильтрует слои со спутниковыми покрытиями по интервалу дат и облачности. Поддерживает фильтрацию дополнительных карт.
* @class 
*/
var CoverControl = function()
{
	this.cloudsIndexes = [];
	this.currCloudsIndex = 4;
	this.commonStyles = null;
	this.cloudsCount = 0;
	this.coverLayers = [];
}

/**
* @function
*/
CoverControl.prototype.saveState = function()
{
	return { currCloudsIndex: this.currCloudsIndex };
}

/**
* @function
*/
CoverControl.prototype.loadState = function( data )
{
	this.currCloudsIndex = data.currCloudsIndex;
	
	$("#MapCalendar .ui-slider").slider("value", data.currCloudsIndex );
	
	if (typeof this.cloudsIndexes[data.currCloudsIndex] !== 'undefined')
		_title($("#MapCalendar .ui-slider")[0].firstChild, this.cloudsIndexes[data.currCloudsIndex].name);
}

CoverControl.prototype._updateStyles = function()
{
	if ( this.commonStyles || this.coverLayers.length == 0 ) return;
	
	var commonStyles = globalFlashMap.layers[this.coverLayers[0]].properties.styles,
		cloudsCount = 0;
	
	for (var i = 0; i < this._icons.length; i++)
		this.cloudsIndexes.push({icon:this._icons[i]});
	
	for (var i = 0; i < commonStyles.length; ++i)
	{
		if (this.cloudsIndexes[i])
			this.cloudsIndexes[i].name = commonStyles[i].Name;
		
		cloudsCount++;
	}
	
	if ( typeof this._initCloudIndex !== 'undefined' )
		this.currCloudsIndex = this._initCloudIndex;
		
	this.cloudsCount = Math.round(cloudsCount / 2);
	this.commonStyles = commonStyles;
	
	if (typeof this.cloudsIndexes[this.currCloudsIndex] !== 'undefined' && $("#MapCalendar .ui-slider").length > 0)
		_title($("#MapCalendar .ui-slider")[0].firstChild, this.cloudsIndexes[this.currCloudsIndex].name);
}

CoverControl.prototype._updateLayers = function()
{
	if (typeof _mapHelper === 'undefined') return;
	//проверим основную карту
	this.coverLayers = nsMapCommon.selectLayersFromTree( globalFlashMap, _layersTree._mapTree, this._coverLayersDescription ).names();

	//и все дополнительные тоже будем фильтровать
	if (typeof _queryExternalMaps.mapsCanvas != 'undefined')
	{
		for (var m = 0; m < _queryExternalMaps.mapsCanvas.childNodes.length; m++)
		{
			var mapElem = _queryExternalMaps.mapsCanvas.childNodes[m].childNodes[0];
			if (mapElem.extLayersTree)
				this.coverLayers = this.coverLayers.concat( nsMapCommon.selectLayersFromTree( globalFlashMap, mapElem.extLayersTree._mapTree, this._coverLayersDescription ).names() );
		}
	}
}

CoverControl.prototype._addWidget = function()
{
	if (this.cloudsIndexes.length == 0 || !this._parent ) return;
	
	var	cloudsSlider = nsGmx.Controls.createSlider(this.currCloudsIndex, function(){}),
		_this = this;
	
	$(cloudsSlider).slider("option", "step", 1);
	$(cloudsSlider).slider("option", "min", 0);
	$(cloudsSlider).slider("option", "max", this.cloudsIndexes.length - 1);
	$(cloudsSlider).slider("option", "value", this.currCloudsIndex);
	$(cloudsSlider).bind("slidestop", function(event, ui)
	{
		_this.currCloudsIndex = ui.value;
		
		_this.setFilters();
		
		_title(cloudsSlider.firstChild, _this.cloudsIndexes[_this.currCloudsIndex].name);
	});
	
	cloudsSlider.style.margin = '10px 3px';
	
	// добавляем раскраску
	cloudsSlider.style.backgroundImage = '';
	var colorTds = [];
	for (var i = 1; i < this.cloudsCount; i++)
	{
		colorTds.push(_td(null,[['css','width', Math.round(100 / (this.cloudsCount - 1)) + 'px'], ['css','height','7px'], ['css','backgroundColor', nsGmx.Utils.convertColor(this.commonStyles[i].RenderStyle.fill.color)]]))
	}
	
	_(cloudsSlider, [_table([_tbody([_tr(colorTds)])],[['css','position','absolute'],['css','left','0px'],['css','top','0px'],['css','border','1px solid #999999']])])
	
	_title(cloudsSlider, _gtxt("Облачность"));
	_title(cloudsSlider.firstChild, this.cloudsIndexes[this.currCloudsIndex].name);
	
	var cloudsLabelDiv = _div(null,[['css','height','16px'],['css','position','relative']]);
	
	for (var i = 0; i < this.cloudsIndexes.length; ++i)
	{
		var img = _img(null,[['attr','src',this.cloudsIndexes[i].icon],['css','position','absolute']]);
		
		img.style.left = (25 * i - 5) + 'px';
		
		_title(img, this.cloudsIndexes[i].name)
		
		_(cloudsLabelDiv, [img])
	}
	
	var trs = [];
	
	trs.push(_tr([_td(),_td([_span([_t(_gtxt("Облачность"))],[['css','fontSize','12px'],['css','margin','0px 10px 0px 7px']])]), _td([cloudsLabelDiv,cloudsSlider],[['attr','colSpan',2]])]));
	trs.push(_tr([_td(null, [['attr','colSpan',2],['css','height','5px']])]));
	
	_(this._parent, [_table([_tbody(trs)],[['css','marginLeft','20px']])]);
	this._parent = null;
}

/**
* @function
* @param {Array} coverLayersDescription Массив имён слоёв для фильтрации
* @param {String} dateAttribute Имя аттрибута слоёв с датой
* @param {String} cloudsAttribute Имя аттрибута слоёв с облачностью
* @param {Array} icons Массив с именами иконок для облачности
* @param {Integer} initCloudIndex Начальная облачность
* @param {nsGmx.Calendar} calendar Календарик, из которого нужно быть интервал дат
* @param {Object} params Остальные параметры виджета (dateFormat, useTimePostfix)
*/
CoverControl.prototype.init = function(coverLayersDescription, dateAttribute, cloudsAttribute, icons, initCloudIndex, calendar, params)
{
	this._params = $.extend({dateFormat: 'yy-mm-dd', useTimePostfix: false}, params);
	this._coverLayersDescription = coverLayersDescription;
	this._initCloudIndex = initCloudIndex;
	this._icons = icons;
	this._calendar = calendar;
	
	this.dateAttribute = dateAttribute;
	this.cloudsAttribute = cloudsAttribute;
	
	this._updateLayers();
	
	this._updateStyles();
	
	var _this = this;
	
	if (typeof _queryExternalMaps !== 'undefined')
	{
		$(_queryExternalMaps).bind('map_loaded', function()
		{
			_this._updateLayers();
			_this._updateStyles();
			_this._addWidget();
			_this.setFilters();
		});
	}
	
	setInterval(function(){
		_this.fixLayers.apply(_this);
	}, 300);
	
	var updateDates = function()
	{
		_this.dateBegin = _this._calendar.getDateBegin();
		_this.dateEnd = _this._calendar.getDateEnd();
	
		_this.setFilters();
	}
	
	$(calendar).change( updateDates );
	updateDates();
}

CoverControl.prototype.fixLayers = function()
{
	for (var i = 0; i < this.coverLayers.length; ++i)
	{
		var layerId = globalFlashMap.layers[this.coverLayers[i]].properties.LayerID,
			div = $("[LayerID='" + layerId + "']");
		
		if (!div.length)
			continue;
		
		$(div[0]).children("[multiStyle]").hide();
		
		if (typeof _mapHelper == 'undefined') continue;
		
		if ($(div[0]).children("[styleType='multi']").length) {
			var icon = nsGmx.Controls.createGeometryIcon(globalFlashMap.layers[this.coverLayers[i]].properties.styles[0], "polygon");
				
			// if ($.browser.msie)
			// {
				// icon.style.width = '9px';
				// icon.style.height = '13px';
				// icon.style.margin = '0px 3px -3px 1px';
			// }
			
			_title(icon, _gtxt("Редактировать стили"));
			
			icon.geometryType = "polygon";
			
			icon.onclick = function()
			{
				_mapHelper.createLayerEditor(this.parentNode, _layersTree, 'styles', -1);
			}
			
			$(div[0]).children("[styleType='multi']").replaceWith(icon);
		}
	}
}

CoverControl.prototype.setFilters = function()
{
	for (var i = 0; i < this.coverLayers.length; ++i)
	{
		var name = this.coverLayers[i],
			layer = globalFlashMap.layers[name];
		
		if (!layer)
			continue;
		
		var	properties = layer.properties;
		
		var timePostfixBegin = this._params.useTimePostfix ? " 00:00:00" : "";
		var timePostfixEnd   = this._params.useTimePostfix ? " 23:59:59" : "";
		
		var filterString = "`" + this.dateAttribute + "` >= '" + $.datepicker.formatDate(this._params.dateFormat, this.dateBegin) + timePostfixBegin + "'" + " AND " + "`" + this.dateAttribute + "` <= '" + $.datepicker.formatDate(this._params.dateFormat, this.dateEnd) + timePostfixEnd + "'",
			filters = layer.filters;
		
		for (var j = 0; j < this.cloudsCount; j++)
		{
			var lastFilter = properties.styles[j].Filter;
			
			if (j <= this.currCloudsIndex)
			{
				filters[j].setVisible(true);
				filters[j + this.cloudsCount].setVisible(true);
				filters[j].setFilter((lastFilter && lastFilter != "") ? ("(" + lastFilter + ") AND" + filterString) : filterString);
				filters[j + this.cloudsCount].setFilter((lastFilter && lastFilter != "") ? ("(" + lastFilter + ") AND" + filterString) : filterString);
			}
			else
			{
				filters[j].setVisible(false);
				filters[j + this.cloudsCount].setVisible(false);
			}
		}
	}
}

/**
* Добавляет в DOM контрол фильтрации по облачности
* @function
* @param {DOMElement} parent Контейнер для добавляения контрола
*/
CoverControl.prototype.add = function(parent)
{
	this._parent = parent;
	this._updateLayers();
	this._updateStyles();
	this._addWidget();
	
}

if ( typeof gmxCore !== 'undefined' )
{
	gmxCore.addModule('CoverControl', {
		CoverControl: CoverControl
	});
}

nsGmx.CoverControl = CoverControl;

})(jQuery);
var nsGmx = nsGmx || {};

(function($){

/**
Фильтрует слои со спутниковыми покрытиями по облачности. Поддерживает фильтрацию дополнительных карт.
* @class 
*/
var CoverControl2 = function()
{
	this.cloudsIndexes = [];
	this.currCloudsIndex = 4;
	this.commonStyles = null;
	this.cloudsCount = 0;
	this.coverLayers = [];
    this._parent = null;
    
    CoverControlInstance.addInstance(this);
}

/**
* @function
*/
CoverControl2.prototype.saveState = function()
{
	return { currCloudsIndex: this.currCloudsIndex };
}

/**
* @function
*/
CoverControl2.prototype.loadState = function( data )
{
	this.currCloudsIndex = data.currCloudsIndex;
	
	$(".ui-slider", this._parent).slider("value", data.currCloudsIndex );
	
	if (typeof this.cloudsIndexes[data.currCloudsIndex] !== 'undefined')
		_title($(".ui-slider", this._parent)[0].firstChild, this.cloudsIndexes[data.currCloudsIndex].name);
}

CoverControl2.prototype._updateStyles = function()
{
	if ( this.commonStyles || this.coverLayers.length == 0 || !(this.coverLayers[0] in globalFlashMap.layers) ) return;
	
	var commonStyles = globalFlashMap.layers[this.coverLayers[0]].properties.styles,
		cloudsCount = 0;
	
	for (var i = 0; i < this._icons.length; i++)
		this.cloudsIndexes.push({icon:this._icons[i]});
	
	for (var i = 0; i < commonStyles.length; ++i)
	{
		if (this.cloudsIndexes[i])
			this.cloudsIndexes[i].name = commonStyles[i].Name;
		
		cloudsCount++;
	}
	
	if ( typeof this._initCloudIndex !== 'undefined' )
		this.currCloudsIndex = this._initCloudIndex;
		
	this.cloudsCount = Math.round(cloudsCount / 2);
	this.commonStyles = commonStyles;
	
	if (typeof this.cloudsIndexes[this.currCloudsIndex] !== 'undefined' && $(".ui-slider", this._parent).length > 0)
		_title($(".ui-slider", this._parent)[0].firstChild, this.cloudsIndexes[this.currCloudsIndex].name);
}

CoverControl2.prototype._updateLayers = function()
{
	if (typeof _mapHelper === 'undefined') return;
    
	//проверим основную карту
	this.coverLayers = nsMapCommon.selectLayersFromTree( globalFlashMap, _layersTree._mapTree, this._coverLayersDescription ).names();

	//и все дополнительные тоже будем фильтровать
	if (typeof _queryExternalMaps.mapsCanvas != 'undefined')
	{
		for (var m = 0; m < _queryExternalMaps.mapsCanvas.childNodes.length; m++)
		{
			var mapElem = _queryExternalMaps.mapsCanvas.childNodes[m].childNodes[0];
			if (mapElem.extLayersTree)
				this.coverLayers = this.coverLayers.concat( nsMapCommon.selectLayersFromTree( globalFlashMap, mapElem.extLayersTree._mapTree, this._coverLayersDescription ).names() );
		}
	}
}

CoverControl2.prototype._addWidget = function()
{
	if (this.cloudsIndexes.length == 0 || !this._parent ) return;
	
	var	cloudsSlider = nsGmx.Controls.createSlider(this.currCloudsIndex, function(){}),
		_this = this;
	
	$(cloudsSlider).slider("option", "step", 1);
	$(cloudsSlider).slider("option", "min", 0);
	$(cloudsSlider).slider("option", "max", this.cloudsIndexes.length - 1);
	$(cloudsSlider).slider("option", "value", this.currCloudsIndex);
	$(cloudsSlider).bind("slidestop", function(event, ui)
	{
		_this.currCloudsIndex = ui.value;
		
		_this.setFilters();
		
		_title(cloudsSlider.firstChild, _this.cloudsIndexes[_this.currCloudsIndex].name);
	});
	
	cloudsSlider.style.margin = '10px 3px';
	
	// добавляем раскраску
	cloudsSlider.style.backgroundImage = '';
	var colorTds = [];
	for (var i = 1; i < this.cloudsCount; i++)
	{
		colorTds.push(_td(null,[['css','width', Math.round(100 / (this.cloudsCount - 1)) + 'px'], ['css','height','7px'], ['css','backgroundColor', nsGmx.Utils.convertColor(this.commonStyles[i].RenderStyle.fill.color)]]))
	}
	
	_(cloudsSlider, [_table([_tbody([_tr(colorTds)])],[['css','position','absolute'],['css','left','0px'],['css','top','0px'],['css','border','1px solid #999999']])])
	
	_title(cloudsSlider, _gtxt("Облачность"));
	_title(cloudsSlider.firstChild, this.cloudsIndexes[this.currCloudsIndex].name);
	
	var cloudsLabelDiv = _div(null,[['css','height','16px'],['css','position','relative']]);
	
	for (var i = 0; i < this.cloudsIndexes.length; ++i)
	{
		var img = _img(null,[['attr','src',this.cloudsIndexes[i].icon],['css','position','absolute']]);
		
		img.style.left = (25 * i - 5) + 'px';
		
		_title(img, this.cloudsIndexes[i].name)
		
		_(cloudsLabelDiv, [img])
	}
    
	var trs = [];
	
	trs.push(_tr([_td(),_td([_span([_t(_gtxt("Облачность"))],[['css','fontSize','12px'],['css','margin','0px 10px 0px 7px']])]), _td([cloudsLabelDiv,cloudsSlider],[['attr','colSpan',2]])]));
	trs.push(_tr([_td(null, [['attr','colSpan',2],['css','height','5px']])]));
	
	_(this._parent, [_table([_tbody(trs)],[['css','marginLeft','20px']])]);
}

/**
* @function
* @param {Array} coverLayersDescription Массив имён слоёв для фильтрации
* @param {String} cloudsAttribute Имя атрибута слоёв с облачностью
* @param {Array} icons Массив с именами иконок для облачности
* @param {Integer} initCloudIndex Начальная облачность
*/
CoverControl2.prototype.init = function(coverLayersDescription, cloudsAttribute, icons, initCloudIndex)
{
	this._coverLayersDescription = coverLayersDescription;
	this._initCloudIndex = initCloudIndex;
	this._icons = icons;
	
	this.cloudsAttribute = cloudsAttribute;
	
	this._updateLayers();
	
	this._updateStyles();
	
	var _this = this;
	
	if (typeof _queryExternalMaps !== 'undefined')
	{
		$(_queryExternalMaps).bind('map_loaded', function()
		{
			_this._updateLayers();
			_this._updateStyles();
			_this._addWidget();
			_this.setFilters();
		});
	}
	
	setInterval(function(){
		_this.fixLayers.apply(_this);
	}, 300);
}

CoverControl2.prototype.fixLayers = function()
{
    if (typeof _mapHelper == 'undefined') return;
    
	for (var i = 0; i < this.coverLayers.length; ++i)
	{
        if (!globalFlashMap.layers[this.coverLayers[i]])
            continue;
            
		var layerId = globalFlashMap.layers[this.coverLayers[i]].properties.LayerID,
			div = $("[LayerID='" + layerId + "']");
		
		if (!div.length)
			continue;
		
		$(div[0]).children("[multiStyle]").hide();
		
		if ($(div[0]).children("[styleType='multi']").length) 
        {
			var icon = nsGmx.Controls.createGeometryIcon(globalFlashMap.layers[this.coverLayers[i]].properties.styles[0], "polygon");
				
			// if ($.browser.msie)
			// {
				// icon.style.width = '9px';
				// icon.style.height = '13px';
				// icon.style.margin = '0px 3px -3px 1px';
			// }
			
			_title(icon, _gtxt("Редактировать стили"));
			
			icon.geometryType = "polygon";
			
            $(div[0]).children("[styleType='multi']").empty().append(icon);
		}
	}
}

CoverControl2.prototype.setFilters = function()
{
	for (var i = 0; i < this.coverLayers.length; ++i)
	{
		var name = this.coverLayers[i],
			layer = globalFlashMap.layers[name];
		
		if (!layer)
			continue;
		
		var filters = layer.filters;
        
		for (var j = 0; j < this.cloudsCount; j++)
		{
			if (j <= this.currCloudsIndex)
			{
				filters[j].setVisible(true);
				filters[j + this.cloudsCount].setVisible(true);
			}
			else
			{
				filters[j].setVisible(false);
				filters[j + this.cloudsCount].setVisible(false);
			}
		}
	}
}

/**
* Добавляет в DOM контрол фильтрации по облачности
* @function
* @param {DOMElement} parent Контейнер для добавляения контрола
*/
CoverControl2.prototype.add = function(parent)
{
	this._parent = parent;
	this._updateStyles();
	this._addWidget();
    $(this).triggerHandler('init');
}

CoverControl2.prototype.getContainer = function()
{
	return this._parent;
}

//предосталяет доступ к первому созданному инстансу CoverControl2
var CoverControlInstance = (function()
{
    var deffered = new $.Deferred();
    var theInstance = null;
    return {
        addInstance: function(coverControl)
        {
            if (theInstance) return;
            
            theInstance = coverControl;
            $(coverControl).bind('init', function()
            {
                deffered.resolve();
            });
        },
        getInstance: function()
        {
            return theInstance;
        },
        whenInited: function(callback)
        {
            deffered.done(callback);
        }
    };
})();

if ( typeof gmxCore !== 'undefined' )
{
	gmxCore.addModule('CoverControl2', {
		CoverControl2: CoverControl2,
        CoverControlInstance: CoverControlInstance
	});
}

nsGmx.CoverControl2 = CoverControl2;

})(jQuery);
var nsGmx = nsGmx || {};

(function($){

/** Управляет видимостью слоёв в зависимости от диапазона дат. 
    Может фильтровать слои только из определённой группы. Работает только с вьюером. Поддерживает фильтрацию в доп. картах.
	@memberOf cover
	@class 
*/
var LayerFiltersControl = function()
{
	var _calendar = null;
	var _groupTitle = null;
	var _layers = null;
	var _map = null;
	
	//по умолчанию слои фильтруются по дате
	var _defaultFilterFunc = function(layer, dateBegin, dateEnd)
	{
		var layerDate = $.datepicker.parseDate('dd.mm.yy', layer.properties.date);
		return dateBegin <= layerDate && layerDate <= dateEnd;
	}
	
	var _filterFunc = _defaultFilterFunc;
	
	var _IterateElems = function(treeElem, callback, parentVisible)
	{
		var visible = parentVisible && (treeElem.content ? treeElem.content.properties.visible : true);
		var childsArr = treeElem.content ? treeElem.content.children : treeElem.children;
		
		for (var i = 0; i < childsArr.length; i++)
		{
			var child = childsArr[i];
			
			if (child.type == 'group')
			{
				callback(child, visible);
				
				_IterateElems(child, callback, visible)
			}
			else
				callback(child, visible);
		}
	}
	
	var _getMapLayersAsHash = function()
	{
		var res = {};
		for (var l = 0;l < _map.layers.length; l++)
			res[_map.layers[l].properties.name] = _map.layers[l];
			
		return res;
	}
	
	var _update = function()
	{
		if (typeof _queryExternalMaps.mapsCanvas != 'undefined')
		{
			for (var m = 0; m < _queryExternalMaps.mapsCanvas.childNodes.length; m++)
			{
				var mapElem = _queryExternalMaps.mapsCanvas.childNodes[m].childNodes[0];
				if (mapElem.extLayersTree)
					_updateTree(mapElem.extLayersTree, mapElem.extLayersTree._mapTree, mapElem);
			}
		}
		
		_updateTree(_layersTree, _layersTree._mapTree, _queryMapLayers.buildedTree);
	}
	
	var _updateTree = function(layersTree, mapTree, domTreeRoot)
	{
		var dateBegin = _calendar.getDateBegin();
		var dateEnd = _calendar.getDateEnd();
		
		var layers = [];
		
		if (_layers)
			layers = nsMapCommon.selectLayersFromTree(_map, mapTree, _layers).asHash();
		else 
			layers = _groupTitle ? nsMapCommon.selectLayersFromTree(_map, mapTree, [{group: _groupTitle}]).asHash() : _getMapLayersAsHash();
		
		_IterateElems( mapTree, function(elem, parentVisible)
		{
			if (elem.content.properties.name in layers)
			{
				var isShowLayer = _filterFunc( layers[elem.content.properties.name], dateBegin, dateEnd );
                layersTree.treeModel.setNodeVisibility(elem, isShowLayer);
			}
		}, true);
	}
	
	/**
	 * @function Инициализитует фильтрацию слоёв. Далее классом будут отслеживаться события календарика.
	 * @param map Основная карта
	 * @param {cover.Calendar} calendar Календарик, который используется для задания дат
	 * @param {Object} params Дополнительные параметры: <br/>
	 *    groupTitle - имя группы, слои в которой нужно фильтровать. Устарело, используйте layers <br/>
	 *    layers - вектор из имён слоёв или указаний на группу, которые нужно фильтровать. Если не задано, будут фильтроваться все слои на карте.<br/>
	 *    filterFunc - ф-ция filterFunc(layer, dateBegin, dateEnd) -> Bool. Возвращает true, если слой нужно показать, false чтобы скрыть. По умолчанию происходит фильтрация по дате слоя.
	 */
	this.init = function(map, calendar, params)
	{
		_map = map;
		
		if ( typeof params != 'undefined' )
		{
			_groupTitle = params.groupTitle;
			_layers = params.layers;
			if (params.filterFunc) 
				_filterFunc = params.filterFunc;
		}
		
		if (_calendar)
			$(_calendar).unbind('change', _update);
			
		_calendar = calendar;
		$(_calendar).bind('change', _update);
		_update();
		
		$(_queryExternalMaps).bind('map_loaded', _update);
	}
	
	this.update = function() { _update() };
}

if ( typeof gmxCore !== 'undefined' )
{
	gmxCore.addModule('LayerFiltersControl', {
		LayerFiltersControl: LayerFiltersControl
	});
}

nsGmx.LayerFiltersControl = LayerFiltersControl;

})(jQuery);
var nsGmx = nsGmx || {};

(function($){

/** Фильтрует объекты внутри векторных слоёв по интервалу дат
* @class
*/
var FiltersControl = function()
{
	var _layers = [];
	var _dateAttribute = null;
	var _dateBegin = null;
	var _dateEnd = null;
	var _type = null;
	var _params = null;
	
	var _setFilters = function()
	{
		var filterLayer = function(layer)
		{
			var	properties = layer.properties;
			
			var timePostfixBegin = _params.useTimePostfix ? " 00:00:00" : "";
			var timePostfixEnd   = _params.useTimePostfix ? " 23:59:59" : "";

			var filterString = "`" + _dateAttribute + "` >= '" + $.datepicker.formatDate(_params.dateFormat, _dateBegin) + timePostfixBegin + "'" + " AND " + "`" + _dateAttribute + "` <= '" + $.datepicker.formatDate(_params.dateFormat, _dateEnd) + timePostfixEnd + "'",
				filters = layer.filters;
			
			for (var j = 0; j < filters.length; j++)
			{
				var lastFilter = properties.styles[j].Filter;
				
				filters[j].setFilter((lastFilter && lastFilter != "") ? ("(" + lastFilter + ") AND" + filterString) : filterString);
			}			
		}
		
		if (_type)
		{ //фильтруем все слои данного типа 
			for (var i = 0; i < globalFlashMap.layers.length; ++i)
				if (globalFlashMap.layers[i].properties.type === _type)
					filterLayer(globalFlashMap.layers[i]);
		}
		else
		{ //фильтруем конкретные слои
			for (var i = 0; i < _layers.length; ++i)
			{
				var name = _layers[i],
					layer = globalFlashMap.layers[name];
				
				if (!layer)
					continue;
					
				filterLayer(layer);
			}
		}
	}

	/** Инициализировать контрол
	* @function
	* @param {Array|string} layers Вектор имён слоёв для фильтрации или тип слоёв для фильтрации (Raster или Vector). В последнем случае фильтруются все слои данного типа
	* @param {String} dateAttribute Имя аттрибута даты в слоях
	*/
	this.init = function(layers, dateAttribute, calendar, params)
	{
		_params = $.extend({dateFormat: 'yy-mm-dd', useTimePostfix: false}, params);
		if (typeof layers === 'string')
			_type = layers;
		else
			_layers = layers;
		
		_dateAttribute = dateAttribute;
		
		var updateDate = function()
		{
			_dateBegin = calendar.getDateBegin();
			_dateEnd = calendar.getDateEnd();
		
			_setFilters();
		}
		
		$(calendar).change(updateDate);
		updateDate();
	}
	
	if (typeof _queryExternalMaps !== 'undefined')
		$(_queryExternalMaps).bind('map_loaded', _setFilters);
}

if ( typeof gmxCore !== 'undefined' )
{
	gmxCore.addModule('FiltersControl', {
		FiltersControl: FiltersControl
	});
}

nsGmx.FiltersControl = FiltersControl;

})(jQuery);
var nsGmx = nsGmx || {};

/** 
* Контроллёр глобального буфера обмена
* @memberOf nsGmx
* @class Синглетон. Позволяет хранить массивы объектов разного типа. Тип объектов - строка. В рамках одного типа объекты упорядочены.
*/
nsGmx.ClipboardController = (function()
{
    var _clipboard = {};
    return {
        addItem: function(type, item)
        {
            _clipboard[type] = _clipboard[type] || [];
            _clipboard[type].push(item);
        },
        
        popItem: function(type)
        {
            if (typeof _clipboard[type] === 'undefined' || _clipboard[type].length == 0) return null;
            return _clipboard[type].pop();
        },
        
        //количество объектов данного типа
        getCount: function(type)
        {
            if ( typeof _clipboard[type] === 'undefined' ) 
                return 0;
            
            return _clipboard[type].length;
        },
        
        //получить объект типа type с индексом index. Если index < 0, то индексация с конца (-1 - последний элемент)
        get: function(type, index)
        {
            if ( typeof _clipboard[type] === 'undefined' ) return null;
            
            if (index < 0) index += _clipboard[type].length;
            
            if (index < 0 || _clipboard[type].length <= index )
                return null;
                
            return _clipboard[type][index];
        }
    }
})();
var nsGmx = nsGmx || {};

(function($){

"use strict";

_translationsHash.addtext("rus", {
                        "pluginsEditor.selectedTitle" : "Плагины карты",
                        "pluginsEditor.availableTitle" : "Доступные плагины",
                        "pluginsEditor.add" : "Добавить плагин",
                        "pluginsEditor.paramsTitle" : "Параметры плагина"
                     });
                     
_translationsHash.addtext("eng", {
                        "pluginsEditor.selectedTitle" : "Map plugins",
                        "pluginsEditor.availableTitle" : "Available plugins",
                        "pluginsEditor.add" : "Add plugin",
                        "pluginsEditor.paramsTitle" : "Parameter of plugin"
                     });


var MapPlugins = function()
{
    var _plugins = [];
    var _params = {};
    
    //вместо массива из одного элемента передаём сам элемент
    var normalizeParams = function(params) {
        var res = {};
        for (var p in params) {
            res[p] = params[p].length === 1 ? params[p][0] : params[p];
        }
        
        return res;
    }
    
    this.addPlugin = function(pluginName, pluginParams, onlyParams)
    {
        _params[pluginName] = pluginParams || _params[pluginName] || {};
        
        if (!onlyParams && _plugins.indexOf(pluginName) === -1) {
            _plugins.push(pluginName);
        }
        
        $(this).change();
        
        return true;
    }
    
    this.each = function(callback) {
        for (var p = 0; p < _plugins.length; p++) {
            callback(_plugins[p], _params[_plugins[p]] || {});
        }
    }
    
    this.remove = function(pluginName) {
        var nameIndex = _plugins.indexOf(pluginName);
        if (nameIndex !== -1) {
            _plugins.splice(nameIndex, 1);
            $(this).change();
        }
    }
    
    this.isExist = function(pluginName)
    {
        return _plugins.indexOf(pluginName) !== -1;
    }
    
    this.getPluginParams = function(pluginName) {
        return _params[pluginName];
    }
    
    this.setPluginParams = function(pluginName, pluginParams) {
        _params[pluginName] = pluginParams;
        $(this).change();
    }
    
    //обновляем используемость и параметры плагинов
    this.updateGeomixerPlugins = function() {
        for (var p = 0; p < _plugins.length; p++) {
            nsGmx.pluginsManager.setUsePlugin(_plugins[p], true);
        }
        
        for (var p in _params) {
            nsGmx.pluginsManager.updateParams(p, normalizeParams(_params[p]));
        }
    }
    
    this.load = function(data, version) {
        if (version === 1) {
            _plugins = data;
            _params = {};
        } else if (version === 2) {
            _plugins = [];
            _params = {};
            for (var p = 0; p < data.length; p++) {
                _plugins.push(data[p].name);
                _params[data[p].name] = data[p].params;
            }
        } else if (version === 3) {
            _plugins = data.plugins;
            
            //поддержка ошибки, которая прокралась в базу...
            if ($.isArray(data.params) && data.params.length === 0) {
                _params = {};
            } else {
                _params = data.params;
            }
        }
    }
    
    this.save = function(version) {
        if (version === 1) {
            return _plugins;
        } else if (version === 2) {
            var res = [];
            _plugins.forEach(function(name) {
                res.push({name: name, params: _params[name]});
            })
            return res;
        } else if (version === 3) {
            return {
                plugins: _plugins,
                params: _params
            }
        }
    }
}

var GeomixerPluginsWidget = function(container, mapPlugins)
{
    var template = Handlebars.compile('<div class="pluginsEditor-allPlugins-container">' +
        '<div class="pluginEditor-widgetHeader">{{i "pluginsEditor.availableTitle"}}</div>' +
        '<div class="pluginEditor-treePlaceholder"></div>' +
        '<div class="pluginEditor-controls">' +
            '<input class="inputStyle inputFullWidth pluginEditor-pluginInput"><br>' +
            '<button class="pluginEditor-addButton">{{i "pluginsEditor.add"}}</button>' +
        '</div>' +
    '</div>');
    
    var lang = window.nsGmx.Translations.getLanguage();

    var DEFAULT_GROUP_NAME = {
        eng: 'Main',
        rus: 'Основные'
    };
    
    var _allPluginGroups = {},
        configGroups = window.gmxPluginGroups || [],
        groupByPluginName = [],
        groupOrder = {};
    
    configGroups.forEach(function(group, index) {
        groupOrder[group[lang]] = index;
        group.plugins.forEach(function(plugin) {
            groupByPluginName[plugin] = group[lang];
        })
    })
    
    nsGmx.pluginsManager.forEachPlugin(function(plugin)
    {
        if ( plugin.pluginName && plugin.mapPlugin && (plugin.isPublic || nsGmx.AuthManager.isRole(nsGmx.ROLE_ADMIN)) )
        {
            var groupName = groupByPluginName[plugin.pluginName] || DEFAULT_GROUP_NAME[lang];
            _allPluginGroups[groupName] = _allPluginGroups[groupName] || {groupName: groupName, plugins: []};
            _allPluginGroups[groupName].plugins.push({name: plugin.pluginName, isPublic: plugin.isPublic});
            //_allPlugins.push({name: plugin.pluginName, isPublic: plugin.isPublic});
        }
    })
    
    //по алфавиту
    for (var g in _allPluginGroups) {
        _allPluginGroups[g].plugins.sort(function(a, b) {
            return a.name > b.name ? 1 : -1;
        })
    }
    
    var isListActive = false;
    var update = function()
    {
        $(container).empty();
        
        var filteredGroups = [];
        for (var g in _allPluginGroups) {
            var plugins = _allPluginGroups[g].plugins.filter(function(plugin) {return !mapPlugins.isExist(plugin.name);});
            //если в группе нет плагинов, не показываем её
            plugins.length && filteredGroups.push({
                groupName: _allPluginGroups[g].groupName,
                plugins: plugins
            });
        };
        
        //сохраняем порядок, как в конфиге, default group - первой
        filteredGroups.sort(function(a, b) {
            return groupOrder[a.groupName] - groupOrder[b.groupName];
        });

        var pluginGroupTemplate = Handlebars.compile('<ul class="pluginEditor-pluginsTree ui-helper-noselect">{{#groups}}' +
            '<li>' +
                '<div class="pluginEditor-groupTitle">{{groupName}}</div>' +
                '<ul>{{#plugins}}' +
                    '<li class="pluginEditor-pluginItem ui-helper-noselect" data-plugin-name="{{name}}">{{name}}</li>' +
                '{{/plugins}}</ul>' +
            '</li>' +
            '{{/groups}}</ul>');

        var pluginsTree = $(pluginGroupTemplate({groups: filteredGroups}));

        pluginsTree.find('.pluginEditor-pluginItem').click(function(e) {
            isListActive = true;
            var pluginName = $(this).data('pluginName');
            
            if (e.ctrlKey) {
                $(this).toggleClass('pluginEditor-activePluginItem');
            } else {
                pluginsTree.find('.pluginEditor-pluginItem').removeClass('pluginEditor-activePluginItem');
                $(this).addClass('pluginEditor-activePluginItem');
            }
        });
        
        pluginsTree.find('.pluginEditor-groupTitle').click(function() {
            $(this).siblings('.hitarea').click();
        })
        
        var ui = $(template());
        
        ui.find('.pluginEditor-treePlaceholder').append(pluginsTree);
        
        ui.find('.pluginEditor-pluginInput').bind('focus', function() {
            isListActive = false;
        });

        ui.find('.pluginEditor-addButton').click(function() {
            var selected = [];

            if (isListActive) {
                pluginsTree.find('.pluginEditor-activePluginItem').each(function(i, elem) {
                    selected.push($(elem).data('pluginName'));
                });
            } else {
                var pluginInput = ui.find('.pluginEditor-pluginInput');
                if (nsGmx.pluginsManager.getPluginByName(pluginInput.val())) {
                    selected.push(pluginInput.val());
                } else {
                    inputError(pluginInput[0]);
                }
            }
            
            for (var sp = 0; sp < selected.length; sp++)
                mapPlugins.addPlugin( selected[sp] );
        });

        ui.appendTo(container);
            
        pluginsTree.treeview(/*{collapsed: true}*/);
    }
    
    $(mapPlugins).change(update);
    update();
}

var paramsWidgets = {};

var MapPluginParamsWidget = function(mapPlugins, pluginName) {

    if (paramsWidgets[pluginName]) {
        return;
    };
    
    var FakeTagMetaInfo = function()
    {
        this.isTag = function(tag) { return true; }
        this.getTagType = function(tag) { return 'String'; }
        this.getTagDescription = function(tag) { return ''; }
        this.getTagArray = function() { return []; }
        this.getTagArrayExt = function() { return []; }
    };
    var fakeTagMetaInfo = new FakeTagMetaInfo();
    
    var pluginParams =  mapPlugins.getPluginParams(pluginName);
    var tagInitInfo = {};
    
    for (var tagName in pluginParams) {
        tagInitInfo[tagName] = {Value: pluginParams[tagName]};
    }
    
    var layerTags = new nsGmx.LayerTagsWithInfo(fakeTagMetaInfo, tagInitInfo);
    
    var container = $('<div/>');
    
    var pluginValues = new nsGmx.LayerTagSearchControl(layerTags, container);
    
    var updateParams = function() {
        var newParams = {};
        layerTags.eachValid(function(tagid, tag, value) {
            newParams[tag] = newParams[tag] || [];
            newParams[tag].push(value);
        })
        
        mapPlugins.setPluginParams(pluginName, newParams);
    }
    
    var dialogDiv = showDialog(
            _gtxt('pluginsEditor.paramsTitle') + " " + pluginName, 
            container[0], 
            {
                width: 320, 
                height: 200, 
                closeFunc: function() {
                    updateParams();
                    delete paramsWidgets[pluginName];
                }
            }
        );
    
    paramsWidgets[pluginName] = {
        update: updateParams,
        closeDialog: function() {
            $(dialogDiv).dialog('close');
        }
    };
    
}

var MapPluginsWidget = Backbone.View.extend({
    template: Handlebars.compile(
        '<div class="pluginEditor-widgetHeader">{{i "pluginsEditor.selectedTitle"}}</div>' +
        '<div class="pluginEditor-currentMapPlugins">' +
            '{{#plugins}}' +
                '<div class="pluginEditor-widgetElem">' +
                    '{{#unless isCommon}}' +
                        '<span class="pluginEditor-remove gmx-icon-close" data-plugin-name="{{name}}"></span>' +
                    '{{/unless}}' +
                    '<span class="pluginEditor-edit gmx-icon-edit" data-plugin-name="{{name}}"></span>' +
                    '<span class="pluginEditor-title {{#if isCommon}} pluginEditor-commonPlugin{{/if}}">{{name}}</span>' +
                '</div>' +
            '{{/plugins}}' +
        '</div>'
    ),

    events: {
        'click .gmx-icon-close': function(event) {
            var pluginName = $(event.target).data('pluginName');
            this._mapPlugins.remove(pluginName);
        },
        
        'click .gmx-icon-edit': function(event) {
            var pluginName = $(event.target).data('pluginName');
            new MapPluginParamsWidget(this._mapPlugins, pluginName);
        }
    },

    initialize: function(options) {
        this._mapPlugins = options.mapPlugins;
        $(this._mapPlugins).change(this.render.bind(this));
        this.render();
    },

    render: function() {
        var mapPlugins = this._mapPlugins,
            pluginsToShow = [];

        nsGmx.pluginsManager.forEachPlugin(function(plugin) {
            if ( plugin.pluginName && !plugin.mapPlugin && !mapPlugins.isExist(plugin.pluginName) ) {
                pluginsToShow.push({
                    name: plugin.pluginName,
                    isCommon: true
                });
            }
        });
        
        mapPlugins.each(function(name) {
            pluginsToShow.push({
                name: name,
                isCommon: false
            });
        });
        
        pluginsToShow.sort(function(a, b) {
            return a.isCommon != b.isCommon ? Number(b.isCommon) - Number(a.isCommon) : (a.name > b.name ? 1 : -1);
        });
        
        this.$el.empty().append(this.template({plugins: pluginsToShow}));
    }
});

var createPluginsEditor = function(container, mapPlugins)
{
    var widgetContainer = $('<div/>', {'class': 'pluginEditor-widgetContainer'});
    var allPluginsContainer = $('<div/>', {'class': 'pluginEditor-allContainer'});
    var mapPluginsWidget = new MapPluginsWidget({
        el: widgetContainer,
        mapPlugins: mapPlugins
    });
    var allPluginsWidget = new GeomixerPluginsWidget(allPluginsContainer, mapPlugins);
    
    $(container)
        .append($('<table/>', {'class': 'pluginEditor-table'}).append($('<tr/>')
            .append($('<td/>', {'class': 'pluginEditor-allTD'}).append(allPluginsContainer))
            .append($('<td/>', {'class': 'pluginEditor-widgetTD'}).append(widgetContainer))
        ));
    
    return {
        update: function() {
            for (var name in paramsWidgets) {
                paramsWidgets[name].update();
            }
        },
        closeParamsDialogs: function() {
            for (var name in paramsWidgets) {
                paramsWidgets[name].closeDialog();
            }
        }
    };
}

gmxCore.addModule('PluginsEditor', {
    createPluginsEditor: createPluginsEditor,
    MapPlugins: MapPlugins
})

nsGmx.createPluginsEditor = createPluginsEditor;
_mapHelper.mapPlugins = new MapPlugins();

//Cтарая версия информации о плагинах карты. Поддерживается для обратной совместимости (например, загрузка доп. карт)
//Формат: {String[]} массив имён плагинов
nsGmx.userObjectsManager.addDataCollector('mapPlugins', {
    load: function(data)
    {
        if (data) {
            _mapHelper.mapPlugins.load(data, 1);
            _mapHelper.mapPlugins.updateGeomixerPlugins();
        }
    },
    collect: function() {
        return _mapHelper.mapPlugins.save(1);
    }
})

//Вторая версия информации о плагинах карты.
//Формат: [{name: pluginName1, params: {param: value, ...}}, ...]
nsGmx.userObjectsManager.addDataCollector('mapPlugins_v2', {
    load: function(data)
    {
        if (data) {
            _mapHelper.mapPlugins.load(data, 2);
            _mapHelper.mapPlugins.updateGeomixerPlugins();
        }
    },
    collect: function()
    {
        return _mapHelper.mapPlugins.save(2);
    }
})

//Третья версия информации о плагинах карты.
//Формат: {plugins: [name1, ....], params: {name1: {param1: value1, ...}, ...}}
nsGmx.userObjectsManager.addDataCollector('mapPlugins_v3', {
    load: function(data)
    {
        if (data) {
            _mapHelper.mapPlugins.load(data, 3);
            _mapHelper.mapPlugins.updateGeomixerPlugins();
        }
    },
    collect: function()
    {
        return _mapHelper.mapPlugins.save(3);
    }
})

})(jQuery);
(function()
{
    var getZoomValue = function(zoomControl)
    {
        var isNotValid = zoomControl.value == '' ||
                    isNaN(Number(zoomControl.value)) ||
                    Number(zoomControl.value) != Math.floor(Number(zoomControl.value)) ||
                    Number(zoomControl.value) < 1;

        if (isNotValid)
        {
            $(zoomControl).addClass("error");
            return null;
        }
        else
        {
            $(zoomControl).removeClass("error");
            return Number(zoomControl.value);
        }
    }

    var checkZoom = function(minZoomInput, maxZoomInput)
    {
        var minVal = getZoomValue(minZoomInput);
        var maxVal = getZoomValue(maxZoomInput);

        if (minVal && maxVal && minVal > maxVal)
        {
            $(minZoomInput).addClass("error");
            $(maxZoomInput).addClass("error");
            return false;
        }

        return !!(minVal && maxVal);
    }

    /**
     Контрол для задания максимального и минимального зумов слоя/стиля.
     Выдаёт два 'li' элемента, которые клиент сам помещает куда-нибудь.
     Генерит событие "change", когда изменились валидные значения зумов
     @memberOf nsGmx
     @class
     @param minZoom {int} Начальный минимальный зум
     @param maxZoom {int} Начальный максимальный зум
    */
    var ZoomPropertiesControl = function(minZoom, maxZoom)
    {
        var _this = this;
        var minZoomInput = _input(null, [['dir','className','inputStyle'],['attr','paramName','MinZoom'],['css','width','30px'],['attr','value', minZoom || 1]]);
        var maxZoomInput = _input(null, [['dir','className','inputStyle'],['attr','paramName','MaxZoom'],['css','width','30px'],['attr','value', maxZoom || 17]]);
        checkZoom(minZoomInput, maxZoomInput);

        var liMinZoom = _li([_div([_table([_tbody([_tr([_td([_span([_t(_gtxt("Мин. зум"))],[['css','fontSize','12px']])],[['css','width','60px']]),_td([minZoomInput])])])])])]);
		var liMaxZoom = _li([_div([_table([_tbody([_tr([_td([_span([_t(_gtxt("Макс. зум"))],[['css','fontSize','12px']])],[['css','width','60px']]),_td([maxZoomInput])])])])])]);

        minZoomInput.onkeyup = maxZoomInput.onkeyup = function()
        {
            if (checkZoom(minZoomInput, maxZoomInput))
                $(_this).change();

            return true;
        }

        this.getMinLi = function() { return liMinZoom; };

        this.getMaxLi = function() { return liMaxZoom; };

        /** Получить минимальный зум
        */
        this.getMinZoom = function() { return Number(minZoomInput.value) };

        /** Получить максимальный зум
        */
        this.getMaxZoom = function() { return Number(maxZoomInput.value) };
    }

    nsGmx.ZoomPropertiesControl = ZoomPropertiesControl;
})();

/**
    Возвращает массив ссылок в верхнее левое мета-меню в формате HeaderWidget из CommonComponents.
    Считывает информацию из window.gmxViewerUI.headerLinkItems в формате [{icon: iconPath, title: TITLE, href: HREF}, ...] (формат ГеоМиксера)
    Если переменной нет, подставляет значения по умолчению ("Карта пожаров", "Поиск снимков", "Платформа Геомиксер")
    @memberOf nsGmx
*/
nsGmx.addHeaderLinks = function()
{
    var isHeaderLinks = false;
    if ( typeof window.headerLinks === 'boolean' ) isHeaderLinks = window.headerLinks; //совместимость с предыдущими версиями
    if ( typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.headerLinks !== 'undefined' )
        isHeaderLinks = window.gmxViewerUI.headerLinks;

    if (!isHeaderLinks) {
        return [];
    }

    var items = (window.gmxViewerUI && window.gmxViewerUI.headerLinkItems) || 
        [
            {title: _gtxt("Карта пожаров"), href: _gtxt("http://fires.ru"), newWindow: true},
            {title: _gtxt("Поиск снимков"), href: _gtxt("http://search.kosmosnimki.ru"), newWindow: true},
            {title: _gtxt("Платформа Геомиксер"), newWindow: true, id: 'HeaderLinkGeoMixer'}
        ];
        
    return $.extend(true, [], items).map(function(item) {
        item.link = item.href;
        return item;
    })
}
!(function()
{
    _translationsHash.addtext("rus", {
							"clusterControl.maxMembers" : "Макс. объектов",
							"clusterControl.radius" : "Радиус кластеризации",
                            "clusterControl.title": "Стиль кластера"
						 });
						 
    _translationsHash.addtext("eng", {
							"clusterControl.maxMembers" : "Max. members in cluster",
							"clusterControl.radius" : "Clustering radius",
                            "clusterControl.title": "Cluster style"
						 });
                         
    var ClusterParamsControl = function(container, initStyle)
    {
        var _this = this;
        var isApplyClusters = typeof initStyle !== 'undefined';
        var clusterView = {        // Атрибуты отображения членов кластера (при отсутствии не отображать)
            'maxMembers': 10,    // максимальное колич.обьектов в кластере (по умолчанию '10')
            'radius': 40,        // максимальный радиус сдвига координат обьектов попавших в кластер (по умолчанию '50')
            'delta': 10,        // разброс сдвига координат (по умолчанию '0')
            'bgStyle': {        // Стиль подложки отображения (по умолчанию '0')
                'fill': { 'color': 0xffff00, 'opacity': 20 },
                'outline': { 'color': 0x00ff00, 'opacity': 1, 'thickness': 10 }
            },
            'lineStyle': { 'color': 0x0600ff, 'opacity': 30, 'thickness': 1 }    // Стиль линии соединяющей центр кластера с отображаемым обьектом
        };
    
        var clusterStyle = {
        }
        
        var ph = {
            radius: 50,                // радиус кластеризации в пикселах (по умолчанию 20)
            iterationCount: 1,        // количество итераций K-means (по умолчанию 1)
            clusterView: clusterView, // Атрибуты отображения членов кластера (при отсутствии не отображать)
            RenderStyle: null,      // стили кластеров
            HoverStyle: null        // стили кластеров при наведении
        };
        
        ph = $.extend(true, ph, initStyle);
                
        var clusterStyleControl = $('<div/>', {'class': 'clusterStyleControl'});
        var clusterStyleContainer = $('<div/>');
        clusterStyleControl.append($('<span/>').text(_gtxt('clusterControl.title'))).append(clusterStyleContainer);
        
        var clusterRadiusInput = $('<input/>', {'class': 'inputStyle'}).val(ph.radius).bind('keyup', function()
        {
            if (ph.radius != this.value)
            {
                ph.radius = Number(this.value);
                $(_this).change();
            }
        });
        
        var maxMembersInput = $('<input/>', {'class': 'inputStyle'}).val(ph.clusterView.maxMembers).bind('keyup', function()
        {
            if (ph.clusterView.maxMembers != this.value)
            {
                ph.clusterView.maxMembers = Number(this.value);
                $(_this).change();
            }
        });
        
        var clusterViewTable = $('<table/>')
            .append($('<tr/>')
                .append($('<td/>').append($('<span/>').text(_gtxt('clusterControl.radius'))))
                .append($('<td/>').append(clusterRadiusInput))
            ).append($('<tr/>')
                .append($('<td/>').append($('<span/>').text(_gtxt('clusterControl.maxMembers'))))
                .append($('<td/>').append(maxMembersInput))
            );
            
        var clusterViewContainer = $('<div/>', {'class': 'clusterViewContainer'}).append(clusterViewTable);
        
        $(container).append(clusterStyleControl).append(clusterViewContainer);
        
        var initRenderStyle = ph.RenderStyle || {marker:{size:3}, outline: {color: 0xff0000, opacity: 100, thickness: 2}};
        
        //предполагаем что модуль уже загружен
        //TODO: или это не так?
        var resObject = gmxCore.getModule('LayerStylesEditor').createStyleEditor(clusterStyleContainer[0], initRenderStyle, "point", true);
        
        $(resObject).change(function()
        {
            ph.RenderStyle = ph.HoverStyle = initRenderStyle;
            $(_this).change();
        });
        
        this.isApplyCluster = function()
        {
            return isApplyClusters;
        }
        
        this.getClusterStyle = function()
        {
            return ph;
        }
        
        this.applyClusters = function(isApply)
        {
            if (isApply != isApplyClusters)
            {
                ph.RenderStyle = initRenderStyle;
                isApplyClusters = isApply;
                $(_this).change();
            }
        }
    }
    
    nsGmx.ClusterParamsControl = ClusterParamsControl;
})();
(function()
{
    /**
    Хранит информацию о тегах: типы и описание
    @memberOf nsGmx
    @class
    @param {Object} initTagsInfo - описание тегов вида tagName: {Type: , Description: }
    */
    var TagMetaInfo = function(initTagsInfo)
    {
        var tags = initTagsInfo || {};
        
        this.isTag = function(tag)
        {
            return tag in tags;
        }
        
        this.getTagType = function(tag)
        {
            return tag in tags ? tags[tag].Type : null;
        }
        
        this.getTagDescription = function(tag)
        {
            return tag in tags ? tags[tag].Description : null;
        }
        
        this.getTagArray = function()
        {
            var res = [];
            for (var t in tags)
                res.push(t);
            return res;
        }
        
        this.getTagArrayExt = function()
        {
            var res = [];
            for (var t in tags)
                res.push( {name: t, type: tags[t].Type, desc: tags[t].Description} );
                
            return res;
        }
    };
    
    (function()
    {
        var def;
        
        /** Загружает данные о доступных тегах с сервера
        * @memberOf nsGmx.TagMetaInfo
        * @name loadFromServer
        * @function
        * @param {function(tagInfo)} [callback] Ф-ция, которая будет вызвана после загрузки информации о типах.
        * @return {jQuery.Deferred} Будет заресолвен после получения информации о типах
        */
        TagMetaInfo.loadFromServer = function(callback)
        {
            if (!def)
            {
                def = $.Deferred();
                sendCrossDomainJSONRequest(serverBase + 'Layer/MetaKeys.ashx', function(response)
                {
                    if (!parseResponse(response))
                    {
                        def.resolve();
                        return;
                    }
                    def.resolve(new TagMetaInfo(response.Result));
                })
            }
            callback && def.done(callback);
            return def;
        }
    })();
    
    var extendClass = function(base, sub) {
        function ctor() {}
     
        ctor.prototype = base.prototype;
        sub.prototype = new ctor();
        sub.prototype.constructor = sub;
    }
    
    var LayerTags = function(initTags)
    {
        /** Вызывается при изменении набора тегов слоя
            @name nsGmx.LayerTags.change
            @event
        */
        
        this._uniqueID = 1;
        this._tags = {};

        for (var tag in initTags) {
            var values = initTags[tag].Value;
            if (!$.isArray(values)) {
                values = [values];
            }
            
            for (var i = 0; i < values.length; i++) {
                this.addNewTag(tag, values[i]);
            }
        }
    }
    
    LayerTags.prototype = {
        _verificationFunctions: {
            'Number': function(value)
            {
                return value.length && !isNaN(Number(value));
            },
            'String': function(value)
            {
                return true; 
            },
            'Date': function(value)
            {
                try {
                    $.datepicker.parseDate('dd.mm.yy', value);
                    return true;
                }
                catch(err) {
                    return false;
                }
            }
        },
        
        _isValidTypeValue: function(type, value)
        {
            return !(type in this._verificationFunctions) || this._verificationFunctions[type](value);
        },
        
        updateTag: function(id, tag, value, type)
        {
            var tags = this._tags;
            if ( !(id in tags) ) return false;
            if ( tags[id].tag !== tag || tags[id].value !== value || tags[id].type !== type)
            {
                tags[id] = {tag: tag, value: value, type: type};
                $(this).change();
            }
            
            return true;
        },
        
        deleteTag: function(id)
        {
            if ( !(id in this._tags) ) return;
            
            delete this._tags[id];
            $(this).change();
        },
        
        each: function(callback)
        {
            var tags = this._tags;
            for (var tagId in tags)
                callback(tagId, tags[tagId].tag, tags[tagId].value, tags[tagId].type);
        },
        
        eachValid: function(callback, allowUnknownTags)
        {
            var tags = this._tags;
            for (var tagId in tags)
                if ((allowUnknownTags || this.isValidValue(tagId)) && !this.isEmptyTag(tagId))
                    callback(tagId, tags[tagId].tag, tags[tagId].value, tags[tagId].type);
        },
        
        addNewTag: function(tag, value, type)
        {
            if (typeof value === 'undefined' || value === null) {
                value = '';
            };
            
            var newId = 'id' + (++this._uniqueID);
            this._tags[newId] = {tag: tag || '', value: value, type: type};
            $(this).change();
            return newId;
        },
        
        isTag: function(tagId)
        {
            return tagId in this._tags;
        },
        
        isEmptyTag: function(tagId)
        {
            var tags = this._tags;
            return tagId in tags && tags[tagId].tag === '' && tags[tagId].value === '';
        },
        
        isValidValue: function(tagId)
        {
            var tags = this._tags;
            return tagId in tags && this._isValidTypeValue(tags[tagId].type, tags[tagId].value);
        },
        
        getTag: function(tagId)
        {
            return this._tags[tagId];
        },
        
        getTagByName: function(tagName)
        {
            var tags = this._tags;
            for (var tagId in tags)
                if (tags[tagId].tag == tagName)
                    return tags[tagId];
        },
        
        getTagIdByName: function(tagName)
        {
            var tags = this._tags;
            for (var tagId in tags)
                if (tags[tagId].tag == tagName)
                    return tagId;
        }
    }
    
    /**
        Набор тегов (метаданных) слоя из определённого набора тегов
        @memberOf nsGmx
        @class
        @param {nsGmx.TagMetaInfo} tagMetaInfo описание типов тегов
        @param {Object} initTags теги для инициализации. Формат: {tagName: {Value: tagValue}, ...}. tagValue может быть массивом
    */
    var LayerTagsWithInfo = function(tagMetaInfo, initTags) {

        // чтобы можно было расширять существующий объект LayerTags
        if (this instanceof LayerTagsWithInfo) {
            LayerTags.call(this, initTags);
        }

        this.getTagMetaInfo = function()
        {
            return tagMetaInfo;
        }
        
        this.isKnownTagname = function(tagname)
        {
            return tagMetaInfo.isTag(tagname);
        }
        
        this.addNewTag = function(tag, value, type)
        {
            type = type || tagMetaInfo.getTagType(tag) || '';
            LayerTags.prototype.addNewTag.call(this, tag, value, type);
        }
        
        this.updateTag = function(id, tag, value) {
            var type = tagMetaInfo.getTagType(tag);
            LayerTags.prototype.updateTag.call(this, id, tag, value, type);
        }
    }
    
    extendClass(LayerTags, LayerTagsWithInfo);

    /**
        Контрол для задания набора тегов (например, для слоя)
        @memberOf nsGmx
        @class
    */
    var LayerTagSearchControl = function(layerTags, container, params)
    {
        var _params = $.extend({
            inputWidth: 130,
            tagHeader: _gtxt('Параметр'),
            valueHeader: _gtxt('Значение')
        }, params )
        var mainTable = $('<table/>', {'class': 'layertags-table'}).appendTo(container);
        mainTable.append($('<tr/>')
            .append($('<th/>').text(_params.tagHeader))
            .append($('<th/>').text(_params.valueHeader))
            .append($('<th/>'))
        );
        
        //добавляем к body элемент с id чтобы добавить к нему jQuery autocomplete и задать стили
        //к текущему виджету добавить нельзя, так как он ещё не добавлен в общее дерево, а виджет ac требует глобального селектора
        if ($('#layertagstable').length == 0)
            $('body').append($('<div id="layertagstable"></div>'));
        
        var rows = {}; //ссылки на контролы для каждого элемента
        var rowsVector = [];
        
        //в зависимости от типа ввода (type), прикрепляет к valueInput виджет выбора даты, время или даты/время
        var updateInput = function(valueInput, type)
        {
            if ( type == 'Date' )
            {
                $(valueInput).timepicker('destroy');
                $(valueInput).datetimepicker('destroy');
                
                $(valueInput).datepicker(
                {
                    changeMonth: true,
                    changeYear: true,
                    dateFormat: "dd.mm.yy"
                });
                
            }
            else if ( type == 'DateTime' )
            {
                $(valueInput).timepicker('destroy');
                $(valueInput).datepicker('destroy');
                
                $(valueInput).datetimepicker(
                {
                    changeMonth: true,
                    changeYear: true,
                    dateFormat: "dd.mm.yy",
                    timeFormat: "HH:mm:ss",
                    showSecond: true,
                    timeOnly: false
                }).addClass('layertags-datetimeinput');
            }
            else if ( type == "Time" )
            {
                
                $(valueInput).datepicker('destroy');
                $(valueInput).datetimepicker('destroy');
                
                $(valueInput).timepicker({
                    timeOnly: true,
                    timeFormat: "HH:mm:ss",
                    showSecond: true
                });
            }
            else
            {
                $(valueInput).timepicker('destroy');
                $(valueInput).datetimepicker('destroy');
                $(valueInput).datepicker('destroy');
            }
        }
        
        var validateRow = function(row)
        {
            if ( !layerTags.isEmptyTag(row.id) && !layerTags.isKnownTagname(row.tag.val()) )
                row.tag.addClass('error');
            else
                row.tag.removeClass('error');
                
            if (!layerTags.isEmptyTag(row.id) && !layerTags.isValidValue(row.id) )
                row.value.addClass('error');
            else
                row.value.removeClass('error');
        }
        
        var addNewRow = function(tagId, tag, value)
        {
            var tagInput = $('<input/>', {'class': 'inputStyle'}).val(tag).css('width', _params.inputWidth).autocomplete({
                source: layerTags.getTagMetaInfo().getTagArrayExt(),
                minLength: 0,
                delay: 0,
                appendTo: "#layertagstable",
                select: function(event, ui)
                {
                    tagInput.val(ui.item.name);
                    updateModel(ui.item.name, valueInput.val());
                    return false;
                }
            }).bind('click', function(){
                $(tagInput).autocomplete("search", "");
            });
            
            tagInput.data( "ui-autocomplete" )._renderItem = function( ul, item ) 
            {
                return $( "<li/>")
                    .append($("<a/>", {title: item.desc}).text(item.name))
                    .appendTo( ul );
            }
            
            var valueInput = $('<input/>', {'class': 'inputStyle'}).val(value).css('width', _params.inputWidth);
            
            var type = layerTags.getTagMetaInfo().getTagType(tag);
            updateInput(valueInput, type);
            
                
            var updateModel = function()
            {
                layerTags.updateTag(tagId, tagInput.val(), valueInput.val());
            }
                        
            tagInput.bind('keyup change', updateModel);
            valueInput.bind('keyup change', updateModel);
            
            var deleteButton = makeImageButton('img/recycle.png', 'img/recycle_a.png');
            deleteButton.onclick = function()
            {
                layerTags.deleteTag(tagId);
            }
            
            var tr = $('<tr/>')
                .append($('<td/>').append(tagInput))
                .append($('<td/>').append(valueInput))
                .append($('<td/>', {'class': 'layertags-delete'}).append(deleteButton));
                
            mainTable.append(tr);
            
            rows[tagId] = {id: tagId, tr: tr, tag: tagInput, value: valueInput, type: type};
            rowsVector.push(rows[tagId]);
            validateRow(rows[tagId]);
        }
        
        var moveEmptyLayersToBottom = function()
        {
            var lastEmptyId = -1;
            for (var irow = 0; irow < rowsVector.length; irow++)
                if (layerTags.isEmptyTag(rowsVector[irow].id))
                    lastEmptyId = irow;
            
            if (lastEmptyId >= 0 && lastEmptyId < rowsVector.length)
            {
                var tr = rowsVector[lastEmptyId].tr;
                $(tr).detach();
                mainTable.append(tr);
            }
        }
        
        $(layerTags).change(function()
        {
            var isAnyEmpty = false;
            layerTags.each(function(tagId, tag, value)
            {
                if (tag == '' && value == '')
                    isAnyEmpty = true;
                
                if (!(tagId in rows))
                    addNewRow(tagId, tag, value);
                else 
                {
                    if (rows[tagId].tag.val() !== tag)
                        rows[tagId].tag.val(tag)
                        
                    if (rows[tagId].value.val() !== value)
                        rows[tagId].value.val(value)
                        
                        
                    var type = layerTags.getTagMetaInfo().getTagType(tag);
                    if (rows[tagId].type !== type)
                    {
                        rows[tagId].type = type;
                        updateInput(rows[tagId].value, type);
                    }
                    
                    validateRow(rows[tagId]);
                }
            });
            
            for (var tagId in rows)
            {
                if (!(layerTags.isTag(tagId)))
                {
                    rows[tagId].tr.remove();
                    delete rows[tagId];
                }
            }
            
            if (!isAnyEmpty)
                layerTags.addNewTag();
                
            moveEmptyLayersToBottom();
        });
        
        layerTags.addNewTag();
    }
    
    nsGmx.LayerTagSearchControl = LayerTagSearchControl;
    nsGmx.LayerTags = LayerTags;
    nsGmx.LayerTagsWithInfo = LayerTagsWithInfo;
    nsGmx.TagMetaInfo = TagMetaInfo;
})();
// Контрол для добавления в каталог растров новых слоёв. 
// Позволяет выбирать из существующих на сервере слоёв, слоёв внутри карты и создавать новый слой
nsGmx.RCAddLayerControl = function(map, layerName)
{
    var currRCName = '';
    var currAttrControl = null;
    var infoContainer = $('<div/>').css('margin-top', '5px');
    var InfoControl = function(container)
    {
        var curProcID = 0;
        var loaderImage = $('<img/>', {src: 'img/loader2.gif'}).hide();
        var statusContainer = $('<span/>', {'class': 'RCAdd-info-container'});
        var warningContainer = $('<span/>', {'class': 'RCAdd-warning-container'});
        
        container.append(loaderImage, statusContainer, warningContainer);
        
        this.startProcess = function()
        {
            loaderImage.show();
            return curProcID++;
        }
        
        this.doneProcess = function(message)
        {
            loaderImage.hide();
            $(statusContainer).empty().show().text(message).fadeOut(2000, 'easeInExpo');
        }
        
        this.failProcess = function(message)
        {
            //$(container).empty().show().text(message).fadeOut(2000, 'easeInExpo');
        }
        
        this.warning = function(message) {
            $(warningContainer).empty().show().text(message).fadeOut(2000, 'easeInExpo');
        }
    }
    var infoControl = new InfoControl(infoContainer);
    
    var LayersToAddWidget = function(parent) {
        var objsByLayer = {};
        var dataProvider = new nsGmx.ScrollTable.StaticDataProvider();
        var table = new nsGmx.ScrollTable();
        table.setDataProvider(dataProvider);
        
        table.createTable({
            parent: parent[0],
            name: 'objtoadd',
            fields: [_gtxt('Каталог Растров'), _gtxt('Растр'), ''],
            fieldsWidths: ['50%', '50%', '20px'],
            drawFunc: function(item) {
                var removeIcon = makeImageButton("img/recycle.png", "img/recycle_a.png");
                removeIcon.onclick = function() {
                    var identityField = item.layerprops.identityField;
                    var id = item.obj[identityField];
                    dataProvider.filterOriginalItems(function(addedItem) {
                        return addedItem.obj[identityField] !== id;
                    })
                }
                //либо однострочное имя, либо просто id
                var objname;

                if (item.layerprops.NameObject) {
                    objname = L.gmxUtil.parseBalloonTemplate(item.layerprops.NameObject, {
                        properties: item.obj, 
                        tileAttributeTypes: item.attrTypes
                    });
                } else {
                    objname = item.obj[item.layerprops.identityField];
                }
                
                var tr = _tr([
                    _td([_t(item.layerprops.title)], [['dir', 'className', 'RCAdd-vis-td']]),
                    _td([_t(objname)],               [['dir', 'className', 'RCAdd-vis-td']]),
                    _td([removeIcon],                [['dir', 'className', 'RCAdd-vis-remove']])
                ])
                
                for (var i = 0; i < tr.childNodes.length; i++)
                    tr.childNodes[i].style.width = this._fields[i].width;
                    
                return tr;
            }
        })
        
        this.addObject = function(layerprops, attrTypes, obj) {
            objsByLayer[layerprops.name] = objsByLayer[layerprops.name] || {};
            objsByLayer[layerprops.name][obj[layerprops.identityField]] = true;
            dataProvider.addOriginalItem({layerprops: layerprops, attrTypes: attrTypes, obj: obj});
        }
        
        this.getObjects = function() {
            return dataProvider.getOriginalItems();
        }
        
        this.clear = function() {
            dataProvider.setOriginalItems([]);
            objsByLayer = {};
        }
        
        this.isExist = function(layerprops, obj) {
            return objsByLayer[layerprops.name] && objsByLayer[layerprops.name][obj[layerprops.identityField]];
        }
    }
    
    var id = layerName;
    var existLayerCanvas = $('<div/>', {id: 'existlayer' + id});
    var mapLayerCanvas   = $('<div/>', {id: 'maplayer' + id, 'class': 'RCAdd-maplayers-container'});
    var RCLayerCanvas    = $('<div/>', {id: 'rclayer' + id});
    var newLayerCanvas   = $('<div/>', {id: 'newlayer' + id}).css('height', '465px');
    var visLayerCanvas   = $('<div/>', {id: 'vislayer' + id});
    
    var tabMenu = _div([_ul([_li([_a([_t(_gtxt("Существующие слои"))],[['attr','href','#existlayer' + id]])]),
                             _li([_a([_t(_gtxt("Слои из карты"))],[['attr','href','#maplayer' + id]])]),
                             _li([_a([_t(_gtxt("Слои из КР"))],[['attr','href','#rclayer' + id]])]),
                             _li([_a([_t(_gtxt("Новый слой"))],[['attr','href','#newlayer' + id]])]),
                             _li([_a([_t(_gtxt("С экрана"))],[['attr','href','#vislayer' + id]])])
                            ])]);
        
    $(tabMenu).append(existLayerCanvas, newLayerCanvas, RCLayerCanvas, mapLayerCanvas, visLayerCanvas);
    var dialogCanvas = $('<div/>').append(tabMenu, infoContainer);
    
    var suggestLayersControl = new nsGmx.LayerManagerControl(existLayerCanvas, 'addimage', {
            fixType: 'raster', 
            enableDragging: false,
            onclick: function(clickContext) {
                infoControl.startProcess();
                _mapHelper.modifyObjectLayer(layerName, [{source: {layerName: clickContext.elem.name}}])
                    .done(function()
                    {
                        infoControl.doneProcess(_gtxt('Добавлен растр') + ' "' + clickContext.elem.title + '"');
                    })
            }
        });
        
    var RCLayerLayerCanvas = $('<div/>').appendTo(RCLayerCanvas);
    var RCLayerObjectCanvas = $('<div/>').appendTo(RCLayerCanvas).css({
        'border-top-width': '1px', 
        'border-top-style': 'solid',
        'border-top-color': '#216B9C'
    });
    
    var sizeProvider = function() {
        console.log(dialogCanvas[0].parentNode.offsetHeight, dialogCanvas[0].parentNode.parentNode.offsetWidth);
        return {
            width: dialogCanvas[0].parentNode.parentNode.offsetWidth - 1,
            height: dialogCanvas[0].parentNode.offsetHeight - RCLayerLayerCanvas[0].offsetHeight - 9
        }
    }
    
    var RCLayersControl = new nsGmx.LayerManagerControl(RCLayerLayerCanvas, 'addrclayer', {
            fixType: 'catalog',
            enableDragging: false,
            height: 300,
            onclick: function(clickContext) {
                currRCName = clickContext.elem.name;
                currAttrControl = nsGmx.createAttributesTable(currRCName, RCLayerObjectCanvas[0], sizeProvider, {
                    hideActions: true,
                    hideRowActions: true,
                    hideDownload: true,
                    onClick: function(elem) {
                        var idfield = currAttrControl.getLayerInfo().identityField;
                        var objid = elem.values[elem.fields[idfield].index];
                        
                        var dstProps = map.layersByID[layerName].getGmxProperties();
                        
                        var properties = {};
                        
                        //переносим все атрибуты объекта, у которых совпадает имя и тип
                        for (var srcAttr in elem.fields) {
                            if (srcAttr !== idfield) {
                                for (var k = 0; k < dstProps.attributes.length; k++) {
                                    if (dstProps.attributes[k] === srcAttr && dstProps.attrTypes[k] === elem.fields[srcAttr].type ) {
                                        properties[srcAttr] = elem.values[elem.fields[srcAttr].index];
                                        break;
                                    }
                                }
                            }
                        }
                        
                        _mapHelper.modifyObjectLayer(layerName, [{source: {rc: currRCName, rcobj: objid}, properties: properties}]);
                    }
                });
            }
        });
        
    var newLayerProperties = {Title:'', Description: '', Date: '', TilePath: {Path:''}, ShapePath: {Path:''}};
    nsGmx.createLayerEditor(null, 'Raster', newLayerCanvas[0], newLayerProperties,
        {
            addToMap: false, 
            doneCallback: function(promise)
            {
                infoControl.startProcess();
                promise.done(function(taskInfo)
                {
                    _mapHelper.modifyObjectLayer(layerName, [{source: {layerName: taskInfo.Result.properties.name}}])
                        .done(function()
                        {
                            infoControl.doneProcess(_gtxt('Добавлен растр') + ' "' + taskInfo.Result.properties.title + '"');
                        })
                })
            }
        }
    );
    
    var visLayersWidget = new LayersToAddWidget($('<div/>').appendTo(visLayerCanvas));
    var addVisLayersButton = makeLinkButton(_gtxt("Добавить выбранные растры"));
    addVisLayersButton.onclick = function() {
        infoControl.startProcess();
        var objs = $.map(visLayersWidget.getObjects(), function(item) {
            return {source: {rc: item.layerprops.name, rcobj: item.obj[item.layerprops.identityField] }}; 
        });
        _mapHelper.modifyObjectLayer(layerName, objs).done(function() {
            visLayersWidget.clear();
            infoControl.doneProcess(_gtxt('Добавлены растры') + ' (' + objs.length + ')');
        });
    }
    
    $(addVisLayersButton).appendTo(visLayerCanvas);
    
    var previewLayersTree = new layersTree({showVisibilityCheckbox: false, allowActive: true, allowDblClick: false});
    
    var treeContainer = $('<div/>').css({'overflow-y': 'scroll', 'height': 400, 'margin-bottom': 10});
    
    var ul = previewLayersTree.drawTree(_layersTree.treeModel.getRawTree(), 2);
    $(ul).treeview().appendTo(treeContainer);
    
    var addMapButton = makeLinkButton(_gtxt("Добавить выбранные растры"));
    
    addMapButton.onclick = function()
    {
        var activeElem = previewLayersTree.getActive();
        if (!activeElem) return;
        
        var objectsToAdd = [];
        
        //если выбрали карту, то elem тут окажется равным undefined
        var elem = activeElem.gmxProperties.content && previewLayersTree.treeModel.findElemByGmxProperties(activeElem.gmxProperties).elem;
        
        if (!elem || elem.type === 'group') {
            previewLayersTree.treeModel.forEachLayer(function(layerElem) {
                var props = layerElem.properties;
                if (props.type === 'Raster' && props.LayerID) {
                    objectsToAdd.push({source: {layerName: props.name}});
                }
            }, elem);
        } else {
            objectsToAdd.push({source: {layerName: elem.content.properties.name}});
        }
        
        if (objectsToAdd.length > 0)
        {
            infoControl.startProcess();
            _mapHelper.modifyObjectLayer(layerName, objectsToAdd)
                .done(function()
                {
                    infoControl.doneProcess(_gtxt('Добавлены растры') + ' (' + objectsToAdd.length + ')');
                })
        }
    }
    
    mapLayerCanvas.append(treeContainer, addMapButton);
    
    var listeners = [];
    var clearListeners = function() {
        for (var i = 0; i < listeners.length; i++) {
            var pt = listeners[i];
            var layer = map.layersByID[pt.layerName];
            layer && layer.off('click', pt.listener);
        }
        listeners = [];
    }
    
    var clickListener = function(event) {
        
        var layerProps = event.gmx.layer.getGmxProperties(),
            attrTypes = event.gmx.layer._gmx.tileAttributeTypes,
            objProps = event.gmx.properties;
        
        if (!objProps['GMX_RasterCatalogID']) {
            infoControl.warning(_gtxt('Выбранный объект не имеет растра'));
            return true;
        }
        
        if (visLayersWidget.isExist(layerProps, objProps)) {
            infoControl.warning(_gtxt('Этот растр уже был выбран'));
            return true;
        }
        
        visLayersWidget.addObject(layerProps, attrTypes, objProps);
        return true;	// Отключить дальнейшую обработку события
    }
    
    $(tabMenu).tabs({
        activate: function(event, ui) {
            var index = $(tabMenu).tabs('option', 'active');
            if (index === 4) { //выбираем на карте - добавляем ко всем растрам listeners
                listeners = [];
                map.layers.forEach(function(layer) {
                    var props = layer.getGmxProperties();
                    if (props.type === 'Vector' && props.IsRasterCatalog)
                    {
                        //тут нужна уникальная ф-ция для дальнейшей очистки слушателей
                        var listener = clickListener.bind(null); 
                        
                        layer.on('click', listener);
                        listeners.push({layerName: props.name, listener: listener});
                    }
                })
            } else {
                clearListeners();
            }
        }
    });
    
    showDialog(_gtxt('Добавить снимки'), dialogCanvas[0], {
        width: 550, 
        height: 550, 
        resizeFunc: function() {
            currAttrControl && currAttrControl.resizeFunc();
        },
        closeFunc: function() {
            clearListeners();
        }
    });
}
//Необходимо подключить JS-библиотеки: jquery, jquery-ui, api.js, utilites.js, treeview.js, translations.js, gmxCore.js, 	файл локализации
//						стили: jquery, jquery-ui, search.css, treeview.css, buttons.css

// ищем только по базе ОСМ
// глобальный конфиг не учитываем,
// поскольку поиск по базе Геоцентра на январь 2017 давно умер
var GLOBAL_USE_OSM = 1;
/**
* @namespace Search
* @description Содержит необходимое для поиска
*/
!(function($){

//TODO: переписать генерацию UI на шаблонах

//Очень суровое решение для разруливания конфликтов с глобальными переменными.
var _, _input, _td, _tr, _div, _t, _table, _tbody, _img, _span, _li, _ul, _form;

$('#flash').droppable({
    drop: function(event, ui) {
        var obj = ui.draggable[0].gmxDrawingObject;

        if (obj) {
            var text = Functions.GetFullName(obj.TypeName, obj.ObjName);
            nsGmx.leafletMap.gmxDrawing.addGeoJSON({
                type: 'Feature',
                geometry: L.gmxUtil.geometryToGeoJSON(obj.Geometry)
            }, {text: text});
        }
    }
})

var initTranslations = function() {
    _translationsHash.addtext("rus", {
        "Текущее местоположение отображается только для России и Украины": "Текущее местоположение отображается только для России и Украины",
        "Следующие [value0] страниц": "Следующие [value0] страниц",
        "Следующие [value0] страницы": "Следующие [value0] страницы",
        "Следующая страница": "Следующая страница",
        "Следующая [value0] страница": "Следующая [value0] страница",
        "Предыдущие [value0] страниц" : "Предыдущие [value0] страниц",
        "Первая страница" : "Первая страница",
        "Последняя страница" : "Последняя страница"
    });

    _translationsHash.addtext("eng", {
        "Текущее местоположение отображается только для России и Украины": "Current location is shown only for Russia and Ukraine",
        "Следующие [value0] страниц": "Next [value0] pages",
        "Следующие [value0] страницы": "Next [value0] pages",
        "Следующая страница": "Next page",
        "Следующая [value0] страница": "Next [value0] pages",
        "Предыдущие [value0] страниц" : "Previous [value0] pages",
        "Первая страница" : "First page",
        "Последняя страница" : "Last page"
    });
}


/** Вспомогательные функции
 @namespace Functions
 @memberOf Search
*/
var Functions = {

	/** Возвращает полное наименование объекта, состоящее из типа и наименования
	 @static
	 @param sType Наименование типа объекта
	 @param sName Наименование объекта
    */
	GetFullName: function(/** string */sType, /** string */sName){
		var sFullName = "";

		if (sType==null || sType == "государство" || sType == "г." || /[a-zA-Z]/.test(sName))
			sFullName = sName;
		else if ((sType.indexOf("район") != -1) || (sType.indexOf("область") != -1) || (sType.indexOf("край") != -1))
			sFullName = sName + " " + sType;
		else
			sFullName = sType + " " + sName;

		return sFullName;
	},

	/** Возвращает полный путь к объекту
    * @memberOf Search.Functions
    *
	* @param oFoundObject найденный объект
	* @param sObjectsSeparator разделитель между дочерним элементом и родителем в строке пути
	* @param bParentAfter признак того, что родительский элемент идет после дочернего
	* @param sObjNameField название свойства, из которого брать наименование
    */
	GetPath: function(/*object*/ oFoundObject,/* string */ sObjectsSeparator, /* bool */ bParentAfter, /* string */ sObjNameField){
		if (sObjNameField == null) sObjNameField = "ObjName";
		if (oFoundObject == null) return "";
		var oParentObj = oFoundObject.Parent;
		if (oParentObj != null && (oParentObj.ObjName == "Российская Федерация" || oParentObj.TypeName == "административный округ")) {
			oParentObj = oParentObj.Parent;
		}
		var sObjectName = (oFoundObject.CountryCode != 28000 && oFoundObject.CountryCode != 310000183) ? oFoundObject[sObjNameField] : this.GetFullName(oFoundObject.TypeName, oFoundObject[sObjNameField]);
		if (oParentObj != null && oParentObj[sObjNameField] != null && oParentObj[sObjNameField]){
			if (bParentAfter){
				return sObjectName + sObjectsSeparator + this.GetPath(oParentObj, sObjectsSeparator,  bParentAfter, sObjNameField);
			}
			else{
				return this.GetPath(oParentObj, sObjectsSeparator,  bParentAfter, sObjNameField) + sObjectsSeparator + sObjectName;
			}
		}
		else{
			return sObjectName;
		}
	},

	/** Возвращает строку, соединяющую переданные свойства
	 @static
	 @param oProps - Свойства
	 @param sObjectsSeparator Разделитель 2х свойств в строке*/
	GetPropertiesString: function(/**object[]*/oProps,/**string*/ sPropSeparator, /**object[]*/arrDisplayFields){
		var sResultString = "";
		if (oProps != null){
			for (var sPropName in oProps){
				if (sResultString != "") sResultString += sPropSeparator;
				sResultString += sPropName + ": " + oProps[sPropName];
			}
		}
		return sResultString;
	}
}

/** Конструктор
 @memberOf Search
 @class Контрол, состоящий из поля поиска с подсказками и кнопкой поиска по векторным слоям
 @param oInitContainer Объект, в котором находится контрол (div) - обязательный
 @param params Параметры: <br/>
	<i>layersSearchFlag</i> - {bool} Признак видимости кнопки поиска по векторным слоям <br/>
	<i>Search</i> = function(event, SearchString, layersSearchFlag) -  осуществляет поиск по строке поиска и признаку "Искать по векторным слоям" <br/>
	<i>AutoCompleteSource</i> = function(request, response) - возвращает данные для автозаполнения: [{label:..., category: ...}] <br/>
	<i>AutoCompleteSelect</i> = function(event, oAutoCompleteItem) - вызывается при выборе из строки автозаполнения*/
var SearchInput = function (oInitContainer, params) {
	/**Объект, в котором находится контрол (div)*/
	var Container = oInitContainer;
	/**Признак видимости кнопки поиска по векторным слоям*/
	var layersSearchFlag = params.layersSearchFlag;
	var _this = this;
	if (Container == null) throw "SearchInput.Container is null";
	var _sDefalutAddressVectorLabel = _gtxt("$$search$$_1");
	var _sDefalutAddressLabel = _gtxt("$$search$$_2");
	/** Возвращает содержимое поля поиска
	@function
	@see Search.SearchInput#SetSearchString*/
	this.GetSearchString = function(){return searchField.value};

	/** Устанавливает содержимое поля поиска
	@function
	@see Search.SearchInput#GetSearchString*/
	this.SetSearchString = function(value) {searchField.value = value;};

	/** Устанавливает содержимое поля поиска
	@function
	@see Search.SearchInput#SetSearchStringFocus*/
	this.SetSearchStringFocus = function(flag) {if (flag) searchField.focus(); else searchField.blur();};

	/** Устанавливает подсказку поля поиска
	@function
	@see Search.SearchInput#SetPlaceholder*/
	this.SetPlaceholder = function(value) {
        searchField.value = searchField.placeholder = sDefaultValue = value;
    };

	if (params.Search != null) $(this).bind('Search', params.Search);
	if (params.AutoCompleteSelect != null) $(this).bind('AutoCompleteSelect', params.AutoCompleteSelect)

	var dtLastSearch = new Date();
	/**Текстовое поле для ввода поискового запроса*/
	var searchField = _input(null, [['dir', 'className', 'searchCenter']]);
	var sDefaultValue;

	var divSearchBegin, tdSearchBegin;
	var tdSearchButton = _td([_div(null, [['dir', 'className', 'searchEnd']])], [['dir', 'className', 'searchEndTD']]);

	/**Вызывает событие необходимости начать поиск*/
	var fnSearch = function(){
		/** Вызывается при необходимости начать поиск (обработчик события его осуществляет)
		@name Search.SearchInput.Search
		@event
		@param {string} SearchString строка для поиска
		@param {bool} layersSearchFlag признак необходимости осуществлять поиск по векторным слоям*/
		$(_this).triggerHandler('Search', [searchField.value, layersSearchFlag]);
	}
    tdSearchButton.onclick = fnSearch;

	/** Смена признака необходимости проводить поиск по векторным слоям*/
	var updateSearchType = function() {
		var bChangeValue = (searchField.value == sDefaultValue);

		if (layersSearchFlag) {
			sDefaultValue = _sDefalutAddressVectorLabel;
			divSearchBegin.className = 'searchBeginOn';
		}
		else {
			sDefaultValue = _sDefalutAddressLabel;
			divSearchBegin.className = 'searchBeginOff';
		}

		if (bChangeValue) searchField.value = sDefaultValue;
	}

	if (!layersSearchFlag) {
        sDefaultValue = _sDefalutAddressLabel;
		divSearchBegin = _div(null, [['dir', 'className', 'searchBegin']]);
        tdSearchBegin = _td([divSearchBegin], [['dir', 'className', 'searchBeginTD']]);
    }
    else {
        sDefaultValue = _sDefalutAddressVectorLabel;
		divSearchBegin = _div(null, [['dir', 'className', 'searchBeginOn']]);
		tdSearchBegin = _td([divSearchBegin], [['dir', 'className', 'searchBeginOnTD']]);
        divSearchBegin.onclick = function() {
            layersSearchFlag = !layersSearchFlag;

            updateSearchType(layersSearchFlag);
        }
        attachEffects(divSearchBegin, 'active');
        _title(divSearchBegin, _gtxt('Изменить параметры поиска'));
    }
	searchField.value = sDefaultValue;

    var searchFieldCanvas = _table(	[_tbody([_tr([tdSearchBegin, _td([searchField], [['dir', 'className', 'searchCenterTD']]), tdSearchButton])])],
									[['dir', 'className', 'SearchInputControl']]);

    $(searchField).on('keyup', function(event) {
        if (event.keyCode === 13) {
			if (Number(new Date()) - dtLastSearch < 1000 || $("#ui-active-menuitem").get().length > 0) return; //Если уже ведется поиск по автозаполнению, то обычный не ведем
			dtLastSearch = new Date();
			if($(searchField).data('ui-autocomplete')) {
                $(searchField).autocomplete("close");
            }
            fnSearch();
            return true;
        }
    });

    searchField.onfocus = function() {
        if (this.value == sDefaultValue) {
            this.value = '';

			$(this).addClass('searchCenterValueExists');
        }
    }

    searchField.onblur = function() {
        if (this.value == '') {
            this.value = sDefaultValue;

			$(this).removeClass('searchCenterValueExists');
        }
    }

    _(Container, [searchFieldCanvas]);

	//Добавляем автокомплит только если задана функция источника данных для него
	if (params.AutoCompleteSource != null)
	{

		/** выбор значения из подсказки
		@param {object} event Событие
		@param {object} ui Элемент управления, вызвавший событие*/
		function fnAutoCompleteSelect(event, ui) {
			if (ui.item) {
				dtLastSearch = new Date();
				/** Вызывается при выборе значения из всплывающей подсказки
				@name Search.SearchInput.AutoCompleteSelect
				@event
				@param {object} AutoCompleteItem Выбранное значение*/
				if (ui.item.GeoObject && ui.item.GeoObject.ObjNameShort){
					var nameProp = ui.item.GeoObject.ObjNameShort.search(/[a-zA-Zа-яА-Я]/)<0?"ObjName":"ObjNameShort";
                    			ui.item.label = ui.item.GeoObject[nameProp];
                    			ui.item.value = ui.item.GeoObject[nameProp];
                    //ui.item.label = ui.item.GeoObject.ObjNameShort;
                    //ui.item.value = ui.item.GeoObject.ObjNameShort;
				}
				$(_this).triggerHandler('AutoCompleteSelect', [ui.item]);
			}
		}

		/** Возвращает данные подсказки
		@param {object} request запрос (request.term - строка запроса)
		@param {object[]} Массив значений для отображения в подсказке*/
		function fnAutoCompleteSource(request, response){
			/** Слова, содержащиеся в строке поиска */
			$(searchField).autocomplete("widget")[0].arrSearchWords = request.term.replace(/[^\wа-яА-Я]+/g, "|").split("|");
			params.AutoCompleteSource(request, function(arrResult){
				if (Number(new Date()) - dtLastSearch > 5000) {
					response(arrResult);
				}
				else
				{
					response([]);
				}
			});
		}

		$(function() {
			$(searchField).autocomplete({
				minLength: 3,
				source: fnAutoCompleteSource,
				select: fnAutoCompleteSelect,
                appendTo: searchField.parentNode
			});

            /** Слова, содержащиеся в строке поиска */
            $(searchField).autocomplete("widget")[0].arrSearchWords = [];

            $(searchField).data("ui-autocomplete")._renderItem = function( ul, item) {
                var t = item.label;
                for (var i=0; i<ul[0].arrSearchWords.length; i++){
                    if(ul[0].arrSearchWords[i].length > 1){
                        var re = new RegExp(ul[0].arrSearchWords[i], 'ig') ;
                        t = t.replace(re, function(str, p1, p2, offset, s){
                            return "<span class='ui-autocomplete-match'>" + str + "</span>";
                        });
                    }
                }
                return $( "<li></li>" )
                    .data( "item.autocomplete", item )
                    .append( "<a>" + t + "</a>" )
                    .appendTo( ul );
            };
		});

	}
	/** Возвращает контрол, в котором находится данный контрол*/
	this.getContainer = function(){return Container;}

	/** Устанавливает значение по умолчанию вместо "Поиск по адресной базе"*/
	this.setAddressVectorDefault = function(value){
		if(searchField.value == _sDefalutAddressLabel) searchField.value = value;
		if(sDefaultValue == _sDefalutAddressLabel) sDefaultValue = value;
		_sDefalutAddressVectorLabel = value;
	}

	/** Устанавливает значение по умолчанию вместо "Поиск по векторным слоям и адресной базе"*/
	this.setAddressDefault = function(value){
		if(searchField.value == _sDefalutAddressLabel) searchField.value = value;
		if(sDefaultValue == _sDefalutAddressLabel) sDefaultValue = value;
		_sDefalutAddressLabel = value;
	}
};

/** Конструктор
 @class Контрол, отображающий результаты поиска в виде списка
 @memberOf Search
 @param {object} oInitContainer Объект, в котором находится контрол (div), обязательный
 @param {string} ImagesHost - строка пути к картинкам*/
var ResultList = function(oInitContainer, ImagesHost){
	/**Объект, в котором находится контрол (div)*/
	var Container = oInitContainer;
	var _this = this;
	var sImagesHost = ImagesHost || "http://maps.kosmosnimki.ru/api/img";

	var arrDisplayedObjects = []; //Объекты, которые отображаются на текущей странице
	var iLimit = 10; //Максимальное количество результатов на странице
	var iPagesCount = 7; //Количество прокручиваемых страниц при нажатии на двойные стрелки
	if (Container == null) throw "ResultList.Container is null";

	var oResultCanvas;
	var arrTotalResultSet = [];

	if(oResultCanvas == null)
	{
		oResultCanvas = _div(null, [['dir', 'className', 'searchResultCanvas']]);
		_(Container, [oResultCanvas]);
	}
	var oLoading = _div([_img(null, [['attr', 'src', sImagesHost + '/progress.gif'], ['dir', 'className', 'searchResultListLoadingImg']]), _t(_gtxt("загрузка..."))], [['dir', 'className', 'searchResultListLoading']]);
	var fnNotFound = function(){_(oResultCanvas, [_div([_t(_gtxt("Поиск не дал результатов"))], [['dir', 'className', 'SearchResultListNotFound']])]);};

	/**Удаляет все найденные объекты из результатов поиска*/
	var unload = function(){
		for(i=0; i<arrDisplayedObjects.length; i++){
			SetDisplayedObjects(i, []);
		}
		$(oResultCanvas).empty();
	}
    /** Переход на следующие страницы*/
    var next = function(iDataSourceN, divChilds, divPages) {
        var button = makeImageButton(sImagesHost + '/next.png', sImagesHost + '/next_a.png');

        button.style.marginBottom = '-7px';

        button.onclick = function() {
			var oDataSource = arrTotalResultSet[iDataSourceN];
            oDataSource.start += iPagesCount;
            oDataSource.reportStart = oDataSource.start * iLimit;

            drawPagesRow(iDataSourceN, divChilds, divPages);
        }

        _title(button, _gtxt('Следующие [value0] страниц', iPagesCount));

        return button;
    }

    /** Переход на предыдущие страницы*/
    var previous = function(iDataSourceN, divChilds, divPages) {
        var button = makeImageButton(sImagesHost + '/prev.png', sImagesHost + '/prev_a.png');

        button.style.marginBottom = '-7px';

        button.onclick = function() {
			var oDataSource = arrTotalResultSet[iDataSourceN];
            oDataSource.start -= iPagesCount;
            oDataSource.reportStart = oDataSource.start * iLimit;

            drawPagesRow(iDataSourceN, divChilds, divPages);
        }

        _title(button, _gtxt('Предыдущие [value0] страниц', iPagesCount));

        return button;
    }

    /** Переход на первую страницу*/
    var first = function(iDataSourceN, divChilds, divPages) {
        var _this = this,
			button = makeImageButton(sImagesHost + '/first.png', sImagesHost + '/first_a.png');

        button.style.marginBottom = '-7px';

        button.onclick = function() {
			var oDataSource = arrTotalResultSet[iDataSourceN];
            oDataSource.start = 0;
            oDataSource.reportStart = oDataSource.start * iLimit;

            drawPagesRow(iDataSourceN, divChilds, divPages);
        }

        _title(button, _gtxt('Первая страница'));

        return button;
    }

    /** Переход на последнюю страницу*/
    var last = function(iDataSourceN, divChilds, divPages) {
        var _this = this,
			button = makeImageButton(sImagesHost + '/last.png', sImagesHost + '/last_a.png');

        button.style.marginBottom = '-7px';

        button.onclick = function() {
			var oDataSource = arrTotalResultSet[iDataSourceN];
            oDataSource.start = Math.floor((oDataSource.SearchResult.length - 1)/ (iPagesCount * iLimit)) * iPagesCount;
            oDataSource.reportStart = Math.floor((oDataSource.SearchResult.length - 1)/ (iLimit)) * iLimit;

            drawPagesRow(iDataSourceN, divChilds, divPages);
        }

        _title(button, _gtxt('Последняя страница'));

        return button;
    }

	/**Добавляет объект в список найденных результатов*/
	var drawObject = function(oFoundObject, elemDiv, bIsParent)
	{
		var	realPath = (oFoundObject.CountryCode != 28000 && oFoundObject.CountryCode != 310000183)  ? oFoundObject.ObjName : Functions.GetFullName(oFoundObject.TypeName, oFoundObject.ObjName);
		if (oFoundObject.Parent != null) realPath += ",";

		var searchElemHeader = _span([_t(realPath)], [['dir', 'className', bIsParent?'searchElemParent':'searchElem']]);

		/** Вызывается при клике на найденный объект в списке результатов поиска
		@name Search.ResultList.onObjectClick
		@event
		@param {object} oFoundObject Найденный объект*/
		searchElemHeader.onclick = function(){$(_this).triggerHandler('onObjectClick', [oFoundObject]);};

		_(elemDiv, [searchElemHeader]);
		if (oFoundObject.Parent != null) drawObject(oFoundObject.Parent, elemDiv, true);
		if (oFoundObject.properties != null) _(elemDiv, [document.createTextNode(" " + Functions.GetPropertiesString(oFoundObject.properties, "; "))]);
	}

	/** Рисует строки списка*/
	var drawRows = function(iDataSourceN, divChilds) {
		var arrObjects = arrDisplayedObjects[iDataSourceN];
		$(divChilds).empty();
		var tbody = _tbody();
		for (var i = 0; i < arrObjects.length; i++) {
			var elemTR = _tr(null, [['dir', 'className', 'SearchResultRow']]);
			var elemTD = _td(null, [['dir', 'className', 'SearchResultText']]);
			_(elemTR, [_td([_t((i+1).toString() + ".")], [['dir', 'className','searchElemPosition']]), elemTD]);
			drawObject(arrObjects[i], elemTD);

			// загрузка SHP Файла
			if (window.gmxGeoCodeShpDownload && arrObjects[i].Geometry != null) {
			    var shpFileLink = _span([_t(".shp")], [['dir', 'className', 'searchElem'], ['attr', 'title', 'скачать SHP-файл'], ['attr', 'number', i]]);

			    shpFileLink.onclick = function () {
			        var obj = arrObjects[$(this).attr('number')];
			        var objsToDownload = [obj];
			        $(_this).triggerHandler('onDownloadSHP', [obj.ObjCode, objsToDownload]);
			    };
			    _(elemTD, [_t(" ")]);
			    _(elemTD, [shpFileLink]);
			}

            elemTD.gmxDrawingObject = arrObjects[i];

            $(elemTD).draggable({
                scroll: false,
                appendTo: document.body,
                helper: 'clone',
                distance: 10
            });

			_(tbody, [elemTR]);
		}
		_(divChilds, [_table([tbody])]);

	}

	/**рисует номера страниц списка
	@param end - последний номер
	@param iDataSourceN - номер источника данных
	@param divChilds - раздел для элементов списка
	@param divPages - раздел для номеров страниц списка*/
	var drawPages = function(end, iDataSourceN, divChilds, divPages) {
		var oDataSource = arrTotalResultSet[iDataSourceN];
		for (var i = oDataSource.start + 1; i <= end; i++) {
			// текущий элемент
			if (i - 1 == oDataSource.reportStart / iLimit) {
				var el = _span([_t(i.toString())]);
				_(divPages, [el]);
				$(el).addClass('page');
			}
			else {
				var link = makeLinkButton(i.toString());

				link.setAttribute('page', i - 1);
				link.style.margin = '0px 2px';

				_(divPages, [link]);

				link.onclick = function() {
					arrTotalResultSet[iDataSourceN].reportStart = this.getAttribute('page') * iLimit;

					drawPagesRow(iDataSourceN, divChilds, divPages);
				};
			}

		}
	}

	/**Рисует одну из страниц списка
	@param iDataSourceN - номер источника данных
	@param divChilds - раздел для элементов списка
	@param divPages - раздел для номеров страниц списка*/
	var drawPagesRow = function(iDataSourceN, divChilds, divPages) {
		var oDataSource = arrTotalResultSet[iDataSourceN];

		// перерисовывем номера страниц
		$(divPages).empty();

		var end = (oDataSource.start + iPagesCount <= oDataSource.allPages) ? oDataSource.start + iPagesCount : oDataSource.allPages;

		if (oDataSource.start - iPagesCount >= 0)
			_(divPages, [first(iDataSourceN, divChilds, divPages), previous(iDataSourceN, divChilds, divPages)]);

		drawPages(end, iDataSourceN, divChilds, divPages);

		if (end + 1 <= oDataSource.allPages)
			_(divPages, [next(iDataSourceN, divChilds, divPages), last(iDataSourceN, divChilds, divPages)]);

		SetDisplayedObjects(iDataSourceN, oDataSource.SearchResult.slice(oDataSource.reportStart, oDataSource.reportStart + iLimit));
		drawRows(iDataSourceN, divChilds);
	}

	/**Рисует таблицу для результатов источника данных
	@param iDataSourceN - номер источника данных
	@param divChilds - раздел для элементов списка
	@param divPages - раздел для номеров страниц списка*/
	var drawTable = function(iDataSourceN, divChilds, divPages) {
		var oDataSource = arrTotalResultSet[iDataSourceN];

		if (oDataSource.SearchResult.length <= iLimit) {
			$(divPages).empty();
			SetDisplayedObjects(iDataSourceN, oDataSource.SearchResult);
			drawRows(iDataSourceN, divChilds);
		}
		else {
			oDataSource.allPages = Math.ceil(oDataSource.SearchResult.length / iLimit);

			drawPagesRow(iDataSourceN, divChilds, divPages);
		}
	}

	/**Обрабатывает событие нажатия на кнопку "Скачать SHP-файл"
	@param iDataSourceN - номер источника данных*/
	var downloadMarkers = function(iDataSourceN) {
		var oDataSource = arrTotalResultSet[iDataSourceN];
		var canvas = _div(),
			filename = _input(null, [['dir', 'className', 'filename'], ['attr', 'value', oDataSource.name]]);

		var downloadButton = makeButton(_gtxt("Скачать"));
		downloadButton.onclick = function() {
			if (filename.value == '') {
				inputError(filename, 2000);

				return;
			}

			/** Вызывается при необходимости осуществить загрузку SHP-файла с результатами поиска
			@name Search.ResultList.onDownloadSHP
			@event
			@param {string} filename Имя файла, которой необходимо будет сформировать
			@param {object[]} SearchResult Результаты поиска, которые необходимо сохранить в файл*/
			$(_this).triggerHandler('onDownloadSHP', [filename.value, oDataSource.SearchResult]);

			$(canvas.parentNode).dialog("destroy").remove();
		}

		_(canvas, [_div([_t(_gtxt("Введите имя файла для скачивания")), filename], [['dir', 'className', 'DownloadSHPButtonText']]), _div([downloadButton], [['dir', 'className', 'DownloadSHPButton']])]);

		var area = getOffsetRect(Container);
		showDialog(_gtxt("Скачать shp-файл"), canvas, 291, 120, 30, area.top + 10);
	}

	/**Отображает результаты поиска с источника данных
	@param iDataSourceN - номер источника данных*/
	var drawSearchResult = function(iDataSourceN) {
		var oDataSource = arrTotalResultSet[iDataSourceN];

		var arrDataSourceList = oDataSource.SearchResult;
		var header = oDataSource.name;

		var divChilds = _div(null, [['dir', 'className', 'SearchResultListChildsCanvas']]),
			divPages = _div(),
			liInner = _li([divChilds, divPages]),
			li;
		if (arrTotalResultSet.length == 1){
			li = _ul([liInner]);
		}
		else{
			li = _li([_div([_t(header), _span([_t("(" + arrDataSourceList.length + ")")])], [['dir', 'className', 'searchLayerHeader']]), _ul([liInner])]);
		}

		oDataSource.start = 0;
		oDataSource.reportStart = 0;
		oDataSource.allPages = 0;

		drawTable(iDataSourceN, divChilds, divPages);

		if (oDataSource.CanDownloadVectors) {
			var downloadVector = makeLinkButton(_gtxt("Скачать shp-файл"));

			downloadVector.onclick = function() {
				downloadMarkers(iDataSourceN);
			}

			liInner.insertBefore(_div([downloadVector], [['dir', 'className', 'SearchDownloadShpLink']]), liInner.firstChild);
		}

		return li;
	}

	/**Отображает результаты поиска в списке
	@param sTotalListName - заголовок итогового результата
	@param {Array.<Object>} arrTotalList. Массив объектов со следующими свойствами{name:DataSourceName, CanDownloadVectors:CanDownloadVectors, SearchResult:arrDataSourceList[oObjFound,...]}
	@returns {void}
	*/
	this.ShowResult = function(sTotalListName, arrTotalList){
		arrTotalResultSet = arrTotalList;
	    $(oResultCanvas).empty();
		arrDisplayedObjects = [];
		if (!objLength(arrTotalResultSet)) {
			fnNotFound();
			return;
		}
		else {
			var foundSomething = false;

			for (var i = 0; i < arrTotalResultSet.length; i++) {
				if (arrTotalResultSet[i].SearchResult.length > 0) {
					foundSomething = true;
					break;
				}
			}
			if (!foundSomething) {
				fnNotFound();
				return;
			}
		}

		var ulSearch = _ul();

		for (var iDataSourceN  = 0; iDataSourceN < arrTotalResultSet.length; iDataSourceN++)
			_(ulSearch, [drawSearchResult(iDataSourceN)]);

		if (arrTotalResultSet.length == 1){
			_(oResultCanvas, [ulSearch]);
		}
		else{
			_(oResultCanvas, [_li([_div([_t(sTotalListName)], [['dir', 'className', 'SearchTotalHeader']]), ulSearch])]);
		}

        if (typeof($.fn.treeview) === 'function') {
            $(oResultCanvas).treeview();
        }

		$(oResultCanvas).find(".SearchResultListChildsCanvas").each(function() {
			this.parentNode.style.padding = '0px';
			this.parentNode.style.background = 'none';
		})
	}


    /**Создается переключатель страниц
    @param results - набор результатов
    @param onclick - обработчик нажатия переключателя страниц
    @returns {void}*/
    this.CreatePager = function (results, onclick) {

        function makeNavigButton(pager, img, imga, id, title) {
            var b = makeImageButton(sImagesHost + img, sImagesHost + imga);
            b.style.marginBottom = '-7px';
            $(b).attr('id', id)
            _title(b, title);
            _(pager, [b]);
            return b;
        }

        containerList = Container;
        $('#respager').remove();
        //var pager = _div([_t('всего: ' + results[0].ResultsCount)], [["attr", "id", "respager"]]);
        var pager = _div([_t('')], [["attr", "id", "respager"]]);
        _(containerList, [pager]);

        var pcount = results[0].SearchResult[0] ? Math.ceil(results[0].SearchResult[0].OneOf / iLimit) : 0;
        if (pcount > 1) {
            var first = makeNavigButton(pager, '/first.png', '/first_a.png', 'firstpage', _gtxt('Первая страница'));
            $(first).bind('click', function () {
                fnShowPage(0);
            });
            var prev = makeNavigButton(pager, '/prev.png', '/prev_a.png', 'prevpages', _gtxt('Предыдущие [value0] страниц', iPagesCount));
            $(prev).bind('click', function () {
                fnShowPage(parseInt($('#page1').text()) - iPagesCount - 1);
            });
            $(first).hide();
            $(prev).hide();

            for (var i = 0; i < iPagesCount && i < pcount; ++i) {
                var pagelink = makeLinkButton(i + 1);
                $(pagelink).attr('id', 'page' + (i + 1));
                if (i == 0){
                    $(pagelink).attr('class', 'page')
                    attachEffects(pagelink, '');
                }
                $(pagelink).bind('click', onclick);
                _(pager, [pagelink, _t(' ')]);
            }

            var remains = pcount % iPagesCount;
            var nextPages = pcount/iPagesCount<2 ? remains : iPagesCount
            var nextButTitle = 'Следующие [value0] страниц';
            if (nextPages == 1)
                nextButTitle = 'Следующая страница';
            if (nextPages % 10 == 1 && nextPages != 1 && nextPages != 11)
                nextButTitle = 'Следующая [value0] страница';
            if (1 < nextPages % 10 && nextPages % 10 < 5 && (nextPages<10 || nextPages > 20))
                nextButTitle = 'Следующие [value0] страницы';
            var next = makeNavigButton(pager, '/next.png', '/next_a.png', 'nextpages', _gtxt(nextButTitle, nextPages));
            $(next).bind('click', function () {
                fnShowPage(parseInt($('#page' + iPagesCount).text()));
            });
            var last = makeNavigButton(pager, '/last.png', '/last_a.png', 'lastpage', _gtxt('Последняя страница'));
            $(last).bind('click', function () {
                var lastindex = (remains == 0 ? iPagesCount : remains)
                fnShowPage(pcount - lastindex, $('#page' + lastindex));
            });

            if (iPagesCount >= pcount) {
                $(next).hide();
                $(last).hide();
            }
        }

        var fnShowPage = function (n, active) {
            //alert(n + "\n" + pcount);
            for (var i = 0; i < iPagesCount; ++i) {//pcount
                if (i + n < pcount) {
                    $('#page' + (i + 1)).text(i + n + 1);
                    $('#page' + (i + 1)).show();
                }
                else
                    $('#page' + (i + 1)).hide();
            }

            if (n < iPagesCount) {
                $('#prevpages').hide(); $('#firstpage').hide();
            }
            else {
                $('#prevpages').show(); $('#firstpage').show();
            }

            if (n + iPagesCount < pcount) {
                $('#nextpages').show(); $('#lastpage').show();
                var rest = pcount - n - iPagesCount;
                var nextPages = rest < iPagesCount ? rest : iPagesCount
                var nextButTitle = 'Следующие [value0] страниц';
                if (nextPages == 1)
                    nextButTitle = 'Следующая страница';
                if (nextPages % 10 == 1 && nextPages != 1 && nextPages != 11)
                    nextButTitle = 'Следующая [value0] страница';
                if (1 < nextPages % 10 && nextPages % 10 < 5 && (nextPages < 10 || nextPages > 20))
                    nextButTitle = 'Следующие [value0] страницы';
                $('#nextpages').attr('title', _gtxt(nextButTitle, nextPages));
            }
            else {
                $('#nextpages').hide(); $('#lastpage').hide();
            }

            if (active == null) active = $('#prevpages~span')[0];
            $(active).trigger('click');
        }
    }
    /*----------------------------------------------------------*/

	/**Возвращает список объектов, которые отображаются на текущей странице во всех разделах*/
	this.GetDisplayedObjects = function(){return arrDisplayedObjects; };
	var SetDisplayedObjects = function(iDataSourceN, value) {
		arrDisplayedObjects[iDataSourceN] = value;

		/** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
		@name Search.ResultList.onDisplayedObjectsChanged
		@event
		@param {int} iDataSourceN № источника данных(группы результатов поиска)
		@param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/
		$(_this).triggerHandler('onDisplayedObjectsChanged',[iDataSourceN, arrDisplayedObjects[iDataSourceN]]);
	};

	/** Показывает режим загрузки
	@returns {void}*/
	this.ShowLoading = function(){
	    $('#respager').remove();
        $(oResultCanvas).empty();
		_(oResultCanvas, [oLoading]);
	}

	/**Показывает сообщение об ошибке
	@returns {void}*/
	this.ShowError = function(){
		$(oResultCanvas).empty();
		_(oResultCanvas, [_t("Произошла ошибка")]);
	}

	/**Очищает результаты поиска
	@returns {void}*/
	this.Unload = function(){unload();};
	/** Возвращает контрол, в котором находится данный контрол*/
	this.getContainer = function(){return Container;};
};

/** Конструктор
 @class Предоставляет функции, отображающие найденные объекты на карте
 @memberof Search
 @param {L.Map} map карта, на которой будут рисоваться объекты
 @param {string} sInitImagesHost - строка пути к картинкам
 @param {bool} bInitAutoCenter - если true, карта будет центрироваться по 1ому найденному объекту*/
var ResultRenderer = function(map, sInitImagesHost, bInitAutoCenter){
	if (map == null)  throw "ResultRenderer.Map is null";

	var sImagesHost = sInitImagesHost || "http://maps.kosmosnimki.ru/api/img";
	var bAutoCenter = (bInitAutoCenter == null) || bInitAutoCenter;

	var arrContainer = [];
	var counts = [];

	/** возвращает стили найденных объектов, используется только для точки*/
	var getSearchIcon = function(iPosition) {
        iPosition = Math.min(iPosition, 9);
        return L.icon({
            iconUrl: sImagesHost + "/search/search_" + (iPosition + 1).toString() + ".png",
            iconAnchor: [15, 38],
            popupAnchor: [0, -28]
        });

		// return [
						// { marker: { image: sImagesHost + "/search/search_" + (iPosition + 1).toString() + ".png", dx: -14, dy: -38} },
						// { marker: { image: sImagesHost + "/search/search_" + (iPosition + 1).toString() + "a.png", dx: -14, dy: -38} }
				// ];
	}

    var bindHoverPopup = function(layer, content) {
        layer.bindPopup(content);
    }

	/**Помещает объект на карту
	@param {MapObject} oContainer контейнер, содержащий в себе объекты текущей группы результатов поиска
	@param {MapObject} oFoundObject добавляемый объект
	@param {int} iPosition порядковый номер добавляемого объекта в группе
	@param {int} iCount общее количество объектов в группе
    @return {Object} Нарисованные на карте объекты: хеш с полями center и boundary */
	var DrawObject = function(oContainer, oFoundObject, iPosition, iCount){
        var color = Math.round(0x22 + 0x99*iPosition/iCount);
		var sDescr = "<b>" + Functions.GetFullName(oFoundObject.TypeName, oFoundObject.ObjName) + "</b><br/>" + Functions.GetPath(oFoundObject.Parent, "<br/>", true);
		if (oFoundObject.properties != null) sDescr += "<br/>" + Functions.GetPropertiesString(oFoundObject.properties, "<br/>");

        sDescr = sDescr.replace(/;/g, "<br/>");

		var fnBaloon = function(o) {
			return o.properties.Descr.replace(/;/g, "<br/>");
		};
		var centerMapElem,
            boundaryMapElem;
		//Рисуем центр объекта
		if (oFoundObject.Geometry != null && oFoundObject.Geometry.type == 'POINT') {
            centerMapElem = L.marker([oFoundObject.Geometry.coordinates[1], oFoundObject.Geometry.coordinates[0]], {
                icon: getSearchIcon(iPosition)
            });
            bindHoverPopup(centerMapElem, sDescr);
            oContainer.addLayer(centerMapElem);
		}
		else if (oFoundObject.CntrLon != null && oFoundObject.CntrLat != null){
            centerMapElem = L.marker([oFoundObject.CntrLat, oFoundObject.CntrLon], {
                icon: getSearchIcon(iPosition)
            });

            bindHoverPopup(centerMapElem, sDescr);
            oContainer.addLayer(centerMapElem);
		}


		//Рисуем контур объекта
		if (oFoundObject.Geometry != null && oFoundObject.Geometry.type != 'POINT') {
            boundaryMapElem = L.geoJson(L.gmxUtil.geometryToGeoJSON(oFoundObject.Geometry), {
                style: function(feature) {
                    return
                },
                onEachFeature: function(feature, layer) {
                    layer.setStyle({
                        color: '#' + (0x1000000 + (color << 16) + (color << 8) + color).toString(16).substr(-6),
                        weight: 3,
                        opacity: 0.6,
                        fill: false
                    });

                    bindHoverPopup(layer, sDescr)
                }
            });

            oContainer.addLayer(boundaryMapElem);
		}

        return {center: centerMapElem, boundary: boundaryMapElem};
	};

	/**Центрует карту по переданному объекту*/
	var CenterObject = function(oFoundObject){
		if (!oFoundObject) return;
		var iZoom = oFoundObject.TypeName == "г." ? 9 : 15;
        if (oFoundObject.Geometry == null) {
		    if (oFoundObject.MinLon != null && oFoundObject.MaxLon != null && oFoundObject.MinLat != null && oFoundObject.MaxLat != null
                && oFoundObject.MaxLon - oFoundObject.MinLon < 1e-9 && oFoundObject.MaxLat - oFoundObject.MinLat < 1e-9)
			    map.setView([oFoundObject.CntrLat, oFoundObject.CntrLon], iZoom);
		    else
			    map.fitBounds([[oFoundObject.MinLat, oFoundObject.MinLon], [oFoundObject.MaxLat, oFoundObject.MaxLon]]);
        }
		else
		{
           if (oFoundObject.Geometry.type == 'POINT') {
		        if (oFoundObject.MinLon != oFoundObject.MaxLon && oFoundObject.MinLat != oFoundObject.MaxLat) {
			        map.fitBounds([[oFoundObject.MinLat, oFoundObject.MinLon], [oFoundObject.MaxLat, oFoundObject.MaxLon]]);
                } else {
                    var c = oFoundObject.Geometry.coordinates;
			        map.setView([c[1], c[0]], iZoom);
                }
		    }
		    else {
                var bounds = L.gmxUtil.getGeometryBounds(oFoundObject.Geometry);
			    //var oExtent = getBounds(oFoundObject.Geometry.coordinates);
			    map.fitBounds([[bounds.min.y, bounds.min.x], [bounds.max.y, bounds.max.x]]);
            }
		}
	};

	/**Центрует карту по переданному объекту
	@param {MapObject} oFoundObject объект, который нужно поместить в центр
	@returns {void}*/
	this.CenterObject = function(oFoundObject){
		CenterObject(oFoundObject);
	}

	/** Рисует объекты на карте.
	@param {int} iDataSourceN № источника данных (группы результатов поиска)
	@param {Array} arrFoundObjects Массив объектов для отрисовки. Каждый объект имеет свойства
	@param {bool} [options.append=false] Добавить к существующим объектам для источника данных, а не удалять их
	@return {Array} Нарисованные на карте объекты: массив хешей с полями center и boundary
    */
	this.DrawObjects = function(iDataSourceN, arrFoundObjects, options){
        options = $.extend({append: false}, options);

        if (!options.append && arrContainer[iDataSourceN]) {
            map.removeLayer(arrContainer[iDataSourceN]);
            delete arrContainer[iDataSourceN];
        }

        if (!arrContainer[iDataSourceN]) {
            arrContainer[iDataSourceN] = L.layerGroup();
            counts[iDataSourceN] = 0;
        }

		iCount = arrFoundObjects.length;

        var mapObjects = [];

        counts[iDataSourceN] += arrFoundObjects.length;

		//Отрисовываем задом наперед, чтобы номер 1 был сверху от 10ого
		for (var i = arrFoundObjects.length - 1; i >= 0; i--){
			mapObjects.unshift(DrawObject(arrContainer[iDataSourceN], arrFoundObjects[i], counts[iDataSourceN] + i - arrFoundObjects.length, counts[iDataSourceN]));
		}

		arrContainer[iDataSourceN].addTo(map);
		if (bAutoCenter && iDataSourceN == 0) CenterObject(arrFoundObjects[0]);

        return mapObjects;
	}
};

/** Конструктор
 @class Предоставляет функции, отображающие найденные объекты на карте
 @memberof Search
 @param {object} oInitMap карта, на которой будут рисоваться объекты
 @param {function} fnSearchLocation = function({Geometry, callback})- функция поиска объектов по переданной геометрии*/
var LocationTitleRenderer = function(oInitMap, fnSearchLocation){
	var _this = this;
	var oMap = oInitMap;
	var dtLastSearch;

	/**Добавляет объект в список найденных результатов*/
	var drawObject = function(oFoundObject, elemDiv)
	{
		if (oFoundObject.Parent != null) drawObject(oFoundObject.Parent, elemDiv, true);
		var	realPath = oFoundObject.IsForeign ? oFoundObject.ObjName : Functions.GetFullName(oFoundObject.TypeName, oFoundObject.ObjName);

		var searchElemHeader = _span([_t(realPath)], [['dir', 'className', 'searchLocationPath']]);

		/** Вызывается при клике на найденный объект в списке результатов поиска
		@name Search.ResultList.onObjectClick
		@event
		@param {object} oFoundObject Найденный объект*/
		searchElemHeader.onclick = function(){$(_this).triggerHandler('onObjectClick', [oFoundObject]);};

		if (oFoundObject.Parent != null) _(elemDiv, [_t("->")]);
		_(elemDiv, [searchElemHeader]);
	}

	var setLocationTitleDiv = function(div, attr) {
		if (dtLastSearch && Number(new Date()) - dtLastSearch < 300) return;
		dtLastSearch = new Date();

		var locationTitleDiv = div;

		fnSearchLocation({Geometry: attr['screenGeometry'], callback: function(arrResultDataSources){
			$(locationTitleDiv).empty();
			if(arrResultDataSources.length>0 && arrResultDataSources[0].SearchResult.length>0){
				drawObject(arrResultDataSources[0].SearchResult[0], locationTitleDiv);
			}
			else{
				_(locationTitleDiv, [_t(_gtxt("Текущее местоположение отображается только для России и Украины"))]);
			}
		}});
	};

	if (oMap.coordinates) oMap.coordinates.addCoordinatesFormat(setLocationTitleDiv);
}

/** Возвращает контрол, отображающий результаты поиска в виде списка с нанесением на карту
 @memberof Search
 @param {object} oInitContainer Объект, в котором находится контрол результатов поиска в виде списка(div)
 @param {object} oInitMap карта, на которой будут рисоваться объекты
 @param {string} ImagesHost - строка пути к картинкам
 @param {bool} bInitAutoCenter - если true, карта будет центрироваться по 1ому найденному объекту
 @returns {Search.ResultListMap}*/
var ResultListMapGet = function(oInitContainer, oInitMap, sImagesHost, CustomResultList, bInitAutoCenter){
	var oRenderer = new ResultRenderer(oInitMap, sImagesHost, bInitAutoCenter),
        lstResult;

    if (typeof CustomResultList === 'function') {
        lstResult = new CustomResultList(oInitContainer, sImagesHost);
    } else {
        lstResult = new ResultList(oInitContainer, sImagesHost);
    }

	ResultListMap.call(this, lstResult, oRenderer);
}

ResultListMapGet.prototype = ResultListMap;

/** Конструктор
 @class Контрол, отображающий результаты поиска в виде списка с нанесением на карту
 @memberof Search
 @param lstResult Контрол результатов поиска в виде списка
 @param oRenderer Объект, предоставляющий функции отрисовки найденных объектов на карте*/
var ResultListMap = function(lstResult, oRenderer){
	var _this = this;

	var fnDisplayedObjectsChanged = function(event, iDataSourceN, arrFoundObjects){
		oRenderer.DrawObjects(iDataSourceN, arrFoundObjects);
		/** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
		@name Search.ResultListMap.onDisplayedObjectsChanged
		@event
		@param {int} iDataSourceN № источника данных(группы результатов поиска)
		@param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/
		$(_this).triggerHandler('onDisplayedObjectsChanged', [iDataSourceN, arrFoundObjects]);
	}

	var fnObjectClick = function(event, oFoundObject){
		oRenderer.CenterObject(oFoundObject);

		/** Вызывается при клике на найденный объект в списке результатов поиска
		@name Search.ResultListMap.onObjectClick
		@event
		@param {object} oFoundObject Найденный объект*/
		$(_this).triggerHandler('onObjectClick', [oFoundObject]);
	}

	var fnDownloadSHP = function(event, filename, arrObjectsToDownload){
		/** Вызывается при необходимости осуществить загрузку SHP-файла с результатами поиска
		@name Search.ResultListMap.onDownloadSHP
		@event
		@param {string} filename Имя файла, которой необходимо будет сформировать
		@param {object[]} SearchResult Результаты поиска, которые необходимо сохранить в файл*/
		$(_this).triggerHandler('onDownloadSHP', [filename, arrObjectsToDownload]);
	}

	$(lstResult).bind('onDisplayedObjectsChanged', fnDisplayedObjectsChanged);
	$(lstResult).bind('onObjectClick', fnObjectClick);
	$(lstResult).bind('onDownloadSHP', fnDownloadSHP);

	/**Отображает результаты поиска в списке
	@param sTotalListName - заголовок итогового результата
	@param {Array.<Object>} arrTotalList Массив объектов со следующими свойствами {name:DataSourceName, CanDownloadVectors:CanDownloadVectors, SearchResult:arrDataSourceList[oObjFound,...]}
	@returns {void}*/
	this.ShowResult = function(sTotalListName, arrTotalList){
		lstResult.ShowResult(sTotalListName, arrTotalList);
	}


    /**Создается переключатель страниц
    @param results - набор результатов
    @param onclick - обработчик нажатия переключателя страниц
    @returns {void}*/
    this.CreatePager = function (results, onclick) {
        lstResult.CreatePager(results, onclick);
    }

	/**Показывает режим загрузки
	@returns {void}*/
	this.ShowLoading = function(){
		lstResult.ShowLoading();
	}

	/**Показывает сообщение об ошибке
	@returns {void}*/
	this.ShowError = function(){
		lstResult.ShowError();
	}

	/**Центрует карту по переданному объекту
	@param {MapObject} oFoundObject объект, который нужно поместить в центр
	@returns {void}*/
	this.CenterObject = function(oFoundObject){
		oRenderer.CenterObject(oFoundObject);
	}

	/**Очищает результаты поиска
	@returns {void}*/
	this.Unload = function(){lstResult.Unload();};
	/** Возвращает контейнер, содержащий список найденных объектов*/
	this.getContainerList = function(){return lstResult.getContainer();};
}

/**Конструктор
 @class SearchDataProvider Посылает запрос к поисковому серверу
 @memberof Search
 @param {string} sInitServerBase Адрес сервера, на котором установлен поисковый модуль Geomixer'а
 @param {L.gmxMap} gmxMap карта, содержащая слои, по которым должен производиться поиск
 @param {string[]} arrDisplayFields список атрибутов векторных слоев, которые будут отображаться в результатах поиска*/
var SearchDataProvider = function(sInitServerBase, gmxMap, arrDisplayFields){
	var sServerBase = sInitServerBase;
	if (sServerBase == null || sServerBase.length < 7) {throw "Error in SearchDataProvider: sServerBase is not supplied"};
	// var oMap = oInitMap;
	var iDefaultLimit = 100;
	var _this = this;
	/**Осуществляет поиск по произвольным параметрам
	@param {object} params Параметры: </br>
		<i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
		<i>SearchString</i> - строка для поиска </br>
		<i>IsStrongSearch</i> - признак того, что искать только целые слова </br>
		<i>Geometry</i> - искать только объекты, пересекающие данную геометрию </br>
		<i>Limit</i> - максимальное число найденных объектов
		<i>WithoutGeometry<i> - не передавать геометрию в результатах поиска
		<i>RequestType<i> - Тип запроса к серверу
        <i>PageNum<i> - Показать страницу
        <i>ShowTotal<i> - Сообщить сколько найдено всего записей
        <i>UseOSM<i> - Искать в базе OSM
	@returns {void}*/
	var fnSearch = function(params)	{
		var callback = params.callback;
		var sQueryString = "RequestType=" + encodeURIComponent(params.RequestType);
		if (params.SearchString != null) sQueryString += "&SearchString=" + encodeURIComponent(params.SearchString);
		if (params.Geometry != null) sQueryString += "&GeometryJSON=" + encodeURIComponent(JSON.stringify(params.Geometry));
		if (params.Limit != null) sQueryString += "&Limit=" + encodeURIComponent(params.Limit.toString());
		if (params.ID != null) sQueryString += "&ID=" + encodeURIComponent(params.ID.toString());
		if (params.TypeCode != null) sQueryString += "&TypeCode=" + encodeURIComponent(params.TypeCode.toString());
		if (params.IsStrongSearch != null) sQueryString += "&IsStrongSearch=" + encodeURIComponent(params.IsStrongSearch ? "1" : "0");
		if (params.WithoutGeometry != null) sQueryString += "&WithoutGeometry=" + encodeURIComponent(params.WithoutGeometry ? "1" : "0");
		if (params.PageNum != null) sQueryString += "&PageNum=" + params.PageNum;
		if (params.ShowTotal != null) sQueryString += "&ShowTotal=" + params.ShowTotal;
		if (params.UseOSM != null) sQueryString += "&UseOSM=" + params.UseOSM;
		//if (sFormatName != null) sQueryString += "&Format=" + encodeURIComponent(sFormatName);

		var key = window.KOSMOSNIMKI_SESSION_KEY;
		if (key == null || key == "INVALID")
			key = false;
		sendCrossDomainJSONRequest(sServerBase + "SearchObject/SearchAddress.ashx?" + sQueryString + (key ? ("&key=" + encodeURIComponent(key)) : ""), function (response) {
			if (response.Status == 'ok') {callback(response.Result);}
			else {throw response.ErrorInfo.ErrorMessage;}
		});
	};

	/**Осуществляет поиск по переданной строке
	@param {object} params Параметры: </br>
		<i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
		<i>SearchString</i> - строка для поиска </br>
		<i>IsStrongSearch</i> - признак того, что искать только целые слова </br>
		<i>Limit</i> - максимальное число найденных объектов
		<i>WithoutGeometry<i> - не передавать геометрию в результатах поиска
        <i>PageNum<i> - Показать страницу
        <i>ShowTotal<i> - Сообщить сколько найдено всего записей
        <i>UseOSM<i> - Искать в базе OSM
	@returns {void}*/
	this.SearchByString = function(params){
	    fnSearch({ callback: params.callback, SearchString: params.SearchString, IsStrongSearch: params.IsStrongSearch, Limit: params.Limit, WithoutGeometry: params.WithoutGeometry, RequestType: "SearchObject",
        PageNum: params.PageNum, ShowTotal: params.ShowTotal, UseOSM: params.UseOSM });
	};

	/**Получает информацию об объекте
	@param {object} params Параметры: </br>
		<i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
		<i>ID</i> - идентификатор объекта </br>
	@returns {void}*/
	this.SearchID = function(params){
		fnSearch({callback: params.callback, ID: params.ID, RequestType: "ID", TypeCode: params.TypeCode, UseOSM: params.UseOSM});
	}

	/**Осуществляет поиск текущего местонахождения
	@param {object} params Параметры: </br>
		<i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
		<i>Geometry</i> - искать только объекты, пересекающие данную геометрию </br>
	@returns {void}*/
	this.SearchLocation = function(params){
		fnSearch({callback: params.callback, Geometry: params.Geometry, WithoutGeometry: true, RequestType: "Location"});
	}

    /**Осуществляет поиск ближайшего объекта к центру указанной области
    @param {object} params Параметры: </br>
    <i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
    <i>Geometry</i> - искать только объекты, пересекающие данную геометрию </br>
    @returns {void}*/
    this.SearchNearest = function (params) {
        fnSearch({ callback: params.callback, Geometry: params.Geometry, WithoutGeometry: true, RequestType: "Nearest" });
    }

	/**Осуществляет поиск по произвольным параметрам
	@param {object} params Параметры: </br>
		<i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
		<i>SearchString</i> - строка для поиска </br>
		<i>IsStrongSearch</i> - признак того, что искать только целые слова </br>
		<i>Geometry</i> - искать только объекты, пересекающие данную геометрию </br>
		<i>Limit</i> - максимальное число найденных объектов
		<i>WithoutGeometry<i> - не передавать геометрию в результатах поиска
	@returns {void}*/
	this.Search = function(params){
		fnSearch({
			callback: params.callback,
			SearchString: params.SearchString,
			IsStrongSearch: params.IsStrongSearch,
			Limit: params.Limit == null ? iDefaultLimit : params.Limit,
			Geometry: params.Geometry,
			WithoutGeometry: params.WithoutGeometry,
			RequestType: "SearchObject"
		});
	};

	/**Осуществляет поиск по векторным слоям
	@returns {void}*/
	this.LayerSearch = function(sInitSearchString, oInitGeometry, callback){
		if (!gmxMap){
			callback([]);
			return;
		}
		var arrResult = [];

		var layersToSearch = [];
		for (var i=0; i< gmxMap.layers.length; i++) {
            //свойства мы берём из дерева слоёв, а не из API. Cвойство AllowSearch относится к карте и не поддерживаются API
            var searchRes = _layersTree.treeModel.findElem('name', gmxMap.layers[i].getGmxProperties().name);

            if (searchRes) {
                var props = searchRes.elem.content.properties;

                if (props.type == "Vector" && props.AllowSearch && gmxMap.layers[i]._map) {
                    layersToSearch.push(props);
                }
            }
        }
		var iRespCount = 0;

		if (layersToSearch.length > 0){
            layersToSearch.forEach(function(props) {
                var mapName = gmxMap.layersByID[props.name].options.mapID;
                var url = "http://" + props.hostName + "/SearchObject/SearchVector.ashx" +
                    "?LayerNames=" + props.name +
                    "&MapName=" + mapName +
                    (sInitSearchString ? ("&SearchString=" + encodeURIComponent(sInitSearchString)) : "") +
                    (oInitGeometry ? ("&border=" + encodeURIComponent(JSON.stringify(L.gmxUtil.convertGeometry(oInitGeometry)))) : "");
                sendCrossDomainJSONRequest(
                    url,
                    function(searchReq)
                    {
                        iRespCount++;
                        var arrLayerResult = [];
                        if (searchReq.Status == 'ok')
                        {
                            for (var iServer = 0; iServer < searchReq.Result.length; iServer++)
                            {
                                var limitSearchResults = typeof(LayerSearchLimit)=="number" ? LayerSearchLimit : 100;
                                var req = searchReq.Result[iServer];
                                for (var j = 0; j<limitSearchResults && j < req.SearchResult.length; j++)
                                {
                                    var arrDisplayProperties = {};
                                    if (!arrDisplayFields) {
                                        arrDisplayProperties = req.SearchResult[j].properties;
                                    }
                                    else {
                                        for (var iProperty=0; iProperty<arrDisplayFields.length; iProperty++){
                                            var sPropName = arrDisplayFields[iProperty];
                                            if(sPropName in req.SearchResult[j].properties) {
                                                arrDisplayProperties[sPropName] = req.SearchResult[j].properties[sPropName];
                                            }
                                        }
                                    }

                                    for (var p in arrDisplayProperties) {
                                        var type = props.attrTypes[props.attributes.indexOf(p)];
                                        arrDisplayProperties[p] = nsGmx.Utils.convertFromServer(type, arrDisplayProperties[p]);
                                    }

                                    arrLayerResult.push({
                                        ObjName: req.SearchResult[j].properties.NAME || req.SearchResult[j].properties.Name || req.SearchResult[j].properties.name || req.SearchResult[j].properties.text || req.SearchResult[j].properties["Название"] || "[объект]",
                                        properties: arrDisplayProperties,
                                        Geometry: L.gmxUtil.convertGeometry(req.SearchResult[j].geometry, true)
                                    });
                                }
                            }
                        }
                        if(arrLayerResult.length > 0) arrResult.push({name: props.title, SearchResult: arrLayerResult, CanDownloadVectors: true});

                        if (iRespCount == layersToSearch.length){
                            callback(arrResult);
                            return;
                        }
                    }
                );
            })
		}
		else{
			callback(arrResult);
		}
	}

	/**Возвращает адрес сервера, на котором установлен поисковый модуль Geomixer'а*/
	this.GetServerBase = function(){
		return sServerBase;
	}
}

/**Возращает класс, который предоставляет функции обработки найденных данных
 @memberof Search
 @param {string} ServerBase Адрес сервера, на котором установлен поисковый модуль Geomixer'а
 @param {L.gmxMap} gmxMap карта с векторными слоями для поиска
 @param {bool} WithoutGeometry - по умолчанию не передавать геометрию в результатах поиска
 @param {object} [params] дополнительные параметры
 @param {object} [params.UseOSM] использовать ли геокодер OSM
 @returns {Search.SearchLogic}*/
var SearchLogicGet = function(ServerBase, gmxMap, WithoutGeometry, params){
    SearchLogic.call(this, new SearchDataProvider(ServerBase, gmxMap), WithoutGeometry, params);
}

SearchLogicGet.prototype = SearchLogic;

/**Конструктор
 @class Предоставляет функции обработки найденных данных
 @memberof Search
 @param {object} oInitSearchDataProvider источник данных для обработки
 @param {bool} WithoutGeometry - по умолчанию не передавать геометрию в результатах поиска
 @param {Object} [params] - дополнительные параметры
 @param {Object} [params.UseOSM] - Искать ли в базе OSM
*/
var SearchLogic = function(oInitSearchDataProvider, WithoutGeometry, params){
    var oSearchDataProvider = oInitSearchDataProvider;
    var iLimitAutoComplete = typeof (AutoCompleteLimit) == "number" ? AutoCompleteLimit : 10; //Максимальное количество результатов
	var _this = this;
	if(oSearchDataProvider == null) throw "Error in SearchLogic: oSearchDataProvider is not supplied";

    var useOSMDefault = 0;
    if (GLOBAL_USE_OSM) {
        useOSMDefault = GLOBAL_USE_OSM;
    } else  if (typeof gmxGeoCodeUseOSM !== 'undefined') {
        useOSMDefault = Number(gmxGeoCodeUseOSM);
    } else if (params && 'UseOSM' in params) {
        useOSMDefault = Number(params.UseOSM);
    }

	/** Возращает полный путь к объекту для отображения в подсказке
	@param oFoundObject Найденный объект
	@param sObjNameField название свойства, из которого брать наименование
	@param sObjNameField название свойства, из которого брать наименование родительского объекта
	*/
	var fnGetLabel = function(oFoundObject, sObjNameField, sObjNameFieldParent){
		var sLabel = Functions.GetFullName(oFoundObject.TypeName, oFoundObject[sObjNameField]);
		if (oFoundObject.Parent != null) sLabel += ", " + Functions.GetPath(oFoundObject.Parent, ", ", true, sObjNameFieldParent);
		if (oFoundObject.Parent == null && oFoundObject.Path != null) {
		    for (var i = oFoundObject.Path.length-2; i >=0; --i)
		        sLabel += (i<oFoundObject.Path.length-1?", ":"") + Functions.GetFullName(oFoundObject.Path[i][0], oFoundObject.Path[i][1])
        }
		return sLabel;
	}

    /** Cинхронное последовательное обращение к наблюдателям
        @param queue {Array} очередь наблюдателей
    */
    var deferredsChain = function(queue, params){
        var deferred = $.Deferred(),
        promise = $.when(deferred);
        if(queue.length>0){
            queue[0](1, deferred, params);
            for (var i=1; i<queue.length; ++i) {
                promise = promise.then(function(current) {
                    if (current<0) return current;
                    var d = $.Deferred();
                    queue[current](current+1, d, params);
                    return d;
                });
            }
        }
        else{
            deferred.resolve(0);
        }
        return promise;
    }

    /** Очередь наблюдателей за началом обработки запроса для подсказки
    */
    var AutoCompleteDataSearchStarting = [];

    /** Событие в начале обработки запроса для подсказки  (перед обращением к геокдеру)
        @param {{add:bool, remove:bool, observer:function(next, deferred, params)}}
        observer возвращает $.Deferred() для асинхронной последовательной обработки, $.Deferred().resolve(next)
        для перехода к очередному наблюдателю или $.Deferred().resolve(-1) для остановки всей обработки
    */
    this.AutoCompleteDataSearchStarting = function(params){
        for (var i = 0; i < AutoCompleteDataSearchStarting.length; i++)
            if(AutoCompleteDataSearchStarting[i] === params.observer)
                if(params.remove){
                    //console.log("remove observer");
                    AutoCompleteDataSearchStarting.splice(i, 1);
                }
                else
                    return;
        if(params.add){
            //console.log("add observer");
            AutoCompleteDataSearchStarting.push(params.observer);
        }
    }

	/**Возращает сгуппированные данные для отображения подсказок поиска в функции callback
	    @param {String} SearchString строка, по которой надо выдать подсказку
	    @param {function(arrResult)} callback вызывается когда подсказка готова
    */
	this.AutoCompleteData = function (SearchString, callback){
            deferredsChain(AutoCompleteDataSearchStarting, {searchString:SearchString, callback:callback}).done(function(fin){
            //console.log('finally ' + fin);
            if (fin!=-1)
	            _this.SearchByString({
                    SearchString: SearchString,
                    IsStrongSearch: 0,
                    Limit: iLimitAutoComplete,
                    WithoutGeometry: 1,
	                UseOSM: useOSMDefault,
                callback: function(arrResultDataSources){
			        var arrResult = [];
			        var sSearchRegExp = new RegExp("("+SearchString.replace(/^\s|\s$/, "").replace(/[^\wа-яА-Я]+/g, "|")+")", "i");
			        for(var iDS=0; iDS<arrResultDataSources.length; iDS++){
				        for(var iFoundObject=0; iFoundObject<arrResultDataSources[iDS].SearchResult.length; iFoundObject++){
					        var oFoundObject = arrResultDataSources[iDS].SearchResult[iFoundObject];
						var nameProp = oFoundObject.ObjNameShort.search(/[a-zA-Zа-яА-Я]/)<0?"ObjName":"ObjNameShort";
					        var sLabel = fnGetLabel(oFoundObject, nameProp, nameProp), sValue = Functions.GetFullName(oFoundObject.TypeName, oFoundObject[nameProp]);
					        //var sLabel = fnGetLabel(oFoundObject, "ObjName", "ObjName"), sValue = Functions.GetFullName(oFoundObject.TypeName, oFoundObject.ObjName);
					        if(/[a-zA-Z]/.test(SearchString)){
                                if(oFoundObject.ObjAltNameEng || oFoundObject.ObjNameEng){
						            if(oFoundObject.ObjAltNameEng && oFoundObject.ObjAltNameEng.match(sSearchRegExp)){
							            sLabel = fnGetLabel(oFoundObject, "ObjAltNameEng", "ObjNameEng");
							            sValue = sLabel;
							            //if (oFoundObject.ObjAltName && !/[a-zA-Z]/.test(oFoundObject.ObjName)) sLabel += ' | ' + fnGetLabel(oFoundObject, "ObjAltName", "ObjName");
						            }
						            else{
							            sLabel = fnGetLabel(oFoundObject, "ObjNameEng", "ObjNameEng");
							            sValue = sLabel;
							            //if (oFoundObject.ObjName && !/[a-zA-Z]/.test(oFoundObject.ObjName)) sLabel += ' | ' + fnGetLabel(oFoundObject, "ObjName", "ObjName");
						            }
						        }
					        }
					        else{
						        if(oFoundObject.ObjAltName && oFoundObject.ObjAltName.match(sSearchRegExp)){
							        sLabel = fnGetLabel(oFoundObject, "ObjAltName", "ObjName");
							        sValue = sLabel;
							        //if (oFoundObject.ObjAltNameEng) sLabel += ' | ' + fnGetLabel(oFoundObject, "ObjAltNameEng", "ObjNameEng");
						        }
						        else{
							        sLabel = fnGetLabel(oFoundObject, nameProp, nameProp);
							        //sLabel = fnGetLabel(oFoundObject, "ObjName", "ObjName");
							        sValue = sLabel;
							        //if (oFoundObject.ObjNameEng) sLabel += ' | ' + fnGetLabel(oFoundObject, "ObjNameEng", "ObjNameEng");
						        }
					        }
					        arrResult.push({
						        label: sLabel,
						        value: sValue,
						        GeoObject: oFoundObject});
				        }
				        if(arrResult.length>0) break;
			        }
			        callback(arrResult);
		        }
            });
        });
	}

	/** Группирует по категории
	@param {Array} arrInitDataSources Массив ответов от поисковых серверов
	@returns {Array} Массив сгруппированых по категориям данных*/
	this.GroupByCategory = function(arrInitDataSources)	{
		var arrResultDataSources = [];
		for(var i=0; i<arrInitDataSources.length; i++){
			arrResultDataSources[i] = {	name: arrInitDataSources[i].name,
										CanDownloadVectors: arrInitDataSources[i].CanDownloadVectors,
										SearchResult: []};
			var oDataSource = arrInitDataSources[i].SearchResult;
			var Categories = arrResultDataSources[i].SearchResult;
			var CategoriesIndex = {};
			for(var j=0; j<oDataSource.length; j++){
				var sCategory = "";
				var sCategoryDesc = "";
				var iPriority = 9999999;
				var iCatID = 0;
				if(oDataSource[j].Parent != null)
				{
					iCatID = oDataSource[j].Parent.ObjCode;
					sCategory = Functions.GetPath(oDataSource[j].Parent, ", ", false);
					sCategoryDesc = Functions.GetPath(oDataSource[j].Parent, ", ", true);
					iPriority = oDataSource[j].Parent.Priority;
				}
				if(CategoriesIndex[iCatID]==null) {
					CategoriesIndex[iCatID] = Categories.push({Name: sCategory, Priority: iPriority, GeoObjects: []}) - 1;
				}
				Categories[CategoriesIndex[iCatID]].GeoObjects.push(oDataSource[j]);
			}
			for(var j in Categories){
				if(Categories[j].GeoObjects.length == 1 && Categories[j].Name != ""){
					if(CategoriesIndex["0"]==null) {
						CategoriesIndex["0"] = Categories.push({Name: "", Priority: 9999999, GeoObjects: []})-1;
					}
					Categories[CategoriesIndex["0"]].GeoObjects.push(Categories[j].GeoObjects[0]);
					Categories[j] = null;
				}
			}
			Categories.sort(function(a, b){
				if (a == null || b == null) return 0;
				if (a.Priority < b.Priority)
					return 1;
				if (a.Priority > b.Priority)
					return -1;
				if (a.Name > b.Name)
					return 1;
				if (a.Name < b.Name)
					return -1;
				return 0;
			});
		}
		return arrResultDataSources;
	}

	/**Осуществляет поиск по переданной строке
	@param {object} params Параметры: </br>
		<i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
		<i>layersSearchFlag</i> - признак необходимости искать по векторным слоям </br>
		<i>SearchString</i> - строка для поиска </br>
		<i>IsStrongSearch</i> - признак того, что искать только целые слова </br>
		<i>Limit</i> - максимальное число найденных объектов
		<i>WithoutGeometry<i> - не передавать геометрию в результатах поиска
		<i>RequestType<i> - Тип запроса к серверу
        <i>PageNum<i> - Показать страницу
        <i>ShowTotal<i> - Сообщить сколько найдено всего записей
        <i>UseOSM<i> - Искать в базе OSM
	@returns {void}*/
	this.SearchByString = function(params){
	    oSearchDataProvider.SearchByString({
            SearchString: params.SearchString,
            IsStrongSearch: params.IsStrongSearch,
            Limit: params.Limit,
            WithoutGeometry: params.WithoutGeometry || WithoutGeometry,
            PageNum: params.PageNum,
            ShowTotal: params.ShowTotal,
            UseOSM: 'UseOSM' in params ? params.UseOSM : useOSMDefault,
			layersSearchFlag: params.layersSearchFlag,
			callback: function(response) {
				for(var i=0; i<response.length; i++)	response[i].CanDownloadVectors = false;
				if (params.layersSearchFlag){
					var arrLayerSearchResult = oSearchDataProvider.LayerSearch(params.SearchString, null, function(arrLayerSearchResult){
						params.callback(response.concat(arrLayerSearchResult));
					});
				}
				else {
					params.callback(response);
				}
			}
		});
	};

	/**Получает информацию об объекте
	@param {object} params Параметры: </br>
		<i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
		<i>ID</i> - идентификатор объекта </br>
	@returns {void}*/
	this.SearchID = function(params){
		oSearchDataProvider.SearchID({
            callback: params.callback,
            ID: params.ID,
            TypeCode: params.TypeCode,
            UseOSM: 'UseOSM' in params ? params.UseOSM : useOSMDefault
        });
	}

	/**Осуществляет поиск текущего местонахождения
	@param {object} params Параметры: </br>
		<i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
		<i>Geometry</i> - искать только объекты, пересекающие данную геометрию </br>
	@returns {void}*/
	this.SearchLocation = function(params){
		oSearchDataProvider.SearchLocation({callback: params.callback, Geometry: params.Geometry});
	}

    /**Осуществляет поиск ближайшего объекта к центру указанной области
    @param {object} params Параметры: </br>
    <i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
    <i>Geometry</i> - область </br>
    @returns {void}*/
    this.SearchNearest = function (params) {
        oSearchDataProvider.SearchNearest({ callback: params.callback, Geometry: params.Geometry });
    }

	/**Осуществляет поиск по произвольным параметрам
	@param {object} params Параметры: </br>
		<i>callback</i> = function(arrResultDataSources) - вызывается после получения ответа от сервера </br>
		<i>SearchString</i> - строка для поиска </br>
		<i>IsStrongSearch</i> - признак того, что искать только целые слова </br>
		<i>Geometry</i> - искать только объекты, пересекающие данную геометрию </br>
		<i>Limit</i> - максимальное число найденных объектов
		<i>WithoutGeometry<i> - не передавать геометрию в результатах поиска
		<i>RequestType<i> - Тип запроса к серверу
	@returns {void}*/
	this.Search = function(params){
		oSearchDataProvider.Search({
			callback: params.callback,
			SearchString: params.SearchString,
			IsStrongSearch: params.IsStrongSearch,
			Limit: params.Limit == null ? iDefaultLimit : params.Limit,
			Geometry: params.Geometry,
			WithoutGeometry: params.WithoutGeometry
		});
	};

	/** Возвращает адрес сервера, на котором установлен поисковый модуль Geomixer'а */
	this.GetServerBase = function(){
		return oSearchDataProvider.GetServerBase();
	}
}

/** Возвращает контрол, содержащий все все компоненты поиска и обеспечивающий их взаимодействие между собой
* @memberof Search
* @param {object} params Параметры:
*
*  * ServerBase - Адрес сервера, на котором установлен поисковый модуль Geomixer'а
*  * ImagesHost - строка пути к картинкам
*  * ContainerInput - Объект, в котором находится контрол поискового поля (div)
*  * layersSearchFlag - Признак видимости кнопки поиска по векторным слоям
*  * ContainerList - Объект, в котором находится контрол результатов поиска в виде списка(div)
*  * Map - карта, на которой будут рисоваться объекты
*  * gmxMap - карта с векторными слоями
*  * WithoutGeometry - не передавать геометрию в результатах поиска
*
* @returns {Search.SearchControl}
*/
var SearchControlGet = function (params){
    var map = params.Map;
	var oLogic = new SearchLogicGet(params.ServerBase, params.gmxMap, params.WithoutGeometry);
	var fnAutoCompleteSource = function (request, response) {
		oLogic.AutoCompleteData(request.term, response);
	}
	/**Результаты поиска*/
	var lstResult = new ResultListMapGet(params.ContainerList, map, params.ImagesHost, params.ResultList);
	/**Строка ввода поискового запроса*/
	var btnSearch = new SearchInput(params.ContainerInput, {
		ImagesHost: params.ImagesHost,
		layersSearchFlag: params.layersSearchFlag,
		AutoCompleteSource: fnAutoCompleteSource
	});
    var oLocationTitleRenderer = new LocationTitleRenderer(map, typeof (gmxGeoCodeShowNearest) != "undefined" && gmxGeoCodeShowNearest ? oLogic.SearchNearest:oLogic.SearchLocation);
	SearchControl.call(this, btnSearch, lstResult, oLogic, oLocationTitleRenderer);

    this.addSearchByStringHook(function(searchString) {
        var pos = L.gmxUtil.parseCoordinates(searchString);
        if (pos) {
            map.panTo(pos);

            // Добавим иконку по умолчанию
            // L.Icon.Default.imagePath = 'leaflet/images';
            map.gmxDrawing.add(L.marker(pos, { draggable: true, title: searchString }));

            // Либо задать свою иконку
            // map.gmxDrawing.add(L.marker(pos, {
                // draggable: true, title: searchString,
                // icon: L.icon({ iconUrl: 'img/flag_blau1.png', iconAnchor: [6, 36] })
            // }));

            //map.moveTo(pos[0], pos[1], map.getZ());
            //map.drawing.addObject({ type: "POINT", coordinates: pos }, { text: searchString });
            return true;
        }
    })
}
SearchControlGet.prototype = SearchControl;

/** Конструктор
 @class Контрол, содержащий все все компоненты поиска и обеспечивающий их взаимодействие между собой
 @memberof Search
 @param oInitInput Текстовое поле ввода
 @param oInitResultListMap Отображение результатов поиска
 @param oInitLogic Слой бизнес-логики
 @param oInitLocationTitleRenderer Отображение на карте текущего местоположения
*/
var SearchControl = function(oInitInput, oInitResultListMap, oInitLogic, oInitLocationTitleRenderer){
	var _this = this;

	var oLogic = oInitLogic;
	/**Результаты поиска*/
	var lstResult = oInitResultListMap;
	/**Строка ввода поискового запроса*/
	var btnSearch = oInitInput;
    /**Максимальное количество результатов на странице*/
	var iLimit = typeof (GeocodePageResults) == "number" ? GeocodePageResults : 10;

	var oLocationTitleRenderer = oInitLocationTitleRenderer;

    var searchByStringHooks = [];

	/**Осуществляет загрузку SHP-файла*/
	var fnDownloadSHP = function(event, filename, arrObjectsToDownload){
        var features = arrObjectsToDownload.map(function(obj) {
            return {
                type: 'Feature',
                geometry: L.gmxUtil.geometryToGeoJSON(obj.Geometry),
                properties: {title: '' + obj.Path}
            }
        });

        nsGmx.Utils.downloadGeometry(features, {FileName: filename});
	};

	var fnBeforeSearch = function(){
		/** Генерируется перед началом поиска
		@name Search.SearchControl.onBeforeSearch
		@event*/
		$(_this).triggerHandler('onBeforeSearch');
	}

	var fnAfterSearch = function(){
		/** Генерируется после окончания поиска
		@name Search.SearchControl.onAfterSearch
		@event*/
		$(_this).triggerHandler('onAfterSearch');
	}

	/**Осуществляет поиск*/
	var fnSearchByString = function(event, SearchString, layersSearchFlag)
	{
		try{
            for (var h = 0; h < searchByStringHooks.length; h++) {
                if (searchByStringHooks[h].hook(SearchString)) {
                    return;
                }
            }
			fnBeforeSearch();
            lstResult.ShowLoading();
            oLogic.SearchByString({ SearchString: SearchString, IsStrongSearch: true, layersSearchFlag: layersSearchFlag, Limit: iLimit, PageNum: 0, ShowTotal: 1,
            callback: function (response) {
                lstResult.ShowResult(SearchString, response);
                lstResult.CreatePager(response, function (e) {
                    var evt = e || window.event,
                    active = evt.srcElement || evt.target
                    oLogic.SearchByString({ SearchString: SearchString, IsStrongSearch: true, Limit: iLimit, PageNum: parseInt($(this).text()) - 1, ShowTotal: 0,
                        callback: function (response) {
                            lstResult.ShowResult(SearchString, response);
                            $('#prevpages~span:visible').attr('class', 'buttonLink');
                            for (var i=0; i<$('#prevpages~span:visible').length; ++i) attachEffects($('#prevpages~span:visible')[i], 'buttonLinkHover');
                            $(active).attr('class', 'page');
                            attachEffects(active, '');
							fnAfterSearch();
                        }
                    });
                });
                fnAfterSearch();
            }});
		}
		catch (e){
			lstResult.ShowError(e);
		}
	}

	/**Осуществляет выбор объекта из подсказки*/
	var fnSelect = function(event, oAutoCompleteItem){
        if(oAutoCompleteItem.GeoObject==null)
            return;
	    if (fnBeforeSearch != null) fnBeforeSearch();
	    $('#respager').remove();
	    oLogic.SearchID({ID: oAutoCompleteItem.GeoObject.ObjCode, RequestType: "ID", TypeCode: oAutoCompleteItem.GeoObject.TypeCode,
                            callback: function (response) {
                                lstResult.ShowResult(oAutoCompleteItem.label, [{ name: "Выбрано", SearchResult: response[0].SearchResult}]);
                        }
                        });
		if (fnAfterSearch != null) fnAfterSearch();
	}


	var onDisplayedObjectsChanged = function(event, iDataSourceN, arrFoundObjects){
		/** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
		@name Search.SearchControl.onDisplayedObjectsChanged
		@event
		@param {int} iDataSourceN № источника данных(группы результатов поиска)
		@param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/
		$(_this).triggerHandler('onDisplayedObjectsChanged', [iDataSourceN, arrFoundObjects]);
	}

	var onObjectClick = function(event, oFoundObject){
		/** Вызывается при клике на найденный объект в списке результатов поиска
		@name Search.SearchControl.onObjectClick
		@event
		@param {object} oFoundObject Найденный объект*/
		$(_this).triggerHandler('onObjectClick', [oFoundObject]);
	}

	$(lstResult).bind('onDisplayedObjectsChanged', onDisplayedObjectsChanged);
	$(lstResult).bind('onObjectClick', onObjectClick);
	$(lstResult).bind('onDownloadSHP', fnDownloadSHP);
	$(btnSearch).bind('Search', fnSearchByString);
	$(btnSearch).bind('AutoCompleteSelect', fnSelect);
	if (oLocationTitleRenderer != null) {
		$(oLocationTitleRenderer).bind('onObjectClick', function(event, oFoundObject){
			lstResult.CenterObject(oFoundObject);
			onObjectClick(event, oFoundObject);
		});
	}
	/**Осуществляет поиск по произвольным параметрам по адресной базе
	@param {object} params Параметры: </br>
		<i>SearchString</i> - строка для поиска </br>
		<i>IsStrongSearch</i> - признак того, что искать только целые слова </br>
		<i>Geometry</i> - искать только объекты, пересекающие данную геометрию </br>
		<i>Limit</i> - максимальное число найденных объектов
	@returns {void}*/
	this.Search = function(params){
		try{
			var sSearchString = params.SearchString || '';
			if (sSearchString == '' && params.Geometry == null) throw "Error in SearchControl: Не заданы параметры поиска!";
			if (sSearchString == '') sSearchString = 'Поиск по выделенной области';
			lstResult.ShowLoading();
			if (fnBeforeSearch != null) fnBeforeSearch();
			oLogic.Search({
				SearchString: params.SearchString,
				IsStrongSearch: params.IsStrongSearch,
				Limit: params.Limit,
				Geometry: params.Geometry,
				callback: function(arrResultDataSources){
					lstResult.ShowResult(sSearchString, arrResultDataSources);
					if (fnAfterSearch != null) fnAfterSearch();
				}
			});
		}
		catch (e){
			lstResult.ShowError();
		}
	};

	/**Возвращает стоку поиска*/
	this.GetSearchString = function(){
		return btnSearch.GetSearchString();
	}

	/**Устанавливает строку поиска*/
	this.SetSearchString = function(value){
		btnSearch.SetSearchString(value);
	}
	this.SetSearchStringFocus = function(value){
		btnSearch.SetSearchStringFocus(value);
	}

	/**Устанавливает подсказку строки поиска*/
	this.SetPlaceholder = function(value){
		btnSearch.SetPlaceholder(value);
	}

	/**Показывает режим загрузки
	@returns {void}*/
	this.ShowLoading = function(){
		lstResult.ShowLoading();
	}

	/**Очищает результаты поиска
	@returns {void}*/
	this.Unload = function(){lstResult.Unload();};

    /**
    Добавление наблюдателя события начала оработки запроса для подсказки
        @param {observer:{add:bool, remove:bool, observer:function(next, deferred, params)}}, selectItem:function(){}}}
    */
    this.onAutoCompleteDataSearchStarting = function(params){
        oLogic.AutoCompleteDataSearchStarting(params.observer);
        $(btnSearch).bind('AutoCompleteSelect', params.selectItem);
    }

    /**Добавляет хук поиска объектов по строке. Хуки выполняются в порядке их добавления с учётом приоритета
    @param {function} hook - ф-ция, которая принимает на вход строку поиска и возвращает признак прекращения дальнейшего поиска (true - прекратить)
    @param {Number} [priority=0] - приоритет хука. Чем больше значение, тем раньше будет выполняться
	@returns {void}*/
    this.addSearchByStringHook = function(hook, priority) {
        searchByStringHooks.push({
            hook: hook,
            priority: priority || 0,
            index: searchByStringHooks.length
        });

        searchByStringHooks.sort(function(a, b) {
            return b.priority - a.priority || a.index - b.index;
        })
    }

    /**Удаляет хук поиска объектов по строке
    @param {function} hook - хук, который нужно удалить
	*/
    this.removeSearchByStringHook = function(hook) {
        for (var h = 0; h < searchByStringHooks.length; h++) {
            if (searchByStringHooks[h].hook === hook) {
                searchByStringHooks.splice(h, 1);
                return;
            }
        }
    }
}

/**Конструктор без параметров
 @class SearchGeomixer Контрол, содержащий все все компоненты поиска и встраивающий их во Viewer
 @memberof Search*/
var SearchGeomixer = function(){
	var _this = this;
	var oMenu;
	var oSearchControl;

	var oSearchInputDiv = _div();
	var oSearchResultDiv = _div();
	var workCanvas;

	_title(oSearchInputDiv, _gtxt('Изменить параметры поиска'));

	var fnLoad = function(){
		if (oMenu != null){
			var alreadyLoaded = oMenu.createWorkCanvas("search", fnUnload);
			if(!alreadyLoaded) _(oMenu.workCanvas, [oSearchResultDiv]);
		}
	}
	var fnUnload = function(){
		if (oSearchControl != null)oSearchControl.Unload();
	}

	var fnBeforeSearch = function(event){
		/** Вызывается перед началом поиска
		@name Search.SearchGeomixer.onBeforeSearch
		@event */
		$(_this).triggerHandler('onBeforeSearch');
		fnLoad();
	}

	var fnAfterSearch = function(event){
		/** Вызывается после окончания поиска
		@name Search.SearchGeomixer.onAfterSearch
		@event */
		$(_this).triggerHandler('onAfterSearch');
	}

	var onDisplayedObjectsChanged = function(event, iDataSourceN, arrFoundObjects){
		/** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
		@name Search.SearchGeomixer.onDisplayedObjectsChanged
		@event
		@param {int} iDataSourceN № источника данных(группы результатов поиска)
		@param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/
		$(_this).triggerHandler('onDisplayedObjectsChanged', [iDataSourceN, arrFoundObjects]);
	}

	var onObjectClick = function(event, oFoundObject){
		/** Вызывается при клике на найденный объект в списке результатов поиска
		@name Search.SearchGeomixer.onObjectClick
		@event
		@param {object} oFoundObject Найденный объект*/
		$(_this).triggerHandler('onObjectClick', [oFoundObject]);
	}

	/**Инициализирует контрол
	@param {object} params Параметры: </br>
		<i>ServerBase</i> - Адрес сервера, на котором установлен поисковый модуль Geomixer'а </br>
		<i>ContainerInput</i> - Объект, в котором находится контрол поискового поля (div) </br>
		<i>layersSearchFlag</i> - Признак видимости кнопки поиска по векторным слоям </br>
		<i>ContainerList</i> - Объект, в котором находится контрол результатов поиска в виде списка(div) </br>
		<i>Map</i> - карта, на которой будут рисоваться объекты </br>
		<i>MapHelper</i> - вспомогательный компонент для работы с картой </br>
	@returns {void}*/
	this.Init = function(params){
		if (oMenu == null) oMenu = params.Menu;
		// if (oMenu == null) throw "Error in SearchGeomixer: Menu is null";
		_(params.ContainerInput, [oSearchInputDiv]);
		oSearchControl = new SearchControlGet({ServerBase: params.ServerBase,
											ImagesHost: params.ServerBase + "/api/img",
											ContainerInput: oSearchInputDiv,
											layersSearchFlag: params.layersSearchFlag,
											ContainerList: oSearchResultDiv,
											Map: params.Map,
                                            gmxMap: params.gmxMap,
                                            ResultList: params.ResultList});
		$(oSearchControl).bind('onBeforeSearch', fnBeforeSearch);
		$(oSearchControl).bind('onAfterSearch', fnAfterSearch);
		$(oSearchControl).bind('onDisplayedObjectsChanged', onDisplayedObjectsChanged);
		$(oSearchControl).bind('onObjectClick', onObjectClick);
	}

	/** Загружает контрол в левое меню
	@returns {void}*/
	this.Load = function(){
		fnLoad();
	}

	/** Выгружает контрол из левого меню
	@returns {void}*/
	this.Unload = function(){
		fnUnload();
	}

	/**Осуществляет поиск по произвольным параметрам по адресной базе
	@param {object} params Параметры: </br>
		<i>SearchString</i> - строка для поиска </br>
		<i>IsStrongSearch</i> - признак того, что искать только целые слова </br>
		<i>Geometry</i> - искать только объекты, пересекающие данную геометрию </br>
		<i>Limit</i> - максимальное число найденных объектов
	@returns {void}*/
	this.Search = function(params){
		oSearchControl.Search({
			SearchString: params.SearchString,
			IsStrongSearch: params.IsStrongSearch,
			Limit: params.Limit,
			Geometry: params.Geometry
		});
	};

	/**Возвращает стоку поиска*/
	this.GetSearchString = function(){
		return oSearchControl.GetSearchString();
	}

	/**Устанавливает строку поиска*/
	this.SetSearchString = function(value){
		oSearchControl.SetSearchString(value);
	}
	this.SetSearchStringFocus = function(value){
		oSearchControl.SetSearchStringFocus(value);
	}
	/**Устанавливает подсказку строки поиска*/
	this.SetPlaceholder = function(value){
		oSearchControl.SetPlaceholder(value);
	}

    this.getSearchControl = function() {
        return oSearchControl;
    }
}

var publicInterface = {
	SearchGeomixer: SearchGeomixer,
	SearchControl: SearchControl,
	SearchControlGet: SearchControlGet,
	SearchInput: SearchInput,
	ResultList: ResultList,
	ResultRenderer: ResultRenderer,
	ResultListMap: ResultListMap,
	ResultListMapGet: ResultListMapGet,
	SearchDataProvider: SearchDataProvider,
	SearchLogic: SearchLogic,
	SearchLogicGet: SearchLogicGet,
	LocationTitleRenderer: LocationTitleRenderer,
	Functions: Functions
}

gmxCore.addModule("search", publicInterface, {
    require: ['utilities', 'translations'],
    init: function() {
        //Очень суровое решение для разруливания конфликтов с глобальными переменными.
        _ = nsGmx.Utils._;
        _input = nsGmx.Utils._input;
        _td = nsGmx.Utils._td;
        _tr = nsGmx.Utils._tr;
        _div = nsGmx.Utils._div;
        _t = nsGmx.Utils._t;
        _table = nsGmx.Utils._table;
        _tbody = nsGmx.Utils._tbody;
        _img = nsGmx.Utils._img;
        _span = nsGmx.Utils._span;
        _li = nsGmx.Utils._li;
        _ul = nsGmx.Utils._ul;
        _form = nsGmx.Utils._form;

        initTranslations();
    }
});

})(jQuery);

(function() {
    window.nsGmx = window.nsGmx || {};
    window.nsGmx.widgets = window.nsGmx.widgets || {};
    nsGmx.widgets.notifications = {
        _container: null,
        _actions: [],
        _messagesToShow: [],
        _messageTimer: null,
        _currentStatusClass: '',
        
        startAction: function(actionId) {
            this._initContainerLazy();
            if (this._actions.indexOf(actionId) === -1) {
                this._actions.push(actionId);
                this._container.find('.notification-process').show();
            }
        },
        
        //supported statuses: success, failure, warning
        stopAction: function(actionId, status, message, timeout) {
            var index = this._actions.indexOf(actionId);
            
            if (index !== -1) {
                this._actions.splice(index, 1);
                this._container.find('.notification-process').toggle(this._actions.length);
            }
                
            if (message) {
                timeout = typeof timeout !== 'undefined' ? timeout : 1500;
                this._messagesToShow.push({text: message, status: status, timeout: timeout});
                this._checkMessages();
            }
        },
        
        _checkMessages: function() {
            if (this._messageTimer || !this._messagesToShow.length) {
                return;
            }
            
            var msg = this._messagesToShow.shift();
            var statusClass = 'notification-' + msg.status;
            this._initContainerLazy();
            this._container.find('.notification-message')
                .show().text(msg.text)
                .removeClass(this._currentStatusClass)
                .addClass(statusClass);
                
            if (msg.timeout) {
                this._messageTimer = setTimeout(function(){
                    this._messageTimer = null;
                    this._container.find('.notification-message').hide();
                    this._checkMessages();
                }.bind(this), msg.timeout);
            }
        },
        
        _initContainerLazy: function() {
            if (this._container) {
                return;
            }
            
            this._container = $(Handlebars.compile(
                '<div class="notification-container">' +
                    '<span class="notification-process"></span>' +
                    '<span class="notification-message"></span>' +
                '</div>')()).appendTo($('#flash'));
                
            this._container.find('.notification-message, .notification-process').hide();
        }
    }
})();
nsGmx.VirtualLayerManager = function() {
    this._classes = window.gmxVirtualClasses || {};
    this.loader = this.loader.bind(this);
}

nsGmx.VirtualLayerManager.prototype.loader = function(type) {
    var promise = new L.gmx.Deferred(),
        classInfo = this._classes[type];
    
    if (!classInfo) {
        promise.resolve();
        return promise;
    }
    
    gmxCore.loadModule(classInfo.module, classInfo.file).then(function(module) {
        promise.resolve(module.layerClass);
    }, promise.reject);
    
    return promise;
};
/*!
 * Lightweight URL manipulation with JavaScript
 * This library is independent of any other libraries and has pretty simple
 * interface and lightweight code-base.
 * Some ideas of query string parsing had been taken from Jan Wolter
 * @see http://unixpapa.com/js/querystring.html
 *
 * @license MIT
 * @author Mykhailo Stadnyk <mikhus@gmail.com>
 */
(function (ns) {
    'use strict';

    // configure given url options
    function urlConfig (url) {
        var config = {
            path: true,
            query: true,
            hash: true
        };

        if (!url) {
            return config;
        }

        if (/^[a-z]+:/.test(url)) {
            config.protocol = true;
            config.host = true;

            if (/[-a-z0-9]+(\.[-a-z0-9])*:\d+/i.test(url)) {
                config.port = true;
            }

            if (/\/\/(.*?)(?::(.*?))?@/.test(url)) {
                config.user = true;
                config.pass = true;
            }
        }

        return config;
    }

    var isNode = typeof window === 'undefined' &&
        typeof global !== 'undefined' &&
        typeof require === 'function';

    // Trick to bypass Webpack's require at compile time
    var nodeRequire = isNode ? ns['require'] : null;

    // mapping between what we want and <a> element properties
    var map = {
        protocol: 'protocol',
        host: 'hostname',
        port: 'port',
        path: 'pathname',
        query: 'search',
        hash: 'hash'
    };

    // jscs: disable
    /**
     * default ports as defined by http://url.spec.whatwg.org/#default-port
     * We need them to fix IE behavior, @see https://github.com/Mikhus/jsurl/issues/2
     */
    // jscs: enable
    var defaultPorts = {
        ftp: 21,
        gopher: 70,
        http: 80,
        https: 443,
        ws: 80,
        wss: 443
    };

    function parse (self, url, absolutize) {
        var link, i, auth;
        var currUrl = isNode ? ('file://' +
            (process.platform.match(/^win/i) ? '/' : '') +
            nodeRequire('fs').realpathSync('.')
        ) : document.location.href;

        if (!url) {
            url = currUrl;
        }

        if (isNode) {
            link = nodeRequire('url').parse(url);
        }

        else {
            link = document.createElement('a');
            link.href = url;
        }

        var config = urlConfig(url);

        auth = url.match(/\/\/(.*?)(?::(.*?))?@/) || [];

        for (i in map) {
            if (config[i]) {
                self[i] = link[map[i]] || '';
            }

            else {
                self[i] = '';
            }
        }

        // fix-up some parts
        self.protocol = self.protocol.replace(/:$/, '');
        self.query = self.query.replace(/^\?/, '');
        self.hash = decode(self.hash.replace(/^#/, ''));
        self.user = decode(auth[1] || '');
        self.pass = decode(auth[2] || '');
        /* jshint ignore:start */
        self.port = (
            // loosely compare because port can be a string
            defaultPorts[self.protocol] == self.port || self.port == 0
        ) ? '' : self.port; // IE fix, Android browser fix
        /* jshint ignore:end */

        if (!config.protocol && /[^/#?]/.test(url.charAt(0))) {
            self.path = url.split('?')[0].split('#')[0];
        }

        if (!config.protocol && absolutize) {
            // is IE and path is relative
            var base = new Url(currUrl.match(/(.*\/)/)[0]);
            var basePath = base.path.split('/');
            var selfPath = self.path.split('/');
            var props = ['protocol', 'user', 'pass', 'host', 'port'];
            var s = props.length;

            basePath.pop();

            for (i = 0; i < s; i++) {
                self[props[i]] = base[props[i]];
            }

            while (selfPath[0] === '..') { // skip all "../
                basePath.pop();
                selfPath.shift();
            }

            self.path =
                (url.charAt(0) !== '/' ? basePath.join('/') : '') +
                '/' + selfPath.join('/')
            ;
        }

        self.path = self.path.replace(/^\/{2,}/, '/');

        self.paths((self.path.charAt(0) === '/' ?
            self.path.slice(1) : self.path).split('/')
        );

        self.query = new QueryString(self.query);
    }

    function encode (s) {
        return encodeURIComponent(s).replace(/'/g, '%27');
    }

    function decode (s) {
        s = s.replace(/\+/g, ' ');

        s = s.replace(/%([ef][0-9a-f])%([89ab][0-9a-f])%([89ab][0-9a-f])/gi,
            function (code, hex1, hex2, hex3) {
                var n1 = parseInt(hex1, 16) - 0xE0;
                var n2 = parseInt(hex2, 16) - 0x80;

                if (n1 === 0 && n2 < 32) {
                    return code;
                }

                var n3 = parseInt(hex3, 16) - 0x80;
                var n = (n1 << 12) + (n2 << 6) + n3;

                if (n > 0xFFFF) {
                    return code;
                }

                return String.fromCharCode(n);
            }
        );

        s = s.replace(/%([cd][0-9a-f])%([89ab][0-9a-f])/gi,
            function (code, hex1, hex2) {
                var n1 = parseInt(hex1, 16) - 0xC0;

                if (n1 < 2) {
                    return code;
                }

                var n2 = parseInt(hex2, 16) - 0x80;

                return String.fromCharCode((n1 << 6) + n2);
            }
        );

        return s.replace(/%([0-7][0-9a-f])/gi,
            function (code, hex) {
                return String.fromCharCode(parseInt(hex, 16));
            }
        );
    }

    /**
     * Class QueryString
     *
     * @param {string} qs - string representation of QueryString
     * @constructor
     */
    function QueryString (qs) {
        var re = /([^=&]+)(=([^&]*))?/g;
        var match;

        while ((match = re.exec(qs))) {
            var key = decodeURIComponent(match[1].replace(/\+/g, ' '));
            var value = match[3] ? decode(match[3]) : '';

            if (!(this[key] === undefined || this[key] === null)) {
                if (!(this[key] instanceof Array)) {
                    this[key] = [this[key]];
                }

                this[key].push(value);
            }

            else {
                this[key] = value;
            }
        }
    }

    /**
     * Converts QueryString object back to string representation
     *
     * @returns {string}
     */
    QueryString.prototype.toString = function () {
        var s = '';
        var e = encode;
        var i, ii;

        for (i in this) {
            if (this[i] instanceof Function || this[i] === null) {
                continue;
            }

            if (this[i] instanceof Array) {
                var len = this[i].length;

                if (len) {
                    for (ii = 0; ii < len; ii++) {
                        s += s ? '&' : '';
                        s += e(i) + '=' + e(this[i][ii]);
                    }
                }

                else {
                    // parameter is an empty array, so treat as
                    // an empty argument
                    s += (s ? '&' : '') + e(i) + '=';
                }
            }

            else {
                s += s ? '&' : '';
                s += e(i) + '=' + e(this[i]);
            }
        }

        return s;
    };

    /**
     * Class Url
     *
     * @param {string} [url] - string URL representation
     * @param {boolean} [noTransform] - do not transform to absolute URL
     * @constructor
     */
    function Url (url, noTransform) {
        parse(this, url, !noTransform);
    }

    /**
     * Clears QueryString, making it contain no params at all
     *
     * @returns {Url}
     */
    Url.prototype.clearQuery = function () {
        for (var key in this.query) {
            if (!(this.query[key] instanceof Function)) {
                delete this.query[key];
            }
        }

        return this;
    };

    /**
     * Returns total number of parameters in QueryString
     *
     * @returns {number}
     */
    Url.prototype.queryLength = function () {
        var count = 0;
        var key;

        for (key in this) {
            if (!(this[key] instanceof Function)) {
                count++;
            }
        }

        return count;
    };

    /**
     * Returns true if QueryString contains no parameters, false otherwise
     *
     * @returns {boolean}
     */
    Url.prototype.isEmptyQuery = function () {
        return this.queryLength() === 0;
    };

    /**
     *
     * @param {Array} [paths] - an array pf path parts (if given will modify
     *                          Url.path property
     * @returns {Array} - an array representation of the Url.path property
     */
    Url.prototype.paths = function (paths) {
        var prefix = '';
        var i = 0;
        var s;

        if (paths && paths.length && paths + '' !== paths) {
            if (this.isAbsolute()) {
                prefix = '/';
            }

            for (s = paths.length; i < s; i++) {
                paths[i] = !i && paths[i].match(/^\w:$/) ? paths[i] :
                    encode(paths[i]);
            }

            this.path = prefix + paths.join('/');
        }

        paths = (this.path.charAt(0) === '/' ?
            this.path.slice(1) : this.path).split('/');

        for (i = 0, s = paths.length; i < s; i++) {
            paths[i] = decode(paths[i]);
        }

        return paths;
    };

    /**
     * Performs URL-specific encoding of the given string
     *
     * @method Url#encode
     * @param {string} s - string to encode
     * @returns {string}
     */
    Url.prototype.encode = encode;

    /**
     * Performs URL-specific decoding of the given encoded string
     *
     * @method Url#decode
     * @param {string} s - string to decode
     * @returns {string}
     */
    Url.prototype.decode = decode;

    /**
     * Checks if current URL is an absolute resource locator (globally absolute
     * or absolute path to current server)
     *
     * @returns {boolean}
     */
    Url.prototype.isAbsolute = function () {
        return this.protocol || this.path.charAt(0) === '/';
    };

    /**
     * Returns string representation of current Url object
     *
     * @returns {string}
     */
    Url.prototype.toString = function () {
        return (
            (this.protocol && (this.protocol + '://')) +
            (this.user && (
            encode(this.user) + (this.pass && (':' + encode(this.pass))
            ) + '@')) +
            (this.host && this.host) +
            (this.port && (':' + this.port)) +
            (this.path && this.path) +
            (this.query.toString() && ('?' + this.query)) +
            (this.hash && ('#' + encode(this.hash)))
        );
    };

    ns[ns.exports ? 'exports' : 'Url'] = Url;
}(typeof module !== 'undefined' && module.exports ? module : window));

var nsGmx = window.nsGmx = window.nsGmx || {};

nsGmx.GmxWidgetMixin = {
    getContainer: function() {
        return this.el || this._container;
    },
    appendTo: function(el) {
        el = el[0] || el;
        el.appendChild(this.getContainer());
    },
    show: function() {
        var el = this.getContainer();
        el.style.display = (this._previousStyleDisplayValue !== 'none' && this._previousStyleDisplayValue) || 'block';
        delete this._previousStyleDisplayValue;
    },
    hide: function() {
        var el = this.getContainer();
        this._previousStyleDisplayValue = el.style.display;
        el.style.display = 'none';
    },
    _terminateMouseEvents: function(el) {
        el = el || this.getContainer();
        L.DomEvent.disableClickPropagation(el);
        el.addEventListener('mousewheel', L.DomEvent.stopPropagation);
        el.addEventListener('mousemove', L.DomEvent.stopPropagation);
    }
}

nsGmx.GmxWidget = Backbone.View.extend(nsGmx.GmxWidgetMixin);

var nsGmx = window.nsGmx = window.nsGmx || {};nsGmx.Templates = nsGmx.Templates || {};nsGmx.Templates.DropdownMenuWidget = {};
nsGmx.Templates.DropdownMenuWidget["dropdownMenuWidget"] = "<div class=\"dropdownMenuWidget ui-widget\">\n" +
    "    {{#each items}}\n" +
    "    <div class=\"dropdownMenuWidget-item{{#if className}} {{className}}{{/if}}\">\n" +
    "        <a\n" +
    "            {{#if id}}id=\"{{id}}\"{{/if}}\n" +
    "            {{#if link}}href=\"{{link}}\"{{else}}href=\"javascript:void(0)\"{{/if}}\n" +
    "            {{#if newWindow}}{{#if link}}target=\"_blank\"{{/if}}{{/if}}\n" +
    "            class=\"dropdownMenuWidget-itemAnchor{{#if newWindow}} dropdownMenuWidget-itemAnchor_newWindow{{/if}}\"\n" +
    "        >\n" +
    "            {{#if icon}}\n" +
    "                <img src=\"{{icon}}\" />\n" +
    "            {{/if}}\n" +
    "            {{#if fonticon}}\n" +
    "                <i class=\"{{fonticon}}\"></i>\n" +
    "            {{/if}}\n" +
    "            {{#if title}}\n" +
    "                <span>{{title}}</span>\n" +
    "                {{#if dropdown}}<i class=\"icon-angle-down\"></i>{{/if}}\n" +
    "            {{/if}}\n" +
    "        </a>\n" +
    "        {{#if dropdown}}\n" +
    "            <div class=\"dropdownMenuWidget-itemDropdown\">\n" +
    "                <ul class=\"dropdownMenuWidget-dropdownMenu\">\n" +
    "                    {{#each dropdown}}\n" +
    "                        <li class=\"dropdownMenuWidget-dropdownMenuItem{{#if className}} {{className}}{{/if}}\">\n" +
    "                            {{#if newWindow}}<div class=\"ui-icon ui-icon-newwin dropdownMenuWidget-dropdownMenuIcon\"></div>{{/if}}\n" +
    "                            <a\n" +
    "                                {{#if id}}id=\"{{id}}\"{{/if}}\n" +
    "                                {{#if link}}href=\"{{link}}\"{{else}}href=\"javascript:void(0)\"{{/if}}\n" +
    "                                {{#if newWindow}}{{#if link}}target=\"_blank\"{{/if}}{{/if}}\n" +
    "                                class=\"dropdownMenuWidget-dropdownItemAnchor{{#if newWindow}} dropdownMenuWidget-dropdownItemAnchor_newWindow{{/if}}\"\n" +
    "                            >\n" +
    "                                {{#if icon}}\n" +
    "                                    <img src=\"{{icon}}\" />\n" +
    "                                {{/if}}\n" +
    "                                {{#if title}}\n" +
    "                                    <span>{{title}}</span>\n" +
    "                                {{/if}}\n" +
    "                            </a>\n" +
    "                        </li>\n" +
    "                    {{/each}}\n" +
    "                </ul>\n" +
    "            </div>\n" +
    "        {{/if}}\n" +
    "    </div>\n" +
    "    {{/each}}\n" +
    "</div>\n" +
    "";
nsGmx.Templates.DropdownMenuWidget["anchor"] = "<a \n" +
    "    {{#if id}}id=\"{{id}}\"{{/if}}\n" +
    "    {{#if link}}href=\"{{link}}\"{{else}}href=\"javascript:void(0)\"{{/if}}\n" +
    "    {{#if newWindow}}target=\"_blank\" class=\"dropdownMenuWidget-anchor_newWindow\"{{/if}}\n" +
    ">\n" +
    "    {{#if icon}}\n" +
    "        <img src=\"{{icon}}\" />\n" +
    "    {{/if}}\n" +
    "    {{#if title}}\n" +
    "        <span>{{title}}</span>\n" +
    "    {{/if}}\n" +
    "</a>";;
var nsGmx = window.nsGmx = window.nsGmx || {};

nsGmx.PlainTextWidget = nsGmx.GmxWidget.extend({
    initialize: function(txt) {
        this.setText(txt);
        this.$el.on('click', function () {
            this.trigger('click')
        }.bind(this));
    },
    getText: function () {
        return this.$el.html();
    },
    setText: function (txt) {
        this.$el.html(txt);
    }
});
;
var nsGmx = window.nsGmx = window.nsGmx || {};

// <String>options.title
// <String>options.className
// <String>options.trigger (hover|click|manual)
// <String>options.direction (down|up)
// <Boolean>options.adjustWidth
// <Boolean>options.showTopItem
nsGmx.DropdownWidget = nsGmx.GmxWidget.extend({
    className: 'dropdownWidget dropdownWidget-item',

    options: {
        title: '',
        trigger: 'hover',
        direction: 'down',
        adjustWidth: true,
        showTopItem: true,
        titleClassName: ''
    },

    initialize: function(options) {
        this.options = _.extend(this.options, options);
        this.$titleContainer = $('<div>')
            .addClass('dropdownWidget-dropdownTitle')
            .addClass(options.titleClassName)
            .html(this.options.title)
            .appendTo(this.$el);
        this.$dropdownContainer = $('<div>')
            .addClass('dropdownWidget-dropdown')
            .hide()
            .appendTo(this.$el);
        this.$dropdownTitle = $('<div>')
            .addClass('dropdownWidget-item dropdownWidget-dropdownTitle')
            .addClass(options.titleClassName)
            .html(this.options.title)
            .appendTo(this.$dropdownContainer);

        if (!this.options.showTopItem) {
            this.$dropdownTitle.hide();
        }

        if (this.options.trigger === 'hover') {
            this.$dropdownTitle.addClass('ui-state-disabled');
            this.$titleContainer.on('mouseover', function(je) {
                this.expand();
            }.bind(this));
            this.$dropdownContainer.on('mouseleave', function(je) {
                this.collapse();
            }.bind(this));
        } else if (this.options.trigger === 'click') {
            this.$titleContainer.on('click', function(je) {
                this.expand();
            }.bind(this));
            this.$dropdownTitle.on('click', function(je) {
                this.collapse();
            }.bind(this));
        }

        if (this.options.direction === 'up') {
            this.$el.addClass('dropdownWidget_direction-up');
        } else {
            this.$el.addClass('dropdownWidget_direction-down');
        }

        this._items = {};
    },

    addItem: function(id, inst, position) {
        this._items[id] = inst;
        var $container = $('<div>')
            .addClass('dropdownWidget-item dropdownWidget-dropdownItem')
            .attr('data-id', id)
            .attr('data-position', position)
            .on('click', function(je) {
                this.trigger('item', $(je.currentTarget).attr('data-id'));
                this.trigger('item:' + $(je.currentTarget).attr('data-id'));
                if (this.options.trigger === 'click') {
                    this.collapse();
                }
            }.bind(this));
        $container.append(inst.el);
        this.$dropdownContainer.append($container);
        this._sortItems()
    },

    setTitle: function(title) {
        this.$titleContainer.html(title);
        this.$dropdownTitle.html(title);
    },

    toggle: function() {
        this._expanded ? this.collapse() : this.expand();
        this._expanded = !this._expanded;
    },

    expand: function() {
        this.$dropdownContainer.css('min-width', this.$el.width());
        this.$dropdownContainer.show();
        this.trigger('expand');
    },

    collapse: function() {
        this.$dropdownContainer.hide();
        this.trigger('collapse');
    },

    reset: function() {
        this.collapse();
    },

    _sortItems: function() {
        var containerEl = this.$dropdownContainer[0];
        var items = Array.prototype.slice.call(containerEl.children);

        var titleEl = items.splice(
            items.indexOf($(containerEl).find('.dropdownWidget-dropdownTitle')[0]), 1
        );

        while (items.length) {
            var maxPositionIndex = items.indexOf(_.max(items, function(el) {
                return el.getAttribute('data-position') / 1;
            }));
            $(containerEl).prepend(items.splice(maxPositionIndex, 1)[0]);
        }

        if (this.options.direction === 'up') {
            $(containerEl).append(titleEl);
        } else {
            $(containerEl).prepend(titleEl);
        }
    }
});
;
var nsGmx = window.nsGmx = window.nsGmx || {};

nsGmx.DropdownMenuWidget = (function() {
    var DropdownMenuWidget = function(options) {
        var h = Handlebars.create();
        h.registerPartial('anchor', nsGmx.Templates.DropdownMenuWidget.anchor);
        this._view = $(h.compile(nsGmx.Templates.DropdownMenuWidget.dropdownMenuWidget)({
            items: options.items
        }));
        this._view.find('.dropdownMenuWidget-itemDropdown').hide();

        var mouseTimeout = options.mouseTimeout || 100;
        this._view.find('.dropdownMenuWidget-item').each(function(index) {
            var mouseIsOver = false;
            $(this).on('mouseenter', function(je) {
                mouseIsOver = true;
                setTimeout(function() {
                    if (mouseIsOver) {
                        $(je.currentTarget).find('.dropdownMenuWidget-itemDropdown').show();
                    }
                }, 100);
            });
            $(this).on('mouseleave', function(je) {
                mouseIsOver = false;
                $(je.currentTarget).find('.dropdownMenuWidget-itemDropdown').hide();
            });
        });
    };

    DropdownMenuWidget.prototype.appendTo = function(placeholder) {
        $(placeholder).append(this._view);
    };

    return DropdownMenuWidget;
})();;
var nsGmx = window.nsGmx = window.nsGmx || {};nsGmx.Templates = nsGmx.Templates || {};nsGmx.Templates.AuthWidget = {};
nsGmx.Templates.AuthWidget["authWidget"] = "{{#if userName}}\n" +
    "    <div class=\"authWidget_authorized\">\n" +
    "        <div class=\"authWidget-userPanel\">\n" +
    "            <div class=\"authWidget-userPanel-iconCell\">\n" +
    "                <div class=\"authWidget-userPanel-userIcon\"></div>\n" +
    "            </div>\n" +
    "            <div class=\"authWidget-userPanel-userMenuCell\"></div>\n" +
    "        </div>\n" +
    "    </div>\n" +
    "{{else}}\n" +
    "    <div class=\"authWidget_unauthorized\">\n" +
    "        <div class=\"authWidget-loginButton\">\n" +
    "            {{i 'auth.login'}}\n" +
    "        </div>\n" +
    "    </div>\n" +
    "{{/if}}";;
var nsGmx = window.nsGmx = window.nsGmx || {};

nsGmx.AuthWidget = (function() {

    // options.loginDialog
    var AuthWidget = function(options) {
        this._view = $('<div>');
        this._view.addClass('authWidget ui-widget');
        this._authManager = options.authManager;
        this._userInfo = null;

        this._options = $.extend({
            showAccountLink: true,
            accountLink: 'http://my.kosmosnimki.ru/Home/Settings/',
            showMapLink: true,
            changePassword: false
                /* mapLink */
        }, options);

        this._authManager.getUserInfo().then(function(response) {
            this._render({
                login: response.Result && response.Result.Login,
                userName: response.Result && (response.Result.FullName || response.Result.Nickname || response.Result.Login)
            });
            this._userInfo = response.Result;
            $(this).trigger('ready');
        }.bind(this)).fail(function(response) {
            this._render(response);
        }.bind(this));
    };

    AuthWidget.prototype._render = function(vm) {
        var self = this;

        this._view.html(Handlebars.compile(nsGmx.Templates.AuthWidget.authWidget)(vm));

        if (vm.userName) {
            var dropdownItems = [];

            if (this._options.showAccountLink) {
                dropdownItems.push({
                    title: nsGmx.Translations.getText('auth.myAccount'),
                    link: this._options.accountLink,
                    id: 'AuthWidgetAccountLink',
                    newWindow: true
                });
            }

            if (this._options.showMapLink) {
                var defaultMapLink = 'http://maps.kosmosnimki.ru/api/index.html?' + encodeURIComponent('@' + vm.login);
                dropdownItems.push({
                    title: nsGmx.Translations.getText('auth.myMap'),
                    link: this._options.mapLink || defaultMapLink,
                    id: 'AuthWidgetMapLink',
                    newWindow: true
                });
            }

            if (this._options.changePassword) {
                dropdownItems.push({
                    title: nsGmx.Translations.getText('auth.changePassword'),
                    className: 'authWidget-changePasswordButton'
                });
            }

            dropdownItems.push({
                title: nsGmx.Translations.getText('auth.logout'),
                className: 'authWidget-logoutButton'
            })

            var dropdownMenuWidget = new nsGmx.DropdownMenuWidget({
                items: [{
                    title: vm.userName,
                    dropdown: dropdownItems
                }]
            });

            dropdownMenuWidget.appendTo(this._view.find('.authWidget-userPanel-userMenuCell'));
        }

        this._view.find('.authWidget-changePasswordButton').click(function(e) {
            var native = this._authManager.getNative();
            native.changePasswordDialog();
        }.bind(this));

        this._view.find('.authWidget-loginButton').click(function(e) {
            var $iframeContainer;
            if (this._options.loginDialog) {
                $iframeContainer = $('<div>').addClass('authWidget-iframeContainer');
                var dialog = $iframeContainer.dialog({
                    width: 500,
                    height: 450,
                    closeText: nsGmx.Translations.getText('auth.closeDialog'),
                    close: function(je, ui) {
                        $(this).dialog('destroy');
                    }
                });
                // HACK:
                $(dialog).parent().find('button.ui-button').addClass('ui-icon').css('outline', 'none')
            }

            this._authManager.login({
                iframeContainer: $iframeContainer && $iframeContainer[0]
            });
        }.bind(this));

        this._view.find('.authWidget-logoutButton').click(function(e) {
            this._authManager.logout().then(function(response) {
                this._render(response);
                this._userInfo = response.Result;
                $(this).trigger('logout');
            }.bind(this));
        }.bind(this));
    };

    /** Получить информацию о пользователе, которую вернул AuthManager
     * @return {Object}
     */
    AuthWidget.prototype.getUserInfo = function() {
        return this._userInfo;
    };

    AuthWidget.prototype.on = function(eventName, callback) {
        $(this).on(eventName, callback);
    };

    AuthWidget.prototype.appendTo = function(placeholder) {
        placeholder.append(this._view);
    };

    return AuthWidget;
})();
;
var nsGmx = window.nsGmx;

nsGmx.Translations.addText('rus', {
	auth: {
		'login': 'Войти',
		'logout': 'Выйти',
		'myAccount': 'Личный кабинет',
        'changePassword': 'Сменить пароль',
		'myMap': 'Личная карта',
		'closeDialog': 'Закрыть'
	}
});

nsGmx.Translations.addText('eng', {
	auth: {
		'login': 'Login',
		'logout': 'Logout',
		'myAccount': 'My account',
        'changePassword': 'Change password',
		'myMap': 'My map',
		'closeDialog': 'Close'
	}
});
;
var nsGmx = window.nsGmx = window.nsGmx || {};nsGmx.Templates = nsGmx.Templates || {};nsGmx.Templates.LanguageWidget = {};
nsGmx.Templates.LanguageWidget["layout"] = "<div class=\"languageWidget ui-widget\">\n" +
    "    <div class=\"languageWidget-item languageWidget-item_rus\"><span class=\"{{^rus}}link languageWidget-link{{/rus}}{{#rus}}languageWidget-disabled{{/rus}}\">Ru</span></div>\n" +
    "    <div class=\"languageWidget-item languageWidget-item_eng\"><span class=\"{{^eng}}link languageWidget-link{{/eng}}{{#eng}}languageWidget-disabled{{/eng}}\">En</span></div>\n" +
    "</div>";;
var nsGmx = window.nsGmx = window.nsGmx || {};

nsGmx.LanguageWidget = (function() {
    'use strict';

    var LanguageWidget = function(options) {
        this._view = $(Handlebars.compile(nsGmx.Templates.LanguageWidget.layout)({
            eng: nsGmx.Translations.getLanguage() === 'eng',
            rus: nsGmx.Translations.getLanguage() === 'rus'
        }));

        if (nsGmx.Translations.getLanguage() !== 'eng') {
            this._view.find('.languageWidget-item_eng').click(function() {
                nsGmx.Translations.updateLanguageCookies('eng');
                // присвоение url не работает, если есть #
                window.location.reload(false);
            });
        }

        if (nsGmx.Translations.getLanguage() !== 'rus') {
            this._view.find('.languageWidget-item_rus').click(function() {
                nsGmx.Translations.updateLanguageCookies('rus');
                window.location.reload(false);
            });
        }
    };

    LanguageWidget.prototype.appendTo = function(placeholder) {
        $(placeholder).append(this._view);
    };

    return LanguageWidget;
})();
;
var nsGmx = window.nsGmx = window.nsGmx || {};

nsGmx.HeaderWidget = (function() {
    'use strict';

    var SocialShareWidget = function(socials) {
        this._view = Handlebars.compile(nsGmx.Templates.HeaderWidget.socials)(socials);
    };

    SocialShareWidget.prototype.appendTo = function(placeholder) {
        $(placeholder).append(this._view);
    };

    var HeaderWidget = function(options) {
        var addDots = function(item) {
            if (!item.icon && !item.className) {
                item.className = item.className + ' headerWidget-menuDot';
            }
            return item;
        };

        var h = Handlebars.create();
        this._view = $(h.compile(nsGmx.Templates.HeaderWidget.layout)(options));
        if (nsGmx.DropdownMenuWidget) {
            (new nsGmx.DropdownMenuWidget({
                items: options.leftLinks && options.leftLinks.map(addDots)
            })).appendTo(this._view.find('.headerWidget-leftLinksContainer'));
            (new nsGmx.DropdownMenuWidget({
                items: options.rightLinks && options.rightLinks.map(addDots)
            })).appendTo(this._view.find('.headerWidget-rightLinksContainer'));
        } else {
            console.warn('DropdownMenuWidget not found');
        }
        (new SocialShareWidget(options.socials)).appendTo(this._view.find('.headerWidget-socialsContainer'));
        this._view.find(".headerWidget-authContainer").hide();
        this._view.find(".headerWidget-menuContainer").hide();
        this._view.find(".headerWidget-searchContainer").hide();
        this._view.find(".headerWidget-languageContainer").hide();
        if (!options.socials) {
            this._view.find(".headerWidget-socialsContainer").hide();
        }
    };

    HeaderWidget.prototype.appendTo = function(placeholder) {
        $(placeholder).append(this._view);
    };

    HeaderWidget.prototype.getAuthPlaceholder = function() {
        return this._view.find(".headerWidget-authContainer").show();
    };

    HeaderWidget.prototype.getMenuPlaceholder = function() {
        return this._view.find(".headerWidget-menuContainer").show();
    };

    HeaderWidget.prototype.getSearchPlaceholder = function() {
        return this._view.find(".headerWidget-searchContainer").show();
    };

    HeaderWidget.prototype.getLanguagePlaceholder = function() {
        return this._view.find(".headerWidget-languageContainer").show();
    };

    HeaderWidget.prototype.getSocialsPlaceholder = function(first_argument) {
        return this._view.find(".headerWidget-socialsContainer");
    };

    return HeaderWidget;
})();;
nsGmx.Translations.addText('rus', {
    header: {
        'langRu': 'Ru',
        'langEn': 'En'
    }
});

nsGmx.Translations.addText('eng', {
    header: {
        'langRu': 'Ru',
        'langEn': 'En'
    }
});;
var nsGmx = window.nsGmx = window.nsGmx || {};nsGmx.Templates = nsGmx.Templates || {};nsGmx.Templates.HeaderWidget = {};
nsGmx.Templates.HeaderWidget["layout"] = "<div class=\"headerWidget\">\n" +
    "    <div class=\"headerWidget-left\">\n" +
    "        <div class=\"headerWidget-logoContainer\">\n" +
    "            <img class=\"headerWidget-logo\" src=\"{{logo}}\" />\n" +
    "        </div>\n" +
    "    </div>\n" +
    "    <div class=\"headerWidget-right\">\n" +
    "        <div class=\"headerWidget-bar headerWidget-navigationBar\">\n" +
    "            <div class=\"headerWidget-barTable headerWidget-navigationBarTable\">\n" +
    "                <div class=\"headerWidget-barCell headerWidget-leftLinksContainer\"></div>\n" +
    "                <div class=\"headerWidget-barCell headerWidget-rightLinksContainer\"></div>\n" +
    "                <div class=\"headerWidget-barCell headerWidget-languageContainer\"></div>\n" +
    "                <div class=\"headerWidget-barCell headerWidget-socialsContainer\"></div>\n" +
    "                <div class=\"headerWidget-barCell headerWidget-authContainer\"></div>\n" +
    "            </div>\n" +
    "        </div>\n" +
    "        <div class=\"headerWidget-bar headerWidget-controlsBar\">\n" +
    "            <div class=\"headerWidget-barTable headerWidget-controlsBarTable\">\n" +
    "                <div class=\"headerWidget-barCell headerWidget-menuContainer\"></div>\n" +
    "                <div class=\"headerWidget-barCell headerWidget-searchContainer\"></div>\n" +
    "            </div>\n" +
    "        </div>\n" +
    "    </div>\n" +
    "</div>\n" +
    "";
nsGmx.Templates.HeaderWidget["socials"] = "<div class=\"headerWidget-socialIcons\">\n" +
    "    {{#if vk}}\n" +
    "        <div class=\"headerWidget-socialIconCell\"><a href=\"{{vk}}\" target=\"_blank\"><i class=\"icon-vk\"></i></a></div>\n" +
    "    {{/if}}\n" +
    "    {{#if facebook}}\n" +
    "        <div class=\"headerWidget-socialIconCell\"><a href=\"{{facebook}}\" target=\"_blank\"><i class=\"icon-facebook\"></i></a></div>\n" +
    "    {{/if}}\n" +
    "    {{#if twitter}}\n" +
    "        <div class=\"headerWidget-socialIconCell\"><a href=\"{{twitter}}\" target=\"_blank\"><i class=\"icon-twitter\"></i></a></div>\n" +
    "    {{/if}}\n" +
    "</div>";;
nsGmx.TransparencySliderWidget = function(container) {
    var _this = this;
    var ui = $(Handlebars.compile(
		'<div class="leaflet-gmx-iconSvg leaflet-gmx-iconSvg-transparency svgIcon leaflet-control gmx-transslider-toggle-icon" title="{{i "TransparencySliderWidget.title"}}"><svg role="img" class="svgIcon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#transparency"></use></svg></div>' +
        '<div class = "gmx-transslider-container"></div>' +
        '<div class = "leaflet-gmx-iconSvg leaflet-gmx-iconSvg-transparency-eye svgIcon leaflet-gmx-iconSvg-active leaflet-control gmx-transslider-onoff" title="{{i "TransparencySliderWidget.onOffTitle"}}"><svg role="img" class="svgIcon gmx-transslider-hide"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#transparency-eye"></use></svg><svg role="img" class="svgIcon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#transparency-eye-off"></use></svg></div>'
    )()).appendTo(container);

    var sliderContainer = container.find('.gmx-transslider-container');

    this._isCollapsed = true;

    container.find('.gmx-transslider-toggle-icon').click(function() {
        this._isCollapsed = !this._isCollapsed;
        sliderContainer.toggle(!this._isCollapsed);
        container.find('.gmx-transslider-onoff').toggle(!this._isCollapsed);
        container.find('.gmx-transslider-toggle-icon').toggleClass('leaflet-gmx-iconSvg-active', !this._isCollapsed);
    }.bind(this));

    var isOpaque = true;
    var updateOnOffIcon = function(value) {
        var isOpaqueNew = value === 1.0;
        if (isOpaqueNew !== isOpaque) {
            isOpaque = isOpaqueNew;
            var arr = container.find('.gmx-transslider-onoff')[0].childNodes;
			if (isOpaque) {
				L.DomUtil.removeClass(arr[1], 'gmx-transslider-hide');
				L.DomUtil.addClass(arr[0], 'gmx-transslider-hide');
			} else {
				L.DomUtil.removeClass(arr[0], 'gmx-transslider-hide');
				L.DomUtil.addClass(arr[1], 'gmx-transslider-hide');
			}
        }
    }

    sliderContainer.slider({
        range: 'min',
        min: 0.0,
        max: 1.0,
        step: 0.01,
        value: 1.0,
        change: function(event, ui) {
            $(_this).triggerHandler(event, ui);
            updateOnOffIcon(ui.value);
        },
        slide: function(event, ui) {
            $(_this).triggerHandler(event, ui);
            updateOnOffIcon(ui.value);
        }
    }).hide();

    // fix map moving in IE
    if (nsGmx.leafletMap) {
        var dragging = nsGmx.leafletMap.dragging;
        L.DomEvent
            .on(sliderContainer[0], 'mouseover', dragging.disable, dragging)
            .on(sliderContainer[0], 'mouseout', dragging.enable, dragging);
    }

    container.find('.gmx-transslider-onoff').click(function(){
        var curValue = sliderContainer.slider('value');
        sliderContainer.slider('value', curValue !== 1.0 ? 1.0 : 0.0);
    }).hide();

    container.on('mousedown click', function(event) {
        event.stopPropagation();
    });
}

nsGmx.TransparencySliderWidget.prototype.isCollapsed = function() {
    return this._isCollapsed;
}
;
nsGmx.Translations.addText('rus', { TransparencySliderWidget: {
    title: 'Прозрачность растровых слоёв',
    onOffTitle: 'Показать/скрыть растры'
}});
                         
nsGmx.Translations.addText("eng", { TransparencySliderWidget: {
    title: 'Raster layers transparency',
    onOffTitle: 'Show/hide rasters'
}});;
/* ========================================================================
 * Bootstrap: tooltip.js v3.3.1
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================

  var Tooltip = function (element, options) {
    this.type       =
    this.options    =
    this.enabled    =
    this.timeout    =
    this.hoverState =
    this.$element   = null

    this.init('tooltip', element, options)
  }

  Tooltip.VERSION  = '3.3.1'

  Tooltip.TRANSITION_DURATION = 150

  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    }
  }

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled   = true
    this.type      = type
    this.$element  = $(element)
    this.options   = this.getOptions(options)
    this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport)

    var triggers = this.options.trigger.split(' ')

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i]

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))
      } else if (trigger != 'manual') {
        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'

        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))
      }
    }

    this.options.selector ?
      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
      this.fixTitle()
  }

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS
  }

  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options)

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      }
    }

    return options
  }

  Tooltip.prototype.getDelegateOptions = function () {
    var options  = {}
    var defaults = this.getDefaults()

    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value
    })

    return options
  }

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (self && self.$tip && self.$tip.is(':visible')) {
      self.hoverState = 'in'
      return
    }

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'in'

    if (!self.options.delay || !self.options.delay.show) return self.show()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show()
    }, self.options.delay.show)
  }

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ?
      obj : $(obj.currentTarget).data('bs.' + this.type)

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())
      $(obj.currentTarget).data('bs.' + this.type, self)
    }

    clearTimeout(self.timeout)

    self.hoverState = 'out'

    if (!self.options.delay || !self.options.delay.hide) return self.hide()

    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide()
    }, self.options.delay.hide)
  }

  Tooltip.prototype.show = function () {
    var that = this;
    if (this.hasContent() && this.enabled) {
      this._toBeShown = true;
      this._preloadImages().then(function() {
        if (that._toBeShown) {
          that.doShow();
        }
      });
    }
  }

  Tooltip.prototype._preloadImages = function() {
    var that = this;
    
    var $images = $('<div>').html(that.getContent()).find('img');
    var srcs = Array.prototype.slice.apply($images).map(function(el) {
      return el.src;
    });

    var promises = srcs.map(function(src) {
      return $.Deferred(function(def) {
        var img = new Image();
        img.addEventListener('load', function() {
          def.resolve();
        });
        img.addEventListener('error', function() {
          def.reject();
        });
        img.src = src;
      }).promise();
    });

    return $.when.apply(null, promises);
  }

  Tooltip.prototype.doShow = function () {
      var e = $.Event('show.bs.' + this.type)

      this.$element.trigger(e)

      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])
      if (e.isDefaultPrevented() || !inDom) return
      var that = this

      var $tip = this.tip()

      var tipId = this.getUID(this.type)

      this.setContent()

      $tip.attr('id', tipId)
      this.$element.attr('aria-describedby', tipId)

      if (this.options.animation) $tip.addClass('fade')

      var placement = typeof this.options.placement == 'function' ?
        this.options.placement.call(this, $tip[0], this.$element[0]) :
        this.options.placement

      var autoToken = /\s?auto?\s?/i
      var autoPlace = autoToken.test(placement)
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'

      $tip
        .detach()
        .css({ top: 0, left: 0, display: 'block' })
        .addClass(placement)
        .data('bs.' + this.type, this)

      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)

      var pos          = this.getPosition()
      var actualWidth  = $tip[0].offsetWidth
      var actualHeight = $tip[0].offsetHeight

      if (autoPlace) {
        var orgPlacement = placement
        var $container   = this.options.container ? $(this.options.container) : this.$element.parent()
        var containerDim = this.getPosition($container)

        placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top'    :
                    placement == 'top'    && pos.top    - actualHeight < containerDim.top    ? 'bottom' :
                    placement == 'right'  && pos.right  + actualWidth  > containerDim.width  ? 'left'   :
                    placement == 'left'   && pos.left   - actualWidth  < containerDim.left   ? 'right'  :
                    placement

        $tip
          .removeClass(orgPlacement)
          .addClass(placement)
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)

      this.applyPlacement(calculatedOffset, placement)

      var complete = function () {
        var prevHoverState = that.hoverState
        that.$element.trigger('shown.bs.' + that.type)
        that.hoverState = null

        if (prevHoverState == 'out') that.leave(that)
      }

      $.support.transition && this.$tip.hasClass('fade') ?
        $tip
          .one('bsTransitionEnd', complete)
          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
        complete()
  }

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip   = this.tip()
    var width  = $tip[0].offsetWidth
    var height = $tip[0].offsetHeight

    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10)
    var marginLeft = parseInt($tip.css('margin-left'), 10)

    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))  marginTop  = 0
    if (isNaN(marginLeft)) marginLeft = 0

    offset.top  = offset.top  + marginTop
    offset.left = offset.left + marginLeft

    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        })
      }
    }, offset), 0)

    $tip.addClass('in')

    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth  = $tip[0].offsetWidth
    var actualHeight = $tip[0].offsetHeight

    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight
    }

    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)

    if (delta.left) offset.left += delta.left
    else offset.top += delta.top

    var isVertical          = /top|bottom/.test(placement)
    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'

    $tip.offset(offset)
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
  }

  Tooltip.prototype.replaceArrow = function (delta, dimension, isHorizontal) {
    this.arrow()
      .css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
      .css(isHorizontal ? 'top' : 'left', '')
  }

  Tooltip.prototype.setContent = function () {
    var $tip  = this.tip()
    var title = this.getTitle()

    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)
    $tip.removeClass('fade in top bottom left right')
  }

  Tooltip.prototype.hide = function (callback) {
    var that = this
    var $tip = this.tip()
    var e    = $.Event('hide.bs.' + this.type)

    this._toBeShown = false;

    function complete() {
      if (that.hoverState != 'in') $tip.detach()
      that.$element
        .removeAttr('aria-describedby')
        .trigger('hidden.bs.' + that.type)
      callback && callback()
    }

    this.$element.trigger(e)

    if (e.isDefaultPrevented()) return

    $tip.removeClass('in')

    $.support.transition && this.$tip.hasClass('fade') ?
      $tip
        .one('bsTransitionEnd', complete)
        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
      complete()

    this.hoverState = null

    return this
  }

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element
    if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')
    }
  }

  Tooltip.prototype.hasContent = function () {
    return this.getTitle()
  }

  Tooltip.prototype.getPosition = function ($element) {
    $element   = $element || this.$element

    var el     = $element[0]
    var isBody = el.tagName == 'BODY'

    var elRect    = el.getBoundingClientRect()
    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })
    }
    var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset()
    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }
    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null

    return $.extend({}, elRect, scroll, outerDims, elOffset)
  }

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2  } :
           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width   }

  }

  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = { top: 0, left: 0 }
    if (!this.$viewport) return delta

    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0
    var viewportDimensions = this.getPosition(this.$viewport)

    if (/right|left/.test(placement)) {
      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight
      if (topEdgeOffset < viewportDimensions.top) { // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset
      }
    } else {
      var leftEdgeOffset  = pos.left - viewportPadding
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth
      if (leftEdgeOffset < viewportDimensions.left) { // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset
      } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset
      }
    }

    return delta
  }

  Tooltip.prototype.getTitle = function () {
    var title
    var $e = this.$element
    var o  = this.options

    title = $e.attr('data-original-title')
      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)

    return title
  }

  Tooltip.prototype.getUID = function (prefix) {
    do prefix += ~~(Math.random() * 1000000)
    while (document.getElementById(prefix))
    return prefix
  }

  Tooltip.prototype.tip = function () {
    return (this.$tip = this.$tip || $(this.options.template))
  }

  Tooltip.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
  }

  Tooltip.prototype.enable = function () {
    this.enabled = true
  }

  Tooltip.prototype.disable = function () {
    this.enabled = false
  }

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled
  }

  Tooltip.prototype.toggle = function (e) {
    var self = this
    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type)
      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions())
        $(e.currentTarget).data('bs.' + this.type, self)
      }
    }

    self.tip().hasClass('in') ? self.leave(self) : self.enter(self)
  }

  Tooltip.prototype.destroy = function () {
    var that = this
    clearTimeout(this.timeout)
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type)
    })
  }


  // TOOLTIP PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this    = $(this)
      var data     = $this.data('bs.tooltip')
      var options  = typeof option == 'object' && option
      var selector = options && options.selector

      if (!data && option == 'destroy') return
      if (selector) {
        if (!data) $this.data('bs.tooltip', (data = {}))
        if (!data[selector]) data[selector] = new Tooltip(this, options)
      } else {
        if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))
      }
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.tooltip

  $.fn.tooltip             = Plugin
  $.fn.tooltip.Constructor = Tooltip


  // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old
    return this
  }

}(jQuery);

/* ========================================================================
 * Bootstrap: popover.js v3.3.1
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options)
  }

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

  Popover.VERSION  = '3.3.1'

  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  })


  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)

  Popover.prototype.constructor = Popover

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS
  }

  Popover.prototype.setContent = function () {
    var $tip    = this.tip()
    var title   = this.getTitle()
    var content = this.getContent()

    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)
    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
    ](content)

    $tip.removeClass('fade top bottom left right in')

    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()
  }

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent()
  }

  Popover.prototype.getContent = function () {
    var $e = this.$element
    var o  = this.options

    return $e.attr('data-content')
      || (typeof o.content == 'function' ?
            o.content.call($e[0]) :
            o.content)
  }

  Popover.prototype.arrow = function () {
    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
  }

  Popover.prototype.tip = function () {
    if (!this.$tip) this.$tip = $(this.options.template)
    return this.$tip
  }


  // POPOVER PLUGIN DEFINITION
  // =========================

  function Plugin(option) {
    return this.each(function () {
      var $this    = $(this)
      var data     = $this.data('bs.popover')
      var options  = typeof option == 'object' && option
      var selector = options && options.selector

      if (!data && option == 'destroy') return
      if (selector) {
        if (!data) $this.data('bs.popover', (data = {}))
        if (!data[selector]) data[selector] = new Popover(this, options)
      } else {
        if (!data) $this.data('bs.popover', (data = new Popover(this, options)))
      }
      if (typeof option == 'string') data[option]()
    })
  }

  var old = $.fn.popover

  $.fn.popover             = Plugin
  $.fn.popover.Constructor = Popover


  // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old
    return this
  }

}(jQuery);

(function (factory) {
    if (typeof module === 'object' && module.exports) {
        module.exports = factory()
    } else {
        window.nsGmx = window.nsGmx || {}
        window.nsGmx.DateInterval = factory()
    }
})(function() {
    var DateInterval = window.Backbone.Model.extend({
        initialize: function() {
            if (!('dateBegin' in this.attributes) && !('dateEnd' in this.attributes)) {
                this.set(DateInterval.getUTCDayBoundary());
            }
        },

        saveState: function() {
            return {
                version: '1.1.0',
                dateBegin: +this.attributes.dateBegin,
                dateEnd: +this.attributes.dateEnd
            }
        },

        loadState: function(state) {
            if (!state.version || state.version === '1.1.0' || state.version === '1.0.0') {
                this.set({
                    dateBegin: new Date(state.dateBegin),
                    dateEnd: new Date(state.dateEnd)
                })
            } else {
                throw 'Unknown state version';
            }
        }
    }, {
        //number of milliseconds in one day
        MS_IN_DAY: 24*3600*1000,

        //set time to UTC midnight
        toMidnight: function(date) {
            return new Date(date - date % DateInterval.MS_IN_DAY);
        },

        getUTCDayBoundary: function(date) {
            date = date || new Date();

            var midnight = DateInterval.toMidnight(date);
            return {
                dateBegin: midnight,
                dateEnd: new Date(midnight.valueOf() + DateInterval.MS_IN_DAY)
            }
        },

        // 24+n interval
        defaultFireDateInterval: function() {
            var now = new Date(),
                lastMidnight = DateInterval.toMidnight(now),
                dateEnd = new Date((now - 1) - (now - 1) % (3600*1000) + 3600*1000), //round to the nearest hour greater then 'now'
                isTooSmall = dateEnd - lastMidnight < 12*3600*1000,
                dateBegin = new Date(isTooSmall ? (lastMidnight - nsGmx.DateInterval.MS_IN_DAY) : lastMidnight.valueOf());

            return {
                dateBegin: dateBegin,
                dateEnd: dateEnd
            }
        }
    })

    return DateInterval
})

var nsGmx = nsGmx || {};nsGmx.Templates = nsGmx.Templates || {};nsGmx.Templates.CalendarWidget = {};
nsGmx.Templates.CalendarWidget["CalendarWidget"] = "<table>\n" +
    "    <tr>\n" +
    "        <td><div class = \"CalendarWidget-iconScrollLeft ui-helper-noselect icon-left-open\"></div></td>\n" +
    "        <td class = \"CalendarWidget-inputCell\"><input class = \"gmx-input-text CalendarWidget-dateBegin\"></td>\n" +
    "        <td class = \"CalendarWidget-inputCell CalendarWidget-onlyMaxVersion\"><input class = \"gmx-input-text CalendarWidget-dateEnd\"></td>\n" +
    "        <td><div class = \"CalendarWidget-iconScrollRight ui-helper-noselect icon-right-open\" ></div></td>\n" +
    "        <td><div class = \"CalendarWidget-iconMore {{moreIconClass}}\" title = \"{{moreIconTitle}}\"></div></td>\n" +
    "        <td><div class = \"CalendarWidget-forecast\" hidden>{{forecast}}</div></td>\n" +
    "    </tr><tr>\n" +
    "        <td></td>\n" +
    "        <td class = \"CalendarWidget-dateBeginInfo\"></td>\n" +
    "        <td class = \"CalendarWidget-dateEndInfo\"></td>\n" +
    "        <td></td>\n" +
    "        <td></td>\n" +
    "    </tr>\n" +
    "</table>\n" +
    "<div class=\"CalendarWidget-footer\"></div>\n" +
    "";;
var nsGmx = nsGmx || {};

(function($){

'use strict';

var _gtxt = nsGmx.Translations.getText.bind(nsGmx.Translations),
    toMidnight = nsGmx.DateInterval.toMidnight;

/** Параметры календаря
 * @typedef nsGmx.CalendarWidget~Parameters
 * @property {nsGmx.DateInterval} dateInterval Временной интервал, который нужно менять
 * @property {Date} [dateMin] минимальная граничная дата для календарей, null - без ограничений
 * @property {Date} [dateMax] максимальная граничная дата для календарей, null - без ограничений
 * @property {String} [dateFormat='dd.mm.yy'] формат даты
 * @property {bool} [minimized=true] показывать ли минимизированный или развёрнутый виджет в начале
 * @property {bool} [showSwitcher=true] показывать ли иконку для разворачивания/сворачивания периода
 * @property {Date} [dateBegin=<текущая дата>] начальная дата интервала
 * @property {Date} [dateEnd=<текущая дата>] конечная дата интервала
 * @property {String|DOMNode} [container] куда добавлять календарик
 * @property {String} [buttonImage] URL иконки для активации календариков
 */

/** Контрол для задания диапазона дат. Даты календарика всегда в UTC, а не в текущем поясе.
 @description Виджет для выбора интервала дат. Пользователь при помощи datepicker'ов выбирает два дня (год, месяц, число),
              затем выбранные значения при помощи ф-ции `_updateModel()` переводятся в интервал дат ({@link nsGmx.DateInterval}).
              Так же виджет реагирует на изменения модели (с использованием ф-ции `_updateWidget()`)
 @alias nsGmx.CalendarWidget
 @extends nsGmx.GmxWidget
 @class
 @param {nsGmx.CalendarWidget~Parameters} options Параметры календаря
*/
var Calendar = nsGmx.GmxWidget.extend({
    tagName: 'div',
    className: 'CalendarWidget ui-widget',
    template: Handlebars.compile(nsGmx.Templates.CalendarWidget.CalendarWidget),

    events: {
        'click .CalendarWidget-iconMore': 'toggleMode',
        'click .CalendarWidget-iconScrollLeft': function() {
            this._shiftDates(-1);
        },
        'click .CalendarWidget-iconScrollRight': function() {
            this._shiftDates(1);
        }
    },

    initialize: function(options) {
        options = $.extend({
            minimized: true,
            showSwitcher: true,
            dateMax: null,
            dateMin: null,
            dateFormat: 'dd.mm.yy',
            name: null
        }, options);

        this._dateMin = options.dateMin;
        this._dateMax = options.dateMax;

        this._dateInterval = options.dateInterval;

        this.$el.html(this.template({
            moreIconClass: options.minimized ? 'icon-calendar' : 'icon-calendar-empty',
            moreIconTitle: options.minimized ? _gtxt('CalendarWidget.ExtendedViewTitle') : _gtxt('CalendarWidget.MinimalViewTitle'),
            forecast: _gtxt('CalendarWidget.forecast')
        }));

        this._moreIcon = this.$('.CalendarWidget-iconMore')
            .toggle(!!options.showSwitcher);

        this._dateBegin = this.$('.CalendarWidget-dateBegin');
        this._dateEnd = this.$('.CalendarWidget-dateEnd');
        this._dateInputs = this._dateBegin.add(this._dateEnd);

        this._dateInputs.datepicker({
            onSelect: function(dateText, inst){
                this._selectFunc(inst.input);
                this._updateModel();
            }.bind(this),
            showAnim: 'fadeIn',
            changeMonth: true,
            changeYear: true,
            minDate: this._dateMin ? Calendar.toUTC(this._dateMin) : null,
            maxDate: this._dateMax ? Calendar.toUTC(this._dateMax) : null,
            dateFormat: options.dateFormat,
            defaultDate: Calendar.toUTC(this._dateMax || new Date()),
            showOn: options.buttonImage ? 'both' : 'focus',
            buttonImageOnly: true
        });

        //устанавливаем опцию после того, как добавили календарик в canvas
        if (options.buttonImage) {
            this._dateInputs.datepicker('option', 'buttonImage', options.buttonImage);
        }

        this.$('.CalendarWidget-onlyMaxVersion').toggle(!options.minimized);

        options.dateBegin && this._dateBegin.datepicker('setDate', Calendar.toUTC(options.dateBegin));
        options.dateEnd && this._dateEnd.datepicker('setDate', Calendar.toUTC(options.dateEnd));

        if (options.container) {
            if (typeof options.container === 'string')
                $('#' + options.container).append(this.$el);
            else
                $(options.container).append(this.$el);
        }

        this.setMode(options.minimized ? Calendar.SIMPLE_MODE : Calendar.ADVANCED_MODE);

        this._updateWidget();

        this._dateInterval.on('change', this._updateWidget, this);

        //for backward compatibility
        this.canvas = this.$el;
    },

    _shiftDates: function(delta) {
        var dateBegin = this.getDateBegin(),
            dateEnd = this.getDateEnd();

        if (!dateBegin || !dateEnd) {
            return;
        }

        var shift = (dateEnd - dateBegin + nsGmx.DateInterval.MS_IN_DAY) * delta,
            newDateBegin = new Date(dateBegin.valueOf() + shift),
            newDateEnd = new Date(dateEnd.valueOf() + shift);

        if ((!this._dateMin || toMidnight(this._dateMin) <= toMidnight(newDateBegin)) &&
            (!this._dateMax || toMidnight(this._dateMax) >= toMidnight(newDateEnd)))
        {
            this._dateBegin.datepicker('setDate', Calendar.toUTC(newDateBegin));
            this._dateEnd.datepicker('setDate', Calendar.toUTC(newDateEnd));

            this._updateModel();
        }
    },

    _selectFunc: function(activeInput) {
        var begin = this._dateBegin.datepicker('getDate');
        var end   = this._dateEnd.datepicker('getDate');

        if (end && begin && begin > end) {
            var dateToFix = activeInput[0] == this._dateEnd[0] ? this._dateBegin : this._dateEnd;
            dateToFix.datepicker('setDate', $(activeInput[0]).datepicker('getDate'));
        } else if (this._curMode === Calendar.SIMPLE_MODE) {
            //либо установлена только одна дата, либо две, но отличающиеся
            if (!begin != !end || begin && begin.valueOf() !== end.valueOf()) {
                this._dateEnd.datepicker('setDate', this._dateBegin.datepicker('getDate'));
            }
        }
    },

    _updateModel: function() {
        var dateBegin = this.getDateBegin(),
            dateEnd = this.getDateEnd();

        this._dateInterval.set({
            dateBegin: dateBegin ? toMidnight(dateBegin) : null,
            dateEnd: dateEnd ? toMidnight(dateEnd.valueOf() + nsGmx.DateInterval.MS_IN_DAY) : null
        });
    },

    _updateWidget: function() {
        var dateBegin = this._dateInterval.get('dateBegin'),
            dateEnd = this._dateInterval.get('dateEnd'),
            dayms = nsGmx.DateInterval.MS_IN_DAY;

        if (!dateBegin || !dateEnd) {
            return;
        };

        var isValid = !(dateBegin % dayms) && !(dateEnd % dayms);

        var newDateBegin = Calendar.toUTC(dateBegin),
            newDateEnd;
        if (isValid) {
            newDateEnd = Calendar.toUTC(new Date(dateEnd - dayms));
            if (dateEnd - dateBegin > dayms) {
                this.setMode(Calendar.ADVANCED_MODE);
            }
        } else {
            newDateEnd = Calendar.toUTC(dateEnd);
            this.setMode(Calendar.ADVANCED_MODE);
        }

        //если мы сюда пришли после выбора интервала в самом виджете, вызов setDate сохраняет фокус на input-поле
        //возможно, это какая-то проблема jQueryUI.datepicker'ов.
        //чтобы этого избежать, явно проверяем, нужно ли изменять дату
        var prevDateBegin = this._dateBegin.datepicker('getDate'),
            prevDateEnd = this._dateEnd.datepicker('getDate');

        if (!prevDateBegin || prevDateBegin.valueOf() !== newDateBegin.valueOf()) {
            this._dateBegin.datepicker('setDate', newDateBegin);
        }

        if (!prevDateEnd || prevDateEnd.valueOf() !== newDateEnd.valueOf()) {
            this._dateEnd.datepicker('setDate', newDateEnd);
        }
    },

    //public interface

    /** Закрыть все открытые datepicker'ы.
     * @return {nsGmx.CalendarWidget} this
     */
    reset: function() {
        this._dateInputs.datepicker('hide');
        return this;
    },

    /** Сериализация состояния виджета
     * @return {Object} Сериализованное состояние
     */
    saveState: function() {
        return {
            version: '1.1.0',
            vismode: this.getMode()
        }
    },

    /** Восстановить состояние виджета по сериализованным данным
     * @param {Object} data Сериализованное состояние календарика
     */
    loadState: function( data ) {
        this.setMode(data.vismode);
    },

    /** Получить начальную дату
     * @return {Date} начальная дата
     */
    getDateBegin: function() {
        return Calendar.fromUTC(this._dateBegin.datepicker('getDate'));
    },

    /** Получить конечную дату
     * @return {Date} конечная дата
     */
    getDateEnd: function() {
        return Calendar.fromUTC(this._dateEnd.datepicker('getDate'));
    },

    /** Получить верхнюю границу возможных дат периода
     * @return {Date} верхняя граница возможных периодов
     */
    getDateMax: function() {
        return this._dateMax;
    },

    /** Получить нижнуюю границу возможных дат периода
     * @return {Date} нижняя граница возможных периодов
     */
    getDateMin: function() {
        return this._dateMin;
    },

    /** Установить нижнуюю границу возможных дат периода
     * @param {Date} dateMin нижняя граница возможных периодов
     */
    setDateMin: function(dateMin) {
        this._dateMin = dateMin;
        this._dateInputs.datepicker('option', 'minDate', dateMin ? Calendar.toUTC(dateMin) : null);
    },

    /** Установить верхнюю границу возможных дат периода
     * @param {Date} dateMax верхняя граница возможных периодов
     */
    setDateMax: function(dateMax) {
        var titleContainer = this.$('.CalendarWidget-forecast');

        this._dateMax = dateMax;
        if (dateMax) {
            var utcDate = Calendar.toUTC(dateMax);
            this._dateInputs.datepicker('option', 'maxDate', utcDate);

            if (dateMax > new Date()) {
                $(titleContainer).attr('title', _gtxt('CalendarWidget.tooltip') + ' ' +
                ('0' + dateMax.getDate()).slice(-2) + '.' +
                ('0' + (dateMax.getMonth() + 1)).slice(-2) + '.' +
                dateMax.getFullYear());
                $(titleContainer).show();
            } else {
                $(titleContainer).hide();
            }

        } else {
            this._dateInputs.datepicker('option', 'maxDate', null);
        }
    },

    setSwitcherVisibility: function(isVisible) {
        this._moreIcon && this._moreIcon.toggle(isVisible);
    },

    getDateInterval: function() {
        return this._dateInterval;
    },

    getMode: function() {
        return this._curMode;
    },

    setMode: function(mode) {
        if (this._curMode === mode) {
            return this;
        }

        this.reset();

        this._curMode = mode;
        var isSimple = mode === Calendar.SIMPLE_MODE;

        this.$('.CalendarWidget-onlyMaxVersion').toggle(!isSimple);

        this._moreIcon
            .toggleClass('icon-calendar', isSimple)
            .toggleClass('icon-calendar-empty', !isSimple)
            .attr('title', isSimple ? _gtxt('CalendarWidget.ExtendedViewTitle') : _gtxt('CalendarWidget.MinimalViewTitle'));


        var dateBegin = this._dateBegin.datepicker('getDate'),
            dateEnd = this._dateEnd.datepicker('getDate');

        if (isSimple && dateBegin && dateEnd && dateBegin.valueOf() !== dateEnd.valueOf()) {
            this._selectFunc(this._dateEnd);
            this._updateModel();
        }

        this.trigger('modechange');

        return this;
    },

    toggleMode: function() {
        this.setMode(this._curMode === Calendar.SIMPLE_MODE ? Calendar.ADVANCED_MODE : Calendar.SIMPLE_MODE );
    }
}, {
    /* static methods */
    fromUTC: function(date) {
        if (!date) return null;
        var timeOffset = date.getTimezoneOffset()*60*1000;
        return new Date(date.valueOf() - timeOffset);
    },
    toUTC: function(date) {
        if (!date) return null;
        var timeOffset = date.getTimezoneOffset()*60*1000;
        return new Date(date.valueOf() + timeOffset);
    },
    SIMPLE_MODE: 1,
    ADVANCED_MODE: 2
});

nsGmx.CalendarWidget = Calendar;

})(jQuery);
;
nsGmx.Translations.addText("rus", { CalendarWidget: {
    ExtendedViewTitle: "Выбор периода",
    MinimalViewTitle:  "Свернуть",
    UTC:               "Всемирное координированное время",
    forecast:           "прогноз",
    tooltip:            "доступны прогнозные данные до"
}});

nsGmx.Translations.addText("eng", { CalendarWidget: {
    ExtendedViewTitle: "Period selection",
    MinimalViewTitle:  "Minimize",
    UTC:               "Coordinated Universal Time",
    forecast:           "forecast",
    tooltip:            "forecast data is available up to"
}});
;
/** Контрол для задания диапазона дат с логикой работы, взятой с сайта fires.ru.
 @description Основное отличае в логине формировании интервала на основе выбранных в календариках дат.
              Работает так же, как и обычный виджет ({@link nsGmx.CalendarWidget}) за исключением ситуации, когда dateEnd попадает в текущие UTC сутки.
              В этом случае, dateEnd устанавливается равном началу следующего часа. Далее, если длина выбранного интервала меньше 12 часов, начало интервала смещается на сутки назад.
              Кроме формирования интервала, этот виджет показывает пользователю дополнительную информацию о выбранном интервале.
 @alias nsGmx.FireCalendarWidget
 @class
 @param {nsGmx.CalendarWidget~Parameters} params Параметры календаря
*/

var nsGmx = nsGmx || {};

(function($){

'use strict';

var toMidnight = nsGmx.DateInterval.toMidnight;

nsGmx.Translations.addText("rus", { FireCalendarWidget: {
    timeTitlePrefix : 'За ',
    timeTitleLastPrefix : 'За последние ',
    timeTitlePostfix : 'ч (UTC)'
}});

nsGmx.Translations.addText("eng", { FireCalendarWidget: {
    timeTitlePrefix : 'For ',
    timeTitleLastPrefix : 'For last ',
    timeTitlePostfix : 'h (UTC)'
}});


function f(n) {
    return n < 10 ? '0' + n : n;
}

function getStr (hours, minutes) {
    return f(hours) + ":" + f(minutes); /*+ ":" + f(time.seconds)*/
};

var FireCalendarWidget = nsGmx.CalendarWidget.extend({
    initialize: function(options) {
        options = $.extend({
            dateMax: new Date()
        }, options);

        nsGmx.CalendarWidget.prototype.initialize.call(this, options);

        this._dateInterval.on('change', this._updateInfo, this);
        this.on('modechange', this._updateInfo, this);
        this.on('modechange', this._updateModel, this);
        this._updateInfo();
    },

    _updateModel: function() {
        var dateBegin = this.getDateBegin(),
            origDateEnd = this.getDateEnd(),
            now = new Date(),
            lastMidnight = toMidnight(now),
            dateEnd;

        if (lastMidnight <= origDateEnd) {
            //last day
            dateEnd = new Date((now - 1) - (now - 1) % (3600*1000) + 3600*1000); //round to the nearest hour greater then 'now'

            if (dateEnd - toMidnight(dateBegin) < 12*3600*1000 && this.getMode() === nsGmx.CalendarWidget.SIMPLE_MODE) {
                dateBegin = new Date(dateBegin - nsGmx.DateInterval.MS_IN_DAY);
            }
        } else {
            //previous days
            dateEnd = new Date(origDateEnd.valueOf() + nsGmx.DateInterval.MS_IN_DAY);
        }

        this._dateInterval.set({
            dateBegin: toMidnight(dateBegin),
            dateEnd: dateEnd
        });
    },

    _updateWidget: function() {
        var dateBegin = +this._dateInterval.get('dateBegin'),
            dateEnd = +this._dateInterval.get('dateEnd');

        if (!dateBegin || !dateEnd) {
            return;
        };

        var currentDayMode = toMidnight(new Date()) < dateEnd;

        if (currentDayMode && this.getMode() === nsGmx.CalendarWidget.SIMPLE_MODE && dateEnd - dateBegin < 2 * nsGmx.DateInterval.MS_IN_DAY) {
            this._dateBegin.datepicker("setDate", nsGmx.CalendarWidget.toUTC(new Date()));
            this._dateEnd.datepicker("setDate", nsGmx.CalendarWidget.toUTC(new Date()));
        } else {
            nsGmx.CalendarWidget.prototype._updateWidget.call(this);
        }
    },

    _updateInfo: function() {
        var isSimpleMode = this.getMode() === nsGmx.CalendarWidget.SIMPLE_MODE;

        this.$('.CalendarWidget-footer').toggle(isSimpleMode);
        this.$('.CalendarWidget-dateBeginInfo, .CalendarWidget-dateEndInfo').toggle(!isSimpleMode);

        var dateBegin = this._dateInterval.get('dateBegin'),
            dateEnd = this._dateInterval.get('dateEnd');

        if (!dateBegin || !dateEnd) {
            return;
        }

        var hours = Math.ceil((dateEnd - dateBegin)/3600000);

        if (isSimpleMode) {
            var hoursStr = hours > 24 ? "24+" + (hours-24) : hours;
            var prefix = hours === 24 ? _gtxt("FireCalendarWidget.timeTitlePrefix") : _gtxt("FireCalendarWidget.timeTitleLastPrefix");

            this.$('.CalendarWidget-footer').html(prefix + hoursStr + _gtxt("FireCalendarWidget.timeTitlePostfix"));
        } else {
            var dateEndToShow = (hours % 24) === 0 ? new Date(+dateEnd - 1) : dateEnd; //hack to show 23:59 instead of 00:00
            this.$('.CalendarWidget-dateBeginInfo').text(getStr(dateBegin.getUTCHours(), dateBegin.getUTCMinutes()) + " (UTC)").attr('title', _gtxt('CalendarWidget.UTC'));
            this.$('.CalendarWidget-dateEndInfo'  ).text(getStr(dateEndToShow.getUTCHours(), dateEndToShow.getUTCMinutes()) + " (UTC)").attr('title', _gtxt('CalendarWidget.UTC'));

        }
    }
}, {
    defaultFireDateInterval: function() {
        var now = new Date(),
            lastMidnight = toMidnight(now),
            dateEnd = new Date((now - 1) - (now - 1) % (3600*1000) + 3600*1000), //round to the nearest hour greater then 'now'
            isTooSmall = dateEnd - lastMidnight < 12*3600*1000,
            dateBegin = new Date(isTooSmall ? (lastMidnight - nsGmx.DateInterval.MS_IN_DAY) : lastMidnight.valueOf());

        return {
            dateBegin: dateBegin,
            dateEnd: dateEnd
        }
    }
});

nsGmx.FireCalendarWidget = FireCalendarWidget;

})(jQuery);
;
(function($){

'use strict';

var _gtxt = nsGmx.Translations.getText.bind(nsGmx.Translations),
    toMidnight = nsGmx.DateInterval.toMidnight;


    nsGmx.Translations.addText("rus", { CalendarWidget: {
        ShowIconTitle:     "Выбрать дату",
        createDateInterval: "Задать интервал",
        resetDateInterval:  "Сбросить интервал",
        selectDateInterval: "Применить",
        hour:               "ч.",
        from: "с",
        to: "до"
    }});

    nsGmx.Translations.addText("eng", { CalendarWidget: {
        ShowIconTitle:     "Select date",
        createDateInterval: "Create date interval",
        resetDateInterval:  "Reset date interval",
        selectDateInterval: "Select date interval",
        hour:               "h.",
        from: "from",
        to: "to"
    }});

    var template = '' +
        '<div>' +
            '<div class = "CalendarWidget-row CalendarWidget-dates">' +
                // dates block
                '<span class = "CalendarWidget-iconScrollLeft icon-left-open"></span>' +
                '<span class = "CalendarWidget-dates-outside">' +
                    '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputBegin"><input class = "CalendarWidget-dateBegin" readonly></span>' +
                    '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputMiddle">-</span>' +
                    '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputEnd"><input class = "CalendarWidget-dateEnd" readonly></span>' +
                '</span>' +
                '<span class = "CalendarWidget-iconScrollRight ui-helper-noselect icon-right-open"></span>' +
                // space between dates and time
                '<span class = "CalendarWidget-space"></span>' +
                // times block
                '<span class = "CalendarWidget-timeicon"><img src="img/time-icon-01.svg"></img></span>' +
                '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputTimeBegin"><input class = "CalendarWidget-timeInput CalendarWidget-timeBegin" value={{hourBegin}} ></span>' +
                '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputMiddle CalendarWidget-inputCell-inputTimeMiddle">-</span>' +
                '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputTimeEnd"><input class = "CalendarWidget-timeInput CalendarWidget-timeEnd" value={{hourEnd}}></span>' +
            '</div>' +
        '</div>';

/** Параметры календаря
 * @typedef nsGmx.CalendarWidget~Parameters
 * @property {nsGmx.DateInterval} dateInterval Временной интервал, который нужно менять
 * @property {Date} [dateMin] минимальная граничная дата для календарей, null - без ограничений
 * @property {Date} [dateMax] максимальная граничная дата для календарей, null - без ограничений
 * @property {String} [dateFormat='dd.mm.yy'] формат даты
 * @property {bool} [minimized=true] показывать ли минимизированный или развёрнутый виджет в начале
 * @property {bool} [showSwitcher=true] показывать ли иконку для разворачивания/сворачивания периода
 * @property {Date} [dateBegin=<текущая дата>] начальная дата интервала
 * @property {Date} [dateEnd=<текущая дата>] конечная дата интервала
 * @property {String|DOMNode} [container] куда добавлять календарик
 * @property {String} [buttonImage] URL иконки для активации календариков
 */

/** Контрол для задания диапазона дат. Даты календарика всегда в UTC, а не в текущем поясе.
 @description Виджет для выбора интервала дат. Пользователь при помощи datepicker'ов выбирает два дня (год, месяц, число),
              затем выбранные значения при помощи ф-ции `_updateModel()` переводятся в интервал дат ({@link nsGmx.DateInterval}).
              Так же виджет реагирует на изменения модели (с использованием ф-ции `_updateWidget()`)
 @alias nsGmx.CalendarWidget
 @extends nsGmx.GmxWidget
 @class
 @param {nsGmx.CalendarWidget~Parameters} options Параметры календаря
*/

var CalendarModel = window.Backbone.Model.extend({
    defaults: {
        dailyFilter: true
    }
});

var Calendar1 = window.Backbone.View.extend({
    tagName: 'div',
    model: new CalendarModel(),
    className: 'CalendarWidget ui-widget',
    template: Handlebars.compile(template),
    events: {
        'click .CalendarWidget-dates-outside .CalendarWidget-inputCell': function (e) {
            e.stopPropagation();
            this.showCalendar();
        },
        'click .CalendarWidget-iconScrollLeft': function () {
            this._shiftDates(-1);
        },
        'click .CalendarWidget-iconScrollRight': function () {
            this._shiftDates(1);
        }
    },

    initialize: function(options) {
        var _this = this;
        options = $.extend({
            minimized: true,
            showSwitcher: true,
            dateMax: null,
            dateMin: null,
            dateFormat: 'dd.mm.yy',
            name: null
        }, options);

        this._dateMin = options.dateMin;
        this._dateMax = options.dateMax;
        this._dateInterval = options.dateInterval;
        this._opened = false;

        $.datepicker.setDefaults({

            onSelect: function(dateText, inst){
                this._selectFunc(inst.input);
            }.bind(this),
            minDate: this._dateMin ? Calendar1.toUTC(this._dateMin) : null,
            maxDate: this._dateMax ? Calendar1.toUTC(this._dateMax) : null,
            changeMonth: true,
            changeYear: true,
            dateFormat: 'dd.mm.yy',
            defaultDate: Calendar1.toUTC(this._dateMax || new Date()),
            buttonImageOnly: true,
            constrainInput: true
        });

        this.calendarTemplates = {
            beginTemplate: Handlebars.compile('' +
                '<div class="outside-calendar-container">' +
                    '<div class="begin-outside-calendar">' +
                    '</div>' +
                    '<div class="time-container begin-time-container">' +
                    '</div>' +
                    '<div class="time-placeholder begin-time-placeholder" hidden>' +
                    '</div>' +
                        '<span class="calendar-button createdateinterval-button">' +
                        '{{i "CalendarWidget.createDateInterval"}}'+
                        '</span>' +
                        '<span class="calendar-button resetdateinterval-button" hidden>' +
                            '{{i "CalendarWidget.resetDateInterval"}}'+
                        '</span>' +
                '</div>'
            ),
            endTemplate: Handlebars.compile('' +
                '<div class="outside-calendar-container">' +
                    '<div class="end-outside-calendar">' +
                    '</div>' +
                    '<div class="time-container end-time-container">' +
                    '</div>' +
                    '<div class="time-placeholder end-time-placeholder" hidden>' +
                    '</div>' +
                    '<span class="calendar-button selectdateinterval-button disabled">' +
                        '{{i "CalendarWidget.selectDateInterval"}}'+
                    '</span>' +
                '</div>'
            )
        };

        var dateBegin = this._dateInterval.get('dateBegin'),
            dateEnd = this._dateInterval.get('dateEnd'),
            hourBegin = Calendar1.getTime(dateBegin, 'begin'),
            hourEnd = Calendar1.getTime(dateEnd, 'end');

        this.$el.html(this.template({
            showCalendarIconClass:'icon-calendar-empty',
            showCalendarIconTitle: _gtxt('CalendarWidget.ShowIconTitle'),
            hourBegin: hourBegin,
            hourEnd: hourEnd
        }));

        // если есть контейнер, куда прикреплять виджет календаря
        if (options.container) {
            if (typeof options.container === 'string')
                $('#' + options.container).append(this.$el);
            else
                $(options.container).append(this.$el);
        }

        this._updateWidget();

        this._dateInterval.on('change', this._updateWidget, this);
        this.listenTo(this.model, 'change:dailyFilter', this.enableDailyFilter);

        $('#leftMenu').on('click', function (e) {
            if (e.target.className !== 'CalendarWidget-show-calendar-icon icon-calendar-empty' &&
                e.target.className !== 'layers-before' &&
                e.target.className.indexOf('CalendarWidget-timeInput') === -1 &&
                e.target.className !== 'calendar-container'
            ) {
                $(".calendar-outside .ui-dialog-titlebar-close").trigger('click');
                _this._opened = false;
            }
        })

        this.$('.CalendarWidget-timeInput').on('blur', this._selectTime.bind(this));

        //for backward compatibility
        this.canvas = this.$el;
    },

    enableDailyFilter: function () {
        var dailyFilter = this.model.get('dailyFilter'),
            timeBeginValue = this.$('.CalendarWidget-timeBegin').val(),
            timeEndValue = this.$('.CalendarWidget-timeEnd').val();

        if (dailyFilter) {
            if (Number(timeBeginValue) >= Number(timeEndValue)) {
                this.$('.CalendarWidget-timeBegin').addClass('error');
                this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
                this.$('.CalendarWidget-timeEnd').addClass('error');
            } else {
                this.$('.CalendarWidget-timeBegin').removeClass('error');
                this.$('.CalendarWidget-inputCell-inputTimeMiddle').removeClass('error');
                this.$('.CalendarWidget-timeEnd').removeClass('error');
            }
        } else {
            this.$('.CalendarWidget-timeBegin').removeClass('error');
            this.$('.CalendarWidget-inputCell-inputTimeMiddle').removeClass('error');
            this.$('.CalendarWidget-timeEnd').removeClass('error');
        }
        this.$('.CalendarWidget-timeBegin').trigger('blur');
        this.$('.CalendarWidget-timeEnd').trigger('blur');
    },

    _selectTime: function (e) {
        var match = this._checkValue(e.target.value);

        if (!match) {
            this.$('.CalendarWidget-timeBegin').addClass('error');
            this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
            this.$('.CalendarWidget-timeEnd').addClass('error');
            return;
        }

        // $(e.target).removeClass('error');

        var isBegin = $(e.target).hasClass('CalendarWidget-timeBegin'),
            dayms = nsGmx.DateInterval.MS_IN_DAY,
            dailyFilter = this.model.get('dailyFilter'),
            timeBeginValue = this.$('.CalendarWidget-timeBegin').val(),
            timeEndValue = this.$('.CalendarWidget-timeEnd').val(),
            msBeginInputValue = Calendar1.convertTimeValueToMs(timeBeginValue),
            msEndInputValue = Calendar1.convertTimeValueToMs(timeEndValue),
            dateBegin = this._dateInterval.get('dateBegin'),
            dateEnd = this._dateInterval.get('dateEnd'),
            hourBegin = Calendar1.getTime(dateBegin, 'begin'),
            hourEnd = Calendar1.getTime(dateEnd, 'end'),
            msBegin = Calendar1.convertTimeValueToMs(hourBegin),
            msEnd = Calendar1.convertTimeValueToMs(hourEnd),
            newDateBegin = new Date(dateBegin.valueOf() + (msBeginInputValue - msBegin)),
            newDateEnd = new Date(dateEnd.valueOf() + (msEndInputValue - msEnd));

            if (dailyFilter && Number(timeBeginValue) >= Number(timeEndValue)) {
                this.$('.CalendarWidget-timeBegin').addClass('error');
                this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
                this.$('.CalendarWidget-timeEnd').addClass('error');
                return;
            }

            if (newDateBegin.valueOf() >= newDateEnd.valueOf()) {
                this.$('.CalendarWidget-timeBegin').addClass('error');
                this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
                this.$('.CalendarWidget-timeEnd').addClass('error');
                return;
            } else {
                this.$('.CalendarWidget-timeBegin').removeClass('error');
                this.$('.CalendarWidget-inputCell-inputTimeMiddle').removeClass('error');
                this.$('.CalendarWidget-timeEnd').removeClass('error');
            }

        this._dateInterval.set({
            dateBegin: newDateBegin,
            dateEnd: newDateEnd
        });
    },

    _checkValue: function (value) {
        var hours = [
                '00', '01', '02', '03', '04', '05', '06', '07', '08', '09',
                '10', '11', '12', '13', '14', '15', '16', '17', '18', '19',
                '20', '21', '22', '23', '24'
             ],
             match = false;

        for (var i = 0; i < hours.length; i++) {
            if (value === hours[i]) {
                match = true;
            }
        }

        return match;
    },

    showCalendar: function () {
        var _this = this,
            beginInput = this.$('.CalendarWidget-dateBegin')[0],
            endInput = this.$('.CalendarWidget-dateEnd')[0],
            dateBegin = this._dateInterval.get('dateBegin'),
            dateEnd = this._dateInterval.get('dateEnd'),
            dayms = nsGmx.DateInterval.MS_IN_DAY,
            oneDayPeriod = (dateEnd.valueOf() - dateBegin.valueOf() === dayms),
            endMidnight = (dateEnd.valueOf() === toMidnight(dateEnd).valueOf());

        this.beginCalendar = $(this.calendarTemplates.beginTemplate({oneDayPeriod: oneDayPeriod}));
        this.endCalendar = $(this.calendarTemplates.endTemplate({}));

        var createIntervalButton = $('.createdateinterval-button', this.beginCalendar),
            resetIntervalButton = $('.resetdateinterval-button', this.beginCalendar),
            selectIntervalButton = $('.selectdateinterval-button', this.endCalendar),
            beginDialogOptions = {
                dialogClass: "calendar-outside begin-calendar",
                draggable: false,
                resizable: false,
                width: 224.8,
                height: 280,
                position: [372, 105],
                resizeFunc: function () {
                    return false;
                },
                closeFunc: function () {
                    _this._dateBegin.datepicker("destroy");
                },
            },
            endDialogOptions = {
                dialogClass: "calendar-outside end-calendar",
                draggable: false,
                resizable: false,
                width: 224.8,
                height: 280,
                position: [610, 105],
                resizeFunc: function () {
                    return false;
                },
                closeFunc: function () {
                    _this._dateEnd.datepicker("destroy");
                }
            };

        oneDayPeriod ? this.setMode(Calendar1.SIMPLE_MODE) : this.setMode(Calendar1.ADVANCED_MODE);

        this._dateBegin = $('.begin-outside-calendar', this.beginCalendar);
        this._dateEnd = $('.end-outside-calendar', this.endCalendar);

        this._dateInputs = this._dateBegin.add(this._dateEnd);

        this._dateInputs.datepicker();

        this._dateInputs.datepicker('option', 'minDate', Calendar1.toUTC(this._dateMin));
        this._dateInputs.datepicker('option', 'maxDate', Calendar1.toUTC(this._dateMax));

        this._dateBegin.datepicker('setDate', Calendar1.toUTC(dateBegin));
        this._dateEnd.datepicker('setDate', oneDayPeriod || endMidnight ? Calendar1.toUTC(new Date(dateEnd.valueOf() - dayms)) : Calendar1.toUTC(dateEnd));

        $(this.beginCalendar).dialog(beginDialogOptions);
        this._opened = true;

        if (this.getMode() === Calendar1.ADVANCED_MODE) {
            $(createIntervalButton).toggle(false);
            $(resetIntervalButton).toggle(true);
            $(this.endCalendar).dialog(endDialogOptions);
            this._opened = true;
        }

        // кнопки в первом календаре
        $(createIntervalButton).on('click', function () {
            var begin = _this._dateInterval.get('dateBegin'),
                end = _this._dateInterval.get('dateEnd');

            _this.setMode(Calendar1.ADVANCED_MODE);
            $(_this.endCalendar).dialog(endDialogOptions);
            _this._opened = true;

            $(this).toggle(false);
            $(resetIntervalButton).toggle(true);
        })

        $(resetIntervalButton).on('click', function () {
            var dateBegin = toMidnight(_this._dateInterval.get('dateBegin'));
            _this.setMode(Calendar1.SIMPLE_MODE);
            _this._dateBegin.datepicker('setDate', Calendar1.toUTC(dateBegin));
            _this._dateEnd.datepicker('setDate', Calendar1.toUTC(dateBegin));
            $(".calendar-outside.end-calendar .ui-dialog-titlebar-close").trigger('click');
            _this._opened = false;

            $(this).toggle(false);
            $(createIntervalButton).toggle(true);
            _this._dateInterval.set({
                dateBegin: dateBegin,
                dateEnd: new Date(dateBegin.valueOf() + dayms)
            })
        })

        // кнопка во втором календаре
        $(selectIntervalButton).on('click', function () {
            _this._updateModel();
            _this.setActive(true);
            _this._enableCreateIntervalButton();
        })
    },

    _enableCreateIntervalButton: function (e) {
        var dayms = nsGmx.DateInterval.MS_IN_DAY,
            selectIntervalButton = $('.selectdateinterval-button'),
            dateBegin = this._dateInterval.get('dateBegin'),
            dateEnd = this._dateInterval.get('dateEnd'),
            beginTimeValue = Calendar1.convertTimeValueToMs(e && e.target === $('CalendarWidget-timeBegin', this)[0] ? $(e.target).val() : $('.CalendarWidget-timeBegin').val()),
            endTimeValue = Calendar1.convertTimeValueToMs(e && e.target === $('CalendarWidget-timeEnd', this)[0] ? $(e.target).val() : $('.CalendarWidget-timeEnd').val()),
            calendarDateBegin = this.getDateBegin(),
            calendarDateEnd = this.getDateEnd(),
            newDateBegin = new Date(calendarDateBegin.valueOf() + beginTimeValue),
            newDateEnd = new Date(calendarDateEnd.valueOf() + endTimeValue);

        // если даты в итоге не поменялись или вторая дата больше первой
        if ((newDateBegin.valueOf() === dateBegin.valueOf() && newDateEnd.valueOf() === dateEnd.valueOf()) ||
            newDateBegin.valueOf() >= newDateEnd.valueOf()) {
                $(selectIntervalButton).addClass('disabled');
        } else {
            $(selectIntervalButton).removeClass('disabled');
        }
    },

    _shiftDates: function(delta) {
        var dateBegin = this._dateInterval.get('dateBegin'),
            dateEnd = this._dateInterval.get('dateEnd'),
            dayms = nsGmx.DateInterval.MS_IN_DAY,
            dailyFilter = this.model.get('dailyFilter'),
            shift;

        if (!dateBegin || !dateEnd) {
            return;
        }

        if (dailyFilter) {
            var diff = (toMidnight(dateEnd) - toMidnight(dateBegin));
            shift = diff ? diff * delta : dayms * delta;
        } else {
            shift = (dateEnd - dateBegin) * delta;
        }

        var newDateBegin = new Date(dateBegin.valueOf() + shift),
            newDateEnd = new Date(dateEnd.valueOf() + shift);

        if ((!this._dateMin || toMidnight(this._dateMin) <= toMidnight(newDateBegin)) &&
            (!this._dateMax || toMidnight(this._dateMax) >= toMidnight(newDateEnd)))
        {
            this._dateInterval.set({
                dateBegin: newDateBegin ? newDateBegin : null,
                dateEnd: newDateEnd ? newDateEnd : null
            });
        }
    },

    _selectFunc: function(activeInput) {
        var begin = this.getDateBegin(),
            end = this.getDateEnd(),
            dayms = nsGmx.DateInterval.MS_IN_DAY,
            selectIntervalButton = $('.selectdateinterval-button');

        if (end && begin && begin > end) {
            var dateToFix = activeInput[0] == this._dateEnd[0] ? this._dateBegin : this._dateEnd;

            dateToFix.datepicker('setDate', $(activeInput[0]).datepicker('getDate'));
        }
        if (this._curMode === Calendar1.SIMPLE_MODE) {
            if (!begin != !end || begin && begin.valueOf() !== end.valueOf()) {
                this._dateEnd.datepicker('setDate', this._dateBegin.datepicker('getDate'));
            }
            this._dateInterval.set({
                dateBegin: begin ? begin : null,
                dateEnd: end ? new Date(begin.valueOf() + nsGmx.DateInterval.MS_IN_DAY) : null
            });
        } else if (this._curMode === Calendar1.ADVANCED_MODE) {
            this._enableCreateIntervalButton();
        }
    },

    _updateModel: function() {
        // получаем значения с дейтпикеров и переводим их в локальное время
        var dateBegin = this.getDateBegin(),
            dateEnd = this.getDateEnd(),
            // значение часов
            beginTimeValue = Calendar1.convertTimeValueToMs($('.CalendarWidget-timeBegin').val()),
            endTimeValue = Calendar1.convertTimeValueToMs($('.CalendarWidget-timeEnd').val()),
            dayms = nsGmx.DateInterval.MS_IN_DAY,
            // если второй день захвачен полностью
            fullDay = endTimeValue === dayms;

        // добавим время к часам (в локальном времени)
        dateBegin = new Date(dateBegin.valueOf() + beginTimeValue);
        dateEnd = new Date(dateEnd.valueOf() + endTimeValue);

        this._dateInterval.set({
            dateBegin: dateBegin ? dateBegin : null,
            dateEnd: dateEnd ? dateEnd : null
        });
    },

    _updateWidget: function() {
        var dateBegin = this._dateInterval.get('dateBegin'),
            dateEnd = this._dateInterval.get('dateEnd'),
            hourBegin = Calendar1.getTime(dateBegin, 'begin'),
            hourEnd = Calendar1.getTime(dateEnd, 'end'),
            beginInput = this.$('.CalendarWidget-dateBegin')[0],
            endInput = this.$('.CalendarWidget-dateEnd')[0],
            timeBegin = this.$('.CalendarWidget-timeBegin')[0],
            timeEnd = this.$('.CalendarWidget-timeEnd')[0],
            dayms = nsGmx.DateInterval.MS_IN_DAY,
            newDateEnd;

        if (!dateBegin || !dateEnd) {
            return;
        };

        var newDateBegin = Calendar1.toUTC(dateBegin),
            newDateEnd = Calendar1.toUTC(new Date(dateEnd));

        // если календарь показывает ровно один день,
        // прибавляем 24 часа к первой дате, чтобы получить сутки
        if (dateEnd.valueOf() === toMidnight(dateEnd).valueOf()) {
            newDateEnd = Calendar1.toUTC(new Date(dateEnd - dayms));
        }

        $(beginInput).val(Calendar1.formatDate(newDateBegin));
        $(endInput).val(Calendar1.formatDate(newDateEnd));

        $(timeBegin).val(Calendar1.prefixTimeValue(hourBegin));
        $(timeEnd).val(Calendar1.prefixTimeValue(hourEnd));

        this.enableDailyFilter();
    },

    setActive: function (value) {
        var active = this.active;
        if (value !== active) {
            this.active = value;
        }

        if (this.active) {
            this.$el.removeClass('gmx-disabled')
        } else {
            this.$el.addClass('gmx-disabled')
        }
    },

    //public interface

    /** Закрыть все открытые datepicker'ы.
     * @return {nsGmx.CalendarWidget} this
     */
    reset: function() {
        this._dateInputs.datepicker('hide');
        return this;
    },

    /** Сериализация состояния виджета
     * @return {Object} Сериализованное состояние
     */
    saveState: function() {
        return {
            version: '1.1.0',
            vismode: this.getMode()
        }
    },

    /** Восстановить состояние виджета по сериализованным данным
     * @param {Object} data Сериализованное состояние календарика
     */
    loadState: function( data ) {
        this.setMode(data.vismode);
    },

    /** Получить начальную дату
     * @return {Date} начальная дата
     */
    getDateBegin: function() {
        return this._dateBegin ? Calendar1.fromUTC(this._dateBegin.datepicker('getDate')) : this.getDateInterval().get('dateBegin');
    },

    /** Получить конечную дату
     * @return {Date} конечная дата
     */
    getDateEnd: function() {
        return this._dateEnd ? Calendar1.fromUTC(this._dateEnd.datepicker('getDate')) : this.getDateInterval().get('dateEnd');
    },

    /** Получить верхнюю границу возможных дат периода
     * @return {Date} верхняя граница возможных периодов
     */
    getDateMax: function() {
        return this._dateMax;
    },

    /** Получить нижнуюю границу возможных дат периода
     * @return {Date} нижняя граница возможных периодов
     */
    getDateMin: function() {
        return this._dateMin;
    },

    /** Установить нижнуюю границу возможных дат периода
     * @param {Date} dateMin нижняя граница возможных периодов
     */
    setDateMin: function(dateMin) {
        this._dateMin = dateMin;
        this._dateInputs.datepicker('option', 'minDate', dateMin ? Calendar1.toUTC(dateMin) : null);
    },

    /** Установить верхнюю границу возможных дат периода
     * @param {Date} dateMax верхняя граница возможных периодов
     */
    setDateMax: function(dateMax) {
        // var titleContainer = this.$('.CalendarWidget-forecast');

        this._dateMax = dateMax;
        if (dateMax) {
            var utcDate = Calendar1.toUTC(dateMax);
            if (this._dateInputs) {
                this._dateInputs.datepicker('option', 'maxDate', utcDate);
            }

            if (dateMax > new Date()) {
            //     $(titleContainer).attr('title', _gtxt('CalendarWidget.tooltip') + ' ' +
            //     ('0' + dateMax.getDate()).slice(-2) + '-' +
            //     ('0' + (dateMax.getMonth() + 1)).slice(-2) + '-' +
            //     dateMax.getFullYear());
            //     $(titleContainer).show();
            // } else {
            //     $(titleContainer).hide();
            }

        } else {
            if (this._dateInputs) {
                this._dateInputs.datepicker('option', 'maxDate', null);
            }
        }
    },

    setSwitcherVisibility: function(isVisible) {
        this._showCalendarIcon && this._showCalendarIcon.toggle(isVisible);
    },

    getDateInterval: function() {
        return this._dateInterval;
    },

    getMode: function() {
        return this._curMode;
    },

    setMode: function(mode) {
        if (this._curMode === mode) {
            return this;
        }

        this._curMode = mode;
    }

}, {
    /* static methods */

    // date показывает в utc
    // нужно вычесть отрицательную разницу
    // utc 13:00
    // 13:00 - (-3 часа) = 16:00
    // locale 16:00
    // return locale date
    fromUTC: function(date) {
        if (!date) return null;
        var timeOffset = date.getTimezoneOffset()*60*1000;
        return new Date(date.valueOf() - timeOffset);
    },
    toUTC: function(date) {
        if (!date) return null;
        var timeOffset = date.getTimezoneOffset()*60*1000;
        return new Date(date.valueOf() + timeOffset);
    },
    formatDate: function(date) {
        var d = new Date(date),
        month = '' + (d.getMonth() + 1),
        day = '' + d.getDate(),
        year = d.getFullYear();

        if (month.length < 2) month = '0' + month;
        if (day.length < 2) day = '0' + day;

        return [day, month, year].join('.');
    },
    convertTimeValueToMs: function (value) {
        var ms = Number(value)*1000*3600;
        return ms;
    },
    getTime: function (date, position) {
        var dayms = nsGmx.DateInterval.MS_IN_DAY,
            offset, hours;

        if (position === 'begin') {
            offset = date.valueOf() - toMidnight(date).valueOf();
        } else {
            if (date.valueOf() === toMidnight(date).valueOf()) {
                offset = dayms;
            } else {
                offset = date.valueOf() - toMidnight(date).valueOf();
            }
        };

        hours = offset/(3600*1000);

        return hours;
    },

    prefixTimeValue: function (value) {
        value = Number(value);
        return value < 10 ? '0' + value : String(value);
    },
    SIMPLE_MODE: 1,
    ADVANCED_MODE: 2
});

nsGmx.CalendarWidget1 = Calendar1;

})(jQuery);

var nsGmx = window.nsGmx = window.nsGmx || {};
//<div class="alertWidget-message ui-state-{{type}}">{{message}}</div>
nsGmx.AlertWidget = nsGmx.GmxWidget.extend({
    className: 'alertWidget ui-widget',
    constructor: function() {
        this.collection = new Backbone.Collection();
        nsGmx.GmxWidget.apply(this, arguments);
    },
    initialize: function() {
        this.collection.on('add remove update', this.render, this);
        var msg = this._getMessageObject(arguments);
        if (msg) {
            this.collection.add(msg);
        }
    },
    // Вывести сообщение об ошибке
    // type может быть 'error' или 'warning'
    // push({ message: 'something wrong', type: 'warning', timeout: 200 }) или
    // push('something wrong', 'warning', 200)
    push: function() {
        var msg = this._getMessageObject(arguments);
        if (msg) {
            this.collection.add(msg);
        }
    },
    // удалить все сообщения
    clear: function() {
        this.collection.reset();
    },
    render: function() {
        this.$el.empty();
        for (var i = 0; i < this.collection.length; i++) {
            var m = this.collection.at(i);
            $('<div>')
                .addClass('alertWidget-message')
                .addClass('ui-state-' + m.get('type'))
                .html(m.get('message'))
                .appendTo(this.$el);
        }
        return this;
    },
    _getMessageObject: function(args) {
        if (args.length === 0 || !args[0]) {
            return null;
        } else if (args.length === 1) {
            return {
                message: args[0].message,
                type: args[0].type === 'warning' ? 'highlight' : 'error',
                timeout: args[0].timeout
            };
        } else {
            return {
                message: args[0],
                type: (args[1] && args[1] === 'warning') ? 'highlight' : 'error',
                timeout: args[2]
            };
        }
    }
});
var nsGmx = nsGmx || {};nsGmx.Templates = nsGmx.Templates || {};nsGmx.Templates.ShareIconControl = {};
nsGmx.Templates.ShareIconControl["shareDialog"] = "<div class=\"shareDialog-row shareDialog-title\">\n" +
    "    <span><%= nsGmx.Translations.getText('shareDialog.permalinkBelow') %></span>\n" +
    "    <a class=\"gmx-link gmx-link_icon shareDialog-socialShareLink shareDialog-socialShareLink_twitter\" target=\"_blank\"><i class=\"icon-twitter\"></i></a>\n" +
    "    <a class=\"gmx-link gmx-link_icon shareDialog-socialShareLink shareDialog-socialShareLink_facebook\" target=\"_blank\"><i class=\"icon-facebook\"></i></a>\n" +
    "    <a class=\"gmx-link gmx-link_icon shareDialog-socialShareLink shareDialog-socialShareLink_vk\" target=\"_blank\"><i class=\"icon-vk\"></i></a>\n" +
    "</div>\n" +
    "<div class=\"shareDialog-row\">\n" +
    "    <div class=\"gmx-table\">\n" +
    "        <div class=\"gmx-table-cell shareDialog-permalinkUrlCell\">\n" +
    "            <input class=\"gmx-input-text gmx-input-text_maxwidth gmx-input-text_readonly shareDialog-inputPermalinkUrl\" type=\"text\" readonly=\"readonly\" />\n" +
    "        </div>\n" +
    "        <div class=\"gmx-table-cell shareDialog-permalinkUrlPreviewButtonCell\">\n" +
    "            <a class=\"gmx-link gmx-link_icon shareDialog-permalinkUrlPreviewButton\" target=\"_blank\"><i class=\"icon-link-ext\" title=\"<%= nsGmx.Translations.getText('shareDialog.newWin') %>\"></i></a>\n" +
    "        </div>\n" +
    "    </div>\n" +
    "</div>\n" +
    "<div class=\"shareDialog-row shareDialog-title\"><%= nsGmx.Translations.getText('shareDialog.embeddedBelow') %></div>\n" +
    "<div class=\"shareDialog-row\">\n" +
    "    <table><tr><td class=\"shareDialog-resolutionTable-cell\">\n" +
    "    <div class=\"gmx-table shareDialog-resolutionTable\">\n" +
    "        <div class=\"gmx-table-cell shareDialog-previewResolutionCell\">\n" +
    "            <input class=\"gmx-input-text shareDialog-inputIframeWidth\" type=\"text\" value=\"<%= iframeWidth %>\"/>\n" +
    "            <span class=\"shareDialog-resolutionCross\">x</span>\n" +
    "            <input class=\"gmx-input-text shareDialog-inputIframeHeight\" type=\"text\" value=\"<%= iframeHeight %>\" />\n" +
    "        </div>\n" +
    "    </div>\n" +
    "    </td><td>\n" +
    "    <div class=\"gmx-table-cell shareDialog-winnieLinkCell shareDialog-validationOk\">\n" +
    "        <a class=\"shareDialog-winnieLink gmx-link\" href=\"#\" target=\"_blank\"><%= nsGmx.Translations.getText('shareDialog.winnieLink') %></a><i class=\"gmx-icon icon-link-ext\"></i>\n" +
    "    </div>\n" +
    "    </td></tr></table>\n" +
    "</div>\n" +
    "<div class=\"shareDialog-row\">\n" +
    "    <textarea class=\"shareDialog-inputEmbedCode gmx-input-text gmx-input-text_maxwidth gmx-input-text_readonly shareDialog-validationOk\" readonly=\"readonly\">\n" +
    "        <%= embedCode %>\n" +
    "    </textarea>\n" +
    "    <div class=\"shareDialog-validationError shareDialog-validationErrorView\"></div>\n" +
    "</div>\n" +
    "\n" +
    "<div class=\"gmx-table-cell shareDialog-previewLinkCell ui-state-disabled shareDialog-validationError\">\n" +
    "    <span><%= nsGmx.Translations.getText('shareDialog.preview') %></span><i class=\"icon-link-ext\"></i>\n" +
    "</div>\n" +
    "<div class=\"gmx-table-cell shareDialog-previewLinkCell shareDialog-validationOk\">\n" +
    "    <a class=\"shareDialog-previewLink gmx-link\" href=\"#\" target=\"_blank\"><%= nsGmx.Translations.getText('shareDialog.preview') %></a><i class=\"gmx-icon icon-link-ext\"></i>\n" +
    "</div>";;
var nsGmx = nsGmx || {};

nsGmx.ShareIconControl = L.Control.gmxIcon.extend({
    options: {
        className: 'shareIcon',
        id: 'share',
        text: 'Share',
        style: {
            width: 'auto'
        }
    },
    onAdd: function(map) {
        if (map.options.svgSprite) {
            delete this.options.text;
        }
        this._container = L.Control.gmxIcon.prototype.onAdd.apply(this, arguments);
        this._shareDialogContainer = L.DomUtil.create('div', 'shareDialogContainer');

        L.DomEvent.addListener(this._shareDialogContainer, 'click', function (e) {
            L.DomEvent.stopPropagation(e);
        });

        $(this._container).popover({
            content: this._shareDialogContainer,
            container: this._container,
            placement: 'bottom',
            html: true
        });

        $(this._container).on('shown.bs.popover', function() {
            var shareDialog = new nsGmx.ShareIconControl.ShareDialog(_.pick(this.options, [
                'permalinkUrlTemplate',
                'embeddedUrlTemplate',
                'winnieUrlTemplate',
                'previewUrlTemplate',
                'embedCodeTemplate',
                'permalinkManager'
            ]));
            shareDialog.appendTo(this._shareDialogContainer);
        }.bind(this));

        $(this._container).on('hide.bs.popover', function() {
            $(this._shareDialogContainer).empty();
        }.bind(this));

        return this._container;
    }
});
;
nsGmx.ShareIconControl.ShareDialogModel = Backbone.Model.extend({
    validate: function(attrs, options) {
        // NaN check
        if (attrs.iframeWidth / 1 !== attrs.iframeWidth / 1) {
            return 'shareDialog.invalidWidth';
        }
        if (attrs.iframeHeight / 1 !== attrs.iframeHeight / 1) {
            return 'shareDialog.invalidHeight';
        }
    }
});

nsGmx.ShareIconControl.ShareDialog = nsGmx.GmxWidget.extend({
    className: 'shareDialog',
    options: {
        permalinkUrlTemplate: '{{origin}}?permalink={{permalinkId}}',
        embeddedUrlTemplate: '{{origin}}embedded.html{{#if winnieId}}?permalink={{winnieId}}{{/if}}',
        winnieUrlTemplate: '{{origin}}{{#if winnieId}}?config={{winnieId}}{{/if}}',
        previewUrlTemplate: '{{origin}}iframePreview.html?width={{width}}&height={{height}}&permalinkUrl={{{embeddedUrl}}}',
        embedCodeTemplate: '<iframe src="{{{embeddedUrl}}}" width="{{width}}" height="{{height}}"></iframe>'
    },
    events: function() {
        return {
            'click .shareDialog-inputPermalinkUrl': function(e) {
                e.target.select();
            },
            'click .shareDialog-inputEmbedCode': function(e) {
                e.target.select();
            },
            'input .shareDialog-inputIframeWidth': this._setModelPropertyFn('iframeWidth'),
            'input .shareDialog-inputIframeHeight': this._setModelPropertyFn('iframeHeight'),
            'change .shareDialog-inputIframeWidth': this._setModelPropertyFn('iframeWidth'),
            'change .shareDialog-inputIframeHeight': this._setModelPropertyFn('iframeHeight')
        }
    },
    constructor: function(options) {
        nsGmx.GmxWidget.call(this, _.extend({
            model: new nsGmx.ShareIconControl.ShareDialogModel({
                permalinkId: '',
                winnieId: '',
                includePermalink: true,
                iframeWidth: 800,
                iframeHeight: 600,
                embedCode: '',
                error: ''
            })
        }, options));
    },
    initialize: function(options) {
        this.options = _.extend(this.options, options);
        this._terminateMouseEvents();
        this._permalinkManager = options.permalinkManager;
        this.createPermalink().then(null, function(err) {
            console.error(err);
        });
    },
    render: function() {
        if (this.model.get('error')) {
            return this._renderError();
        }
        if (!this.model.get('permalinkId')) {
            return this._renderLoader();
        }
        var changed = arguments[0] && arguments[0].changed;
        if (changed && (changed.iframeWidth || changed.iframeHeight)) {
            this._updateFields();
            return this;
        }
        this._renderDialog();
        return this;
    },
    createPermalink: function() {
        return $.Deferred(function(def) {
            this.model.set('permalinkId', '');
            this.model.set('error', '');
            this._permalinkManager.save()
                .then(function(permalinkId, winnieId) {
                    this.model.set({
                        permalinkId: permalinkId,
                        winnieId: winnieId
                    });
                    def.resolve();
                }.bind(this), function() {
                    this.model.set('error', 'shareDialog.permalinkError');
                    def.reject();
                }.bind(this))
                .fail(function(err) {
                    console.error(err);
                });
        }.bind(this)).promise();
    },
    appendTo: function() {
        nsGmx.GmxWidget.prototype.appendTo.apply(this, arguments);
        this.model.on('change', this.render, this);
        this.render();
    },
    _setModelPropertyFn: function(property) {
        return function(e) {
            this.model.set(property, $(e.currentTarget).val());
        }
    },
    _renderLoader: function() {
        this.undelegateEvents();
        this.$el.html(nsGmx.Translations.getText('shareDialog.creatingPermalink'));
        return this;
    },
    _renderError: function() {
        this.undelegateEvents();
        this.$el.html(nsGmx.Translations.getText(this.model.get('error')));
        return this;
    },
    _renderDialog: function() {
        this.undelegateEvents();
        this.$el.html(_.template(nsGmx.Templates.ShareIconControl.shareDialog)(this.model.attributes));
        this.errorsView = new nsGmx.AlertWidget();
        this.errorsView.appendTo(this.$('.shareDialog-validationErrorView'));
        this._updateFields();
        this.delegateEvents();
        this.$el.contextmenu(function (e) {
            e.stopPropagation();
            return true;
        });
        return this;
    },
    _updateFields: function() {
        var urls = this._generateUrls();
        this.errorsView.clear();
        if (this.model.isValid()) {
            this.$el.find('.shareDialog-validationOk').show();
            this.$el.find('.shareDialog-validationError').hide();
        } else {
            this.errorsView.push(nsGmx.Translations.getText(this.model.validationError), 'error');
            this.$el.find('.shareDialog-validationOk').hide();
            this.$el.find('.shareDialog-validationError').show();
        }
        this.$el.find('.shareDialog-inputPermalinkUrl').val(urls.permalinkUrl);
        this.$el.find('.shareDialog-permalinkUrlPreviewButton').attr('href', urls.permalinkUrl);
        this.$el.find('.shareDialog-previewLink').attr('href', urls.previewUrl);
        this.$el.find('.shareDialog-winnieLink').attr('href', urls.winnieUrl);
        this.$el.find('.shareDialog-inputEmbedCode').html(urls.embedCode);

        this.$el.find('.shareDialog-socialShareLink_vk').attr('href', urls.vkShareUrl);
        this.$el.find('.shareDialog-socialShareLink_twitter').attr('href', urls.twitterShareUrl);
        this.$el.find('.shareDialog-socialShareLink_facebook').attr('href', urls.facebookShareUrl);
    },
    _generateUrls: function() {
        var escapeHtml = function(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        var tpl = Handlebars.compile;
        var urls = {};

        var origin = window.location.protocol + '//' + window.location.host + '/';
        var href = window.location.search ? window.location.href.split(window.location.search)[0] : window.location.href;

        var permalinkUrl = urls.permalinkUrl = tpl(this.options.permalinkUrlTemplate)({
            origin: origin,
            href: href,
            permalinkId: this.model.get('permalinkId')
        });

        var embeddedUrl = urls.embeddedUrl = tpl(this.options.embeddedUrlTemplate)({
            origin: origin,
            href: href,
            winnieId: this.model.get('includePermalink') ? this.model.get('winnieId') : false            
        });

        var previewUrl = urls.previewUrl = tpl(this.options.previewUrlTemplate)({
            origin: origin,
            href: href,
            embeddedUrl: encodeURIComponent(embeddedUrl),
            width: this.model.get('iframeWidth'),
            height: this.model.get('iframeHeight')
        });
        
        var winnieUrl = urls.winnieUrl = tpl(this.options.winnieUrlTemplate)({
            origin: origin,
            href: href,
            winnieId: this.model.get('winnieId')
        });

        var embedCode = urls.embedCode = escapeHtml(tpl(this.options.embedCodeTemplate)({
            embeddedUrl: embeddedUrl,
            href: href,
            width: this.model.get('iframeWidth'),
            height: this.model.get('iframeHeight')
        }));

        var vkShareUrl = urls.vkShareUrl = tpl('http://vkontakte.ru/share.php?url={{urltoshare}}')({
            urltoshare: escape(permalinkUrl)
        });

        var twitterShareUrl = urls.twitterShareUrl = tpl('http://www.twitter.com/share?url={{urltoshare}}')({
            urltoshare: escape(permalinkUrl)
        });

        var facebookShareUrl = urls.facebookShareUrl = tpl('https://www.facebook.com/sharer/sharer.php?u={{urltoshare}}')({
            urltoshare: escape(permalinkUrl)
        });

        return urls;
    }
});
nsGmx.Translations.addText('rus', {
    shareDialog: {
        permalinkBelow: 'Ссылка на карту:',
        embeddedBelow: 'Код для вставки:',
        creatingPermalink: 'формирование ссылки..',
        invalidWidth: 'Некорректная ширина фрейма',
        invalidHeight: 'Некорректная высота фрейма',
        newWin: 'открыть в новом окне',
        includePermalink: 'добавить пермалинк',
        preview: 'предпросмотр',
        winnieLink: 'конструктор приложений'
    }
});

nsGmx.Translations.addText('eng', {
    shareDialog: {
        permalinkBelow: 'Share link:',
        embeddedBelow: 'Embed map:',
        creatingPermalink: 'creating permalink..',
        invalidWidth: 'Invalid frame width',
        invalidHeight: 'Invalid frame height',
        newWin: 'open in new window',
        includePermalink: 'include permalink',
        preview: 'preview',
        winnieLink: 'application constructor'
    }
});
;
+ function() {
    function each(o, cb) {
        for (var p in o) {
            if (o.hasOwnProperty(p)) {
                cb(o[p], p, o);
            }
        }
    }

    function find(ar, cb) {
        if (ar.length) {
            for (var i = 0; i < ar.length; i++) {
                if (cb(ar[i])) {
                    return ar[i];
                }
            }
        } else {
            for (var p in ar) {
                if (ar.hasOwnProperty(p) && cb(ar[p])) {
                    return ar[p];
                }
            }
        }
    }

    function first(o) {
        for (var p in o) {
            if (o.hasOwnProperty(p)) {
                return o[p];
            }
        }
    }

    function length(o) {
        var length = 0;
        for (var p in o) {
            if (o.hasOwnProperty(p)) {
                length++;
            }
        }
        return length;
    }

    function prepend(parent, el) {
        if (parent.children.length) {
            parent.insertBefore(el, parent.children[0]);
        } else {
            parent.appendChild(el);
        }
    }

    L.Control.IconLayers = L.Control.extend({
        includes: L.Mixin.Events,
        _getActiveLayer: function() {
            if (this._activeLayerId) {
                return this._layers[this._activeLayerId];
            } else if (length(this._layers)) {
                return first(this._layers);
            } else {
                return null;
            }
        },
        _getPreviousLayer: function() {
            var activeLayer = this._getActiveLayer();
            if (!activeLayer) {
                return null;
            } else if (this._previousLayerId) {
                return this._layers[this._previousLayerId];
            } else {
                return find(this._layers, function(l) {
                    return l.id !== activeLayer.id;
                }.bind(this)) || null;
            }
        },
        _getInactiveLayers: function() {
            var ar = [];
            var activeLayerId = this._getActiveLayer() ? this._getActiveLayer().id : null;
            var previousLayerId = this._getPreviousLayer() ? this._getPreviousLayer().id : null;
            each(this._layers, function(l) {
                if ((l.id !== activeLayerId) && (l.id !== previousLayerId)) {
                    ar.push(l);
                }
            });
            return ar;
        },
        _arrangeLayers: function() {
            var behaviors = {};

            behaviors['previous'] = function() {
                var layers = this._getInactiveLayers();
                this._getActiveLayer() && layers.unshift(this._getActiveLayer());
                this._getPreviousLayer() && layers.unshift(this._getPreviousLayer());
                return layers;
            };

            return behaviors[this.options.behavior].apply(this, arguments);
        },
        _getLayerCellByLayerId: function(id) {
            var els = this._container.getElementsByClassName('leaflet-iconLayers-layerCell');
            for (var i = 0; i < els.length; i++) {
                if (els[i].getAttribute('data-layerid') == id) {
                    return els[i];
                }
            }
        },
        _createLayerElement: function(layerObj) {
            var el = L.DomUtil.create('div', 'leaflet-iconLayers-layer');
            if (layerObj.title) {
                var titleContainerEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerTitleContainer');
                var titleEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerTitle');
                var checkIconEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerCheckIcon');
                titleEl.innerHTML = layerObj.title;
                titleContainerEl.appendChild(titleEl);
                el.appendChild(titleContainerEl);
                el.appendChild(checkIconEl);
            }
            if (layerObj.icon) {
                el.setAttribute('style', "background-image: url('" + layerObj.icon + "')");
            }
            return el;
        },
        _createLayerElements: function() {
            var currentRow, layerCell;
            var layers = this._arrangeLayers();
            var activeLayerId = this._getActiveLayer() && this._getActiveLayer().id;

            for (var i = 0; i < layers.length; i++) {
                if (i % this.options.maxLayersInRow === 0) {
                    currentRow = L.DomUtil.create('div', 'leaflet-iconLayers-layersRow');
                    if (this.options.position.indexOf('bottom') === -1) {
                        this._container.appendChild(currentRow);
                    } else {
                        prepend(this._container, currentRow);
                    }
                }
                layerCell = L.DomUtil.create('div', 'leaflet-iconLayers-layerCell');
                layerCell.setAttribute('data-layerid', layers[i].id);
                if (i !== 0) {
                    L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_hidden');
                }
                if (layers[i].id === activeLayerId) {
                    L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_active');
                }
                if (this._expandDirection === 'left') {
                    L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_expandLeft');
                } else {
                    L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_expandRight');
                }
                layerCell.appendChild(this._createLayerElement(layers[i]));

                if (this.options.position.indexOf('right') === -1) {
                    currentRow.appendChild(layerCell);
                } else {
                    prepend(currentRow, layerCell);
                }
            }
        },
        _onLayerClick: function(e) {
            e.stopPropagation();
            var layerId = e.currentTarget.getAttribute('data-layerid');
            var layer = this._layers[layerId];
            this.setActiveLayer(layer.layer);
            this.expand();
        },
        _attachEvents: function() {
            each(this._layers, function(l) {
                var e = this._getLayerCellByLayerId(l.id);
                if (e) {
                    e.addEventListener('click', this._onLayerClick.bind(this));
                }
            }.bind(this));
            var layersRowCollection = this._container.getElementsByClassName('leaflet-iconLayers-layersRow');
            for (var i = 0; i < layersRowCollection.length; i++) {
                var el = layersRowCollection[i];
                el.addEventListener('mouseenter', function(e) {
                    e.stopPropagation();
                    this.expand();
                }.bind(this));
                el.addEventListener('mouseleave', function(e) {
                    e.stopPropagation();
                    this.collapse();
                }.bind(this));
                el.addEventListener('mousemove', function(e) {
                    e.stopPropagation();
                });
            }
        },
        _render: function() {
            this._container.innerHTML = '';
            this._createLayerElements();
            this._attachEvents();
        },
        _switchMapLayers: function() {
            if (!this._map) {
                return;
            }
            var activeLayer = this._getActiveLayer();
            var previousLayer = this._getPreviousLayer();
            if (previousLayer) {
                this._map.removeLayer(previousLayer.layer);
            } else {
                each(this._layers, function(layerObject) {
                    var layer = layerObject.layer;
                    this._map.removeLayer(layer);
                }.bind(this));
            }
            if (activeLayer) {
                this._map.addLayer(activeLayer.layer);
            }
        },
        options: {
            position: 'bottomleft', // one of expanding directions depends on this
            behavior: 'previous', // may be 'previous', 'expanded' or 'first'
            expand: 'horizontal', // or 'vertical'
            autoZIndex: true, // from L.Control.Layers
            maxLayersInRow: 5,
            manageLayers: true
        },
        initialize: function(layers, options) {
            if (!L.Util.isArray(arguments[0])) {
                // first argument is options
                options = layers;
                layers = [];
            }
            L.setOptions(this, options);
            this._expandDirection = (this.options.position.indexOf('left') != -1) ? 'right' : 'left';
            if (this.options.manageLayers) {
                this.on('activelayerchange', this._switchMapLayers, this);
            }
            this.setLayers(layers);
        },
        onAdd: function(map) {
            this._container = L.DomUtil.create('div', 'leaflet-iconLayers');
            L.DomUtil.addClass(this._container, 'leaflet-iconLayers_' + this.options.position);
            this._render();
            map.on('click', this.collapse, this);
            if (this.options.manageLayers) {
                this._switchMapLayers();
            }
            return this._container;
        },
        onRemove: function(map) {
            map.off('click', this.collapse, this);
        },
        setLayers: function(layers) {
            this._layers = {};
            layers.map(function(layer) {
                var id = L.stamp(layer.layer)
                this._layers[id] = L.extend(layer, {
                    id: id
                });
            }.bind(this));
            this._container && this._render();
        },
        setActiveLayer: function(layer) {
            var l = layer && this._layers[L.stamp(layer)];
            if (!l || l.id === this._activeLayerId) {
                return;
            }
            this._previousLayerId = this._activeLayerId;
            this._activeLayerId = l.id;
            this._container && this._render();
            this.fire('activelayerchange', {
                layer: layer
            });
        },
        expand: function() {
            this._arrangeLayers().slice(1).map(function(l) {
                var el = this._getLayerCellByLayerId(l.id);
                L.DomUtil.removeClass(el, 'leaflet-iconLayers-layerCell_hidden');
            }.bind(this));
        },
        collapse: function() {
            this._arrangeLayers().slice(1).map(function(l) {
                var el = this._getLayerCellByLayerId(l.id);
                L.DomUtil.addClass(el, 'leaflet-iconLayers-layerCell_hidden');
            }.bind(this));
        }
    });
}();

L.control.iconLayers = function(layers, options) {
    return new L.Control.IconLayers(layers, options);
};
window.nsGmx.Translations.addText('rus', {
    gmxIconLayers: {
        zoominpls: 'Приблизьте карту, чтобы активировать слой',
        zoomoutpls: 'Отдалите карту, чтобы активировать слой'
    }
});

window.nsGmx.Translations.addText('eng', {
    gmxIconLayers: {
        zoominpls: 'Zoom in to enable layer',
        zoomoutpls: 'Zoom out to enable layer'
    }
});

window.L.Control.GmxIconLayers = window.L.Control.IconLayers.extend({
    _updateLayers: function() {
        var lang = nsGmx && nsGmx.Translations && nsGmx.Translations.getLanguage() || 'rus';
        var blm = this._baseLayersManager;
        var layers = blm.getActiveIDs().map(function(id) {
            var layer = blm.get(id);
            if (!layer) {
                return null;
            } else {
                return {
                    layer: layer,
                    icon: layer.options.icon,
                    title: layer.options[lang]
                }
            }
        }).filter(function(e) {
            return e;
        });

        this.setLayers(layers);
        this.setActiveLayer(
            blm.get(
                blm.getCurrentID()
            )
        );

        this._updateDisabledLayers();
    },
    _updateDisabledLayers: function() {
        this._disabledLayerIds = this._map ? this._baseLayersManager.getActiveIDs().map(function(id) {
            return this._baseLayersManager.get(id);
        }.bind(this)).filter(function(l) {
            return !!l && (this._map.getZoom() < l.options.minZoom || this._map.getZoom() > l.options.maxZoom);
        }.bind(this)).map(function(l) {
            return L.stamp(l) + '';
        }) : [];
        this._updateDisabledLayersStyle();
    },
    _updateDisabledLayersStyle: function() {
        var els = this._container ? this._container.getElementsByClassName('leaflet-iconLayers-layerCell') : [];

        Array.prototype.slice.call(els).map(function(el) {
            var elId = el.getAttribute('data-layerid');
            if (this._disabledLayerIds.indexOf(elId) + 1) {
                L.DomUtil.addClass(el, 'leaflet-iconLayers-layerCell_disabled');
            } else {
                L.DomUtil.removeClass(el, 'leaflet-iconLayers-layerCell_disabled');
            }
        }.bind(this));
    },
    _updatePopoversContent: function() {
        var els = this._container ? this._container.getElementsByClassName('leaflet-iconLayers-layerCell') : [];

        var defaultTemplate = (new $.fn.popover.Constructor()).getDefaults().template;

        function createPopover(el, text) {
            $(el).popover({
                viewport: {
                    selector: this._map && this._map.getContainer(),
                    padding: 10
                },
                container: this._map && this._map.getContainer(),
                content: text,
                trigger: 'manual',
                placement: this.options.position.indexOf('bottom') != -1 ? 'top' : 'bottom',
                html: true,
                template: $(defaultTemplate).css('pointer-events', 'none')[0].outerHTML
            });
            if (el.mouseIsOver) {
                $(el).popover('show');
            }
        }

        Array.prototype.slice.call(els).map(function(el) {
            var elId = el.getAttribute('data-layerid');
            var layerEl = el.getElementsByClassName('leaflet-iconLayers-layer')[0];
            var layer = this._layers[elId].layer;
            if (layer.options.maxZoom && this._map && this._map.getZoom() > layer.options.maxZoom) {
                $(layerEl).popover('destroy');
                createPopover.call(this, layerEl, nsGmx.Translations.getText('gmxIconLayers.zoomoutpls'));
            } else if (layer.options.minZoom && this._map && this._map.getZoom() < layer.options.minZoom) {
                $(layerEl).popover('destroy');
                createPopover.call(this, layerEl, nsGmx.Translations.getText('gmxIconLayers.zoominpls'));
            } else if (layer.options.description) {
                $(layerEl).popover('destroy');
                createPopover.call(this, layerEl, layer.options.description);
            } else {
                $(layerEl).popover('destroy');
            }
        }.bind(this));
    },
    _createLayerElement: function(layerObj) {
        var layer = layerObj.layer;
        var el = L.Control.IconLayers.prototype._createLayerElement.call(this, layerObj);
        var shutterEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerShutter');
        $(el).prepend(shutterEl);
        el.addEventListener('mouseover', function(e) {
            e.currentTarget.mouseIsOver = true;
            $(e.currentTarget).popover('show');
        });
        el.addEventListener('mouseout', function(e) {
            e.currentTarget.mouseIsOver = false;
            $(e.currentTarget).popover('hide');
        });
        return el;
    },
    _render: function() {
        L.Control.IconLayers.prototype._render.apply(this, arguments);
        this._updateDisabledLayers();
        this._updatePopoversContent();
    },
    _onLayerClick: function(e) {
        e.stopPropagation();
        $(e.currentTarget).find('.leaflet-iconLayers-layer').popover('hide')
        var layerId = e.currentTarget.getAttribute('data-layerid');
        if (this._disabledLayerIds.indexOf(layerId) === -1) {
            var layer = this._layers[layerId];
            this.setActiveLayer(layer.layer);
        }
        this.expand();
    },
    initialize: function(gmxBaseLayersManager, options) {
        L.Control.IconLayers.prototype.initialize.call(this, [], L.extend(options || {}, {
            manageLayers: false
        }));

        this._baseLayersManager = gmxBaseLayersManager;
        this._updateLayers();

        this.on('activelayerchange', function(le) {
            this._baseLayersManager.setCurrentID(le.layer.id);
        }.bind(this));

        this._baseLayersManager.on('baselayeradd', this._updateLayers.bind(this));
        this._baseLayersManager.on('baselayerremove', this._updateLayers.bind(this));
        this._baseLayersManager.on('baselayeractiveids', this._updateLayers.bind(this));
        this._baseLayersManager.on('baselayerchange', this._updateLayers.bind(this));
        this._baseLayersManager.on('baselayerlayerschange', this._updateLayers.bind(this));
    },
    onAdd: function() {
        var container = L.Control.IconLayers.prototype.onAdd.apply(this, arguments);
        this._map.on('zoomend', function() {
            this._updateDisabledLayers();
            this._updatePopoversContent();
        }.bind(this));
        return container;
    }
});

/*
	Leaflet.contextmenu, a context menu for Leaflet.
	(c) 2015, Adam Ratcliffe, GeoSmart Maps Limited
       
        @preserve
*/

(function(factory) {
	// Packaging/modules magic dance
	var L;
	if (typeof define === 'function' && define.amd) {
		// AMD
		define(['leaflet'], factory);
	} else if (typeof module !== 'undefined') {
		// Node/CommonJS
		L = require('leaflet');
		module.exports = factory(L);
	} else {
		// Browser globals
		if (typeof window.L === 'undefined') {
			throw new Error('Leaflet must be loaded first');
		}
		factory(window.L);
	}
})(function(L) {
L.Map.mergeOptions({
	contextmenuItems: []
});

L.Map.ContextMenu = L.Handler.extend({

	_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',

	statics: {
		BASE_CLS: 'leaflet-contextmenu'
	},

	initialize: function (map) {
		L.Handler.prototype.initialize.call(this, map);

		this._items = [];
		this._visible = false;

		var container = this._container = L.DomUtil.create('div', L.Map.ContextMenu.BASE_CLS, map._container);
		container.style.zIndex = 10000;
		container.style.position = 'absolute';

		if (map.options.contextmenuWidth) {
			container.style.width = map.options.contextmenuWidth + 'px';
		}
		
		this._createItems();

		L.DomEvent
			.on(container, 'click', L.DomEvent.stop)
			.on(container, 'mousedown', L.DomEvent.stop)
			.on(container, 'dblclick', L.DomEvent.stop)
			.on(container, 'contextmenu', L.DomEvent.stop);
	},

	addHooks: function () {
		L.DomEvent
		    .on(document, (L.Browser.touch ? this._touchstart : 'mousedown'), this._onMouseDown, this)
			.on(document, 'keydown', this._onKeyDown, this);

		this._map.on({
			contextmenu: this._show,
			mousedown: this._hide,
			movestart: this._hide,
			zoomstart: this._hide
		}, this);

        L.DomEvent.on(this._map.getContainer(), 'mouseleave', this._hide, this);
	},

	removeHooks: function () {
		L.DomEvent
			.off(document, (L.Browser.touch ? this._touchstart : 'mousedown'), this._onMouseDown, this)
			.off(document, 'keydown', this._onKeyDown, this);

		this._map.off({
			contextmenu: this._show,
			mousedown: this._hide,
			movestart: this._hide,
			zoomstart: this._hide
		}, this);

        L.DomEvent.off(this._map.getContainer(), 'mouseleave', this._hide, this);
	},

	showAt: function (point, data, relatedEvent) {
		if (point instanceof L.LatLng) {
			point = this._map.latLngToContainerPoint(point);
		}
		this._showAtPoint(point, data, relatedEvent);
	},

	hide: function () {
		this._hide();
	},

	addItem: function (options) {
		return this.insertItem(options);
	},

	insertItem: function (options, index) {
		index = index !== undefined ? index: this._items.length; 

		var item = this._createItem(this._container, options, index);
		
		this._items.push(item);

		this._sizeChanged = true;

		this._map.fire('contextmenu.additem', {
			contextmenu: this,
			el: item.el,
			index: index
		});

		return item.el;
	},

	removeItem: function (item) {
		var container = this._container;

		if (!isNaN(item)) {
			item = container.children[item];
		}

		if (item) {
			this._removeItem(L.Util.stamp(item));

			this._sizeChanged = true;

			this._map.fire('contextmenu.removeitem', {
				contextmenu: this,
				el: item
			});
		}		
	},

	removeAllItems: function () {
		var item;

		while (this._container.children.length) {
			item = this._container.children[0];
			this._removeItem(L.Util.stamp(item));
		}
	},

	hideAllItems: function () {
		var item, i, l;

		for (i = 0, l = this._items.length; i < l; i++) {
			item = this._items[i];
			item.el.style.display = 'none';
		}
	},

	showAllItems: function () {
		var item, i, l;

		for (i = 0, l = this._items.length; i < l; i++) {
			item = this._items[i];
			item.el.style.display = '';
		}		
	},

	setDisabled: function (item, disabled) {
		var container = this._container,
		itemCls = L.Map.ContextMenu.BASE_CLS + '-item';

		if (!isNaN(item)) {
			item = container.children[item];
		}

		if (item && L.DomUtil.hasClass(item, itemCls)) {
			if (disabled) {
				L.DomUtil.addClass(item, itemCls + '-disabled');
				this._map.fire('contextmenu.disableitem', {
					contextmenu: this,
					el: item
				});
			} else {
				L.DomUtil.removeClass(item, itemCls + '-disabled');
				this._map.fire('contextmenu.enableitem', {
					contextmenu: this,
					el: item
				});
			}			
		}
	},

	isVisible: function () {
		return this._visible;
	},

	_createItems: function () {
		var itemOptions = this._map.options.contextmenuItems,
		    item,
		    i, l;

		for (i = 0, l = itemOptions.length; i < l; i++) {
			this._items.push(this._createItem(this._container, itemOptions[i]));
		}
	},

	_createItem: function (container, options, index) {
		if (options.separator || options === '-') {
			return this._createSeparator(container, index);
		}

		var itemCls = L.Map.ContextMenu.BASE_CLS + '-item', 
		    cls = options.disabled ? (itemCls + ' ' + itemCls + '-disabled') : itemCls,
		    el = this._insertElementAt('a', cls, container, index),
		    callback = this._createEventHandler(el, options.callback, options.context, options.hideOnSelect),
		    html = '';
		
		if (options.icon) {
			html = '<img class="' + L.Map.ContextMenu.BASE_CLS + '-icon" src="' + options.icon + '"/>';
		} else if (options.iconCls) {
			html = '<span class="' + L.Map.ContextMenu.BASE_CLS + '-icon ' + options.iconCls + '"></span>';
		}

		el.innerHTML = html + options.text;		
		el.href = '#';

		L.DomEvent
			.on(el, 'mouseover', this._onItemMouseOver, this)
			.on(el, 'mouseout', this._onItemMouseOut, this)
			.on(el, 'mousedown', L.DomEvent.stopPropagation)
			.on(el, 'click', callback);

		return {
			id: L.Util.stamp(el),
			el: el,
			callback: callback
		};
	},

	_removeItem: function (id) {
		var item,
		    el,
		    i, l, callback;

		for (i = 0, l = this._items.length; i < l; i++) {
			item = this._items[i];

			if (item.id === id) {
				el = item.el;
				callback = item.callback;

				if (callback) {
					L.DomEvent
						.off(el, 'mouseover', this._onItemMouseOver, this)
						.off(el, 'mouseover', this._onItemMouseOut, this)
						.off(el, 'mousedown', L.DomEvent.stopPropagation)
						.off(el, 'click', callback);
				}
				
				this._container.removeChild(el);
				this._items.splice(i, 1);

				return item;
			}
		}
		return null;
	},

	_createSeparator: function (container, index) {
		var el = this._insertElementAt('div', L.Map.ContextMenu.BASE_CLS + '-separator', container, index);
		
		return {
			id: L.Util.stamp(el),
			el: el
		};
	},

	_createEventHandler: function (el, func, context, hideOnSelect) {
		var me = this,
		    map = this._map,
		    disabledCls = L.Map.ContextMenu.BASE_CLS + '-item-disabled',
		    hideOnSelect = (hideOnSelect !== undefined) ? hideOnSelect : true;
		
		return function (e) {
			if (L.DomUtil.hasClass(el, disabledCls)) {
				return;
			}
			
			if (hideOnSelect) {
				me._hide();			
			}

			if (func) {
				func.call(context || map, me._showLocation);			
			}

			me._map.fire('contextmenu:select', {
				contextmenu: me,
				el: el
			});
		};
	},

	_insertElementAt: function (tagName, className, container, index) {
		var refEl,
		    el = document.createElement(tagName);

		el.className = className;

		if (index !== undefined) {
			refEl = container.children[index];
		}

		if (refEl) {
			container.insertBefore(el, refEl);
		} else {
			container.appendChild(el);
		}

		return el;
	},

	_show: function (e) {
		this._showAtPoint(e.containerPoint, null, e);
	},

	_showAtPoint: function (pt, data, relatedEvent) {
		if (this._items.length) {
			var map = this._map,
			layerPoint = map.containerPointToLayerPoint(pt),
			latlng = map.layerPointToLatLng(layerPoint),
			event = {contextmenu: this};
			
			if (data) {
				event = L.extend(data, event);
			}
			
			this._showLocation = {
				latlng: latlng,
				layerPoint: layerPoint,
				containerPoint: pt
			};

            if (relatedEvent) {
                this._showLocation.relatedEvent = relatedEvent;
            }

			if(data && data.relatedTarget){
				this._showLocation.relatedTarget = data.relatedTarget;
			}

			this._setPosition(pt);			

			if (!this._visible) {
				this._container.style.display = 'block';							
				this._visible = true;							
			} else {
				this._setPosition(pt);			
			}

			this._map.fire('contextmenu.show', event);
		}
	},

	_hide: function () {        
		if (this._visible) {
			this._visible = false;
			this._container.style.display = 'none';
			this._map.fire('contextmenu.hide', {contextmenu: this});
		}
	},

	_setPosition: function (pt) {
		var mapSize = this._map.getSize(),
		    container = this._container,
		    containerSize = this._getElementSize(container),
		    anchor;

		if (this._map.options.contextmenuAnchor) {
			anchor = L.point(this._map.options.contextmenuAnchor);
			pt = pt.add(anchor);
		}

		container._leaflet_pos = pt;

		if (pt.x + containerSize.x > mapSize.x) {
			container.style.left = 'auto';
			container.style.right = Math.max(mapSize.x - pt.x, 0) + 'px';
		} else {
			container.style.left = Math.max(pt.x, 0) + 'px';
			container.style.right = 'auto';
		}
		
		if (pt.y + containerSize.y > mapSize.y) {
			container.style.top = 'auto';
			container.style.bottom = Math.max(mapSize.y - pt.y, 0) + 'px';
		} else {
			container.style.top = Math.max(pt.y, 0) + 'px';
			container.style.bottom = 'auto';
		}
	},

	_getElementSize: function (el) {		
		var size = this._size,
		    initialDisplay = el.style.display;

		if (!size || this._sizeChanged) {
			size = {};

			el.style.left = '-999999px';
			el.style.right = 'auto';
			el.style.display = 'block';
			
			size.x = el.offsetWidth;
			size.y = el.offsetHeight;
			
			el.style.left = 'auto';
			el.style.display = initialDisplay;
			
			this._sizeChanged = false;
		}

		return size;
	},

	_onMouseDown: function (e) {
		this._hide();
	},

	_onKeyDown: function (e) {
		var key = e.keyCode;

		// If ESC pressed and context menu is visible hide it 
		if (key === 27) {
			this._hide();
		}
	},

	_onItemMouseOver: function (e) {
		L.DomUtil.addClass(e.target || e.srcElement, 'over');
	},

	_onItemMouseOut: function (e) {
		L.DomUtil.removeClass(e.target || e.srcElement, 'over');
	}
});

L.Map.addInitHook('addHandler', 'contextmenu', L.Map.ContextMenu);
L.Mixin.ContextMenu = {

	bindContextMenu: function (options) {
		L.setOptions(this, options);
		this._initContextMenu();

		return this;
	},

	unbindContextMenu: function (){
		this.off('contextmenu', this._showContextMenu, this);

		return this;
	},

	_initContextMenu: function () {
		this._items = [];
	
		this.on('contextmenu', this._showContextMenu, this);
	},

	_showContextMenu: function (e) {
		var itemOptions,
		    pt, i, l;

		if (this._map.contextmenu) {
			pt = this._map.mouseEventToContainerPoint(e.originalEvent);

			if (!this.options.contextmenuInheritItems) {
				this._map.contextmenu.hideAllItems();
			}

			for (i = 0, l = this.options.contextmenuItems.length; i < l; i++) {
				itemOptions = this.options.contextmenuItems[i];
				this._items.push(this._map.contextmenu.insertItem(itemOptions, itemOptions.index));
			}

			this._map.once('contextmenu.hide', this._hideContextMenu, this);
		
			this._map.contextmenu.showAt(pt, {relatedTarget: this}, e);
		}
	},

	_hideContextMenu: function () {
		var i, l;

		for (i = 0, l = this._items.length; i < l; i++) {
			this._map.contextmenu.removeItem(this._items[i]);
		}
		this._items.length = 0;		

		if (!this.options.contextmenuInheritItems) {
			this._map.contextmenu.showAllItems();
		}
	}	
};

var classes = [L.Marker, L.Path],
    defaultOptions = {
		contextmenu: false,
		contextmenuItems: [],
	    contextmenuInheritItems: true
	},
    cls, i, l;

for (i = 0, l = classes.length; i < l; i++) {
	cls = classes[i];

	// L.Class should probably provide an empty options hash, as it does not test
	// for it here and add if needed
	if (!cls.prototype.options) {
		cls.prototype.options = defaultOptions;
	} else {
		cls.mergeOptions(defaultOptions);
	}

	cls.addInitHook(function () {
		if (this.options.contextmenu) {
			this._initContextMenu();
		}
	});

	cls.include(L.Mixin.ContextMenu);
}
	return L.Map.ContextMenu;
	});

/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.SearchControl = undefined;
	
	__webpack_require__(1);
	
	var _ResultView = __webpack_require__(6);
	
	var _GmxRenderer = __webpack_require__(7);
	
	var _OsmDataProvider = __webpack_require__(8);
	
	var _CoordinatesDataProvider = __webpack_require__(9);
	
	var _CadastreDataProvider = __webpack_require__(10);
	
	var SearchControl = L.Control.extend({
	    includes: [L.Mixin.Events],
	    initialize: function initialize(options) {
	        L.setOptions(this, options);
	        this._allowSuggestion = true;
	        this.options.suggestionTimeout = this.options.suggestionTimeout || 1000;
	    },
	    _chain: function _chain(tasks, state) {
	        return tasks.reduce(function (prev, next) {
	            return prev.then(next);
	        }, new Promise(function (resolve, reject) {
	            return resolve(state);
	        }));
	    },
	
	    _suggest: function _suggest(text) {
	        var _this = this;
	
	        var tasks = this.options.providers.filter(function (provider) {
	            return provider.showSuggestion;
	        }).map(function (provider) {
	            return function (state) {
	                return new Promise(function (resolve) {
	                    if (state.completed) {
	                        resolve(state);
	                    } else {
	                        provider.find(text, _this.options.limit, false, false).then(function (response) {
	                            state.completed = response.length > 0;
	                            state.response = state.response.concat(response);
	                            resolve(state);
	                        });
	                    }
	                });
	            };
	        });
	        this._chain(tasks, { completed: false, response: [] }).then(function (state) {
	            _this.results.show(state.response, text.trim());
	        });
	    },
	    _handleChange: function _handleChange(e) {
	        var _this2 = this;
	
	        if (this._input.value.length) {
	            if (this._allowSuggestion) {
	                this._allowSuggestion = false;
	                this._timer = setTimeout(function () {
	                    clearTimeout(_this2._timer);
	                    _this2._allowSuggestion = true;
	                    var text = _this2._input.value;
	                    _this2._suggest(text);
	                }, this.options.suggestionTimeout);
	            }
	        } else {
	            this.results.hide();
	        }
	    },
	    _handleMouseMove: function _handleMouseMove(e) {
	        e.stopPropagation();
	    },
	    _search: function _search(text) {
	        var tasks = this.options.providers.filter(function (provider) {
	            return provider.showOnEnter;
	        }).map(function (provider) {
	            return function (state) {
	                return new Promise(function (resolve) {
	                    if (state.completed) {
	                        resolve(state);
	                    } else {
	                        var p = provider.find(text, 1, true, true);
	                        p.then(function (response) {
	                            state.completed = response.length > 0;
	                            state.response = state.response.concat(response);
	                            resolve(state);
	                        });
	                    }
	                });
	            };
	        });
	
	        this._chain(tasks, { completed: false, response: [] }).then(function (state) {
	            if (state.response.length) {
	                var item = state.response[0];
	                item.provider.fetch(item.properties).then(function (response) {});
	            }
	        });
	    },
	    _selectItem: function _selectItem(item) {
	        var _this3 = this;
	
	        item.provider.fetch(item.properties).then(function (response) {
	            if (item.provider.showOnSelect && response.length) {
	                var features = response.filter(function (x) {
	                    return x.provider.showOnMap;
	                }).map(function (x) {
	                    return x.feature;
	                });
	                _this3._renderer.render(features, _this3.options.style);
	            }
	        });
	    },
	    onAdd: function onAdd(map) {
	        this._container = L.DomUtil.create('div', 'leaflet-ext-search');
	        this._container.innerHTML = '<input type="text" value="" placeholder="' + this.options.placeHolder + '" /><span class="leaflet-ext-search-button"></span>';
	        this._input = this._container.querySelector('input');
	        this._input.addEventListener('input', this._handleChange.bind(this));
	        this._input.addEventListener('mousemove', this._handleMouseMove.bind(this));
	        this._input.addEventListener('dragstart', this._handleMouseMove.bind(this));
	        this._input.addEventListener('drag', this._handleMouseMove.bind(this));
	
	        this._button = this._container.querySelector('.leaflet-ext-search-button');
	        this._button.addEventListener('click', this._handleSearch.bind(this));
	
	        this.results = new _ResultView.ResultView({
	            input: this._input,
	            onSelect: this._selectItem.bind(this),
	            onEnter: this._search.bind(this)
	        });
	
	        this._renderer = this.options.renderer || new _GmxRenderer.GmxRenderer(map);
	
	        map.on('click', this.results.hide.bind(this.results));
	        map.on('dragstart', this.results.hide.bind(this.results));
	        return this._container;
	    },
	
	    _handleSearch: function _handleSearch(e) {
	        e.stopPropagation();
	        this._search(this._input.value);
	    },
	
	    addTo: function addTo(map) {
	        L.Control.prototype.addTo.call(this, map);
	        if (this.options.addBefore) {
	            this.addBefore(this.options.addBefore);
	        }
	        return this;
	    },
	
	    addBefore: function addBefore(id) {
	        var parentNode = this._parent && this._parent._container;
	        if (!parentNode) {
	            parentNode = this._map && this._map._controlCorners[this.getPosition()];
	        }
	        if (!parentNode) {
	            this.options.addBefore = id;
	        } else {
	            for (var i = 0, len = parentNode.childNodes.length; i < len; i++) {
	                var it = parentNode.childNodes[i];
	                if (id === it._id) {
	                    parentNode.insertBefore(this._container, it);
	                    break;
	                }
	            }
	        }
	
	        return this;
	    },
	
	    setText: function setText(text) {
	        this._input.value = text;
	    }
	
	});
	
	window.nsGmx = window.nsGmx || {};
	window.nsGmx.SearchControl = SearchControl;
	
	exports.SearchControl = SearchControl;

/***/ },
/* 1 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var ResultView = function () {
	    function ResultView(_ref) {
	        var input = _ref.input,
	            onSelect = _ref.onSelect,
	            onEnter = _ref.onEnter;
	
	        _classCallCheck(this, ResultView);
	
	        this._input = input;
	        this._onSelect = onSelect;
	        this._onEnter = onEnter;
	        this.index = -1;
	        this.count = 0;
	        this._item = null;
	        this._inputText = '';
	        this._list = L.DomUtil.create('div');
	        this._list.setAttribute('class', 'leaflet-ext-search-list noselect');
	
	        this._list.style.top = this._input.offsetTop + this._input.offsetHeight + 2 + 'px';
	        this._list.style.left = this._input.offsetLeft + 'px';
	        this._input.addEventListener('keydown', this._handleKey.bind(this));
	        this._input.addEventListener('click', this._handleInputClick.bind(this));
	        this._input.addEventListener('focus', this._handleFocus.bind(this));
	        this._list.addEventListener('keydown', this._handleKey.bind(this));
	        this._list.addEventListener('wheel', this._handleWheel.bind(this));
	        L.DomEvent.disableClickPropagation(this._list).disableScrollPropagation(this._list);
	        // this._list.addEventListener('mousewheel', this._handleWheel.bind(this));
	        // this._list.addEventListener('MozMousePixelScroll', this._handleWheel.bind(this));       
	        this._input.parentElement.appendChild(this._list);
	        this._input.addEventListener('input', this._handleChange.bind(this));
	    }
	
	    _createClass(ResultView, [{
	        key: '_handleInputClick',
	        value: function _handleInputClick(e) {
	            e.stopPropagation();
	        }
	    }, {
	        key: '_handleFocus',
	        value: function _handleFocus(e) {
	            if (this.index >= 0) {
	                var el = this._list.querySelector('[tabindex="' + this.index + '"]');
	                L.DomUtil.removeClass(el, 'leaflet-ext-search-list-selected');
	            }
	            this.index = -1;
	            this._item = null;
	        }
	    }, {
	        key: '_handleChange',
	        value: function _handleChange(e) {
	            this._inputText = this._input.value;
	        }
	    }, {
	        key: '_handleWheel',
	        value: function _handleWheel(e) {
	            e.stopPropagation();
	        }
	    }, {
	        key: '_handleKey',
	        value: function _handleKey(e) {
	            if (this.listVisible()) {
	                switch (e.keyCode) {
	                    // ArroLeft / ArrowRight
	                    case 37:
	                    case 39:
	                        e.stopPropagation();
	                        break;
	                    // ArrowDown
	                    case 40:
	                        e.preventDefault();
	                        e.stopPropagation();
	                        if (this.index < 0) {
	                            this.index = 0;
	                        } else if (0 <= this.index && this.index < this.count - 1) {
	                            var _el = this._list.querySelector('[tabindex="' + this.index + '"]');
	                            L.DomUtil.removeClass(_el, 'leaflet-ext-search-list-selected');
	                            ++this.index;
	                        } else {
	                            var _el2 = this._list.querySelector('[tabindex="' + this.index + '"]');
	                            L.DomUtil.removeClass(_el2, 'leaflet-ext-search-list-selected');
	                            this.index = this.count - 1;
	                        }
	                        var el = this._list.querySelector('[tabindex="' + this.index + '"]');
	                        L.DomUtil.addClass(el, 'leaflet-ext-search-list-selected');
	                        this.selectItem(this.index);
	                        el.focus();
	                        break;
	                    // ArrowUp
	                    case 38:
	                        e.preventDefault();
	                        e.stopPropagation();
	                        if (this.index > 0) {
	                            var _el3 = this._list.querySelector('[tabindex="' + this.index + '"]');
	                            L.DomUtil.removeClass(_el3, 'leaflet-ext-search-list-selected');
	                            --this.index;
	                            _el3 = this._list.querySelector('[tabindex="' + this.index + '"]');
	                            L.DomUtil.addClass(_el3, 'leaflet-ext-search-list-selected');
	                            this.selectItem(this.index);
	                            _el3.focus();
	                        } else if (this.index === 0) {
	                            this._input.focus();
	                            this._input.value = this._inputText;
	                        }
	                        break;
	                    // Enter
	                    case 13:
	                        if (this.index < 0 && this._input.value && typeof this._onEnter === 'function') {
	                            var text = this._input.value;
	                            this._input.focus();
	                            this._input.setSelectionRange(text.length, text.length);
	                            this.hide();
	                            this._onEnter(text);
	                        } else {
	                            this.complete(this.index);
	                        }
	                        break;
	                    // Escape
	                    case 27:
	                        if (this.index < 0) {
	                            this.hide();
	                        }
	                        this._input.focus();
	                        this._input.value = this._inputText;
	                        break;
	                    default:
	                        break;
	                }
	            } else {
	                if (e.keyCode === 13 && this._input.value && typeof this._onEnter == 'function') {
	                    var _text = this._input.value;
	                    this._input.setSelectionRange(_text.length, _text.length);
	                    this._onEnter(_text);
	                } else if (e.keyCode === 27) {
	                    this._input.value = '';
	                    this.index = -1;
	                    this._input.focus();
	                }
	            }
	        }
	    }, {
	        key: 'listVisible',
	        value: function listVisible() {
	            return this.count > 0 && this._list.style.display !== 'none';
	        }
	    }, {
	        key: 'selectItem',
	        value: function selectItem(i) {
	            this._item = this._items[i];
	            var text = this._item.name;
	            this._input.value = text;
	            this._input.setSelectionRange(text.length, text.length);
	        }
	    }, {
	        key: '_handleClick',
	        value: function _handleClick(i, e) {
	            e.preventDefault();
	            this.complete(i);
	        }
	    }, {
	        key: 'complete',
	        value: function complete(i) {
	            var item = i >= 0 ? this._items[i] : this._item ? this._item : null;
	            if (item) {
	                this._item = item;
	                this.index = -1;
	                var text = item.name;
	                this._input.value = text;
	                this._input.setSelectionRange(text.length, text.length);
	                this._input.focus();
	                this.hide();
	                if (typeof this._onSelect === 'function') {
	                    this._onSelect(item);
	                }
	            }
	        }
	    }, {
	        key: 'show',
	        value: function show(items, highlight) {
	            if (items.length) {
	                this._item = null;
	                this.index = -1;
	                this._items = items;
	                var html = '<ul>' + this._items.filter(function (x) {
	                    return x.name && x.name.length;
	                }).map(function (x, i) {
	                    var name = '<span class="leaflet-ext-search-list-item-normal">' + x.name + '</span>';
	                    if (highlight && highlight.length) {
	                        var start = x.name.toLowerCase().indexOf(highlight.toLowerCase());
	                        if (start != -1) {
	                            var head = x.name.substr(0, start);
	                            if (head.length) {
	                                head = '<span class="leaflet-ext-search-list-item-normal">' + head + '</span>';
	                            }
	                            var tail = x.name.substr(start + highlight.length);
	                            if (tail.length) {
	                                tail = '<span class="leaflet-ext-search-list-item-normal">' + tail + '</span>';
	                            }
	                            name = head + '<span class="leaflet-ext-search-list-item-highlight">' + highlight + '</span>' + tail;
	                        }
	                    }
	                    return '<li tabindex=' + i + '>' + name + '</li>';
	                }, []).join('') + '</ul>';
	
	                this._list.innerHTML = html;
	                var elements = this._list.querySelectorAll('li');
	                for (var i = 0; i < elements.length; ++i) {
	                    elements[i].addEventListener('click', this._handleClick.bind(this, i));
	                }
	
	                this.count = elements.length;
	                this._list.style.display = 'block';
	            }
	        }
	    }, {
	        key: 'hide',
	        value: function hide() {
	            this._list.style.display = 'none';
	        }
	    }]);
	
	    return ResultView;
	}();
	
	exports.ResultView = ResultView;

/***/ },
/* 7 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var GmxRenderer = function () {
	    function GmxRenderer(map) {
	        _classCallCheck(this, GmxRenderer);
	
	        this._map = map;
	        this._gmxDrawing = this._map.gmxDrawing;
	    }
	
	    _createClass(GmxRenderer, [{
	        key: "render",
	        value: function render(features, _style) {
	            var _this = this;
	
	            if (features && features.length) {
	                var json = features.reduce(function (a, geojson) {
	                    L.geoJson(geojson, {
	                        style: function style(feature) {
	                            return _style.lineStyle;
	                        },
	                        onEachFeature: function (feature, layer) {
	                            this._gmxDrawing.add(layer, _style);
	                        }.bind(_this)
	                    });
	                    a.addData(geojson.geometry);
	                    return a;
	                }, L.geoJson());
	                var bounds = json.getBounds();
	                this._map.fitBounds(bounds);
	                this._map.invalidateSize();
	            }
	        }
	    }]);
	
	    return GmxRenderer;
	}();
	
	exports.GmxRenderer = GmxRenderer;

/***/ },
/* 8 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var OsmDataProvider = function () {
	    function OsmDataProvider(_ref) {
	        var serverBase = _ref.serverBase,
	            limit = _ref.limit,
	            onFetch = _ref.onFetch,
	            showOnMap = _ref.showOnMap;
	
	        _classCallCheck(this, OsmDataProvider);
	
	        this._serverBase = serverBase;
	        this._onFetch = onFetch;
	        this.showSuggestion = true;
	        this.showOnMap = showOnMap;
	        this.showOnSelect = true;
	        this.showOnEnter = true;
	        this.find = this.find.bind(this);
	        this.fetch = this.fetch.bind(this);
	        this._convertGeometry = this._convertGeometry.bind(this);
	
	        this._key = window.KOSMOSNIMKI_SESSION_KEY == null || window.KOSMOSNIMKI_SESSION_KEY == 'INVALID' ? '' : '&key=' + window.KOSMOSNIMKI_SESSION_KEY;
	    }
	
	    _createClass(OsmDataProvider, [{
	        key: '_convertGeometry',
	        value: function _convertGeometry(geometry) {
	            switch (geometry.type.toUpperCase()) {
	                case 'POINT':
	                    geometry.type = 'Point';
	                    break;
	                case 'POLYGON':
	                    geometry.type = 'Polygon';
	                    break;
	                case 'MULTIPOLYGON':
	                    geometry.type = 'MultiPolygon';
	                    break;
	                case 'LINESTRING':
	                case 'POLYLINE':
	                    geometry.type = 'LineString';
	                    break;
	                case 'MULTILINESTRING':
	                    geometry.type = 'MultiLineString';
	                    break;
	                default:
	                    throw 'Unknown WKT type';
	            }
	            return geometry;
	        }
	    }, {
	        key: 'fetch',
	        value: function (_fetch) {
	            function fetch(_x) {
	                return _fetch.apply(this, arguments);
	            }
	
	            fetch.toString = function () {
	                return _fetch.toString();
	            };
	
	            return fetch;
	        }(function (obj) {
	            var _this = this;
	
	            var query = 'RequestType=ID&ID=' + obj.ObjCode + '&TypeCode=' + obj.TypeCode + '&UseOSM=1';
	            var req = new Request(this._serverBase + '/SearchObject/SearchAddress.ashx?' + query + this._key);
	            var headers = new Headers();
	            headers.append('Content-Type', 'application/json');
	            var init = {
	                method: 'GET',
	                mode: 'cors',
	                credentials: 'include',
	                cache: 'default'
	            };
	            return new Promise(function (resolve, reject) {
	                fetch(req, init).then(function (response) {
	                    return response.text();
	                }).then(function (response) {
	                    var json = JSON.parse(response.slice(1, response.length - 1));
	                    if (json.Status === 'ok') {
	                        var rs = json.Result.reduce(function (a, x) {
	                            return a.concat(x.SearchResult);
	                        }, []).map(function (x) {
	                            var g = _this._convertGeometry(x.Geometry);
	                            var props = Object.keys(x).filter(function (k) {
	                                return k !== 'Geometry';
	                            }).reduce(function (a, k) {
	                                a[k] = x[k];
	                                return a;
	                            }, {});
	                            return {
	                                feature: {
	                                    type: 'Feature',
	                                    geometry: g,
	                                    properties: props
	                                },
	                                provider: _this,
	                                query: obj
	                            };
	                        });
	                        if (typeof _this._onFetch === 'function') {
	                            _this._onFetch(rs);
	                        }
	                        resolve(rs);
	                    } else {
	                        reject(json);
	                    }
	                });
	            });
	        })
	    }, {
	        key: 'find',
	        value: function find(value, limit, strong, retrieveGeometry) {
	            var _this2 = this;
	
	            var _strong = Boolean(strong) ? 1 : 0;
	            var _withoutGeometry = Boolean(retrieveGeometry) ? 0 : 1;
	            var query = 'RequestType=SearchObject&IsStrongSearch=' + _strong + '&WithoutGeometry=' + _withoutGeometry + '&UseOSM=1&Limit=' + limit + '&SearchString=' + encodeURIComponent(value);
	            var req = new Request(this._serverBase + '/SearchObject/SearchAddress.ashx?' + query + this._key);
	            var headers = new Headers();
	            headers.append('Content-Type', 'application/json');
	            var init = {
	                method: 'GET',
	                mode: 'cors',
	                credentials: 'include',
	                cache: 'default'
	            };
	            return new Promise(function (resolve, reject) {
	                fetch(req, init).then(function (response) {
	                    return response.text();
	                }).then(function (response) {
	                    var json = JSON.parse(response.slice(1, response.length - 1));
	                    if (json.Status === 'ok') {
	                        var rs = json.Result.reduce(function (a, x) {
	                            return a.concat(x.SearchResult);
	                        }, []).map(function (x) {
	                            if (retrieveGeometry) {
	                                var g = _this2._convertGeometry(x.Geometry);
	                                var props = Object.keys(x).filter(function (k) {
	                                    return k !== 'Geometry';
	                                }).reduce(function (a, k) {
	                                    a[k] = x[k];
	                                    return a;
	                                }, {});
	                                return {
	                                    name: x.ObjNameShort,
	                                    feature: {
	                                        type: 'Feature',
	                                        geometry: g,
	                                        properties: props
	                                    },
	                                    properties: props,
	                                    provider: _this2,
	                                    query: value
	                                };
	                            } else {
	                                return {
	                                    name: x.ObjNameShort,
	                                    properties: x,
	                                    provider: _this2,
	                                    query: value
	                                };
	                            }
	                        });
	                        if (limit === 1 && strong && retrieveGeometry && typeof _this2._onFetch === 'function') {
	                            _this2._onFetch(rs);
	                        }
	                        resolve(rs);
	                    } else {
	                        reject(json);
	                    }
	                });
	            });
	        }
	    }]);
	
	    return OsmDataProvider;
	}();
	
	window.nsGmx = window.nsGmx || {};
	window.nsGmx.OsmDataProvider = OsmDataProvider;
	
	exports.OsmDataProvider = OsmDataProvider;

/***/ },
/* 9 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var CoordinatesDataProvider = function () {
	    function CoordinatesDataProvider(_ref) {
	        var onFetch = _ref.onFetch,
	            showOnMap = _ref.showOnMap;
	
	        _classCallCheck(this, CoordinatesDataProvider);
	
	        this._onFetch = onFetch;
	        this.showSuggestion = true;
	        this.showOnMap = showOnMap;
	        this.showOnSelect = false;
	        this.showOnEnter = true;
	        this.fetch = this.fetch.bind(this);
	        this.find = this.find.bind(this);
	
	        this.rxF = new RegExp('^\\s*\\-?(\\d+(\\.\\d+)?)(\\s+(N|S))?(,\\s*|\\s+)\\-?(\\d+(\\.\\d+)?)(\\s+(E|W))?');
	        this.rxD = new RegExp('^\\s*\\-?(\\d{1,2})(\\s|\\u00b0)(\\d{1,2})(\\s|\\u0027)(\\d{1,2}(\\.\\d+)?)(\\s|\\u0022)(N|S)?(,\\s*|\\s+)\\-?(\\d{1,2})(\\s|\\u00b0)(\\d{1,2})(\\s|\\u0027)(\\d{1,2}(\\.\\d+)?)(\\s|\\u0022)(E|W)?');
	    }
	
	    _createClass(CoordinatesDataProvider, [{
	        key: '_parseCoordinates',
	        value: function _parseCoordinates(value) {
	            var m = this.rxD.exec(value);
	            if (Array.isArray(m) && m.length === 18) {
	                return this._parseDegrees([m[1], m[3], m[5], m[10], m[12], m[14]].map(function (x) {
	                    return parseFloat(x);
	                }));
	            }
	            m = this.rxF.exec(value);
	            if (Array.isArray(m) && m.length === 10) {
	                return { type: 'Point', coordinates: [parseFloat(m[6]), parseFloat(m[1])] };
	            }
	
	            return null;
	        }
	    }, {
	        key: '_parseDegrees',
	        value: function _parseDegrees(_ref2) {
	            var _ref3 = _slicedToArray(_ref2, 6),
	                latDeg = _ref3[0],
	                latMin = _ref3[1],
	                latSec = _ref3[2],
	                lngDeg = _ref3[3],
	                lngMin = _ref3[4],
	                lngSec = _ref3[5];
	
	            return { type: 'Point', coordinates: [lngDeg + lngMin / 60 + lngSec / 3600, latDeg + latMin / 60 + latSec / 3600] };
	        }
	    }, {
	        key: 'fetch',
	        value: function fetch(value) {
	            return new Promise(function (resolve) {
	                return resolve([]);
	            });
	        }
	    }, {
	        key: 'find',
	        value: function find(value, limit, strong, retrieveGeometry) {
	            var _this = this;
	
	            var g = this._parseCoordinates(value);
	            return new Promise(function (resolve) {
	                var result = { feature: { type: 'Feature', geometry: g, properties: {} }, provider: _this, query: value };
	                if (g && typeof _this._onFetch === 'function') {
	                    _this._onFetch(result);
	                }
	                resolve(g ? [result] : []);
	            });
	        }
	    }]);
	
	    return CoordinatesDataProvider;
	}();
	
	window.nsGmx = window.nsGmx || {};
	window.nsGmx.CoordinatesDataProvider = CoordinatesDataProvider;
	
	exports.CoordinatesDataProvider = CoordinatesDataProvider;

/***/ },
/* 10 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var CadastreDataProvider = function () {
	    function CadastreDataProvider(_ref) {
	        var serverBase = _ref.serverBase,
	            limit = _ref.limit,
	            tolerance = _ref.tolerance,
	            onFetch = _ref.onFetch,
	            showOnMap = _ref.showOnMap;
	
	        _classCallCheck(this, CadastreDataProvider);
	
	        this._serverBase = serverBase;
	        this._tolerance = tolerance;
	        this._onFetch = onFetch;
	        this.showSuggestion = true;
	        this.showOnMap = showOnMap;
	        this.showOnSelect = false;
	        this.showOnEnter = true;
	        this._cadastreLayers = [{ id: 1, title: 'Участок', reg: /^\d\d:\d+:\d+:\d+$/ }, { id: 2, title: 'Квартал', reg: /^\d\d:\d+:\d+$/ }, { id: 3, title: 'Район', reg: /^\d\d:\d+$/ }, { id: 4, title: 'Округ', reg: /^\d\d$/ }, { id: 5, title: 'ОКС', reg: /^\d\d:\d+:\d+:\d+:\d+$/ }, { id: 10, title: 'ЗОУИТ', reg: /^\d+\.\d+\.\d+/ }
	        // ,
	        // {id: 7, title: 'Границы', 	reg: /^\w+$/},
	        // {id: 6, title: 'Тер.зоны', 	reg: /^\w+$/},
	        // {id: 12, title: 'Лес', 		reg: /^\w+$/},
	        // {id: 13, title: 'Красные линии', 		reg: /^\w+$/},
	        // {id: 15, title: 'СРЗУ', 	reg: /^\w+$/},
	        // {id: 16, title: 'ОЭЗ', 		reg: /^\w+$/},
	        // {id: 9, title: 'ГОК', 		reg: /^\w+$/},
	        // {id: 10, title: 'ЗОУИТ', 	reg: /^\w+$/}
	        // /[^\d\:]/g,
	        // /\d\d:\d+$/,
	        // /\d\d:\d+:\d+$/,
	        // /\d\d:\d+:\d+:\d+$/
	        ];
	    }
	
	    _createClass(CadastreDataProvider, [{
	        key: 'getCadastreLayer',
	        value: function getCadastreLayer(str, type) {
	            str = str.trim();
	            for (var i = 0, len = this._cadastreLayers.length; i < len; i++) {
	                var it = this._cadastreLayers[i];
	                if (it.id === type) {
	                    return it;
	                }
	                if (it.reg.exec(str)) {
	                    return it;
	                }
	            }
	            return this._cadastreLayers[0];
	        }
	    }, {
	        key: 'find',
	        value: function find(value, limit, strong, retrieveGeometry) {
	            var _this = this;
	
	            var cadastreLayer = this.getCadastreLayer(value);
	            return new Promise(function (resolve) {
	                var req = new Request(_this._serverBase + '/typeahead?limit=' + limit + '&skip=0&text=' + value + '&type=' + cadastreLayer.id);
	                var headers = new Headers();
	                headers.append('Content-Type', 'application/json');
	                var init = {
	                    method: 'GET',
	                    mode: 'cors',
	                    cache: 'default'
	                };
	                fetch(req, init).then(function (response) {
	                    return response.text();
	                }).then(function (response) {
	                    var json = JSON.parse(response);
	                    // if(json.status === 200){
	                    var rs = json.results.map(function (x) {
	                        return {
	                            name: x.title,
	                            properties: x,
	                            provider: _this,
	                            query: value
	                        };
	                    });
	                    resolve(rs);
	                    // }
	                    // else {
	                    // resolve(json);
	                    // }                                       
	                });
	            });
	        }
	    }, {
	        key: 'fetch',
	        value: function (_fetch) {
	            function fetch(_x) {
	                return _fetch.apply(this, arguments);
	            }
	
	            fetch.toString = function () {
	                return _fetch.toString();
	            };
	
	            return fetch;
	        }(function (obj) {
	            var _this2 = this;
	
	            var cadastreLayer = this.getCadastreLayer(obj.value);
	            return new Promise(function (resolve) {
	                if (cadastreLayer) {
	                    var req = new Request(_this2._serverBase + '/features/' + cadastreLayer.id + '?tolerance=' + _this2._tolerance + '&limit=1&text=' + obj.value);
	                    var headers = new Headers();
	                    headers.append('Content-Type', 'application/json');
	                    var init = {
	                        method: 'GET',
	                        mode: 'cors',
	                        cache: 'default'
	                    };
	                    fetch(req, init).then(function (response) {
	                        return response.text();
	                    }).then(function (response) {
	                        var json = JSON.parse(response);
	                        if (json.status === 200) {
	                            if (typeof _this2._onFetch === 'function') {
	                                _this2._onFetch(json);
	                            }
	                            var rs = json.features.map(function (x) {
	                                return {
	                                    name: x.attrs.name || x.attrs.cn || x.attrs.id,
	                                    properties: x,
	                                    provider: _this2,
	                                    query: obj
	                                };
	                            });
	                            resolve(rs);
	                        } else {
	                            resolve(json);
	                        }
	                    });
	                } else {
	                    resolve([]);
	                }
	            });
	        })
	    }]);
	
	    return CadastreDataProvider;
	}();
	
	window.nsGmx = window.nsGmx || {};
	window.nsGmx.CadastreDataProvider = CadastreDataProvider;
	
	exports.CadastreDataProvider = CadastreDataProvider;

/***/ }
/******/ ]);
//# sourceMappingURL=bundle.js.map
/*
 Leaflet.markercluster, Provides Beautiful Animated Marker Clustering functionality for Leaflet, a JS library for interactive maps.
 https://github.com/Leaflet/Leaflet.markercluster
 (c) 2012-2013, Dave Leaver, smartrak
*/
(function (window, document, undefined) {/*
 * L.MarkerClusterGroup extends L.FeatureGroup by clustering the markers contained within
 */

L.MarkerClusterGroup = L.FeatureGroup.extend({

	options: {
		maxClusterRadius: 80, //A cluster will cover at most this many pixels from its center
		iconCreateFunction: null,

		spiderfyOnMaxZoom: true,
		showCoverageOnHover: true,
		zoomToBoundsOnClick: true,
		singleMarkerMode: false,

		disableClusteringAtZoom: null,

		// Setting this to false prevents the removal of any clusters outside of the viewpoint, which
		// is the default behaviour for performance reasons.
		removeOutsideVisibleBounds: true,

		// Set to false to disable all animations (zoom and spiderfy).
		// If false, option animateAddingMarkers below has no effect.
		// If L.DomUtil.TRANSITION is falsy, this option has no effect.
		animate: true,

		//Whether to animate adding markers after adding the MarkerClusterGroup to the map
		// If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.
		animateAddingMarkers: false,

		//Increase to increase the distance away that spiderfied markers appear from the center
		spiderfyDistanceMultiplier: 1,

		// Make it possible to specify a polyline options on a spider leg
		spiderLegPolylineOptions: { weight: 1.5, color: '#222', opacity: 0.5 },

		// When bulk adding layers, adds markers in chunks. Means addLayers may not add all the layers in the call, others will be loaded during setTimeouts
		chunkedLoading: false,
		chunkInterval: 200, // process markers for a maximum of ~ n milliseconds (then trigger the chunkProgress callback)
		chunkDelay: 50, // at the end of each interval, give n milliseconds back to system/browser
		chunkProgress: null, // progress callback: function(processed, total, elapsed) (e.g. for a progress indicator)

		//Options to pass to the L.Polygon constructor
		polygonOptions: {}
	},

	initialize: function (options) {
		L.Util.setOptions(this, options);
		if (!this.options.iconCreateFunction) {
			this.options.iconCreateFunction = this._defaultIconCreateFunction;
		}

		this._featureGroup = L.featureGroup();
		this._featureGroup.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);

		this._nonPointGroup = L.featureGroup();
		this._nonPointGroup.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);

		this._inZoomAnimation = 0;
		this._needsClustering = [];
		this._needsRemoving = []; //Markers removed while we aren't on the map need to be kept track of
		//The bounds of the currently shown area (from _getExpandedVisibleBounds) Updated on zoom/move
		this._currentShownBounds = null;

		this._queue = [];

		// Hook the appropriate animation methods.
		var animate = L.DomUtil.TRANSITION && this.options.animate;
		L.extend(this, animate ? this._withAnimation : this._noAnimation);
		// Remember which MarkerCluster class to instantiate (animated or not).
		this._markerCluster = animate ? L.MarkerCluster : L.MarkerClusterNonAnimated;
	},

	addLayer: function (layer) {

		if (layer instanceof L.LayerGroup) {
			var array = [];
			for (var i in layer._layers) {
				array.push(layer._layers[i]);
			}
			return this.addLayers(array);
		}

		//Don't cluster non point data
		if (!layer.getLatLng) {
			this._nonPointGroup.addLayer(layer);
			return this;
		}

		if (!this._map) {
			this._needsClustering.push(layer);
			return this;
		}

		if (this.hasLayer(layer)) {
			return this;
		}


		//If we have already clustered we'll need to add this one to a cluster

		if (this._unspiderfy) {
			this._unspiderfy();
		}

		this._addLayer(layer, this._maxZoom);

		// Refresh bounds and weighted positions.
		this._topClusterLevel._recalculateBounds();

		//Work out what is visible
		var visibleLayer = layer,
			currentZoom = this._map.getZoom();
		if (layer.__parent) {
			while (visibleLayer.__parent._zoom >= currentZoom) {
				visibleLayer = visibleLayer.__parent;
			}
		}

		if (this._currentShownBounds.contains(visibleLayer.getLatLng())) {
			if (this.options.animateAddingMarkers) {
				this._animationAddLayer(layer, visibleLayer);
			} else {
				this._animationAddLayerNonAnimated(layer, visibleLayer);
			}
		}
		return this;
	},

	removeLayer: function (layer) {

		if (layer instanceof L.LayerGroup)
		{
			var array = [];
			for (var i in layer._layers) {
				array.push(layer._layers[i]);
			}
			return this.removeLayers(array);
		}

		//Non point layers
		if (!layer.getLatLng) {
			this._nonPointGroup.removeLayer(layer);
			return this;
		}

		if (!this._map) {
			if (!this._arraySplice(this._needsClustering, layer) && this.hasLayer(layer)) {
				this._needsRemoving.push(layer);
			}
			return this;
		}

		if (!layer.__parent) {
			return this;
		}

		if (this._unspiderfy) {
			this._unspiderfy();
			this._unspiderfyLayer(layer);
		}

		//Remove the marker from clusters
		this._removeLayer(layer, true);

		// Refresh bounds and weighted positions.
		this._topClusterLevel._recalculateBounds();

		if (this._featureGroup.hasLayer(layer)) {
			this._featureGroup.removeLayer(layer);
			if (layer.clusterShow) {
				layer.clusterShow();
			}
		}

		return this;
	},

	//Takes an array of markers and adds them in bulk
	addLayers: function (layersArray) {
		var fg = this._featureGroup,
			npg = this._nonPointGroup,
			chunked = this.options.chunkedLoading,
			chunkInterval = this.options.chunkInterval,
			chunkProgress = this.options.chunkProgress,
			newMarkers, i, l, m;

		if (this._map) {
			var offset = 0,
				started = (new Date()).getTime();
			var process = L.bind(function () {
				var start = (new Date()).getTime();
				for (; offset < layersArray.length; offset++) {
					if (chunked && offset % 200 === 0) {
						// every couple hundred markers, instrument the time elapsed since processing started:
						var elapsed = (new Date()).getTime() - start;
						if (elapsed > chunkInterval) {
							break; // been working too hard, time to take a break :-)
						}
					}

					m = layersArray[offset];

					//Not point data, can't be clustered
					if (!m.getLatLng) {
						npg.addLayer(m);
						continue;
					}

					if (this.hasLayer(m)) {
						continue;
					}

					this._addLayer(m, this._maxZoom);

					//If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will
					if (m.__parent) {
						if (m.__parent.getChildCount() === 2) {
							var markers = m.__parent.getAllChildMarkers(),
								otherMarker = markers[0] === m ? markers[1] : markers[0];
							fg.removeLayer(otherMarker);
						}
					}
				}

				if (chunkProgress) {
					// report progress and time elapsed:
					chunkProgress(offset, layersArray.length, (new Date()).getTime() - started);
				}

				// Completed processing all markers.
				if (offset === layersArray.length) {

					// Refresh bounds and weighted positions.
					this._topClusterLevel._recalculateBounds();

					//Update the icons of all those visible clusters that were affected
					this._featureGroup.eachLayer(function (c) {
						if (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {
							c._updateIcon();
						}
					});

					this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);
				} else {
					setTimeout(process, this.options.chunkDelay);
				}
			}, this);

			process();
		} else {
			newMarkers = [];
			for (i = 0, l = layersArray.length; i < l; i++) {
				m = layersArray[i];

				//Not point data, can't be clustered
				if (!m.getLatLng) {
					npg.addLayer(m);
					continue;
				}

				if (this.hasLayer(m)) {
					continue;
				}

				newMarkers.push(m);
			}
			this._needsClustering = this._needsClustering.concat(newMarkers);
		}
		return this;
	},

	//Takes an array of markers and removes them in bulk
	removeLayers: function (layersArray) {
		var i, l, m,
			fg = this._featureGroup,
			npg = this._nonPointGroup;

		if (!this._map) {
			for (i = 0, l = layersArray.length; i < l; i++) {
				m = layersArray[i];
				this._arraySplice(this._needsClustering, m);
				npg.removeLayer(m);
				if (this.hasLayer(m)) {
					this._needsRemoving.push(m);
				}
			}
			return this;
		}

		if (this._unspiderfy) {
			this._unspiderfy();
			for (i = 0, l = layersArray.length; i < l; i++) {
				m = layersArray[i];
				this._unspiderfyLayer(m);
			}
		}

		for (i = 0, l = layersArray.length; i < l; i++) {
			m = layersArray[i];

			if (!m.__parent) {
				npg.removeLayer(m);
				continue;
			}

			this._removeLayer(m, true, true);

			if (fg.hasLayer(m)) {
				fg.removeLayer(m);
				if (m.clusterShow) {
					m.clusterShow();
				}
			}
		}

		// Refresh bounds and weighted positions.
		this._topClusterLevel._recalculateBounds();

		//Fix up the clusters and markers on the map
		this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);

		fg.eachLayer(function (c) {
			if (c instanceof L.MarkerCluster) {
				c._updateIcon();
			}
		});

		return this;
	},

	//Removes all layers from the MarkerClusterGroup
	clearLayers: function () {
		//Need our own special implementation as the LayerGroup one doesn't work for us

		//If we aren't on the map (yet), blow away the markers we know of
		if (!this._map) {
			this._needsClustering = [];
			delete this._gridClusters;
			delete this._gridUnclustered;
		}

		if (this._noanimationUnspiderfy) {
			this._noanimationUnspiderfy();
		}

		//Remove all the visible layers
		this._featureGroup.clearLayers();
		this._nonPointGroup.clearLayers();

		this.eachLayer(function (marker) {
			delete marker.__parent;
		});

		if (this._map) {
			//Reset _topClusterLevel and the DistanceGrids
			this._generateInitialClusters();
		}

		return this;
	},

	//Override FeatureGroup.getBounds as it doesn't work
	getBounds: function () {
		var bounds = new L.LatLngBounds();

		if (this._topClusterLevel) {
			bounds.extend(this._topClusterLevel._bounds);
		}

		for (var i = this._needsClustering.length - 1; i >= 0; i--) {
			bounds.extend(this._needsClustering[i].getLatLng());
		}

		bounds.extend(this._nonPointGroup.getBounds());

		return bounds;
	},

	//Overrides LayerGroup.eachLayer
	eachLayer: function (method, context) {
		var markers = this._needsClustering.slice(),
			i;

		if (this._topClusterLevel) {
			this._topClusterLevel.getAllChildMarkers(markers);
		}

		for (i = markers.length - 1; i >= 0; i--) {
			method.call(context, markers[i]);
		}

		this._nonPointGroup.eachLayer(method, context);
	},

	//Overrides LayerGroup.getLayers
	getLayers: function () {
		var layers = [];
		this.eachLayer(function (l) {
			layers.push(l);
		});
		return layers;
	},

	//Overrides LayerGroup.getLayer, WARNING: Really bad performance
	getLayer: function (id) {
		var result = null;
		
		id = parseInt(id, 10);

		this.eachLayer(function (l) {
			if (L.stamp(l) === id) {
				result = l;
			}
		});

		return result;
	},

	//Returns true if the given layer is in this MarkerClusterGroup
	hasLayer: function (layer) {
		if (!layer) {
			return false;
		}

		var i, anArray = this._needsClustering;

		for (i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i] === layer) {
				return true;
			}
		}

		anArray = this._needsRemoving;
		for (i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i] === layer) {
				return false;
			}
		}

		return !!(layer.__parent && layer.__parent._group === this) || this._nonPointGroup.hasLayer(layer);
	},

	//Zoom down to show the given layer (spiderfying if necessary) then calls the callback
	zoomToShowLayer: function (layer, callback) {
		
		if (typeof callback !== 'function') {
			callback = function () {};
		}

		var showMarker = function () {
			if ((layer._icon || layer.__parent._icon) && !this._inZoomAnimation) {
				this._map.off('moveend', showMarker, this);
				this.off('animationend', showMarker, this);

				if (layer._icon) {
					callback();
				} else if (layer.__parent._icon) {
					this.once('spiderfied', callback, this);
					layer.__parent.spiderfy();
				}
			}
		};

		if (layer._icon && this._map.getBounds().contains(layer.getLatLng())) {
			//Layer is visible ond on screen, immediate return
			callback();
		} else if (layer.__parent._zoom < this._map.getZoom()) {
			//Layer should be visible at this zoom level. It must not be on screen so just pan over to it
			this._map.on('moveend', showMarker, this);
			this._map.panTo(layer.getLatLng());
		} else {
			var moveStart = function () {
				this._map.off('movestart', moveStart, this);
				moveStart = null;
			};

			this._map.on('movestart', moveStart, this);
			this._map.on('moveend', showMarker, this);
			this.on('animationend', showMarker, this);
			layer.__parent.zoomToBounds();

			if (moveStart) {
				//Never started moving, must already be there, probably need clustering however
				showMarker.call(this);
			}
		}
	},

	//Overrides FeatureGroup.onAdd
	onAdd: function (map) {
		this._map = map;
		var i, l, layer;

		if (!isFinite(this._map.getMaxZoom())) {
			throw "Map has no maxZoom specified";
		}

		this._featureGroup.onAdd(map);
		this._nonPointGroup.onAdd(map);

		if (!this._gridClusters) {
			this._generateInitialClusters();
		}

		this._maxLat = map.options.crs.projection.MAX_LATITUDE;

		for (i = 0, l = this._needsRemoving.length; i < l; i++) {
			layer = this._needsRemoving[i];
			this._removeLayer(layer, true);
		}
		this._needsRemoving = [];

		//Remember the current zoom level and bounds
		this._zoom = this._map.getZoom();
		this._currentShownBounds = this._getExpandedVisibleBounds();

		this._map.on('zoomend', this._zoomEnd, this);
		this._map.on('moveend', this._moveEnd, this);

		if (this._spiderfierOnAdd) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely
			this._spiderfierOnAdd();
		}

		this._bindEvents();

		//Actually add our markers to the map:
		l = this._needsClustering;
		this._needsClustering = [];
		this.addLayers(l);
	},

	//Overrides FeatureGroup.onRemove
	onRemove: function (map) {
		map.off('zoomend', this._zoomEnd, this);
		map.off('moveend', this._moveEnd, this);

		this._unbindEvents();

		//In case we are in a cluster animation
		this._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');

		if (this._spiderfierOnRemove) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely
			this._spiderfierOnRemove();
		}

		delete this._maxLat;

		//Clean up all the layers we added to the map
		this._hideCoverage();
		this._featureGroup.onRemove(map);
		this._nonPointGroup.onRemove(map);

		this._featureGroup.clearLayers();

		this._map = null;
	},

	getVisibleParent: function (marker) {
		var vMarker = marker;
		while (vMarker && !vMarker._icon) {
			vMarker = vMarker.__parent;
		}
		return vMarker || null;
	},

	//Remove the given object from the given array
	_arraySplice: function (anArray, obj) {
		for (var i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i] === obj) {
				anArray.splice(i, 1);
				return true;
			}
		}
	},

	/**
	 * Removes a marker from all _gridUnclustered zoom levels, starting at the supplied zoom.
	 * @param marker to be removed from _gridUnclustered.
	 * @param z integer bottom start zoom level (included)
	 * @private
	 */
	_removeFromGridUnclustered: function (marker, z) {
		var map = this._map,
		    gridUnclustered = this._gridUnclustered;

		for (; z >= 0; z--) {
			if (!gridUnclustered[z].removeObject(marker, map.project(marker.getLatLng(), z))) {
				break;
			}
		}
	},

	//Internal function for removing a marker from everything.
	//dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)
	_removeLayer: function (marker, removeFromDistanceGrid, dontUpdateMap) {
		var gridClusters = this._gridClusters,
			gridUnclustered = this._gridUnclustered,
			fg = this._featureGroup,
			map = this._map;

		//Remove the marker from distance clusters it might be in
		if (removeFromDistanceGrid) {
			this._removeFromGridUnclustered(marker, this._maxZoom);
		}

		//Work our way up the clusters removing them as we go if required
		var cluster = marker.__parent,
			markers = cluster._markers,
			otherMarker;

		//Remove the marker from the immediate parents marker list
		this._arraySplice(markers, marker);

		while (cluster) {
			cluster._childCount--;
			cluster._boundsNeedUpdate = true;

			if (cluster._zoom < 0) {
				//Top level, do nothing
				break;
			} else if (removeFromDistanceGrid && cluster._childCount <= 1) { //Cluster no longer required
				//We need to push the other marker up to the parent
				otherMarker = cluster._markers[0] === marker ? cluster._markers[1] : cluster._markers[0];

				//Update distance grid
				gridClusters[cluster._zoom].removeObject(cluster, map.project(cluster._cLatLng, cluster._zoom));
				gridUnclustered[cluster._zoom].addObject(otherMarker, map.project(otherMarker.getLatLng(), cluster._zoom));

				//Move otherMarker up to parent
				this._arraySplice(cluster.__parent._childClusters, cluster);
				cluster.__parent._markers.push(otherMarker);
				otherMarker.__parent = cluster.__parent;

				if (cluster._icon) {
					//Cluster is currently on the map, need to put the marker on the map instead
					fg.removeLayer(cluster);
					if (!dontUpdateMap) {
						fg.addLayer(otherMarker);
					}
				}
			} else {
				if (!dontUpdateMap || !cluster._icon) {
					cluster._updateIcon();
				}
			}

			cluster = cluster.__parent;
		}

		delete marker.__parent;
	},

	_isOrIsParent: function (el, oel) {
		while (oel) {
			if (el === oel) {
				return true;
			}
			oel = oel.parentNode;
		}
		return false;
	},

	_propagateEvent: function (e) {
		if (e.layer instanceof L.MarkerCluster) {
			//Prevent multiple clustermouseover/off events if the icon is made up of stacked divs (Doesn't work in ie <= 8, no relatedTarget)
			if (e.originalEvent && this._isOrIsParent(e.layer._icon, e.originalEvent.relatedTarget)) {
				return;
			}
			e.type = 'cluster' + e.type;
		}

		this.fire(e.type, e);
	},

	//Default functionality
	_defaultIconCreateFunction: function (cluster) {
		var childCount = cluster.getChildCount();

		var c = ' marker-cluster-';
		if (childCount < 10) {
			c += 'small';
		} else if (childCount < 100) {
			c += 'medium';
		} else {
			c += 'large';
		}

		return new L.DivIcon({ html: '<div><span>' + childCount + '</span></div>', className: 'marker-cluster' + c, iconSize: new L.Point(40, 40) });
	},

	_bindEvents: function () {
		var map = this._map,
		    spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,
		    showCoverageOnHover = this.options.showCoverageOnHover,
		    zoomToBoundsOnClick = this.options.zoomToBoundsOnClick;

		//Zoom on cluster click or spiderfy if we are at the lowest level
		if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
			this.on('clusterclick', this._zoomOrSpiderfy, this);
		}

		//Show convex hull (boundary) polygon on mouse over
		if (showCoverageOnHover) {
			this.on('clustermouseover', this._showCoverage, this);
			this.on('clustermouseout', this._hideCoverage, this);
			map.on('zoomend', this._hideCoverage, this);
		}
	},

	_zoomOrSpiderfy: function (e) {
		var cluster = e.layer,
		    bottomCluster = cluster;

		while (bottomCluster._childClusters.length === 1) {
			bottomCluster = bottomCluster._childClusters[0];
		}

		if (bottomCluster._zoom === this._maxZoom && bottomCluster._childCount === cluster._childCount) {
			// All child markers are contained in a single cluster from this._maxZoom to this cluster.
			if (this.options.spiderfyOnMaxZoom) {
				cluster.spiderfy();
			}
		} else if (this.options.zoomToBoundsOnClick) {
			cluster.zoomToBounds();
		}

		// Focus the map again for keyboard users.
		if (e.originalEvent && e.originalEvent.keyCode === 13) {
			this._map._container.focus();
		}
	},

	_showCoverage: function (e) {
		var map = this._map;
		if (this._inZoomAnimation) {
			return;
		}
		if (this._shownPolygon) {
			map.removeLayer(this._shownPolygon);
		}
		if (e.layer.getChildCount() > 2 && e.layer !== this._spiderfied) {
			this._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions);
			map.addLayer(this._shownPolygon);
		}
	},

	_hideCoverage: function () {
		if (this._shownPolygon) {
			this._map.removeLayer(this._shownPolygon);
			this._shownPolygon = null;
		}
	},

	_unbindEvents: function () {
		var spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,
			showCoverageOnHover = this.options.showCoverageOnHover,
			zoomToBoundsOnClick = this.options.zoomToBoundsOnClick,
			map = this._map;

		if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
			this.off('clusterclick', this._zoomOrSpiderfy, this);
		}
		if (showCoverageOnHover) {
			this.off('clustermouseover', this._showCoverage, this);
			this.off('clustermouseout', this._hideCoverage, this);
			map.off('zoomend', this._hideCoverage, this);
		}
	},

	_zoomEnd: function () {
		if (!this._map) { //May have been removed from the map by a zoomEnd handler
			return;
		}
		this._mergeSplitClusters();

		this._zoom = this._map._zoom;
		this._currentShownBounds = this._getExpandedVisibleBounds();
	},

	_moveEnd: function () {
		if (this._inZoomAnimation) {
			return;
		}

		var newBounds = this._getExpandedVisibleBounds();

		this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, this._zoom, newBounds);
		this._topClusterLevel._recursivelyAddChildrenToMap(null, this._map._zoom, newBounds);

		this._currentShownBounds = newBounds;
		return;
	},

	_generateInitialClusters: function () {
		var maxZoom = this._map.getMaxZoom(),
			radius = this.options.maxClusterRadius,
			radiusFn = radius;
	
		//If we just set maxClusterRadius to a single number, we need to create
		//a simple function to return that number. Otherwise, we just have to
		//use the function we've passed in.
		if (typeof radius !== "function") {
			radiusFn = function () { return radius; };
		}

		if (this.options.disableClusteringAtZoom) {
			maxZoom = this.options.disableClusteringAtZoom - 1;
		}
		this._maxZoom = maxZoom;
		this._gridClusters = {};
		this._gridUnclustered = {};
	
		//Set up DistanceGrids for each zoom
		for (var zoom = maxZoom; zoom >= 0; zoom--) {
			this._gridClusters[zoom] = new L.DistanceGrid(radiusFn(zoom));
			this._gridUnclustered[zoom] = new L.DistanceGrid(radiusFn(zoom));
		}

		// Instantiate the appropriate L.MarkerCluster class (animated or not).
		this._topClusterLevel = new this._markerCluster(this, -1);
	},

	//Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)
	_addLayer: function (layer, zoom) {
		var gridClusters = this._gridClusters,
		    gridUnclustered = this._gridUnclustered,
		    markerPoint, z;

		if (this.options.singleMarkerMode) {
			this._overrideMarkerIcon(layer);
		}

		//Find the lowest zoom level to slot this one in
		for (; zoom >= 0; zoom--) {
			markerPoint = this._map.project(layer.getLatLng(), zoom); // calculate pixel position

			//Try find a cluster close by
			var closest = gridClusters[zoom].getNearObject(markerPoint);
			if (closest) {
				closest._addChild(layer);
				layer.__parent = closest;
				return;
			}

			//Try find a marker close by to form a new cluster with
			closest = gridUnclustered[zoom].getNearObject(markerPoint);
			if (closest) {
				var parent = closest.__parent;
				if (parent) {
					this._removeLayer(closest, false);
				}

				//Create new cluster with these 2 in it

				var newCluster = new this._markerCluster(this, zoom, closest, layer);
				gridClusters[zoom].addObject(newCluster, this._map.project(newCluster._cLatLng, zoom));
				closest.__parent = newCluster;
				layer.__parent = newCluster;

				//First create any new intermediate parent clusters that don't exist
				var lastParent = newCluster;
				for (z = zoom - 1; z > parent._zoom; z--) {
					lastParent = new this._markerCluster(this, z, lastParent);
					gridClusters[z].addObject(lastParent, this._map.project(closest.getLatLng(), z));
				}
				parent._addChild(lastParent);

				//Remove closest from this zoom level and any above that it is in, replace with newCluster
				this._removeFromGridUnclustered(closest, zoom);

				return;
			}

			//Didn't manage to cluster in at this zoom, record us as a marker here and continue upwards
			gridUnclustered[zoom].addObject(layer, markerPoint);
		}

		//Didn't get in anything, add us to the top
		this._topClusterLevel._addChild(layer);
		layer.__parent = this._topClusterLevel;
		return;
	},

	//Enqueue code to fire after the marker expand/contract has happened
	_enqueue: function (fn) {
		this._queue.push(fn);
		if (!this._queueTimeout) {
			this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300);
		}
	},
	_processQueue: function () {
		for (var i = 0; i < this._queue.length; i++) {
			this._queue[i].call(this);
		}
		this._queue.length = 0;
		clearTimeout(this._queueTimeout);
		this._queueTimeout = null;
	},

	//Merge and split any existing clusters that are too big or small
	_mergeSplitClusters: function () {

		//Incase we are starting to split before the animation finished
		this._processQueue();

		if (this._zoom < this._map._zoom && this._currentShownBounds.intersects(this._getExpandedVisibleBounds())) { //Zoom in, split
			this._animationStart();
			//Remove clusters now off screen
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, this._zoom, this._getExpandedVisibleBounds());

			this._animationZoomIn(this._zoom, this._map._zoom);

		} else if (this._zoom > this._map._zoom) { //Zoom out, merge
			this._animationStart();

			this._animationZoomOut(this._zoom, this._map._zoom);
		} else {
			this._moveEnd();
		}
	},

	//Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)
	_getExpandedVisibleBounds: function () {
		if (!this.options.removeOutsideVisibleBounds) {
			return this._mapBoundsInfinite;
		} else if (L.Browser.mobile) {
			return this._checkBoundsMaxLat(this._map.getBounds());
		}

		return this._checkBoundsMaxLat(this._map.getBounds().pad(1)); // Padding expands the bounds by its own dimensions but scaled with the given factor.
	},

	/**
	 * Expands the latitude to Infinity (or -Infinity) if the input bounds reach the map projection maximum defined latitude
	 * (in the case of Web/Spherical Mercator, it is 85.0511287798 / see https://en.wikipedia.org/wiki/Web_Mercator#Formulas).
	 * Otherwise, the removeOutsideVisibleBounds option will remove markers beyond that limit, whereas the same markers without
	 * this option (or outside MCG) will have their position floored (ceiled) by the projection and rendered at that limit,
	 * making the user think that MCG "eats" them and never displays them again.
	 * @param bounds L.LatLngBounds
	 * @returns {L.LatLngBounds}
	 * @private
	 */
	_checkBoundsMaxLat: function (bounds) {
		var maxLat = this._maxLat;

		if (maxLat !== undefined) {
			if (bounds.getNorth() >= maxLat) {
				bounds._northEast.lat = Infinity;
			}
			if (bounds.getSouth() <= -maxLat) {
				bounds._southWest.lat = -Infinity;
			}
		}

		return bounds;
	},

	//Shared animation code
	_animationAddLayerNonAnimated: function (layer, newCluster) {
		if (newCluster === layer) {
			this._featureGroup.addLayer(layer);
		} else if (newCluster._childCount === 2) {
			newCluster._addToMap();

			var markers = newCluster.getAllChildMarkers();
			this._featureGroup.removeLayer(markers[0]);
			this._featureGroup.removeLayer(markers[1]);
		} else {
			newCluster._updateIcon();
		}
	},

	/**
	 * Implements the singleMarkerMode option.
	 * @param layer Marker to re-style using the Clusters iconCreateFunction.
	 * @returns {L.Icon} The newly created icon.
	 * @private
	 */
	_overrideMarkerIcon: function (layer) {
		var icon = layer.options.icon = this.options.iconCreateFunction({
			getChildCount: function () {
				return 1;
			},
			getAllChildMarkers: function () {
				return [layer];
			}
		});

		return icon;
	}
});

// Constant bounds used in case option "removeOutsideVisibleBounds" is set to false.
L.MarkerClusterGroup.include({
	_mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-Infinity, -Infinity), new L.LatLng(Infinity, Infinity))
});

L.MarkerClusterGroup.include({
	_noAnimation: {
		//Non Animated versions of everything
		_animationStart: function () {
			//Do nothing...
		},
		_animationZoomIn: function (previousZoomLevel, newZoomLevel) {
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel);
			this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());

			//We didn't actually animate, but we use this event to mean "clustering animations have finished"
			this.fire('animationend');
		},
		_animationZoomOut: function (previousZoomLevel, newZoomLevel) {
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel);
			this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());

			//We didn't actually animate, but we use this event to mean "clustering animations have finished"
			this.fire('animationend');
		},
		_animationAddLayer: function (layer, newCluster) {
			this._animationAddLayerNonAnimated(layer, newCluster);
		}
	},
	_withAnimation: {
		//Animated versions here
		_animationStart: function () {
			this._map._mapPane.className += ' leaflet-cluster-anim';
			this._inZoomAnimation++;
		},
		_animationZoomIn: function (previousZoomLevel, newZoomLevel) {
			var bounds = this._getExpandedVisibleBounds(),
			    fg     = this._featureGroup,
			    i;

			//Add all children of current clusters to map and remove those clusters from map
			this._topClusterLevel._recursively(bounds, previousZoomLevel, 0, function (c) {
				var startPos = c._latlng,
				    markers  = c._markers,
				    m;

				if (!bounds.contains(startPos)) {
					startPos = null;
				}

				if (c._isSingleParent() && previousZoomLevel + 1 === newZoomLevel) { //Immediately add the new child and remove us
					fg.removeLayer(c);
					c._recursivelyAddChildrenToMap(null, newZoomLevel, bounds);
				} else {
					//Fade out old cluster
					c.clusterHide();
					c._recursivelyAddChildrenToMap(startPos, newZoomLevel, bounds);
				}

				//Remove all markers that aren't visible any more
				//TODO: Do we actually need to do this on the higher levels too?
				for (i = markers.length - 1; i >= 0; i--) {
					m = markers[i];
					if (!bounds.contains(m._latlng)) {
						fg.removeLayer(m);
					}
				}

			});

			this._forceLayout();

			//Update opacities
			this._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel);
			//TODO Maybe? Update markers in _recursivelyBecomeVisible
			fg.eachLayer(function (n) {
				if (!(n instanceof L.MarkerCluster) && n._icon) {
					n.clusterShow();
				}
			});

			//update the positions of the just added clusters/markers
			this._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, function (c) {
				c._recursivelyRestoreChildPositions(newZoomLevel);
			});

			//Remove the old clusters and close the zoom animation
			this._enqueue(function () {
				//update the positions of the just added clusters/markers
				this._topClusterLevel._recursively(bounds, previousZoomLevel, 0, function (c) {
					fg.removeLayer(c);
					c.clusterShow();
				});

				this._animationEnd();
			});
		},

		_animationZoomOut: function (previousZoomLevel, newZoomLevel) {
			this._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel);

			//Need to add markers for those that weren't on the map before but are now
			this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());
			//Remove markers that were on the map before but won't be now
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel, this._getExpandedVisibleBounds());
		},
		_animationAddLayer: function (layer, newCluster) {
			var me = this,
			    fg = this._featureGroup;

			fg.addLayer(layer);
			if (newCluster !== layer) {
				if (newCluster._childCount > 2) { //Was already a cluster

					newCluster._updateIcon();
					this._forceLayout();
					this._animationStart();

					layer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng()));
					layer.clusterHide();

					this._enqueue(function () {
						fg.removeLayer(layer);
						layer.clusterShow();

						me._animationEnd();
					});

				} else { //Just became a cluster
					this._forceLayout();

					me._animationStart();
					me._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._map.getZoom());
				}
			}
		}
	},

	// Private methods for animated versions.
	_animationZoomOutSingle: function (cluster, previousZoomLevel, newZoomLevel) {
		var bounds = this._getExpandedVisibleBounds();

		//Animate all of the markers in the clusters to move to their cluster center point
		cluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, previousZoomLevel + 1, newZoomLevel);

		var me = this;

		//Update the opacity (If we immediately set it they won't animate)
		this._forceLayout();
		cluster._recursivelyBecomeVisible(bounds, newZoomLevel);

		//TODO: Maybe use the transition timing stuff to make this more reliable
		//When the animations are done, tidy up
		this._enqueue(function () {

			//This cluster stopped being a cluster before the timeout fired
			if (cluster._childCount === 1) {
				var m = cluster._markers[0];
				//If we were in a cluster animation at the time then the opacity and position of our child could be wrong now, so fix it
				m.setLatLng(m.getLatLng());
				if (m.clusterShow) {
					m.clusterShow();
				}
			} else {
				cluster._recursively(bounds, newZoomLevel, 0, function (c) {
					c._recursivelyRemoveChildrenFromMap(bounds, previousZoomLevel + 1);
				});
			}
			me._animationEnd();
		});
	},

	_animationEnd: function () {
		if (this._map) {
			this._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');
		}
		this._inZoomAnimation--;
		this.fire('animationend');
	},

	//Force a browser layout of stuff in the map
	// Should apply the current opacity and location to all elements so we can update them again for an animation
	_forceLayout: function () {
		//In my testing this works, infact offsetWidth of any element seems to work.
		//Could loop all this._layers and do this for each _icon if it stops working

		L.Util.falseFn(document.body.offsetWidth);
	}
});

L.markerClusterGroup = function (options) {
	return new L.MarkerClusterGroup(options);
};


L.MarkerCluster = L.Marker.extend({
	initialize: function (group, zoom, a, b) {

		L.Marker.prototype.initialize.call(this, a ? (a._cLatLng || a.getLatLng()) : new L.LatLng(0, 0), { icon: this });


		this._group = group;
		this._zoom = zoom;

		this._markers = [];
		this._childClusters = [];
		this._childCount = 0;
		this._iconNeedsUpdate = true;
		this._boundsNeedUpdate = true;

		this._bounds = new L.LatLngBounds();

		if (a) {
			this._addChild(a);
		}
		if (b) {
			this._addChild(b);
		}
	},

	//Recursively retrieve all child markers of this cluster
	getAllChildMarkers: function (storageArray) {
		storageArray = storageArray || [];

		for (var i = this._childClusters.length - 1; i >= 0; i--) {
			this._childClusters[i].getAllChildMarkers(storageArray);
		}

		for (var j = this._markers.length - 1; j >= 0; j--) {
			storageArray.push(this._markers[j]);
		}

		return storageArray;
	},

	//Returns the count of how many child markers we have
	getChildCount: function () {
		return this._childCount;
	},

	//Zoom to the minimum of showing all of the child markers, or the extents of this cluster
	zoomToBounds: function () {
		var childClusters = this._childClusters.slice(),
			map = this._group._map,
			boundsZoom = map.getBoundsZoom(this._bounds),
			zoom = this._zoom + 1,
			mapZoom = map.getZoom(),
			i;

		//calculate how far we need to zoom down to see all of the markers
		while (childClusters.length > 0 && boundsZoom > zoom) {
			zoom++;
			var newClusters = [];
			for (i = 0; i < childClusters.length; i++) {
				newClusters = newClusters.concat(childClusters[i]._childClusters);
			}
			childClusters = newClusters;
		}

		if (boundsZoom > zoom) {
			this._group._map.setView(this._latlng, zoom);
		} else if (boundsZoom <= mapZoom) { //If fitBounds wouldn't zoom us down, zoom us down instead
			this._group._map.setView(this._latlng, mapZoom + 1);
		} else {
			this._group._map.fitBounds(this._bounds);
		}
	},

	getBounds: function () {
		var bounds = new L.LatLngBounds();
		bounds.extend(this._bounds);
		return bounds;
	},

	_updateIcon: function () {
		this._iconNeedsUpdate = true;
		if (this._icon) {
			this.setIcon(this);
		}
	},

	//Cludge for Icon, we pretend to be an icon for performance
	createIcon: function () {
		if (this._iconNeedsUpdate) {
			this._iconObj = this._group.options.iconCreateFunction(this);
			this._iconNeedsUpdate = false;
		}
		return this._iconObj.createIcon();
	},
	createShadow: function () {
		return this._iconObj.createShadow();
	},


	_addChild: function (new1, isNotificationFromChild) {

		this._iconNeedsUpdate = true;

		this._boundsNeedUpdate = true;
		this._setClusterCenter(new1);

		if (new1 instanceof L.MarkerCluster) {
			if (!isNotificationFromChild) {
				this._childClusters.push(new1);
				new1.__parent = this;
			}
			this._childCount += new1._childCount;
		} else {
			if (!isNotificationFromChild) {
				this._markers.push(new1);
			}
			this._childCount++;
		}

		if (this.__parent) {
			this.__parent._addChild(new1, true);
		}
	},

	/**
	 * Makes sure the cluster center is set. If not, uses the child center if it is a cluster, or the marker position.
	 * @param child L.MarkerCluster|L.Marker that will be used as cluster center if not defined yet.
	 * @private
	 */
	_setClusterCenter: function (child) {
		if (!this._cLatLng) {
			// when clustering, take position of the first point as the cluster center
			this._cLatLng = child._cLatLng || child._latlng;
		}
	},

	/**
	 * Assigns impossible bounding values so that the next extend entirely determines the new bounds.
	 * This method avoids having to trash the previous L.LatLngBounds object and to create a new one, which is much slower for this class.
	 * As long as the bounds are not extended, most other methods would probably fail, as they would with bounds initialized but not extended.
	 * @private
	 */
	_resetBounds: function () {
		var bounds = this._bounds;

		if (bounds._southWest) {
			bounds._southWest.lat = Infinity;
			bounds._southWest.lng = Infinity;
		}
		if (bounds._northEast) {
			bounds._northEast.lat = -Infinity;
			bounds._northEast.lng = -Infinity;
		}
	},

	_recalculateBounds: function () {
		var markers = this._markers,
		    childClusters = this._childClusters,
		    latSum = 0,
		    lngSum = 0,
		    totalCount = this._childCount,
		    i, child, childLatLng, childCount;

		// Case where all markers are removed from the map and we are left with just an empty _topClusterLevel.
		if (totalCount === 0) {
			return;
		}

		// Reset rather than creating a new object, for performance.
		this._resetBounds();

		// Child markers.
		for (i = 0; i < markers.length; i++) {
			childLatLng = markers[i]._latlng;

			this._bounds.extend(childLatLng);

			latSum += childLatLng.lat;
			lngSum += childLatLng.lng;
		}

		// Child clusters.
		for (i = 0; i < childClusters.length; i++) {
			child = childClusters[i];

			// Re-compute child bounds and weighted position first if necessary.
			if (child._boundsNeedUpdate) {
				child._recalculateBounds();
			}

			this._bounds.extend(child._bounds);

			childLatLng = child._wLatLng;
			childCount = child._childCount;

			latSum += childLatLng.lat * childCount;
			lngSum += childLatLng.lng * childCount;
		}

		this._latlng = this._wLatLng = new L.LatLng(latSum / totalCount, lngSum / totalCount);

		// Reset dirty flag.
		this._boundsNeedUpdate = false;
	},

	//Set our markers position as given and add it to the map
	_addToMap: function (startPos) {
		if (startPos) {
			this._backupLatlng = this._latlng;
			this.setLatLng(startPos);
		}
		this._group._featureGroup.addLayer(this);
	},

	_recursivelyAnimateChildrenIn: function (bounds, center, maxZoom) {
		this._recursively(bounds, 0, maxZoom - 1,
			function (c) {
				var markers = c._markers,
					i, m;
				for (i = markers.length - 1; i >= 0; i--) {
					m = markers[i];

					//Only do it if the icon is still on the map
					if (m._icon) {
						m._setPos(center);
						m.clusterHide();
					}
				}
			},
			function (c) {
				var childClusters = c._childClusters,
					j, cm;
				for (j = childClusters.length - 1; j >= 0; j--) {
					cm = childClusters[j];
					if (cm._icon) {
						cm._setPos(center);
						cm.clusterHide();
					}
				}
			}
		);
	},

	_recursivelyAnimateChildrenInAndAddSelfToMap: function (bounds, previousZoomLevel, newZoomLevel) {
		this._recursively(bounds, newZoomLevel, 0,
			function (c) {
				c._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel);

				//TODO: depthToAnimateIn affects _isSingleParent, if there is a multizoom we may/may not be.
				//As a hack we only do a animation free zoom on a single level zoom, if someone does multiple levels then we always animate
				if (c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel) {
					c.clusterShow();
					c._recursivelyRemoveChildrenFromMap(bounds, previousZoomLevel); //Immediately remove our children as we are replacing them. TODO previousBounds not bounds
				} else {
					c.clusterHide();
				}

				c._addToMap();
			}
		);
	},

	_recursivelyBecomeVisible: function (bounds, zoomLevel) {
		this._recursively(bounds, 0, zoomLevel, null, function (c) {
			c.clusterShow();
		});
	},

	_recursivelyAddChildrenToMap: function (startPos, zoomLevel, bounds) {
		this._recursively(bounds, -1, zoomLevel,
			function (c) {
				if (zoomLevel === c._zoom) {
					return;
				}

				//Add our child markers at startPos (so they can be animated out)
				for (var i = c._markers.length - 1; i >= 0; i--) {
					var nm = c._markers[i];

					if (!bounds.contains(nm._latlng)) {
						continue;
					}

					if (startPos) {
						nm._backupLatlng = nm.getLatLng();

						nm.setLatLng(startPos);
						if (nm.clusterHide) {
							nm.clusterHide();
						}
					}

					c._group._featureGroup.addLayer(nm);
				}
			},
			function (c) {
				c._addToMap(startPos);
			}
		);
	},

	_recursivelyRestoreChildPositions: function (zoomLevel) {
		//Fix positions of child markers
		for (var i = this._markers.length - 1; i >= 0; i--) {
			var nm = this._markers[i];
			if (nm._backupLatlng) {
				nm.setLatLng(nm._backupLatlng);
				delete nm._backupLatlng;
			}
		}

		if (zoomLevel - 1 === this._zoom) {
			//Reposition child clusters
			for (var j = this._childClusters.length - 1; j >= 0; j--) {
				this._childClusters[j]._restorePosition();
			}
		} else {
			for (var k = this._childClusters.length - 1; k >= 0; k--) {
				this._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);
			}
		}
	},

	_restorePosition: function () {
		if (this._backupLatlng) {
			this.setLatLng(this._backupLatlng);
			delete this._backupLatlng;
		}
	},

	//exceptBounds: If set, don't remove any markers/clusters in it
	_recursivelyRemoveChildrenFromMap: function (previousBounds, zoomLevel, exceptBounds) {
		var m, i;
		this._recursively(previousBounds, -1, zoomLevel - 1,
			function (c) {
				//Remove markers at every level
				for (i = c._markers.length - 1; i >= 0; i--) {
					m = c._markers[i];
					if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
						c._group._featureGroup.removeLayer(m);
						if (m.clusterShow) {
							m.clusterShow();
						}
					}
				}
			},
			function (c) {
				//Remove child clusters at just the bottom level
				for (i = c._childClusters.length - 1; i >= 0; i--) {
					m = c._childClusters[i];
					if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
						c._group._featureGroup.removeLayer(m);
						if (m.clusterShow) {
							m.clusterShow();
						}
					}
				}
			}
		);
	},

	//Run the given functions recursively to this and child clusters
	// boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to
	// zoomLevelToStart: zoom level to start running functions (inclusive)
	// zoomLevelToStop: zoom level to stop running functions (inclusive)
	// runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level
	// runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level
	_recursively: function (boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {
		var childClusters = this._childClusters,
		    zoom = this._zoom,
		    i, c;

		if (zoomLevelToStart > zoom) { //Still going down to required depth, just recurse to child clusters
			for (i = childClusters.length - 1; i >= 0; i--) {
				c = childClusters[i];
				if (boundsToApplyTo.intersects(c._bounds)) {
					c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);
				}
			}
		} else { //In required depth

			if (runAtEveryLevel) {
				runAtEveryLevel(this);
			}
			if (runAtBottomLevel && this._zoom === zoomLevelToStop) {
				runAtBottomLevel(this);
			}

			//TODO: This loop is almost the same as above
			if (zoomLevelToStop > zoom) {
				for (i = childClusters.length - 1; i >= 0; i--) {
					c = childClusters[i];
					if (boundsToApplyTo.intersects(c._bounds)) {
						c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);
					}
				}
			}
		}
	},

	//Returns true if we are the parent of only one cluster and that cluster is the same as us
	_isSingleParent: function () {
		//Don't need to check this._markers as the rest won't work if there are any
		return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;
	}
});



/*
* Extends L.Marker to include two extra methods: clusterHide and clusterShow.
* 
* They work as setOpacity(0) and setOpacity(1) respectively, but
* they will remember the marker's opacity when hiding and showing it again.
* 
*/


L.Marker.include({
	
	clusterHide: function () {
		this.options.opacityWhenUnclustered = this.options.opacity || 1;
		return this.setOpacity(0);
	},
	
	clusterShow: function () {
		var ret = this.setOpacity(this.options.opacity || this.options.opacityWhenUnclustered);
		delete this.options.opacityWhenUnclustered;
		return ret;
	}
	
});





L.DistanceGrid = function (cellSize) {
	this._cellSize = cellSize;
	this._sqCellSize = cellSize * cellSize;
	this._grid = {};
	this._objectPoint = { };
};

L.DistanceGrid.prototype = {

	addObject: function (obj, point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    grid = this._grid,
		    row = grid[y] = grid[y] || {},
		    cell = row[x] = row[x] || [],
		    stamp = L.Util.stamp(obj);

		this._objectPoint[stamp] = point;

		cell.push(obj);
	},

	updateObject: function (obj, point) {
		this.removeObject(obj);
		this.addObject(obj, point);
	},

	//Returns true if the object was found
	removeObject: function (obj, point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    grid = this._grid,
		    row = grid[y] = grid[y] || {},
		    cell = row[x] = row[x] || [],
		    i, len;

		delete this._objectPoint[L.Util.stamp(obj)];

		for (i = 0, len = cell.length; i < len; i++) {
			if (cell[i] === obj) {

				cell.splice(i, 1);

				if (len === 1) {
					delete row[x];
				}

				return true;
			}
		}

	},

	eachObject: function (fn, context) {
		var i, j, k, len, row, cell, removed,
		    grid = this._grid;

		for (i in grid) {
			row = grid[i];

			for (j in row) {
				cell = row[j];

				for (k = 0, len = cell.length; k < len; k++) {
					removed = fn.call(context, cell[k]);
					if (removed) {
						k--;
						len--;
					}
				}
			}
		}
	},

	getNearObject: function (point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    i, j, k, row, cell, len, obj, dist,
		    objectPoint = this._objectPoint,
		    closestDistSq = this._sqCellSize,
		    closest = null;

		for (i = y - 1; i <= y + 1; i++) {
			row = this._grid[i];
			if (row) {

				for (j = x - 1; j <= x + 1; j++) {
					cell = row[j];
					if (cell) {

						for (k = 0, len = cell.length; k < len; k++) {
							obj = cell[k];
							dist = this._sqDist(objectPoint[L.Util.stamp(obj)], point);
							if (dist < closestDistSq) {
								closestDistSq = dist;
								closest = obj;
							}
						}
					}
				}
			}
		}
		return closest;
	},

	_getCoord: function (x) {
		return Math.floor(x / this._cellSize);
	},

	_sqDist: function (p, p2) {
		var dx = p2.x - p.x,
		    dy = p2.y - p.y;
		return dx * dx + dy * dy;
	}
};


/* Copyright (c) 2012 the authors listed at the following URL, and/or
the authors of referenced articles or incorporated external code:
http://en.literateprograms.org/Quickhull_(Javascript)?action=history&offset=20120410175256

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Retrieved from: http://en.literateprograms.org/Quickhull_(Javascript)?oldid=18434
*/

(function () {
	L.QuickHull = {

		/*
		 * @param {Object} cpt a point to be measured from the baseline
		 * @param {Array} bl the baseline, as represented by a two-element
		 *   array of latlng objects.
		 * @returns {Number} an approximate distance measure
		 */
		getDistant: function (cpt, bl) {
			var vY = bl[1].lat - bl[0].lat,
				vX = bl[0].lng - bl[1].lng;
			return (vX * (cpt.lat - bl[0].lat) + vY * (cpt.lng - bl[0].lng));
		},

		/*
		 * @param {Array} baseLine a two-element array of latlng objects
		 *   representing the baseline to project from
		 * @param {Array} latLngs an array of latlng objects
		 * @returns {Object} the maximum point and all new points to stay
		 *   in consideration for the hull.
		 */
		findMostDistantPointFromBaseLine: function (baseLine, latLngs) {
			var maxD = 0,
				maxPt = null,
				newPoints = [],
				i, pt, d;

			for (i = latLngs.length - 1; i >= 0; i--) {
				pt = latLngs[i];
				d = this.getDistant(pt, baseLine);

				if (d > 0) {
					newPoints.push(pt);
				} else {
					continue;
				}

				if (d > maxD) {
					maxD = d;
					maxPt = pt;
				}
			}

			return { maxPoint: maxPt, newPoints: newPoints };
		},


		/*
		 * Given a baseline, compute the convex hull of latLngs as an array
		 * of latLngs.
		 *
		 * @param {Array} latLngs
		 * @returns {Array}
		 */
		buildConvexHull: function (baseLine, latLngs) {
			var convexHullBaseLines = [],
				t = this.findMostDistantPointFromBaseLine(baseLine, latLngs);

			if (t.maxPoint) { // if there is still a point "outside" the base line
				convexHullBaseLines =
					convexHullBaseLines.concat(
						this.buildConvexHull([baseLine[0], t.maxPoint], t.newPoints)
					);
				convexHullBaseLines =
					convexHullBaseLines.concat(
						this.buildConvexHull([t.maxPoint, baseLine[1]], t.newPoints)
					);
				return convexHullBaseLines;
			} else {  // if there is no more point "outside" the base line, the current base line is part of the convex hull
				return [baseLine[0]];
			}
		},

		/*
		 * Given an array of latlngs, compute a convex hull as an array
		 * of latlngs
		 *
		 * @param {Array} latLngs
		 * @returns {Array}
		 */
		getConvexHull: function (latLngs) {
			// find first baseline
			var maxLat = false, minLat = false,
				maxLng = false, minLng = false,
				maxLatPt = null, minLatPt = null,
				maxLngPt = null, minLngPt = null,
				maxPt = null, minPt = null,
				i;

			for (i = latLngs.length - 1; i >= 0; i--) {
				var pt = latLngs[i];
				if (maxLat === false || pt.lat > maxLat) {
					maxLatPt = pt;
					maxLat = pt.lat;
				}
				if (minLat === false || pt.lat < minLat) {
					minLatPt = pt;
					minLat = pt.lat;
				}
				if (maxLng === false || pt.lng > maxLng) {
					maxLngPt = pt;
					maxLng = pt.lng;
				}
				if (minLng === false || pt.lng < minLng) {
					minLngPt = pt;
					minLng = pt.lng;
				}
			}
			
			if (minLat !== maxLat) {
				minPt = minLatPt;
				maxPt = maxLatPt;
			} else {
				minPt = minLngPt;
				maxPt = maxLngPt;
			}

			var ch = [].concat(this.buildConvexHull([minPt, maxPt], latLngs),
								this.buildConvexHull([maxPt, minPt], latLngs));
			return ch;
		}
	};
}());

L.MarkerCluster.include({
	getConvexHull: function () {
		var childMarkers = this.getAllChildMarkers(),
			points = [],
			p, i;

		for (i = childMarkers.length - 1; i >= 0; i--) {
			p = childMarkers[i].getLatLng();
			points.push(p);
		}

		return L.QuickHull.getConvexHull(points);
	}
});


//This code is 100% based on https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet
//Huge thanks to jawj for implementing it first to make my job easy :-)

L.MarkerCluster.include({

	_2PI: Math.PI * 2,
	_circleFootSeparation: 25, //related to circumference of circle
	_circleStartAngle: Math.PI / 6,

	_spiralFootSeparation:  28, //related to size of spiral (experiment!)
	_spiralLengthStart: 11,
	_spiralLengthFactor: 5,

	_circleSpiralSwitchover: 9, //show spiral instead of circle from this marker count upwards.
								// 0 -> always spiral; Infinity -> always circle

	spiderfy: function () {
		if (this._group._spiderfied === this || this._group._inZoomAnimation) {
			return;
		}

		var childMarkers = this.getAllChildMarkers(),
			group = this._group,
			map = group._map,
			center = map.latLngToLayerPoint(this._latlng),
			positions;

		this._group._unspiderfy();
		this._group._spiderfied = this;

		//TODO Maybe: childMarkers order by distance to center

		if (childMarkers.length >= this._circleSpiralSwitchover) {
			positions = this._generatePointsSpiral(childMarkers.length, center);
		} else {
			center.y += 10; // Otherwise circles look wrong => hack for standard blue icon, renders differently for other icons.
			positions = this._generatePointsCircle(childMarkers.length, center);
		}

		this._animationSpiderfy(childMarkers, positions);
	},

	unspiderfy: function (zoomDetails) {
		/// <param Name="zoomDetails">Argument from zoomanim if being called in a zoom animation or null otherwise</param>
		if (this._group._inZoomAnimation) {
			return;
		}
		this._animationUnspiderfy(zoomDetails);

		this._group._spiderfied = null;
	},

	_generatePointsCircle: function (count, centerPt) {
		var circumference = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count),
			legLength = circumference / this._2PI,  //radius from circumference
			angleStep = this._2PI / count,
			res = [],
			i, angle;

		res.length = count;

		for (i = count - 1; i >= 0; i--) {
			angle = this._circleStartAngle + i * angleStep;
			res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
		}

		return res;
	},

	_generatePointsSpiral: function (count, centerPt) {
		var spiderfyDistanceMultiplier = this._group.options.spiderfyDistanceMultiplier,
			legLength = spiderfyDistanceMultiplier * this._spiralLengthStart,
			separation = spiderfyDistanceMultiplier * this._spiralFootSeparation,
			lengthFactor = spiderfyDistanceMultiplier * this._spiralLengthFactor * this._2PI,
			angle = 0,
			res = [],
			i;

		res.length = count;

		// Higher index, closer position to cluster center.
		for (i = count - 1; i >= 0; i--) {
			angle += separation / legLength + i * 0.0005;
			res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
			legLength += lengthFactor / angle;
		}
		return res;
	},

	_noanimationUnspiderfy: function () {
		var group = this._group,
			map = group._map,
			fg = group._featureGroup,
			childMarkers = this.getAllChildMarkers(),
			m, i;

		this.setOpacity(1);
		for (i = childMarkers.length - 1; i >= 0; i--) {
			m = childMarkers[i];

			fg.removeLayer(m);

			if (m._preSpiderfyLatlng) {
				m.setLatLng(m._preSpiderfyLatlng);
				delete m._preSpiderfyLatlng;
			}
			if (m.setZIndexOffset) {
				m.setZIndexOffset(0);
			}

			if (m._spiderLeg) {
				map.removeLayer(m._spiderLeg);
				delete m._spiderLeg;
			}
		}

		group._spiderfied = null;
	}
});

//Non Animated versions of everything
L.MarkerClusterNonAnimated = L.MarkerCluster.extend({
	_animationSpiderfy: function (childMarkers, positions) {
		var group = this._group,
			map = group._map,
			fg = group._featureGroup,
			legOptions = this._group.options.spiderLegPolylineOptions,
			i, m, leg, newPos;

		// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.
		// The reverse order trick no longer improves performance on modern browsers.
		for (i = 0; i < childMarkers.length; i++) {
			newPos = map.layerPointToLatLng(positions[i]);
			m = childMarkers[i];

			// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.
			leg = new L.Polyline([this._latlng, newPos], legOptions);
			map.addLayer(leg);
			m._spiderLeg = leg;

			// Now add the marker.
			m._preSpiderfyLatlng = m._latlng;
			m.setLatLng(newPos);
			if (m.setZIndexOffset) {
				m.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING
			}

			fg.addLayer(m);
		}
		this.setOpacity(0.3);
		group.fire('spiderfied');
	},

	_animationUnspiderfy: function () {
		this._noanimationUnspiderfy();
	}
});

//Animated versions here
L.MarkerCluster.include({

	_animationSpiderfy: function (childMarkers, positions) {
		var group = this._group,
			map = group._map,
			fg = group._featureGroup,
			thisLayerLatLng = this._latlng,
			thisLayerPos = map.latLngToLayerPoint(thisLayerLatLng),
			svg = L.Path.SVG,
			legOptions = L.extend({}, this._group.options.spiderLegPolylineOptions), // Copy the options so that we can modify them for animation.
			finalLegOpacity = legOptions.opacity,
			i, m, leg, legPath, legLength, newPos;

		if (finalLegOpacity === undefined) {
			finalLegOpacity = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity;
		}

		if (svg) {
			// If the initial opacity of the spider leg is not 0 then it appears before the animation starts.
			legOptions.opacity = 0;

			// Add the class for CSS transitions.
			legOptions.className = (legOptions.className || '') + ' leaflet-cluster-spider-leg';
		} else {
			// Make sure we have a defined opacity.
			legOptions.opacity = finalLegOpacity;
		}

		// Add markers and spider legs to map, hidden at our center point.
		// Traverse in ascending order to make sure that inner circleMarkers are on top of further legs. Normal markers are re-ordered by newPosition.
		// The reverse order trick no longer improves performance on modern browsers.
		for (i = 0; i < childMarkers.length; i++) {
			m = childMarkers[i];

			newPos = map.layerPointToLatLng(positions[i]);

			// Add the leg before the marker, so that in case the latter is a circleMarker, the leg is behind it.
			leg = new L.Polyline([thisLayerLatLng, newPos], legOptions);
			map.addLayer(leg);
			m._spiderLeg = leg;

			// Explanations: https://jakearchibald.com/2013/animated-line-drawing-svg/
			// In our case the transition property is declared in the CSS file.
			if (svg) {
				legPath = leg._path;
				legLength = legPath.getTotalLength() + 0.1; // Need a small extra length to avoid remaining dot in Firefox.
				legPath.style.strokeDasharray = legLength; // Just 1 length is enough, it will be duplicated.
				legPath.style.strokeDashoffset = legLength;
			}

			// If it is a marker, add it now and we'll animate it out
			if (m.setZIndexOffset) {
				m.setZIndexOffset(1000000); // Make normal markers appear on top of EVERYTHING
			}
			if (m.clusterHide) {
				m.clusterHide();
			}

			// Vectors just get immediately added
			fg.addLayer(m);

			if (m._setPos) {
				m._setPos(thisLayerPos);
			}
		}

		group._forceLayout();
		group._animationStart();

		// Reveal markers and spider legs.
		for (i = childMarkers.length - 1; i >= 0; i--) {
			newPos = map.layerPointToLatLng(positions[i]);
			m = childMarkers[i];

			//Move marker to new position
			m._preSpiderfyLatlng = m._latlng;
			m.setLatLng(newPos);
			
			if (m.clusterShow) {
				m.clusterShow();
			}

			// Animate leg (animation is actually delegated to CSS transition).
			if (svg) {
				leg = m._spiderLeg;
				legPath = leg._path;
				legPath.style.strokeDashoffset = 0;
				//legPath.style.strokeOpacity = finalLegOpacity;
				leg.setStyle({opacity: finalLegOpacity});
			}
		}
		this.setOpacity(0.3);

		setTimeout(function () {
			group._animationEnd();
			group.fire('spiderfied');
		}, 200);
	},

	_animationUnspiderfy: function (zoomDetails) {
		var group = this._group,
			map = group._map,
			fg = group._featureGroup,
			thisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng),
			childMarkers = this.getAllChildMarkers(),
			svg = L.Path.SVG,
			m, i, leg, legPath, legLength, nonAnimatable;

		group._animationStart();

		//Make us visible and bring the child markers back in
		this.setOpacity(1);
		for (i = childMarkers.length - 1; i >= 0; i--) {
			m = childMarkers[i];

			//Marker was added to us after we were spiderfied
			if (!m._preSpiderfyLatlng) {
				continue;
			}

			//Fix up the location to the real one
			m.setLatLng(m._preSpiderfyLatlng);
			delete m._preSpiderfyLatlng;

			//Hack override the location to be our center
			nonAnimatable = true;
			if (m._setPos) {
				m._setPos(thisLayerPos);
				nonAnimatable = false;
			}
			if (m.clusterHide) {
				m.clusterHide();
				nonAnimatable = false;
			}
			if (nonAnimatable) {
				fg.removeLayer(m);
			}

			// Animate the spider leg back in (animation is actually delegated to CSS transition).
			if (svg) {
				leg = m._spiderLeg;
				legPath = leg._path;
				legLength = legPath.getTotalLength() + 0.1;
				legPath.style.strokeDashoffset = legLength;
				leg.setStyle({opacity: 0});
			}
		}

		setTimeout(function () {
			//If we have only <= one child left then that marker will be shown on the map so don't remove it!
			var stillThereChildCount = 0;
			for (i = childMarkers.length - 1; i >= 0; i--) {
				m = childMarkers[i];
				if (m._spiderLeg) {
					stillThereChildCount++;
				}
			}


			for (i = childMarkers.length - 1; i >= 0; i--) {
				m = childMarkers[i];

				if (!m._spiderLeg) { //Has already been unspiderfied
					continue;
				}

				if (m.clusterShow) {
					m.clusterShow();
				}
				if (m.setZIndexOffset) {
					m.setZIndexOffset(0);
				}

				if (stillThereChildCount > 1) {
					fg.removeLayer(m);
				}

				map.removeLayer(m._spiderLeg);
				delete m._spiderLeg;
			}
			group._animationEnd();
		}, 200);
	}
});


L.MarkerClusterGroup.include({
	//The MarkerCluster currently spiderfied (if any)
	_spiderfied: null,

	_spiderfierOnAdd: function () {
		this._map.on('click', this._unspiderfyWrapper, this);

		if (this._map.options.zoomAnimation) {
			this._map.on('zoomstart', this._unspiderfyZoomStart, this);
		}
		//Browsers without zoomAnimation or a big zoom don't fire zoomstart
		this._map.on('zoomend', this._noanimationUnspiderfy, this);
	},

	_spiderfierOnRemove: function () {
		this._map.off('click', this._unspiderfyWrapper, this);
		this._map.off('zoomstart', this._unspiderfyZoomStart, this);
		this._map.off('zoomanim', this._unspiderfyZoomAnim, this);
		this._map.off('zoomend', this._noanimationUnspiderfy, this);

		//Ensure that markers are back where they should be
		// Use no animation to avoid a sticky leaflet-cluster-anim class on mapPane
		this._noanimationUnspiderfy();
	},

	//On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)
	//This means we can define the animation they do rather than Markers doing an animation to their actual location
	_unspiderfyZoomStart: function () {
		if (!this._map) { //May have been removed from the map by a zoomEnd handler
			return;
		}

		this._map.on('zoomanim', this._unspiderfyZoomAnim, this);
	},

	_unspiderfyZoomAnim: function (zoomDetails) {
		//Wait until the first zoomanim after the user has finished touch-zooming before running the animation
		if (L.DomUtil.hasClass(this._map._mapPane, 'leaflet-touching')) {
			return;
		}

		this._map.off('zoomanim', this._unspiderfyZoomAnim, this);
		this._unspiderfy(zoomDetails);
	},

	_unspiderfyWrapper: function () {
		/// <summary>_unspiderfy but passes no arguments</summary>
		this._unspiderfy();
	},

	_unspiderfy: function (zoomDetails) {
		if (this._spiderfied) {
			this._spiderfied.unspiderfy(zoomDetails);
		}
	},

	_noanimationUnspiderfy: function () {
		if (this._spiderfied) {
			this._spiderfied._noanimationUnspiderfy();
		}
	},

	//If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc
	_unspiderfyLayer: function (layer) {
		if (layer._spiderLeg) {
			this._featureGroup.removeLayer(layer);

			if (layer.clusterShow) {
				layer.clusterShow();
			}
			//Position will be fixed up immediately in _animationUnspiderfy
			if (layer.setZIndexOffset) {
				layer.setZIndexOffset(0);
			}

			this._map.removeLayer(layer._spiderLeg);
			delete layer._spiderLeg;
		}
	}
});


/**
 * Adds 1 public method to MCG and 1 to L.Marker to facilitate changing
 * markers' icon options and refreshing their icon and their parent clusters
 * accordingly (case where their iconCreateFunction uses data of childMarkers
 * to make up the cluster icon).
 */


L.MarkerClusterGroup.include({
	/**
	 * Updates the icon of all clusters which are parents of the given marker(s).
	 * In singleMarkerMode, also updates the given marker(s) icon.
	 * @param layers L.MarkerClusterGroup|L.LayerGroup|Array(L.Marker)|Map(L.Marker)|
	 * L.MarkerCluster|L.Marker (optional) list of markers (or single marker) whose parent
	 * clusters need to be updated. If not provided, retrieves all child markers of this.
	 * @returns {L.MarkerClusterGroup}
	 */
	refreshClusters: function (layers) {
		if (!layers) {
			layers = this._topClusterLevel.getAllChildMarkers();
		} else if (layers instanceof L.MarkerClusterGroup) {
			layers = layers._topClusterLevel.getAllChildMarkers();
		} else if (layers instanceof L.LayerGroup) {
			layers = layers._layers;
		} else if (layers instanceof L.MarkerCluster) {
			layers = layers.getAllChildMarkers();
		} else if (layers instanceof L.Marker) {
			layers = [layers];
		} // else: must be an Array(L.Marker)|Map(L.Marker)
		this._flagParentsIconsNeedUpdate(layers);
		this._refreshClustersIcons();

		// In case of singleMarkerMode, also re-draw the markers.
		if (this.options.singleMarkerMode) {
			this._refreshSingleMarkerModeMarkers(layers);
		}

		return this;
	},

	/**
	 * Simply flags all parent clusters of the given markers as having a "dirty" icon.
	 * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
	 * @private
	 */
	_flagParentsIconsNeedUpdate: function (layers) {
		var id, parent;

		// Assumes layers is an Array or an Object whose prototype is non-enumerable.
		for (id in layers) {
			// Flag parent clusters' icon as "dirty", all the way up.
			// Dumb process that flags multiple times upper parents, but still
			// much more efficient than trying to be smart and make short lists,
			// at least in the case of a hierarchy following a power law:
			// http://jsperf.com/flag-nodes-in-power-hierarchy/2
			parent = layers[id].__parent;
			while (parent) {
				parent._iconNeedsUpdate = true;
				parent = parent.__parent;
			}
		}
	},

	/**
	 * Refreshes the icon of all "dirty" visible clusters.
	 * Non-visible "dirty" clusters will be updated when they are added to the map.
	 * @private
	 */
	_refreshClustersIcons: function () {
		this._featureGroup.eachLayer(function (c) {
			if (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {
				c._updateIcon();
			}
		});
	},

	/**
	 * Re-draws the icon of the supplied markers.
	 * To be used in singleMarkerMode only.
	 * @param layers Array(L.Marker)|Map(L.Marker) list of markers.
	 * @private
	 */
	_refreshSingleMarkerModeMarkers: function (layers) {
		var id, layer;

		for (id in layers) {
			layer = layers[id];

			// Make sure we do not override markers that do not belong to THIS group.
			if (this.hasLayer(layer)) {
				// Need to re-create the icon first, then re-draw the marker.
				layer.setIcon(this._overrideMarkerIcon(layer));
			}
		}
	}
});

L.Marker.include({
	/**
	 * Updates the given options in the marker's icon and refreshes the marker.
	 * @param options map object of icon options.
	 * @param directlyRefreshClusters boolean (optional) true to trigger
	 * MCG.refreshClustersOf() right away with this single marker.
	 * @returns {L.Marker}
	 */
	refreshIconOptions: function (options, directlyRefreshClusters) {
		var icon = this.options.icon;

		L.setOptions(icon, options);

		this.setIcon(icon);

		// Shortcut to refresh the associated MCG clusters right away.
		// To be used when refreshing a single marker.
		// Otherwise, better use MCG.refreshClusters() once at the end with
		// the list of modified markers.
		if (directlyRefreshClusters && this.__parent) {
			this.__parent._group.refreshClusters(this);
		}

		return this;
	}
});


}(window, document));
/*
 (c) 2014, Vladimir Agafonkin
 simpleheat, a tiny JavaScript library for drawing heatmaps with Canvas
 https://github.com/mourner/simpleheat
*/
!function(){"use strict";function t(i){return this instanceof t?(this._canvas=i="string"==typeof i?document.getElementById(i):i,this._ctx=i.getContext("2d"),this._width=i.width,this._height=i.height,this._max=1,void this.clear()):new t(i)}t.prototype={defaultRadius:25,defaultGradient:{.4:"blue",.6:"cyan",.7:"lime",.8:"yellow",1:"red"},data:function(t,i){return this._data=t,this},max:function(t){return this._max=t,this},add:function(t){return this._data.push(t),this},clear:function(){return this._data=[],this},radius:function(t,i){i=i||15;var a=this._circle=document.createElement("canvas"),s=a.getContext("2d"),e=this._r=t+i;return a.width=a.height=2*e,s.shadowOffsetX=s.shadowOffsetY=200,s.shadowBlur=i,s.shadowColor="black",s.beginPath(),s.arc(e-200,e-200,t,0,2*Math.PI,!0),s.closePath(),s.fill(),this},gradient:function(t){var i=document.createElement("canvas"),a=i.getContext("2d"),s=a.createLinearGradient(0,0,0,256);i.width=1,i.height=256;for(var e in t)s.addColorStop(e,t[e]);return a.fillStyle=s,a.fillRect(0,0,1,256),this._grad=a.getImageData(0,0,1,256).data,this},draw:function(t){this._circle||this.radius(this.defaultRadius),this._grad||this.gradient(this.defaultGradient);var i=this._ctx;i.clearRect(0,0,this._width,this._height);for(var a,s=0,e=this._data.length;e>s;s++)a=this._data[s],i.globalAlpha=Math.max(a[2]/this._max,t||.05),i.drawImage(this._circle,a[0]-this._r,a[1]-this._r);var n=i.getImageData(0,0,this._width,this._height);return this._colorize(n.data,this._grad),i.putImageData(n,0,0),this},_colorize:function(t,i){for(var a,s=3,e=t.length;e>s;s+=4)a=4*t[s],a&&(t[s-3]=i[a],t[s-2]=i[a+1],t[s-1]=i[a+2])}},window.simpleheat=t}(),/*
 (c) 2014, Vladimir Agafonkin
 Leaflet.heat, a tiny and fast heatmap plugin for Leaflet.
 https://github.com/Leaflet/Leaflet.heat
*/
L.HeatLayer=(L.Layer?L.Layer:L.Class).extend({initialize:function(t,i){this._latlngs=t,L.setOptions(this,i)},setLatLngs:function(t){return this._latlngs=t,this.redraw()},addLatLng:function(t){return this._latlngs.push(t),this.redraw()},setOptions:function(t){return L.setOptions(this,t),this._heat&&this._updateOptions(),this.redraw()},redraw:function(){return!this._heat||this._frame||this._map._animating||(this._frame=L.Util.requestAnimFrame(this._redraw,this)),this},onAdd:function(t){this._map=t,this._canvas||this._initCanvas(),t._panes.overlayPane.appendChild(this._canvas),t.on("moveend",this._reset,this),t.options.zoomAnimation&&L.Browser.any3d&&t.on("zoomanim",this._animateZoom,this),this._reset()},onRemove:function(t){t.getPanes().overlayPane.removeChild(this._canvas),t.off("moveend",this._reset,this),t.options.zoomAnimation&&t.off("zoomanim",this._animateZoom,this)},addTo:function(t){return t.addLayer(this),this},_initCanvas:function(){var t=this._canvas=L.DomUtil.create("canvas","leaflet-heatmap-layer leaflet-layer"),i=L.DomUtil.testProp(["transformOrigin","WebkitTransformOrigin","msTransformOrigin"]);t.style[i]="50% 50%";var a=this._map.getSize();t.width=a.x,t.height=a.y;var s=this._map.options.zoomAnimation&&L.Browser.any3d;L.DomUtil.addClass(t,"leaflet-zoom-"+(s?"animated":"hide")),this._heat=simpleheat(t),this._updateOptions()},_updateOptions:function(){this._heat.radius(this.options.radius||this._heat.defaultRadius,this.options.blur),this.options.gradient&&this._heat.gradient(this.options.gradient),this.options.max&&this._heat.max(this.options.max)},_reset:function(){var t=this._map.containerPointToLayerPoint([0,0]);L.DomUtil.setPosition(this._canvas,t);var i=this._map.getSize();this._heat._width!==i.x&&(this._canvas.width=this._heat._width=i.x),this._heat._height!==i.y&&(this._canvas.height=this._heat._height=i.y),this._redraw()},_redraw:function(){var t,i,a,s,e,n,h,o,r,d=[],_=this._heat._r,l=this._map.getSize(),m=new L.Bounds(L.point([-_,-_]),l.add([_,_])),c=void 0===this.options.max?1:this.options.max,u=void 0===this.options.maxZoom?this._map.getMaxZoom():this.options.maxZoom,f=1/Math.pow(2,Math.max(0,Math.min(u-this._map.getZoom(),12))),g=_/2,p=[],v=this._map._getMapPanePos(),w=v.x%g,y=v.y%g;for(t=0,i=this._latlngs.length;i>t;t++)if(a=this._map.latLngToContainerPoint(this._latlngs[t]),m.contains(a)){e=Math.floor((a.x-w)/g)+2,n=Math.floor((a.y-y)/g)+2;var x=void 0!==this._latlngs[t].alt?this._latlngs[t].alt:void 0!==this._latlngs[t][2]?+this._latlngs[t][2]:1;r=x*f,p[n]=p[n]||[],s=p[n][e],s?(s[0]=(s[0]*s[2]+a.x*r)/(s[2]+r),s[1]=(s[1]*s[2]+a.y*r)/(s[2]+r),s[2]+=r):p[n][e]=[a.x,a.y,r]}for(t=0,i=p.length;i>t;t++)if(p[t])for(h=0,o=p[t].length;o>h;h++)s=p[t][h],s&&d.push([Math.round(s[0]),Math.round(s[1]),Math.min(s[2],c)]);this._heat.data(d).draw(this.options.minOpacity),this._frame=null},_animateZoom:function(t){var i=this._map.getZoomScale(t.zoom),a=this._map._getCenterOffset(t.center)._multiplyBy(-i).subtract(this._map._getMapPanePos());L.DomUtil.setTransform?L.DomUtil.setTransform(this._canvas,a,i):this._canvas.style[L.DomUtil.TRANSFORM]=L.DomUtil.getTranslateString(a)+" scale("+i+")"}}),L.heatLayer=function(t,i){return new L.HeatLayer(t,i)};
// COMMON CalendarWidget

var nsGmx = nsGmx || {};

(function($){

    nsGmx.Translations.addText("rus", { CommonCalendarWidget: {
        Timeline:    "Таймлайн",
        select: "Выберите мультивременной слой",
        sync: "Единый интервал для слоев",
        daily: "посуточно",
        on: "Включить синхронизацию слоев",
        off: "Выключить синхронизацию слоев",
        all: "Интервал для всех слоев"
    }});

    nsGmx.Translations.addText("eng", { CommonCalendarWidget: {
        Timeline:     "Timeline",
        select: "Select temporal layer",
        sync: "Single dateinterval",
        daily: "daily",
        on: "Layers sync on",
        off: "Layers sync off",
        all: "Интервал для всех слоев"
    }});

    var toMidnight = nsGmx.DateInterval.toMidnight,
        dayms = nsGmx.DateInterval.MS_IN_DAY;

    var calendarWidgetTemplate = '' +
        '<div class="commoncalendar-container">' +
            '<div class="calendar-layers-container">' +
                '<div class="calendar-container">' +
                    '<div class="calendar-widget-container"></div>' +
                '</div>' +
            '</div>' +
            '<div class="sync-switch-container switch-container">' +
                '<label class="sync-switch switch">' +
                    '<input type="checkbox"' +
                    '{{#if synchronyzed}}checked{{/if}}' +
                    '>' +
                    '<div class="sync-switch-slider switch-slider round"></div>' +
                '</label>' +
                '<span class="sync-switch-slider-description">{{i "CommonCalendarWidget.sync"}}</span>' +
                '<label class="daily-switch">' +
                    '<input type="checkbox"' +
                    '{{#if dailyFilter}}checked{{/if}}' +
                    '>' +
                    '{{i "CommonCalendarWidget.daily"}}' +
                '</label>' +
            '</div>' +
            '<div class="unsync-layers-container" style="display: none">' +
                '<select class="layersList">' +
                    '{{#each this.layers}}' +
                    '<option value="{{this.layer}}"' +
                        '{{#if this.current}} selected="selected"{{/if}}>' +
                        '{{this.layer}}' +
                    '</option>' +
                    '{{/each}}' +
                '</select>' +
            '</div>' +
        '</div>' ;
    'use strict';

    var _gtxt = nsGmx.Translations.getText.bind(nsGmx.Translations);

    var CommonCalendarModel = window.Backbone.Model.extend({
        defaults: {
            active: true,
            currentLayer: null,
            calendar: null,
            isAppended: false,
            unbindedTemporalLayers: {},
            dailyFiltersHash: {},
            dailyFilter: true,
            synchronyzed: true
        }
    });

    var CommonCalendar = window.Backbone.View.extend({
        tagName: 'div',
        model: new CommonCalendarModel(),
        className: 'CommonCalendarWidget ui-widget',
        template: Handlebars.compile(calendarWidgetTemplate),
        events: {
            'change .sync-switch': 'toggleSync',
            'change .daily-switch': 'toggleDailyFilter',
            'change .layersList': 'changeCurrentLayer'
        },
        initialize: function (options) {
            var _this = this;

            this.$el.html(this.template({
                synchronyzed: _this.model.get('synchronyzed'),
                layers: _this.model.get('visibleTemporalLayers'),
                dailyFilter: _this.model.get('dailyFilter')
            }));

            //for backward compatibility
            this.canvas = this.$el;
            this.dateInterval = new nsGmx.DateInterval();

            this.listenTo(this.model, 'change:synchronyzed', this.updateSync);
            this.listenTo(this.model, 'change:dailyFilter', (function () {
                this.handleFiltersHash();
                this.applyDailyFilter();
            }).bind(this));

            this.dateInterval.on('change', function () {
                _this.updateVisibleTemporalLayers(nsGmx.gmxMap.layers);
                if (_this.model.get('dailyFilter')) {
                    _this.applyDailyFilter();
                }
            });

            this._fillFiltersHash();
        },

        _fillFiltersHash: function(layers) {
            layers = layers || nsGmx.gmxMap.layers;

            var dailyFiltersHash = {};

            for (var i = 0; i < layers.length; i++) {
                var layer = layers[i],
                    props = layer.getGmxProperties(),
                    layerID = props.LayerID,
                    isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                if (isTemporalLayer) {
                    dailyFiltersHash[layerID] = true;
                }

                this.model.set('dailyFiltersHash', dailyFiltersHash);
            }
        },

        _clearFiltersHash: function (layers) {
            layers = layers || nsGmx.gmxMap.layers;

            var dailyFiltersHash = {};

            for (var i = 0; i < layers.length; i++) {
                var layer = layers[i],
                    props = layer.getGmxProperties(),
                    layerID = props.LayerID,
                    isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                if (isTemporalLayer) {
                    dailyFiltersHash[layerID] = false;
                }

                this.model.set('dailyFiltersHash', dailyFiltersHash);
            }
        },

        setDateInterval: function (dateBegin, dateEnd, layer) {
            if (layer) {
                this.setCurrentLayer(layer);
            }

            var oldBegin = this.dateInterval.get('dateBegin').valueOf(),
                oldEnd = this.dateInterval.get('dateEnd').valueOf();

            if (oldBegin === dateBegin.valueOf() && oldEnd === dateEnd.valueOf()) {
                this.updateTemporalLayers();

                this.updateVisibleTemporalLayers(nsGmx.gmxMap.layers);
                if (this.model.get('dailyFilter')) {
                    this.applyDailyFilter();
                }
                this.trigger('change:dateInterval');
            } else {
                this.dateInterval.set({
                    dateBegin: dateBegin,
                    dateEnd: dateEnd
                });
            }

            if (this.dateInterval.get('dailyFilter')) {
                this.applyDailyFilter();
            }
        },

        setCurrentLayer: function (layer) {
            var props = layer.getGmxProperties();

            this.model.set('currentLayer', props.LayerID);
        },

        changeCurrentLayer: function (e) {
            var _this = this,
                layerID = e.target.value;

            _this.model.set('currentLayer', layerID);
        },

        log: function () {
            var f = function(list) {
                var layers = nsGmx.gmxMap.layers;

                for (var i = 0; i < layers.length; i++) {
	               var layer = layers[i],
                        props = layer.getGmxProperties(),
                        t = props.title,
                        isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);
                        int = layer.getDateInterval();

                    if (isTemporalLayer && int) {
                        var b = int.beginDate.toString(),
                            e = int.endDate.toString();
                        list.push({
                            title: t,
                            beginDate: b,
                            endDate: e
                        });
                    }
	            }
	               console.table(list);
            };
            f([]);
        },

        getDateInterval: function () {
            return this.dateInterval;
        },

        get: function() {
            var attrs = this.model.toJSON(),
                _this = this,
                calendar;

            if (!attrs.calendar) {
                calendar = new nsGmx.CalendarWidget1({
                    minimized: false,
                    dateMin: new Date(2000, 1, 1),
                    dateMax: new Date(Date.now() + dayms) > _this.dateInterval.get('dateEnd') ? new Date(Date.now() + dayms) : _this.dateInterval.get('dateEnd'),
                    dateInterval: _this.dateInterval
                });

                this.dateInterval.on('change', this.updateTemporalLayers.bind(this, null));

                this.model.set('calendar', calendar);
            this.updateTemporalLayers();
            }

            return this.model.get('calendar');
        },

        replaceCalendarWidget: function(newCalendar) {
            this._calendar = newCalendar;

            //заменим виджет перед деревом слоёв
            if (this._isAppended) {
                var doChange = function() {
                    var calendarDiv = $('<div class="commoncalendar-container"></div>').append(newCalendar.canvas);
                    // special for steppe project
                    if (nsGmx.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
                        _queryMapLayers.getContainerAfter().find('.commoncalendar-container').replaceWith(calendarDiv);
                    } else {
                        _queryMapLayers.getContainerBefore().findcommoncalendar-container('.commoncalendar-container').replaceWith(calendarDiv);
                    }
                }
                //явная проверка, так как хочется быть максимально синхронными в этом методе
                if (_queryMapLayers.loadDeferred.state() === 'resolved') {
                    doChange();
                } else {
                    _queryMapLayers.loadDeferred.then(doChange);
                }
            }
        },

        show: function() {
            var calendarDiv = this.$('.calendar-widget-container'),
                calendarCanvas = this.get().canvas;

            $(_queryMapLayers.getContainerBefore()).append(calendarCanvas[0]);

            var doAdd = function() {
                calendarDiv.append(calendarCanvas);

                var commonCanvas = this.canvas;

                // special for steppe Project
                if (nsGmx.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
                    _queryMapLayers.getContainerAfter().append(commonCanvas);
                } else {
                    _queryMapLayers.getContainerBefore().append(commonCanvas);
                }
                this.model.set('isAppended', true);
            }.bind(this);

            if (!this.model.get('isAppended')) {
                //явная проверка, так как хочется быть максимально синхронными в этом методе
                if (_queryMapLayers.loadDeferred.state() === 'resolved') {
                    doAdd();
                } else {
                    _queryMapLayers.loadDeferred.then(doAdd);
                }
            }
        },

        hide: function() {
            var attrs = this.model.toJSON();
            attrs._isAppended && $(this.get().canvas).hide();
            this.model.set('isAppended', true);
        },

        bindLayer: function(layerName) {
            var attrs = this.model.toJSON(),
                unbindedTemporalLayers = attrs.unbindedTemporalLayers,
                clone = {};

            // clone object
            for (var variable in unbindedTemporalLayers) {
                if (unbindedTemporalLayers.hasOwnProperty(variable)) {
                    clone[variable] = unbindedTemporalLayers[variable];
                }
            };

            delete clone[layerName];

            this.model.set('unbindedTemporalLayers', clone);
            this.updateTemporalLayers();
        },

        unbindLayer: function(layerName) {
            var attrs = this.model.toJSON(),
                unbindedTemporalLayers = attrs.unbindedTemporalLayers,
                clone = {};

            // clone object
            for (var variable in unbindedTemporalLayers) {
                if (unbindedTemporalLayers.hasOwnProperty(variable)) {
                    clone[variable] = unbindedTemporalLayers[variable];
                }
            };

            clone[layerName] = true;
            this.model.set('unbindedTemporalLayers', clone);
        },

        _updateOneLayer: function(layer, dateBegin, dateEnd) {
            var props = layer.getGmxProperties();
            if (props.maxShownPeriod) {
                var msecPeriod = props.maxShownPeriod*24*3600*1000;
                var newDateBegin = new Date( Math.max(dateBegin.valueOf(), dateEnd.valueOf() - msecPeriod));
                layer.setDateInterval(newDateBegin, dateEnd);
            } else {
                layer.setDateInterval(dateBegin, dateEnd);
            }
        },

        updateTemporalLayers: function() {
            var layers = layers || nsGmx.gmxMap.layers,
                attrs = this.model.toJSON(),
                synchronyzed = attrs.synchronyzed,
                dateBegin = this.dateInterval.get('dateBegin'),
                dateEnd = this.dateInterval.get('dateEnd'),
                currentLayer = attrs.currentLayer,
                layersMaxDates = [],
                maxDate = null,
                localeDate;

            if (!attrs.calendar) {return;}

            if (synchronyzed) {
                for (var i = 0, len = layers.length; i < len; i++) {
                    var layer = layers[i],
                    props = layer.getGmxProperties(),
                    isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                    if (isTemporalLayer && !(props.name in attrs.unbindedTemporalLayers)) {
                        if (props.DateEnd) {
                            if (typeof props.DateEnd === "string") {
                                localeDate = $.datepicker.parseDate('dd.mm.yy', props.DateEnd);
                            } else if (typeof props.DateEnd === "number") {
                                localeDate = new Date(props.DateEnd);
                            }

                            layersMaxDates.push(localeDate);
                        }

                        this._updateOneLayer(layer, dateBegin, dateEnd);
                    }
                }
            } else {
                if (currentLayer) {
                    currentLayer = nsGmx.gmxMap.layersByID[currentLayer];
                    this._updateOneLayer(currentLayer, dateBegin, dateEnd);
                } else {
                    return;
                }
            }

            if (layersMaxDates.length > 0) {
                layersMaxDates.sort(function(a, b) {
                    return b - a;
                });

                maxDate = new Date(layersMaxDates[0]);

                if (maxDate > attrs.calendar.getDateMax()) {
                    attrs.calendar.setDateMax(nsGmx.CalendarWidget.fromUTC(new Date(maxDate.valueOf() + dayms)));
                }

                this.model.set('calendar', attrs.calendar);
            }
        },

        onDateIntervalChanged: function (e) {
            var attrs = this.model.toJSON(),
                currentLayer = attrs.currentLayer,
                layer = e.target,
                props,
                layerName,
                dateInterval, dateBegin, dateEnd;

            if (!currentLayer) {
                return;
            }

            props = layer.getGmxProperties(),
            layerID = props.LayerID;

            if (layerID === currentLayer) {
                if (props.maxShownPeriod) { return; }
                dateInterval = layer.getDateInterval(),
                dateBegin = dateInterval.beginDate,
                dateEnd = dateInterval.endDate;

                this.setDateInterval(dateBegin, dateEnd, layer);
            }
        },

        updateVisibleTemporalLayers: function (layers) {
            var _this = this,
                attrs = this.model.toJSON(),
                currentLayer = attrs.currentLayer,
                layersList = this.$('.layersList'),
                temporalLayers = [],
                layersArr = [],
                str = '';

            $.widget( "ui.temporallayersmenu", $.ui.selectmenu, {
                _renderItem: function(ul, item) {
                    var li = $( "<li>" );

                    if ( item.value ) {
                        var l = nsGmx.gmxMap.layersByID[item.value],
                            props = l.getGmxProperties(),
                            di = l.getDateInterval && l.getDateInterval(),
                            dateBegin, dateEnd,
                            hourBegin, hourEnd,
                            newDateBegin, newDateEnd,
                            str = '';

                        if (di) {
                            var now = new Date(),
                                dateBeginToMidnight = new Date(now - now % dayms);

                            // dateBegin = di.beginDate;
                            // dateEnd = di.endDate);
                            dateBegin = di.beginDate || dateBeginToMidnight;
                            dateEnd = di.endDate || new Date(dateBeginToMidnight.valueOf() + dayms);
                            hourBegin = nsGmx.CalendarWidget1.prefixTimeValue(nsGmx.CalendarWidget1.getTime(dateBegin, 'begin'));
                            hourEnd = nsGmx.CalendarWidget1.prefixTimeValue(nsGmx.CalendarWidget1.getTime(dateEnd, 'end'));
                            newDateBegin = nsGmx.CalendarWidget1.toUTC(dateBegin);
                            newDateEnd = nsGmx.CalendarWidget1.toUTC(dateEnd);

                            // если календарь показывает ровно один день,
                            // прибавляем 24 часа к первой дате, чтобы получить сутки
                            if (dateEnd.valueOf() === toMidnight(dateEnd).valueOf()) {
                                newDateEnd = nsGmx.CalendarWidget1.toUTC(new Date(dateEnd - dayms));
                            }

                            str = '<span class=\'layerslist-title\'>' +  props.title + '</span>' + ' ' +
                                  '<span class=\'layerslist-dates-times\'>' + nsGmx.CalendarWidget1.formatDate(newDateBegin) + ' - ' + nsGmx.CalendarWidget1.formatDate(newDateEnd) +
                                  ' | ' + hourBegin + '-' + hourEnd + '</span>';

                        }

                        $(li).html(str);
                        $(li).prop('layerID', item.value);

                        return li.appendTo( ul );
                    }
                },
                _renderMenu: function( ul, items ) {
                    var that = this;
                    $.each( items, function( index, item ) {
                        that._renderItemData( ul, item );
                    });
                }
            });

            if ($(layersList).temporallayersmenu("instance")) {
                $(layersList).temporallayersmenu("destroy");
            }

            for (var i = 0; i < layers.length; i++) {
                var layer = layers[i];
                    if (layer.getGmxProperties) {
                        var props = layer.getGmxProperties(),
                            isVisible = props.visible,
                            isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                        if (isTemporalLayer && isVisible) {
                            temporalLayers.push(layer);
                        }
                    }
                }

            for (var i = 0; i < temporalLayers.length; i++) {
                var layer = temporalLayers[i],
                    props = layer.getGmxProperties(),
                    layerID = props.LayerID;

                str += '<option value=' + layerID + '>' + props.title + '</option>';
            };

            $(layersList).html(str);

            if (currentLayer) {
                var l = nsGmx.gmxMap.layersByID[currentLayer];

                this.$('.layersList option').each(function () {
                    if ($(this).val() === currentLayer) {
                        $(this).prop("selected", true);
                    }
                })

            // установим текщим первый слой из списка
            } else if (!currentLayer && temporalLayers.length) {
                var props = temporalLayers[0].getGmxProperties(),
                    layerID = props.LayerID;

                this.$('.layersList option[value="' + layerID + '"]').prop("selected", true);
            }

            $(layersList).temporallayersmenu({
                change: function (e) {
                    var layerID = $(e.currentTarget).prop('layerID'),
                        layer = nsGmx.gmxMap.layersByID[layerID],
                        filters = layer._gmx.dataManager._filtersView,
                        layerFilters = filters[layerID],
                        dateBegin, dateEnd;

                    dateInterval = layer.getDateInterval();

                    if (dateInterval.beginDate && dateInterval.endDate) {
                        dateBegin = dateInterval.beginDate;
                        dateEnd = dateInterval.endDate;
                    } else {
                        dateInterval = new nsGmx.DateInterval();
                        dateBegin = dateInterval.get('dateBegin');
                        dateEnd = dateInterval.get('dateEnd');
                    }

                    if (layerFilters) {
                        if ('screen_dailyFilter' in layerFilters) {
                            _this.$('.daily-switch input').prop("checked", true);
                        } else {
                            _this.$('.daily-switch input').prop("checked", false);
                        }
                    }

                    _this.$('.layersList option[value="' + layerID + '"]').prop("selected", true);
                    _this.setDateInterval(dateBegin, dateEnd, layer);

                }
            });
        },

        toggleSync: function () {
            this.model.set('synchronyzed', !this.model.get('synchronyzed'));
        },

        updateSync: function () {
            var _this = this,
                layers = nsGmx.gmxMap.layers,
                attrs = this.model.toJSON(),
                synchronyzed = attrs.synchronyzed,
                currentLayer = attrs.currentLayer,
                listContainer = this.$('.unsync-layers-container'),
                layersList = this.$('.layersList'),
                dateBegin, dateEnd;

            if (synchronyzed) {
                dateBegin = _this.dateInterval.get('dateBegin'),
                dateEnd = _this.dateInterval.get('dateEnd'),
                _this.setDateInterval(dateBegin, dateEnd);
                this.model.set('currentLayer', null);
                this.model.set('currentLayer', null);
                this.$('.sync-switch input').prop("checked", true);
                $(listContainer).hide();
            } else {
                if (currentLayer) {
                    return;
                } else {
                    var temporalLayers = [];

                    this.$('.sync-switch input').prop("checked", false);
                    $(listContainer).show();
                    this.updateVisibleTemporalLayers(layers);

                    for (var i = 0; i < layers.length; i++) {
                        var layer = layers[i];
                        if (layer.getGmxProperties) {
                            var props = layer.getGmxProperties(),
                            isVisible = props.visible,
                            isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                            if (isTemporalLayer && isVisible) {
                                temporalLayers.push(layer);
                            }
                        }
                    }
                    if (!temporalLayers.length) {
                        this.model.set('currentLayer', null);
                    } else {
                        var props = temporalLayers[0].getGmxProperties(),
                        layerID = props.LayerID;
                        this.model.set('currentLayer', layerID);
                    }
                }
            }
        },

        toggleDailyFilter: function () {
            var attrs = this.model.toJSON(),
                calendar = attrs.calendar;

            calendar.model.set('dailyFilter', !this.model.get('dailyFilter'));
            this.model.set('dailyFilter', !this.model.get('dailyFilter'));
        },

        handleFiltersHash: function () {
            var attrs = this.model.toJSON(),
                synchronyzed = attrs.synchronyzed,
                currentLayer = attrs.currentLayer,
                dateInterval = this.dateInterval,
                calendar = attrs.calendar,
                dailyFilter = attrs.dailyFilter,
                dailyFiltersHash = attrs.dailyFiltersHash;

            if (dailyFilter) {
                if (currentLayer) {
                    dailyFiltersHash[currentLayer] = true;
                } else {
                    this._fillFiltersHash();
                }
            } else {
                if (currentLayer) {
                    dailyFiltersHash[currentLayer] = false;
                } else {
                    this._clearFiltersHash();
                }
            }
        },

        applyDailyFilter: function (layers) {
            var temporalLayers = layers || nsGmx.gmxMap.layers,
                _this = this,
                attrs = this.model.toJSON(),
                dailyFilter = attrs.dailyFilter,
                dailyFiltersHash = attrs.dailyFiltersHash,
                synchronyzed = attrs.synchronyzed,
                currentLayer = attrs.currentLayer,
                dateInterval = this.dateInterval,
                calendar = attrs.calendar,
                dateBegin = this.dateInterval.get('dateBegin'),
                dateEnd = this.dateInterval.get('dateEnd'),
                hourBegin = Number(nsGmx.CalendarWidget1.getTime(dateBegin, 'begin')) * 1000 * 3600,
                hourEnd = Number(nsGmx.CalendarWidget1.getTime(dateEnd, 'end')) * 1000 * 3600;
                temporalLayers;

            if (synchronyzed) {
                temporalLayers = nsGmx.gmxMap.layers;
            }

            if (!synchronyzed && !currentLayer) {
                return;
            }

            for (var i = 0; i < temporalLayers.length; i++) {
                (function (x) {
                var layer = temporalLayers[x];

                if (layer.getGmxProperties) {
                        var props = layer.getGmxProperties(),
                            isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                        if (isTemporalLayer && layer.getDataManager) {

                            if (!synchronyzed && layer.getDateInterval()) {
                                dateInterval = layer.getDateInterval();
                                if (dateInterval.beginDate && dateInterval.endDate) {
                                    dateBegin = dateInterval.beginDate;
                                    dateEnd = dateInterval.endDate;
                                    hourBegin = Number(nsGmx.CalendarWidget1.getTime(dateBegin, 'begin')) * 1000 * 3600,
                                    hourEnd = Number(nsGmx.CalendarWidget1.getTime(dateEnd, 'end')) * 1000 * 3600;
                                }
                            }

                            var dm = layer.getDataManager(),
                                dmOpt = dm.options,
                                fullDays,
                                intervals = [];

                            if (dmOpt.Temporal) {
                                var tmpKeyNum = dm.tileAttributeIndexes[dmOpt.TemporalColumnName];
                            }

                            if (hourEnd < dayms) {
                                fullDays = toMidnight(dateEnd).valueOf() - toMidnight(dateBegin).valueOf() + dayms;
                            } else if (hourEnd === dayms) {
                                fullDays = toMidnight(dateEnd).valueOf() - toMidnight(dateBegin).valueOf();
                            }

                            for (var i = 0; i < fullDays; i+= dayms) {
                                intervals.push({
                                    begin: toMidnight(dateBegin).valueOf() + hourBegin + i,
                                    end: toMidnight(dateBegin).valueOf() + hourEnd + i
                                });
                            }

                            if (dailyFilter && dailyFiltersHash[props.LayerID]) {
                                layer.addLayerFilter(function (item) {
                                    var itemDate = item.properties[tmpKeyNum] * 1000,
                                        inside = false;
                                    for (var j = 0; j < intervals.length; j++) {
                                        if (intervals[j].begin <= itemDate && itemDate <= intervals[j].end) {
                                            inside = true;
                                            break;
                                        }
                                    }
                                    //
                                    // if (inside) {
                                    //     console.log(layer.getGmxProperties().title + ' / ' + 'loaded');
                                    // } else {
                                    //     console.log(layer.getGmxProperties().title + ' / ' + 'filtered');
                                    // }
                                    return inside;
                                }, {id: 'dailyFilter'});

                                _this.$('.daily-switch input').prop("checked", true);

                            } else {
                                layer.removeLayerFilter({id: 'dailyFilter'});
                                _this.$('.daily-switch input').prop("checked", false);
                            }
                        }
                    }
                }(i));
            }
        }
    });

    nsGmx.CommonCalendarWidget = CommonCalendar;

})(jQuery);

//Тут кратко описываются разные внешние классы для системы генерации документации

/** ГеоМиксер активно использует {@link http://jquery.com/|jQuery}
 * @namespace jQuery
 */

/** Официальная документация: {@link http://api.jquery.com/category/deferred-object/|jQuery Deferred}
 * @name Deferred
 * @memberOf jQuery
 */


/** Библиотека для формализации понятия модели и представления: {@link http://backbonejs.org/|Backbone}
 * @namespace Backbone
 */

/** Официальная документация: {@link http://backbonejs.org/#Model| Backbone Model}
 * @name Model
 * @memberOf Backbone
 */


/**
    Основное пространство имён ГеоМиксера
    @namespace
*/
var nsGmx = nsGmx || {};
nsGmx.widgets = nsGmx.widgets || {};

(function(){

'use strict';

var gmxJSHost = window.gmxJSHost || '';

if (!window.mapHostName && window.gmxJSHost) {
    window.mapHostName = /http:\/\/(.*)\/api\//.exec(window.gmxJSHost)[1];
}

var _mapHostName; //откуда грузить API
var protocol = window.location.protocol;

if (window.mapHostName) {
    _mapHostName = protocol + '//' + window.mapHostName + '/api/';
} else {
    var curUri = L.gmxUtil.parseUri(window.location.href);
    _mapHostName = protocol + '//' + curUri.host + curUri.directory;
}

var _serverBase = window.serverBase || /(.*)\/[^\/]*\//.exec(_mapHostName)[1] + '/';

//подставляет к локальному имени файла хост (window.gmxJSHost) и, опционально, рандомное поле для сброса кэша (window.gmxDropBrowserCache)
var _getFileName = function( localName ) {
    return gmxJSHost + localName + ( window.gmxDropBrowserCache ? '?' + Math.random() : '');
}

nsGmx.initGeoMixer = function() {

var oSearchLeftMenu = new leftMenu();

//для синхронизации меню и тулбара при включении/выключении сетки координат
nsGmx.gridManager = {
    state: false,
    gridControl: null,
    options: null,
    menu: null,

    setState: function(state) {
        var isActive = state.isActive,
            options = state.options;

        if (this.state == isActive) {
            return;
        }

        //lazy instantantion
        this.gridControl = this.gridControl || new L.GmxGrid();
        nsGmx.leafletMap[isActive ? 'addLayer' : 'removeLayer'](this.gridControl);
        if (options) {
            this.restoreOptions(options);
        }
        this.state = isActive;
        nsGmx.leafletMap.gmxControlIconManager.get('gridTool').setActive(isActive);
        _menuUp.checkItem('mapGrid', isActive);
        _mapHelper.gridView = isActive; //можно удалить?

        if (this.state) {
            this.configureGrid();
        } else {
            if (this.menu) {
                this.menu.Unload();
            }
        }
    },

    saveOptions: function() {
        this.options = this.gridControl.options;
    },

    restoreOptions: function(options) {
        this.gridControl.setUnits(options.units);
        this.gridControl.setStep(options.customStep.x, options.customStep.y);
        this.gridControl.setColor(options.color);
        this.gridControl.setTitleFormat(options.titleFormat);
    },

    configureGrid: function () {
        var _this = this;
        gmxCore.loadModule('GridPlugin', 'src/GridPlugin.js').then(function (def) {
              _this.menu = new def.ConfigureGridMenu(nsGmx.gridManager);
              _this.menu.Load();
        });
    }
}

var createMenuNew = function() {
    //формирует описание элемента меню для включения/выключения плагина
    var getPluginToMenuBinding = function(pluginName, menuItemName, menuTitle) {
        var plugin = nsGmx.pluginsManager.getPluginByName(pluginName);

        if (!plugin) {
            return null;
        }

        var sel = function() {
            nsGmx.pluginsManager.setUsePlugin(pluginName, true);
            nsGmx.pluginsManager.done(function() {
                var paramsClone = $.extend(true, {}, plugin.params);
                plugin.body.afterViewer && plugin.body.afterViewer(paramsClone, nsGmx.leafletMap);
                _mapHelper.mapPlugins.addPlugin(pluginName, plugin.params);
            })
        }

        var unsel = function() {
            nsGmx.pluginsManager.setUsePlugin(pluginName, false);
            nsGmx.pluginsManager.done(function() {
                _mapHelper.mapPlugins.remove(pluginName);
                plugin.body.unload && plugin.body.unload();
            })
        }

        return {
            id: menuItemName,
            title: menuTitle,
            onsel: sel,
            onunsel: unsel,
            checked: plugin.isUsed()
        }
    }

    var isMapEditor = _queryMapLayers.currentMapRights() === 'edit',
        isLogined = nsGmx.AuthManager.isLogin();

    _menuUp.submenus = [];

    _menuUp.addItem(
        {id: 'mapsMenu', title:_gtxt('Карта'),childs: [].concat(
            isLogined ? [{id: 'mapList',      title: _gtxt('Открыть'), func: function(){_queryMapLayers.getMaps()}}] : [], [
                {id: 'mapCreate',    title: _gtxt('Создать'),           func: function(){
                    _queryMapLayers.createMapDialog(_gtxt('Создать карту'), _gtxt('Создать'), _queryMapLayers.createMap)
                }},
                {id: 'mapSave',      title: _gtxt('Сохранить'),         func: _queryMapLayers.saveMap},
                {id: 'mapSaveAs',    title: _gtxt('Сохранить как'),     func: function(){
                    _queryMapLayers.createMapDialog(_gtxt('Сохранить карту как'), _gtxt('Сохранить'), _queryMapLayers.saveMapAs)
                }, delimiter: true},
                {id: 'export',    title: _gtxt('Экспорт'),     func: function(){
                    mapExportMenu();
                }, disabled: !isLogined},
                {id: 'shareMenu',        title: _gtxt('Поделиться'),        func: function(){_mapHelper.showPermalink()}},
                // {id: 'codeMap',      title: _gtxt('Код для вставки'),   func: function(){_mapHelper.createAPIMapDialog()}, disabled: true},
                {id: 'mapTabsNew',   title: _gtxt('Добавить закладку'), func: function(){mapHelp.tabs.load('mapTabs');_queryTabs.add();}},
                {id: 'printMap',     title: _gtxt('Печать'),            func: function(){_mapHelper.print()}, delimiter: true},
                {id: 'mapProperties',title: _gtxt('Свойства'),          func: function(){
                    var div = $(_layersTree._treeCanvas).find('div[MapID]')[0];
                    nsGmx.createMapEditor(div);
                }, disabled: !isMapEditor},
                {id:'createGroup', title: _gtxt('Добавить подгруппу'), func:function(){
                    var div = $(_layersTree._treeCanvas).find('div[MapID]')[0];
                    nsGmx.addSubGroup(div, _layersTree);
                }, disabled: !isMapEditor},
                {id: 'mapSecurity',  title: _gtxt('Права доступа'),     func: function(){
                    var securityDialog = new nsGmx.mapSecurity(),
                        props = _layersTree.treeModel.getMapProperties();
                    securityDialog.getRights(props.MapID, props.title);
                }, disabled: !isMapEditor}
            ]
        )}
    );

    _menuUp.addItem(
    {id:'dataMenu', title: _gtxt('Данные'), childs: [
            {id:'layerList',   title: _gtxt('Открыть слой'),    func:function(){_queryMapLayers.getLayers()}, disabled: !isMapEditor},
            {id:'createLayer', title: _gtxt('Создать слой'),    childs: [
                    {id:'createRasterLayer', title: _gtxt('Растровый'), func: _mapHelper.createNewLayer.bind(_mapHelper, 'Raster'), disabled: !isMapEditor},
                    {id:'createVectorLayer', title: _gtxt('Векторный'), func: _mapHelper.createNewLayer.bind(_mapHelper, 'Vector'), disabled: !isMapEditor},
                    {id:'createMultiLayer',  title: _gtxt('Мультислой'), func: _mapHelper.createNewLayer.bind(_mapHelper, 'Multi'), disabled: !isMapEditor}
                ],
                disabled: !isMapEditor
            },
            {id:'baseLayers',  title: _gtxt('Базовые слои'),    func:function(){
                var div = $(_layersTree._treeCanvas).find('div[MapID]')[0];
                nsGmx.createMapEditor(div, 1);
            }, delimiter: true, disabled: !isMapEditor},
            {id:'loadFile',    title: _gtxt('Загрузить объекты'),  func:drawingObjects.loadShp.load, delimiter: true},
            {id:'loadPhotos',    title: _gtxt('Загрузить фотографии'),  func:function () {PhotoLayerDialog()}, delimiter: true},
            {id:'wms',         title: _gtxt('Подключить WMS'),  func:loadServerData.WMS.load},
            {id:'wfs',         title: _gtxt('Подключить WFS'),  func:loadServerData.WFS.load}
        ]});

    _menuUp.addItem(
    {id: 'viewMenu', title: _gtxt('Вид'),childs: [
            {id:'externalMaps',   title: _gtxt('Дополнительные карты'), func: mapHelp.externalMaps.load},
            {id:'mapTabs',        title: _gtxt('Закладки'),             func: mapHelp.tabs.load},
            {id:'DrawingObjects', title: _gtxt('Объекты'),              func: oDrawingObjectGeomixer.Load},
            {id:'searchView',     title: _gtxt('Результаты поиска'),    func: oSearchControl.Load}
        ]});

    _menuUp.addItem(
        {id: 'instrumentsMenu', title:_gtxt('Инструменты'), childs: [
            {
                id: 'mapGrid', title:_gtxt('Координатная сетка'),
                onsel: nsGmx.gridManager.setState.bind(nsGmx.gridManager, {isActive: true}),
                onunsel: nsGmx.gridManager.setState.bind(nsGmx.gridManager, {isActive: false}),
                checked: _mapHelper.gridView
            },
            {
                id: 'mapIndexGrid', title:_gtxt('Индексная сетка'),     func: function(){
                    indexGridMenu();
                }
            },
            {id: 'shift',         title: _gtxt('Ручная привязка растров'), func:function(){}, disabled: true},
            {id: 'crowdsourcing', title: _gtxt('Краудсорсинг данных'), func:function(){}, disabled: true},
            {id: 'geocoding',     title: _gtxt('Пакетный геокодинг'), func:function(){}, disabled: true},
            {id: 'directions',    title: _gtxt('Маршруты'), func:function(){}, disabled: true}
        ]});


    function fillPluginsMenu() {
        var plugins = window.menuPlugins || [];

        // для локальной версии Геомиксера покажем плагины кадастра и Викимапии
        if (!window.menuPlugins) {
            if (nsGmx.pluginsManager.getPluginByName('Cadastre')) {
                plugins.push({pluginName: 'Cadastre', menuItemName: 'cadastre', menuTitle: 'Кадастр Росреестра'});
            }
            if (nsGmx.pluginsManager.getPluginByName('Wikimapia')) {
                plugins.push({pluginName: 'Wikimapia', menuItemName: 'wikimapia', menuTitle: 'Викимапиа'});
            }
        }

        if (plugins.length) {
            var childs = [];
            for (var p = 0; p < plugins.length; p++) {
                childs.push(
                    getPluginToMenuBinding(
                        plugins[p].pluginName,
                        plugins[p].menuItemName,
                        window._gtxt(plugins[p].menuTitle)
                    )
                )
            }

        _menuUp.addItem(
            {id: 'pluginsMenu', title: _gtxt('Сервисы'), childs: childs});
        }
    }
     fillPluginsMenu();

    _menuUp.addItem(
    {id:'helpMenu', title:_gtxt('Справка'), childs: [
            {id:'about',        title:_gtxt('О проекте'),                 func: _mapHelper.version},
        ].concat(window.mapsSite ? [
            {id:'usage',        title: _gtxt('Руководство пользователя'), func: function(){
                window.open('http://geomixer.ru/index.php/ru/docs/', '_blank');
            }},
            {id:'api',          title: _gtxt('GeoMixer API'),             func: function(){
                window.open('http://geomixer.ru/index.php/ru/docs/dev-manual/getting-started', '_blank');
            }},
            {id:'pluginsUsage', title: _gtxt('Использование плагинов'),   func: function(){
                window.open('http://geomixer.ru/index.php/ru/docs/manual/plugins', '_blank');
            }}
        ] : [])
    });
}

var createToolbar = function() {
    var lmap = nsGmx.leafletMap;

    var SliderControl = L.Control.extend({
        options: {
            position: 'topleft'
        },
        onAdd: function(map) {
            var sliderContainer = $('<div class="gmx-slider-control"></div>');
            this._widget = new nsGmx.TransparencySliderWidget(sliderContainer);

            $(this._widget).on('slide slidechange', function(event, ui) {
                _queryMapLayers.applyOpacityToRasterLayers(ui.value*100, _queryMapLayers.buildedTree);
            })

            return sliderContainer[0];
        },
        onRemove: function(){},
        isCollapsed: function(){ return this._widget.isCollapsed(); }
    });
    var sliderControl = new SliderControl();
    lmap.addControl(sliderControl);

    //пополняем тулбар
    var uploadFileIcon = L.control.gmxIcon({
        id: 'uploadFile',
        title: _gtxt('Загрузить объекты')
    }).on('click', drawingObjects.loadShp.load.bind(drawingObjects.loadShp));

    lmap.gmxControlIconManager.get('drawing').addIcon(uploadFileIcon);

    // выпадающие группы иконок наезжают на слайдер прозрачности.
    // Эта ф-ция разруливает этот конфликт, скрывая слайдер в нужный момент
    var resolveToolConflict = function(iconGroup) {
        iconGroup
            .on('collapse', function() {
                $('.gmx-slider-control').removeClass('invisible');
            }).on('expand', function() {
                sliderControl.isCollapsed() || $('.gmx-slider-control').addClass('invisible');
            });
    }

    if (_queryMapLayers.currentMapRights() === 'edit') {

        var saveMapIcon = L.control.gmxIcon({
            id: 'saveMap',
            title: _gtxt('Сохранить карту'),
            addBefore: 'drawing'
        })
            .addTo(lmap)
            .on('click', _queryMapLayers.saveMap.bind(_queryMapLayers));

        //группа создания слоёв
        var createVectorLayerIcon = L.control.gmxIcon({
            id: 'createVectorLayer',
            title: _gtxt('Создать векторный слой'),
            addBefore: 'drawing'
        }).on('click', _mapHelper.createNewLayer.bind(_mapHelper, 'Vector'));

        var createRasterLayerIcon = L.control.gmxIcon({
            id: 'createRasterLayer',
            title: _gtxt('Создать растровый слой'),
            addBefore: 'drawing'
        }).on('click', _mapHelper.createNewLayer.bind(_mapHelper, 'Raster'));

        var createLayerIconGroup = L.control.gmxIconGroup({
            id: 'createLayer',
            isSortable: true,
            //isCollapsible: false,
            items: [createVectorLayerIcon, createRasterLayerIcon],
            addBefore: 'drawing'
        }).addTo(lmap);

        var bookmarkIcon = L.control.gmxIcon({
            id: 'bookmark',
            title: _gtxt('Добавить закладку'),
            addBefore: 'drawing'
        }).on('click', function() {
            mapHelp.tabs.load('mapTabs');
            _queryTabs.add();
        }).addTo(lmap);

        resolveToolConflict(createLayerIconGroup);
    } else {
        resolveToolConflict(lmap.gmxControlIconManager.get('drawing'));
    }

    var printIcon = L.control.gmxIcon({
        id: 'gmxprint',
        title: _gtxt('Печать'),
        addBefore: 'drawing'
    })
        .addTo(lmap)
        .on('click', _mapHelper.print.bind(_mapHelper));

    var permalinkIcon = L.control.gmxIcon({
        id: 'permalink',
        title: _gtxt('Ссылка на карту'),
        addBefore: 'drawing'
    })
        .addTo(lmap)
        .on('click', _mapHelper.showPermalink.bind(_mapHelper));

    if (window.mapsSite) {
        var shareIconControl = new nsGmx.ShareIconControl({
            permalinkManager: {
                save: function() {
                    return $.when(
                        _mapHelper.createPermalink(),
                        nsMapCommon.generateWinniePermalink()
                    )
                }
            },
            permalinkUrlTemplate: '{{href}}?permalink={{permalinkId}}',
            embeddedUrlTemplate: 'http://winnie.kosmosnimki.ru/viewer.html?config={{winnieId}}',
            winnieUrlTemplate: 'http://winnie.kosmosnimki.ru/?config={{winnieId}}',
            previewUrlTemplate: 'iframePreview.html?width={{width}}&height={{height}}&permalinkUrl={{{embeddedUrl}}}'
        });
        lmap.addControl(shareIconControl);
    }

    var gridIcon = L.control.gmxIcon({
        id: 'gridTool',
        title: _gtxt('Координатная сетка'),
        togglable: true,
        addBefore: 'drawing'
    })
        .addTo(lmap)
        .on('click', function() {
            var state = {isActive: gridIcon.options.isActive};
            nsGmx.gridManager.setState(state);
        });

    _mapHelper.customParamsManager.addProvider({
        name: 'GridManager',
        loadState: function(state) {
            nsGmx.gridManager.setState(state);
        },
        saveState: function() {
            return {
                version: '1.0.0',
                isActive: gridIcon.options.isActive,
                options: nsGmx.gridManager.options
            }
        }
    });

	lmap.addControl(L.control.gmxIcon({
		id: 'boxzoom-dashed-rounded',
		toggle: true,
		addBefore: 'drawing',
		title: 'Увеличение',
		onAdd: function (control) {
			var map = control._map,
				_onMouseDown = map.boxZoom._onMouseDown;
			map.boxZoom._onMouseDown = function (e) {
				_onMouseDown.call(map.boxZoom, {
					clientX: e.clientX,
					clientY: e.clientY,
					which: 1,
					shiftKey: true
				});
			};
			map.on('boxzoomend', function () {
					map.dragging.enable();
					map.boxZoom.removeHooks();
					control.setActive(false);
			});
		},
		stateChange: function (control) {
			var map = control._map;
			if (control.options.isActive) {
				map.dragging.disable();
				map.boxZoom.addHooks();
			} else {
				map.dragging.enable();
				map.boxZoom.removeHooks();
			}
		}
	}));

    // var ToolsGroup = new L.Control.gmxIconGroup({
        // id: 'toolsGroup',
        // isSortable: true,
        // items: [gridIcon, bookmarkIcon]
    // }).addTo(lmap);
}

var createDefaultMenu = function() {
    _menuUp.submenus = [];

    _menuUp.addItem(
    {id:'mapsMenu', title:_gtxt('Карта'), childs: [
            {id:'mapCreate', title:_gtxt('Создать'),func:function(){_queryMapLayers.createMapDialog(_gtxt('Создать карту'), _gtxt('Создать'), _queryMapLayers.createMap)}},
            {id:'mapList', title:_gtxt('Открыть'),func:function(){_queryMapLayers.getMaps()}}
        ]
    });

    _menuUp.addItem(
    {id:'helpMenu', title:_gtxt('Справка'), childs: [
            {id:'usage', title:_gtxt('Использование'),onsel:mapHelp.mapHelp.load,onunsel:mapHelp.mapHelp.unload},
            {id:'serviceHelp', title:_gtxt('Сервисы'),onsel:mapHelp.serviceHelp.load,onunsel:mapHelp.serviceHelp.unload},
            {id:'about', title:_gtxt('О проекте'),func:_mapHelper.version}
        ]});
}

var parseURLParams = function() {
    var q = window.location.search,
        kvp = (q.length > 1) ? q.substring(1).split('&') : [];

    for (var i = 0; i < kvp.length; i++) {
        kvp[i] = kvp[i].split('=');
    }

    var params = {},
        givenMapName = false;

    for (var j=0; j < kvp.length; j++) {
        if (kvp[j].length == 1) {
            if (!givenMapName)
                givenMapName = decodeURIComponent(kvp[j][0]);
        }
        else {
            params[kvp[j][0]] = kvp[j][1];
        }
    }

    return {params: params, givenMapName: givenMapName};
}

$(function() {

    var virtualLayerManager = new nsGmx.VirtualLayerManager();
    L.gmx.addLayerClassLoader(virtualLayerManager.loader);

    $('body').on('keyup', function(event) {
        if ((event.target === document.body || $(event.target).hasClass('leaflet-container')) && event.keyCode === 79) {
            _queryMapLayers.getMaps();
            return false;
        }
    })

    var languageFromSettings = translationsHash.getLanguageFromCookies() || window.defaultLang;
    window.language = languageFromSettings || 'rus';

    window.shownTitle =  window.pageTitle || _gtxt('ScanEx Web Geomixer - просмотр карты');
    document.title = window.shownTitle;

    window.serverBase = _serverBase;

    addParseResponseHook('*', function(response, customErrorDescriptions) {
        if (response.Warning) {
            //мы дожидаемся загрузки дерева слоёв, чтобы не добавлять notification widget слишком рано (до инициализации карты в контейнере)
            _queryMapLayers.loadDeferred.then(function() {
                nsGmx.widgets.notifications.stopAction(null, 'warning', response.Warning, 0);
            });
        }
    })

    var customErrorTemplate = Handlebars.compile('<div class="CustomErrorText">{{description}}</div>'),
        commonErrorTemplate = Handlebars.compile(
            '<div class="CommonErrorText"><table class="CommonErrorTable">' +
                '<tr><td>{{message}}</td></tr>' +
                '<tr class="StacktraceContainer"><td class="StacktraceContainer">{{#if stacktrace}}<textarea class="inputStyle error StacktraceErrorText">{{stacktrace}}</textarea>{{/if}}</td></tr>' +
            '</table></div>'
        );

    //при каждой ошибке от сервера будем показывать диалог с ошибкой и стектрейсом.
    addParseResponseHook('error', function(response, customErrorDescriptions) {
        var errInfo = response.ErrorInfo;

        if (errInfo.ErrorMessage && !errInfo.ErrorMessage in _mapHelper.customErrorsHash) {
            if (customErrorDescriptions && errInfo.ExceptionType in customErrorDescriptions) {
                var canvas = $(customErrorTemplate({
                    description: customErrorDescriptions[errInfo.ExceptionType]
                }));
                showDialog(_gtxt('Ошибка!'), canvas[0], 220, 100);
            } else {
                var stackTrace = response.ErrorInfo.ExceptionType && response.ErrorInfo.StackTrace;
                var canvas = $(commonErrorTemplate({
                    message: errInfo.ErrorMessage,
                    stacktrace: stackTrace
                }));
                showDialog(_gtxt('Ошибка сервера'), canvas[0], 220, 170, false, false);
                return false;
            }
        }
    })

    _translationsHash.addErrorHandler(function(text) {
        showErrorMessage('Не найдено тектовое описание для "' + text + '"');
    })

    nsGmx.pluginsManager = new (gmxCore.getModule('PluginsManager').PluginsManager)();

    //будем сохранять в пермалинке все активные плагины
    _mapHelper.customParamsManager.addProvider({
        name: 'PluginManager',
        loadState: function(state) {
            for (var p in state.usage) {
                var plugin = nsGmx.pluginsManager.getPluginByName(p);

                plugin && plugin.setUsage(state.usage[p] ? 'used' : 'notused');
            }
        },
        saveState: function() {
            var usage = {};
            nsGmx.pluginsManager.forEachPlugin(function(plugin) {
                if (plugin.pluginName) {
                    usage[plugin.pluginName] = plugin.isUsed();
                }
            })

            return {
                version: '1.0.0',
                usage: usage
            }
        }
    });

    //сейчас подгружаются все глобальные плагины + все плагины карт, у которых нет имени в конфиге
    nsGmx.pluginsManager.done(function() {
        nsGmx.AuthManager.checkUserInfo(function() {
            nsGmx.pluginsManager.beforeMap();

            var parsedURL = parseURLParams();

            parseReferences(parsedURL.params, parsedURL.givenMapName);

        }, function() {
            //TODO: обработка ошибок
        })
    })
});

function parseReferences(params, givenMapName) {
    window.documentHref = window.location.href.split('?')[0];

    if (params['permalink']) {
        eraseCookie('TinyReference');
        createCookie('TinyReference', params['permalink']);

        window.location.replace(documentHref + (givenMapName ? ('?' + givenMapName) : ''));
        return;
    }

    var defaultState = { isFullScreen: params['fullscreen'] == 'true' || params['fullscreen'] == 'false' ? params['fullscreen'] : 'false' };

    if ('x' in params && 'y' in params && 'z' in params &&
        !isNaN(Number(params.x)) && !isNaN(Number(params.y)) && !isNaN(Number(params.z)))
        defaultState.position = {x: Number(params.x), y: Number(params.y), z: Number(params.z)}

    if ('mx' in params && 'my' in params &&
        !isNaN(Number(params.mx)) && !isNaN(Number(params.my)))
        defaultState.marker = {mx: Number(params.mx), my: Number(params.my), mt: 'mt' in params ? params.mt : false}

    if ('mode' in params)
        defaultState.mode = params.mode;

    if ('dt' in params) {
        defaultState.dt = params.dt;
    }

    window.defaultMapID = typeof window.defaultMapID !== 'undefined' ? window.defaultMapID : 'DefaultMap';

    var mapName = window.defaultMapID && !givenMapName ? window.defaultMapID : givenMapName;

    window.globalMapName = mapName;

    if (!window.globalMapName) {
        // нужно прописать дефолтную карту в конфиге
        alert(_gtxt('$$phrase$$_1'))

        return;
    } else {
        checkUserInfo(defaultState);
    }
}

function checkUserInfo(defaultState) {
    var tinyRef = readCookie('TinyReference');

    if (tinyRef) {
        eraseCookie('TinyReference');
        _mapHelper.restoreTinyReference(tinyRef, function(obj) {
            if (obj.mapName) {
                window.globalMapName = obj.mapName;
            }
            loadMap(obj);
        }, function() {
            loadMap(defaultState); //если пермалинк какой-то не такой, просто открываем дефолтное состояние
        });

        var tempPermalink = readCookie('TempPermalink');

        if (tempPermalink && tempPermalink == tinyRef) {
            nsGmx.Utils.TinyReference.remove(tempPermalink);
            eraseCookie('TempPermalink');
        }
    } else {
        loadMap(defaultState);
    }
}


window.layersShown = true;

window.resizeAll = function() {
    if (window.printMode) {
        return;
    }

    var top = 0,
        bottom = 0,
        right = 0,
        left = window.exportMode ? 0 : (layersShown ? 360 : 12),
        headerHeight = $('#header').outerHeight(),
        mainDiv = $('#flash')[0];

    mainDiv.style.left = left + 'px';
    mainDiv.style.top = top + 'px';
    mainDiv.style.width = getWindowWidth() - left - right + 'px';
    mainDiv.style.height = getWindowHeight() - top - headerHeight - bottom + 'px';

    nsGmx.leafletMap && nsGmx.leafletMap.invalidateSize();

    if (layersShown) {
        $('#leftMenu').show();

        var mapNameHeight = $('.mainmap-title').outerHeight();

        var baseHeight = getWindowHeight() - top - bottom - headerHeight;

        $('#leftMenu')[0].style.height = baseHeight + 'px'

        $('#leftContent')[0].style.top = ($('#leftPanelHeader')[0].offsetHeight + mapNameHeight) + 'px';
        $('#leftContent')[0].style.height = baseHeight -
            $('#leftPanelHeader')[0].offsetHeight -
            $('#leftPanelFooter')[0].offsetHeight -
            mapNameHeight + 'px';
    } else {
        $('#leftMenu').hide();
    }
}

var editUIInited = false;
var initEditUI = function(){
    if (editUIInited) {
        return;
    }

    var isEditableLayer = function(layer) {
        var props = layer.getGmxProperties(),
            layerRights = _queryMapLayers.layerRights(props.name);

        return props.type === 'Vector' &&
            (layerRights === 'edit' || layerRights === 'editrows');
    }

    var hasEditableLayer = false;
    for (var iL = 0; iL < nsGmx.gmxMap.layers.length; iL++)
        if (isEditableLayer(nsGmx.gmxMap.layers[iL])) {
            hasEditableLayer = true;
            break;
        }

    if (!hasEditableLayer) return;

    //добавляем пункт меню к нарисованным объектам
    nsGmx.ContextMenuController.addContextMenuElem({
        title: _gtxt('EditObject.drawingMenuTitle'),
        isVisible: function(context) {
            var active = $(_queryMapLayers.treeCanvas).find('.active');

            //должен быть векторный слой
            if ( !active[0] || !active[0].parentNode.getAttribute('LayerID') ||
                 !active[0].parentNode.gmxProperties.content.properties.type === 'Vector')
            {
                return false;
            }

            //TODO: проверить тип геометрии

            var layer = nsGmx.gmxMap.layersByID[active[0].parentNode.gmxProperties.content.properties.name];

            //слой поддерживает редактирование и у нас есть права на это
            return isEditableLayer(layer);
        },
        clickCallback: function(context) {
            var active = $(_queryMapLayers.treeCanvas).find('.active');
            var layerName = active[0].parentNode.gmxProperties.content.properties.name;
            new nsGmx.EditObjectControl(layerName, null, {drawingObject: context.obj});
        }
    }, 'DrawingObject');

    //добавляем пункт меню ко всем слоям
    nsGmx.ContextMenuController.addContextMenuElem({
        title: _gtxt('EditObject.menuTitle'),
        isVisible: function(context) {
            var layer = nsGmx.gmxMap.layersByID[context.elem.name];
            return !context.layerManagerFlag && isEditableLayer(layer);
        },
        clickCallback: function(context) {
            new nsGmx.EditObjectControl(context.elem.name);
        }
    }, 'Layer');

    //добавляем тул в тублар карты
    var listeners = {};
    var pluginPath = gmxCore.getModulePath('EditObjectPlugin');

    var editIcon = L.control.gmxIcon({
        id: 'editTool',
        title: _gtxt('Редактировать'),
        togglable: true,
        addBefore: 'gmxprint'
    }).addTo(nsGmx.leafletMap);

    editIcon.on('statechange', function() {
        if (editIcon.options.isActive) {

            var clickHandler = function(event) {
                var layer = event.target,
                    props = layer.getGmxProperties(),
                    id = event.gmx.properties[props.identityField];

                layer.bringToTopItem(id);
                new nsGmx.EditObjectControl(props.name, id, {event: event});
                return true; // TODO: как oтключить дальнейшую обработку события
            }

            for (var iL = 0; iL < nsGmx.gmxMap.layers.length; iL++) {
                var layer = nsGmx.gmxMap.layers[iL],
                    props = layer.getGmxProperties();

                if (layer.disableFlip && layer.disablePopup) {
                    layer.disableFlip();
                    layer.disablePopup();
                }

                listeners[props.name] = clickHandler.bind(null); //bind чтобы были разные ф-ции
                layer.on('click', listeners[props.name]);
            }
        } else {
            for (var layerName in listeners) {
                var pt = listeners[layerName];
                var layer = nsGmx.gmxMap.layersByID[layerName];
                if (layer) {
                    layer.off('click', listeners[layerName]);
                    layer.enableFlip();
                    layer.enablePopup();
                }
            }
            listeners = {};
        }
    });

    editUIInited = true;
}

function initAuthWidget() {
    var registrationCallback = function() {
        gmxCore.loadModule('ProfilePlugin').then(function(AccountModule) {
            AccountModule.showRegistrationForm(function () {
                window.location.reload();
            });
        })
    };

    var nativeAuthWidget = new nsGmx.GeoMixerAuthWidget($('<div/>')[0], nsGmx.AuthManager, function() {
        _mapHelper.reloadMap();
    }, {registrationCallback: registrationCallback});

    // прокси между nsGmx.AuthManager редактора и AuthManager'а из общей библиотеки
    var authManagerProxy = {
        getUserInfo: function(){
            var def = $.Deferred();
            nsGmx.AuthManager.checkUserInfo(function() {
                var auth = nsGmx.AuthManager;
                def.resolve({
                    Status: 'ok',
                    Result: {
                        Login: auth.getLogin(),
                        Nickname: auth.getNickname(),
                        FullName: auth.getFullname()
                    }
                });
            })
            return def;
        },

        login: function(){
            nativeAuthWidget.showLoginDialog();
        },

        logout: function(){
            var def = $.Deferred();
            nsGmx.AuthManager.logout(function() {
                def.resolve({Status: 'ok', Result: {}});
                _mapHelper.reloadMap();
            });
            return def;
        },
        getNative: function() {
            return nativeAuthWidget;
        }
    };
    nsGmx.widgets.authWidget = new nsGmx.AuthWidget({
        authManager: authManagerProxy,
        showAccountLink: !!window.mapsSite,
        accountLink: null,
        showMapLink: !!window.mapsSite,
        changePassword: !window.mapsSite
    });

    var authPlaceholder = nsGmx.widgets.header.getAuthPlaceholder();
    nsGmx.widgets.authWidget.appendTo(authPlaceholder);

    authPlaceholder.on('click', '#AuthWidgetAccountLink', function() {
        gmxCore.loadModule('ProfilePlugin').then(function(AccountModule) {
            AccountModule.showProfile();
        })
    });

    //ugly hack
    nsGmx.widgets.authWidget.showLoginDialog = nativeAuthWidget.showLoginDialog.bind(nativeAuthWidget);
}


function loadMap(state) {
    //при переходе на новое API мы изменили место хранения мапплетов карты
    //раньше мапплеты хранились в свойстве onLoad карты
    //теперь - внутри клиентских данных (UserData)

    nsGmx.mappletLoader = {
        _script: '',

        //UserObjectsManager interface
        collect: function() {
            return this._script;
        },
        load: function(data) {
            this._script = data;
        },

        //self public interface
        execute: function() {
            if (this._script) {
                var evalStr = '(' + this._script + ')';
                try {
                    eval(evalStr)();
                } catch (e) {
                    console.error(e);
                }
            }
        },
        get: function() {
            return this._script;
        },
        set: function(data) {
            this._script = data;
        }
    }
    nsGmx.userObjectsManager.addDataCollector('mapplet_v2', nsGmx.mappletLoader);

    layersShown = (state.isFullScreen == 'false');

    if (state.language) {
        window.language = state.language;
        translationsHash.updateLanguageCookies(window.language);
    }

    window.onresize = resizeAll;
    resizeAll();

    L.Icon.Default.imagePath = (window.gmxJSHost || '') + 'img';
	var iconUrl = L.Icon.Default.imagePath + '/flag_blau1.png';
	L.Marker = L.Marker.extend({
        options: {
            icon: new L.Icon.Default({
				iconUrl: iconUrl,
				iconSize: [36, 41],
				iconAnchor: [7, 37],
				popupAnchor: [3, -25],
				shadowUrl: iconUrl,
				shadowSize: [0, 0],
				shadowAnchor: [0, 0]
			})
        }
    });

    var hostName = L.gmxUtil.normalizeHostname(window.serverBase),
        apiKey = window.mapsSite ? window.apiKey : null; //передаём apiKey только если не локальная версия ГеоМиксера

    //мы явно получаем описание карты, но пока что не начинаем создание слоёв
    //это нужно, чтобы получить список плагинов и загрузить их до того, как начнутся создаваться слои
	var srs = window.mapOptions ? window.mapOptions.srs : '';
	if (!srs) { var arr = location.href.match(/[?&][cs]rs=(\d+)/); if (arr) { srs = arr[1]; } }
	var skipTiles = (window.mapOptions ? window.mapOptions.skipTiles : '') || window.gmxSkipTiles || '';
    L.gmx.gmxMapManager.loadMapProperties({
		srs: srs,
		serverHost: hostName,
		apiKey: apiKey,
		mapName: globalMapName,
		skipTiles: skipTiles
	}).then(function(mapInfo) {
        var userObjects = state.userObjects || (mapInfo && mapInfo.properties.UserData);
        userObjects && nsGmx.userObjectsManager.setData(JSON.parse(userObjects));

        //в самом начале загружаем только данные о плагинах карты.
        //Остальные данные будем загружать чуть позже после частичной инициализации вьюера
        //О да, формат хранения данных о плагинах часто менялся!
        //Поддерживаются все предыдущие форматы из-за старых версий клиента и сложности обновления базы данных
        nsGmx.userObjectsManager.load('mapPlugins');
        nsGmx.userObjectsManager.load('mapPlugins_v2');
        nsGmx.userObjectsManager.load('mapPlugins_v3');

        //вызываем сразу после загрузки списка плагинов ГеоМиксера,
        //так как в state может содержаться информация о включённых плагинах
        if (state.customParamsCollection) {
            _mapHelper.customParamsManager.loadParams(state.customParamsCollection);
        }

        //после загрузки списка плагинов карты начали загружаться не глобальные плагины,
        //у которых имя плагина было прописано в конфиге. Ждём их загрузки.
        nsGmx.pluginsManager.done(function() {
            nsGmx.pluginsManager.preloadMap();
            L.gmx.loadMap(globalMapName, {
                srs: srs,
				skipTiles: skipTiles,
                hostName: window.serverBase,
                apiKey: apiKey,
                setZIndex: true,
                isGeneralized: 'isGeneralized' in window ? window.isGeneralized : true
            }).then(processGmxMap.bind(null, state));
        })
    }, function(resp) {
        initHeader();
        initAuthWidget();

        _menuUp.defaultHash = 'usage';

        _menuUp.createMenu = function() {
            createDefaultMenu();
            nsGmx.pluginsManager.addMenuItems(_menuUp);
        };

        _menuUp.go(nsGmx.widgets.header.getMenuPlaceholder()[0]);

        $('#left_usage').hide();

        _menuUp.checkView();

        var str = resp && resp.ErrorInfo && resp.ErrorInfo.ErrorMessage ? resp.ErrorInfo.ErrorMessage : 'У вас нет прав на просмотр данной карты';
		nsGmx.widgets.notifications.stopAction(null, 'failure', _gtxt(str) || str, 0);

        window.onresize = resizeAll;
        resizeAll();

        state.originalReference && createCookie('TinyReference', state.originalReference);

        nsGmx.widgets.authWidget.showLoginDialog();
    });
}

//создаём подложки в BaseLayerManager по описанию из config.js
function initDefaultBaseLayers() {

    var lang = L.gmxLocale.getLanguage(),
        iconPrefix = 'img/baseLayers/',
        blm = nsGmx.leafletMap.gmxBaseLayersManager,
        zIndexOffset = 2000000,
        defaultMapID = window.baseMap.defaultMapID,
        promises = [],
        defaultHostName;

    if (window.baseMap.defaultHostName) {
        defaultHostName = window.baseMap.defaultHostName === '/' ? _serverBase : window.baseMap.defaultHostName;
    } else {
        defaultHostName = 'maps.kosmosnimki.ru';
    }

    if (window.baseMap.baseLayers) {
        var baseLayers = window.baseMap.baseLayers,
            bl;

        // проставляем дефолтным слоям свойства, зависящие от путей, языка, zIndex
        for (var i = 0; i < baseLayers.length; i++) {
            bl = baseLayers[i];
            // у Спутника в конфиге нет иконки и копирайта
            if (bl.id === 'sputnik') {
                bl.icon = iconPrefix + 'basemap_sputnik_ru.png';
                bl.layers[0].attribution = '<a href="http://maps.sputnik.ru">Спутник</a> © ' + (lang === 'rus' ? 'Ростелеком' : 'Rostelecom') + ' | © <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>';
            }
            // у ОСМ в конфиге нет иконки и урл
            if (bl.id === 'OSM') {
                bl.icon = iconPrefix + 'basemap_osm_' + (lang === 'rus' ? 'ru' : 'eng') + '.png',
                bl.layers[0].urlTemplate = 'http://{s}.tile.osm.kosmosnimki.ru/kosmo' + (lang === 'rus' ? '' : '-en') + '/{z}/{x}/{y}.png';
            }
            // у гибрида в конфиге нет урл
            if (bl.id === 'OSMHybrid') {
                bl.layers[0].urlTemplate = 'http://{s}.tile.osm.kosmosnimki.ru/kosmohyb' + (lang === 'rus' ? '' : '-en') + '/{z}/{x}/{y}.png';
                // bl.layers[0].setZIndex(zIndexOffset);
            }
            // у спутника нет иконки
            if (bl.id === 'satellite') {
                bl.icon = iconPrefix + 'basemap_satellite.png';
            }
        }

        for (var i = 0; i < baseLayers.length; i++) {
            var bl = baseLayers[i];
            if (bl.layers && bl.layers.length) {
                var l = bl.layers;
                for (var j = 0; j < l.length; j++) {
                    if (l[j].urlTemplate) {
                        // заменяем в подложках с айди описания слоев на L.tileLayers
                        l[j] = L.tileLayer(l[j].urlTemplate, l[j]);
                    } else {
                        var currentTl = bl,
                            layerID = l[j].layerID,
                            hostName = l[j].hostName || defaultHostName,
                            mapID = l[j].mapID || defaultMapID;

                            // resolve promise -> заменяем в подложках с айди описания слоев на gmxLayers
                            var promise = L.gmx.loadLayer(mapID, layerID, {hostName: hostName}).then(function(layer) {
                                var id = layer.getGmxProperties().name;
                                for (var k = 0; k < baseLayers.length; k++) {
                                    var bl = baseLayers[k];

                                    if (bl.layers && bl.layers.length) {
                                        var l = bl.layers;

                                        for (var m = 0; m < l.length; m++) {
                                            if (l[m].layerID && l[m].layerID === id) {
                                                l[m] = layer;
                                            }
                                        }
                                    }
                                }
                            });

                        promises.push(promise);
                    }
                }
            }
        }
    }
        return L.gmx.Deferred.all.apply(null, promises).then(function() {
            if (window.baseMap.baseLayers) {
                var layers = window.baseMap.baseLayers,
                    layersToLoad = {};

                layers.forEach(function(bl) {
                    layersToLoad[bl.id] = bl;
                });

                // добавим в гибрид снимок
                if (layersToLoad.satellite && layersToLoad.OSMHybrid) {
                    layersToLoad.OSMHybrid.layers[0].setZIndex(zIndexOffset);
                    layersToLoad.OSMHybrid.layers.push(layersToLoad.satellite.layers[0]);
                }

                _.each(layersToLoad, function(l, name) {
                    blm.add(name, l);
                });
            }
        });
}

// Инициализации шапки. Будем оттягивать с инициализацией до последнего момента, так как при инициализации
// требуется знать текущий язык, а он становится известен только после загрузки карты
function initHeader() {
    var rightLinks = [];
    if (nsGmx.AuthManager.isRole(nsGmx.ROLE_ADMIN)) {
        rightLinks.push({
            title: _gtxt('Администрирование'),
            dropdown: [{
                title: _gtxt('Системные настройки'),
                link: serverBase + 'Administration/Actions.aspx'
            }, {
                title: _gtxt('Управление группами'),
                link: 'javascript:void(0)',
                id: 'usergroupMenuItem'
            }]
        })
    }

    nsGmx.widgets.header = new nsGmx.HeaderWidget({
        leftLinks: nsGmx.addHeaderLinks(),
        rightLinks: rightLinks,
        logo: (window.gmxViewerUI && window.gmxViewerUI.logoImage) || 'img/geomixer_transpar.png'
    });

    nsGmx.widgets.header.appendTo($('.header'));

    $('.header').find('#usergroupMenuItem').click(function() {
        gmxCore.loadModule('UserGroupWidget').then(function(module) {
            var canvas = $('<div/>');
            new module.UserGroupListWidget(canvas);
            canvas.dialog({
                width: 400,
                height: 400,
                title: _gtxt('Управление группами пользователей')
            });
        });
    })
}

function processGmxMap(state, gmxMap) {
	var DEFAULT_VECTOR_LAYER_ZINDEXOFFSET = 2000000;
    var defCenter = [55.7574, 37.5952],
        mapProps = gmxMap.properties,
        defZoom = mapProps.DefaultZoom || 5,
        data = gmxMap.rawTree;

    if (mapProps.DefaultLat && mapProps.DefaultLong) {
        defCenter = [mapProps.DefaultLat, mapProps.DefaultLong];
    } else {
        //подсчитаем общий extend всех видимых слоёв
        var visBounds = L.latLngBounds([]);



        for (var l = 0; l < gmxMap.layers.length; l++) {
            var layer = gmxMap.layers[l];

            if (layer.getGmxProperties().visible && layer.getBounds) {
                visBounds.extend(layer.getBounds());
            }
        }

        if (visBounds.isValid()) {
            //вычислям центр и максимальный zoom по bounds (map.fitBounds() использовать не можем, так как ещё нет карты)
            var proj = L.Projection.Mercator;
            var mercBounds = L.bounds([proj.project(visBounds.getNorthWest()), proj.project(visBounds.getSouthEast())]);
            var ws = 2*proj.project(L.latLng(0, 180)).x,
                screenSize = [$('#flash').width(), $('#flash').height()];

            var zoomX = Math.log( ws * screenSize[0] / (mercBounds.max.x - mercBounds.min.x))/Math.log(2) - 8;
            var zoomY = Math.log( ws * screenSize[1] / (mercBounds.max.y - mercBounds.min.y))/Math.log(2) - 8;

            defZoom = Math.floor(Math.min(zoomX, zoomY, 17));
            defCenter = proj.unproject(mercBounds.getCenter());
        }
    }

    //если информации о языке нет ни в куках ни в config.js, то используем данные о языке из карты
    if (!translationsHash.getLanguageFromCookies() && !window.defaultLang && data) {
        window.language = data.properties.DefaultLanguage;
    }

    initHeader();

    if (!window.gmxViewerUI || !window.gmxViewerUI.hideLanguage) {
        var langContainer = nsGmx.widgets.header.getLanguagePlaceholder();
        nsGmx.widgets.languageWidget = new nsGmx.LanguageWidget();
        nsGmx.widgets.languageWidget.appendTo(langContainer);
    }
	var mapOptions = L.extend(window.mapOptions ? window.mapOptions : {}, {
        contextmenu: true,
        // если есть пермалинк, центрируем и зумируем карту сразу по его параметрам
        center: state.position ? [state.position.y, state.position.x] : defCenter,
        zoom: state.position ? state.position.z : defZoom,
        // boxZoom: false,
        zoomControl: false,
        attributionControl: false,
        trackResize: true,
        fadeAnimation: !window.gmxPhantom,  // отключение fadeAnimation при запуске тестов
        zoomAnimation: !window.gmxPhantom,  // отключение zoomAnimation при запуске тестов
        distanceUnit: mapProps.DistanceUnit,
        squareUnit: mapProps.SquareUnit,
        minZoom: mapProps.MinZoom || undefined,
        maxZoom: mapProps.MaxZoom || undefined,
        maxPopupCount: mapProps.maxPopupContent
    });

    var lmap = new L.Map($('#flash')[0], mapOptions);


    // update layers zIndexes
    var currentZoom = lmap.getZoom(),
        layerOrder = gmxMap.rawTree.properties.LayerOrder;

    updateZIndexes ();

    lmap.on('zoomend', function(e) {
        currentZoom = lmap.getZoom();
        updateZIndexes();
    })

    //clip polygons
    if (mapProps.MinViewX && mapProps.MinViewY && mapProps.MaxViewX && mapProps.MaxViewY) {
        lmap.on('layeradd', function(e) {
            if (e.layer.addClipPolygon) {
                _mapHelper.clipLayer(e.layer, mapProps);
            }
        })
    }

    // bind clusters to photoLayers
    for (var l = 0; l < gmxMap.layers.length; l++) {
        var layer = gmxMap.layers[l],
            props = layer.getGmxProperties();

        if (props.IsPhotoLayer) {
            layer.bindClusters({
                iconCreateFunction: function(cluster) {
                    var photoClusterIcon = L.divIcon({
                        html: '<img src="http://maps.kosmosnimki.ru/api/img/camera18.png" class="photo-icon"/><div class="marker-cluster-photo">' + cluster.getChildCount() + '</div>',
                        className: 'photo-div-icon',
                        iconSize: [14, 12],
                        iconAnchor: [0, 0]
                    });
                    return photoClusterIcon;
                },
                maxClusterRadius: 40,
                spiderfyOnMaxZoom: true,
                spiderfyDistanceMultiplier: 1.2,
                disableClusteringAtZoom: 19,
                maxZoom: 19
            });
        }
    }
    lmap.contextmenu.insertItem({
        text: _gtxt('Поставить маркер'),
        callback: function(event) {
            lmap.gmxDrawing.addGeoJSON({type: 'Point', coordinates: [event.latlng.lng, event.latlng.lat]});
        }
    })

    lmap.contextmenu.insertItem({
        text: _gtxt('Центрировать'),
        callback: function(event) {
            lmap.setView(event.latlng);
        }
    });

    function updateZIndexes () {
        for (var l = 0; l < gmxMap.layers.length; l++) {
            var layer = gmxMap.layers[l],
                props = layer.getGmxProperties();

            switch (layerOrder) {
                case 'VectorOnTop':
                if (props.type === 'Vector' && layer.setZIndexOffset) {
                    var minZoom,
                        rcMinZoom,
                        quickLookMinZoom,
                        defaultMinZoom = 6;

                    if (props.IsRasterCatalog || (props.Quicklook && props.Quicklook !== 'null')) {
                        rcMinZoom = props.IsRasterCatalog ? props.RCMinZoomForRasters : null;
                        quickLookMinZoom = (props.Quicklook && nsGmx.Utils.isJSON(props.Quicklook)) ? JSON.parse(props.Quicklook).minZoom : null;

                        if (props.IsRasterCatalog && !props.Quicklook) {
                            minZoom = nsGmx.Utils.checkForNumber(rcMinZoom) ? rcMinZoom : defaultMinZoom;
                        } else if (!props.IsRasterCatalog && props.Quicklook) {
                            minZoom = nsGmx.Utils.checkForNumber(quickLookMinZoom) ? quickLookMinZoom : defaultMinZoom;
                        } else if (props.IsRasterCatalog && props.Quicklook) {
                            rcMinZoom = nsGmx.Utils.checkForNumber(rcMinZoom) ? rcMinZoom : defaultMinZoom;
                            quickLookMinZoom = nsGmx.Utils.checkForNumber(quickLookMinZoom) ? quickLookMinZoom : defaultMinZoom;

                            minZoom = Math.min(rcMinZoom, quickLookMinZoom);
                        }
                        layer.setZIndexOffset(currentZoom < rcMinZoom ? DEFAULT_VECTOR_LAYER_ZINDEXOFFSET : 0);
                    } else {
                        layer.setZIndexOffset(DEFAULT_VECTOR_LAYER_ZINDEXOFFSET);
                    }
                }
                break;
            }
        }
    }

	// Begin: запоминание текущей позиции карты
	function saveMapPosition(key) {
		window.localStorage.setItem('lastMapPosiotion_' + key, JSON.stringify({zoom: lmap.getZoom(), center: lmap.getCenter()}));
	}
	function getMapPosition(key) {
		return JSON.parse(localStorage.getItem('lastMapPosiotion_' + key));
	}
	lmap.on('boxzoomstart', function(ev) { saveMapPosition('z'); });
	L.DomEvent.on(document, 'keydown', function(ev) {
		var key = ev.key;
		if (lmap.gmxMouseDown === 1) {
			var pos = getMapPosition(key);
			if (pos && (key === 'z' || Number(key) >= 0)) {
				lmap.setView(pos.center, pos.zoom);
			}
		} else if (lmap.gmxMouseDown > 1) {
			if (Number(key) >= 0) {
				saveMapPosition(key);
			}
		}

	}, lmap);
	// End: запоминание текущей позиции карты

    lmap.gmxControlsManager.init(window.controlsOptions);
    lmap.addControl(new L.Control.gmxLayers(lmap.gmxBaseLayersManager, {hideBaseLayers: true}));
    nsGmx.leafletMap = lmap;

    var loc = nsGmx.leafletMap.gmxControlsManager.get('location');

    loc.setCoordinatesFormat(gmxMap.properties.coordinatesFormat);

    loc.on('coordinatesformatchange', function(ev) {
        nsGmx.leafletMap.options.coordinatesFormat = ev.coordinatesFormat;
    });

    var baseLayerDef = 'baseMap' in window ? initDefaultBaseLayers() : lmap.gmxBaseLayersManager.initDefaults({apiKey: window.apiKey, srs: lmap.options.srs});

    baseLayerDef.always(function() {

        nsGmx.gmxMap = gmxMap;
        gmxAPI.layersByID = gmxMap.layersByID; // слои по layerID

        var mapProp = gmxMap.rawTree.properties || {}
        var baseLayers = mapProp.BaseLayers ? JSON.parse(mapProp.BaseLayers) : [window.language === 'eng' ? 'mapbox' : 'sputnik', 'OSMHybrid', 'satellite'];

        lmap.gmxBaseLayersManager.setActiveIDs(baseLayers);

        var baseLayersControl = new L.Control.GmxIconLayers(lmap.gmxBaseLayersManager, {id: 'iconLayers'});
        lmap.gmxControlsManager.add(baseLayersControl);

        lmap.addControl(baseLayersControl);

        /**
         *
         * OPERATIVE NEW COMMONCALENDAR TEST
         * START
         *
        */
        // if (mapProp.MapID === 'ATTBP') {
        nsGmx.widgets.commonCalendar = new nsGmx.CommonCalendarWidget();

        // добавление временных слоев в commonCalendar
        // добавление происходит безопасно, в клон объекта со списком слоев
        var initTemporalLayers = function(layers) {
            layers = layers || nsGmx.gmxMap.layers;

            var attrs = nsGmx.widgets.commonCalendar.model.toJSON(),
                showCalendar = undefined,
                dateInterval,
                dateBegin,
                dateEnd;

            for (var i = 0; i < layers.length; i++) {
                var layer = layers[i],
                    props = layer.getGmxProperties(),
                    isVisible = props.visible,
                    isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                if (isTemporalLayer) {
                    // показываем виджет календаря, если в карте есть хоть один мультивременной слой
                    showCalendar = true;

                    dateInterval = layer.getDateInterval ? layer.getDateInterval() : new nsGmx.DateInterval();

                    if (dateInterval.beginDate && dateInterval.endDate) {
                        dateBegin = dateInterval.beginDate;
                        dateEnd = dateInterval.endDate;
                    } else {
                        dateInterval = new nsGmx.DateInterval();
                        dateBegin = dateInterval.get('dateBegin');
                        dateEnd = dateInterval.get('dateEnd');
                    }

                    if (props.name in attrs.unbindedTemporalLayers) {
                        nsGmx.widgets.commonCalendar.bindLayer(props.name);
                    }

                    layer.setDateInterval(dateBegin, dateEnd);

                    if (props.LayerID in attrs.dailyFiltersHash) {
                        nsGmx.widgets.commonCalendar.applyDailyFilter([layer]);
                    }

                    //подписка на изменение dateInterval
                    if (layer.getDateInterval) {
                        layer.on('dateIntervalChanged', nsGmx.widgets.commonCalendar.onDateIntervalChanged, nsGmx.widgets.commonCalendar);
                    }
                }
            }

            nsGmx.widgets.commonCalendar.updateVisibleTemporalLayers(nsGmx.gmxMap.layers);

            if (showCalendar && !attrs.isAppended) {
                nsGmx.widgets.commonCalendar.show();
            }
        }

        // привяжем изменение активной ноды к календарю
        $(_layersTree).on('activeNodeChange', function(e, p) {
            var layerID = $(p).attr('layerid'),
                calendar = nsGmx.widgets.commonCalendar.model.get('calendar'),
                synchronyzed = nsGmx.widgets.commonCalendar.model.get('synchronyzed');

            lmap.fireEvent('layersTree.activeNodeChange', {layerID: layerID});
        });

        $(_layersTree).on('layerVisibilityChange', function(event, elem) {
            var props = elem.content.properties,
                attrs = nsGmx.widgets.commonCalendar.model.toJSON(),
                visible = props.visible,
                layerID = props.LayerID,
                calendar = attrs.calendar,
                currentLayer = attrs.currentLayer,
                synchronyzed = attrs.synchronyzed;

            if (synchronyzed) {
                return;
            } else {
                if (layerID) {
                    var layer = nsGmx.gmxMap.layersByID[layerID],
                        props = layer.getGmxProperties(),
                        isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval),
                        visibleTemporalLayers, index;

                    if (isTemporalLayer) {
                        if (visible) {
                            if (currentLayer) {
                                return;
                            } else {
                                var dateInterval = layer.getDateInterval();

                                if (dateInterval.beginDate && dateInterval.endDate) {
                                    nsGmx.widgets.commonCalendar.setDateInterval(dateInterval.beginDate, dateInterval.endDate, layer);
                                }
                            }
                        } else {
                            if (currentLayer) {
                                if (layerID !== currentLayer) {
                                    return;
                                } else {
                                    visibleTemporalLayers = getLayersListWithTarget(nsGmx.gmxMap.layers, layer),
                                    index = visibleTemporalLayers.indexOf(layer);

                                    if (visibleTemporalLayers.length === 1) {
                                        nsGmx.widgets.commonCalendar.model.set('currentLayer', null);
                                    } else {
                                            if (index === 0) {
                                                var targetLayer = visibleTemporalLayers[index + 1],
                                                    targetLayerID = targetLayer.getGmxProperties().LayerID,
                                                    dateInterval = targetLayer.getDateInterval();

                                                nsGmx.widgets.commonCalendar.setDateInterval(dateInterval.beginDate, dateInterval.endDate, targetLayer);
                                                // nsGmx.widgets.commonCalendar.model.set('currentLayer', targetLayerID)
                                            } else {
                                                var targetLayer = visibleTemporalLayers[index - 1],
                                                    targetLayerID = targetLayer.getGmxProperties().LayerID,
                                                    dateInterval = targetLayer.getDateInterval();

                                                nsGmx.widgets.commonCalendar.setDateInterval(dateInterval.beginDate, dateInterval.endDate, targetLayer);
                                                // nsGmx.widgets.commonCalendar.model.set('currentLayer', targetLayerID)
                                            }
                                        }

                                }
                            } else {
                                return;
                            }
                        }
                    }
                }
            }
            nsGmx.widgets.commonCalendar.updateVisibleTemporalLayers(nsGmx.gmxMap.layers);

            function getLayersListWithTarget(layers, targetLayer) {
                var visibleTemporalLayers = [];
                for (var i = 0; i < layers.length; i++) {
                    var layer = layers[i],
                    props = layer.getGmxProperties && layer.getGmxProperties(),
                    isTemporalLayer,
                    isVisible;

                    if (props) {
                        isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);
                        isVisible = props.visible;

                        if (isTemporalLayer && isVisible || layer === targetLayer) {
                            visibleTemporalLayers.push(layer);
                        }
                    }
                }
                return visibleTemporalLayers;
            }
        });



        lmap.on('gmxTimeLine.currentTabChanged', function(ev) {
            var layerID = ev.currentTab,
                layer = nsGmx.gmxMap.layersByID[layerID],
                synchronyzed = nsGmx.widgets.commonCalendar.model.get('synchronyzed'),
                props = layer.getGmxProperties(),
                isVisible = props.visible,
                isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

            if (isTemporalLayer && isVisible && !synchronyzed) {
                nsGmx.widgets.commonCalendar.model.set('currentLayer', layerID);
            }

        });

        _mapHelper.customParamsManager.addProvider({
            name: 'commonCalendar',
            loadState: function(state) {
                if (!('version' in state)) {
                    var tmpDateInterval = new nsGmx.DateInterval({
                        dateBegin: new Date(state.dateBegin),
                        dateEnd: new Date(state.dateEnd)
                    });
                    nsGmx.widgets.commonCalendar.getDateInterval().loadState(tmpDateInterval.saveState());
                } else if (state.version === '1.0.0') {
                    nsGmx.widgets.commonCalendar.model.set('synchronyzed', typeof(state.synchronyzed) !== 'undefined' ? state.synchronyzed : true);
                    nsGmx.widgets.commonCalendar.model.set('currentLayer', typeof(state.currentLayer) !== 'undefined' ? state.currentLayer : null);
                    nsGmx.widgets.commonCalendar.getDateInterval().loadState(state.dateInterval);
                    nsGmx.widgets.commonCalendar.model.set('dailyFilter', typeof(state.dailyFilter) !== 'undefined' ? state.dailyFilter : true);
                } else {
                    throw 'Unknown params version';
                }
            },
            saveState: function() {
                return {
                    version: '1.0.0',
                    dateInterval: nsGmx.widgets.commonCalendar.getDateInterval().saveState(),
                    currentLayer: nsGmx.widgets.commonCalendar.model.get('currentLayer'),
                    synchronyzed: nsGmx.widgets.commonCalendar.model.get('synchronyzed'),
                    dailyFilter: nsGmx.widgets.commonCalendar.model.get('dailyFilter')
                };
            }
        });

        /**
         *
         * OPERATIVE
         * END
         *
        */
    // } else {
        // var now = new Date();
        // nsGmx.widgets.commonCalendar = {
        //     _calendar: null,
        //     _dateInterval: new nsGmx.DateInterval(),
        //     _isAppended: false,
        //     _unbindedTemporalLayers: {},
        //     active: true,
        //     setActive: function (active) {
        //         this.active = active;
        //     },
        //     getDateInterval: function() {
        //         return this._dateInterval;
        //     },
        //     get: function() {
        //         var _this = this;
        //         if (!this._calendar) {
        //             this._calendar = new nsGmx.CalendarWidget({
        //                 minimized: true,
        //                 dateMin: new Date(2000, 1, 1),
        //                 dateMax: this._dateInterval.get('dateEnd'),
        //                 dateInterval: this._dateInterval
        //             });
        //
        //             this._dateInterval.on('change', this.updateTemporalLayers.bind(this, null));
        //             this.updateTemporalLayers();
        //         }
        //
        //         return this._calendar;
        //     },
        //     replaceCalendarWidget: function(newCalendar) {
        //         this._calendar = newCalendar;
        //
        //         //заменим виджет перед деревом слоёв
        //         if (this._isAppended) {
        //             var doChange = function() {
        //                 var calendarDiv = $('<div class="common-calendar-container"></div>').append(newCalendar.canvas);
        //                 // special for steppe project
        //                 if (nsGmx.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
        //                     _queryMapLayers.getContainerAfter().find('.common-calendar-container').replaceWith(calendarDiv);
        //                 } else {
        //                     _queryMapLayers.getContainerBefore().find('.common-calendar-container').replaceWith(calendarDiv);
        //                 }
        //             }
        //             //явная проверка, так как хочется быть максимально синхронными в этом методе
        //             if (_queryMapLayers.loadDeferred.state() === 'resolved') {
        //                 doChange();
        //             } else {
        //                 _queryMapLayers.loadDeferred.then(doChange);
        //             }
        //         }
        //     },
        //     show: function() {
        //         var doAdd = function() {
        //             var calendarDiv = $('<div class="common-calendar-container"></div>').append(this.get().canvas);
        //             // special for steppe Project
        //             if (nsGmx.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
        //                 _queryMapLayers.getContainerAfter().append(calendarDiv);
        //             } else {
        //                 _queryMapLayers.getContainerBefore().append(calendarDiv);
        //             }
        //             this._isAppended = true;
        //         }.bind(this);
        //
        //         if (!this._isAppended) {
        //             //явная проверка, так как хочется быть максимально синхронными в этом методе
        //             if (_queryMapLayers.loadDeferred.state() === 'resolved') {
        //                 doAdd();
        //             } else {
        //                 _queryMapLayers.loadDeferred.then(doAdd);
        //             }
        //         }
        //     },
        //     hide: function() {
        //         this._isAppended && $(this.get().canvas).hide();
        //         this._isAppended = false;
        //     },
        //
        //     bindLayer: function(layerName) {
        //         delete this._unbindedTemporalLayers[layerName];
        //         this.updateTemporalLayers();
        //     },
        //     unbindLayer: function(layerName) {
        //         this._unbindedTemporalLayers[layerName] = true;
        //     },
        //     _updateOneLayer: function(layer, dateBegin, dateEnd) {
        //         var props = layer.getGmxProperties();
        //         if (props.maxShownPeriod) {
        //             var msecPeriod = props.maxShownPeriod*24*3600*1000;
        //             var newDateBegin = new Date( Math.max(dateBegin.valueOf(), dateEnd.valueOf() - msecPeriod));
        //             layer.setDateInterval(newDateBegin, dateEnd);
        //         } else {
        //             layer.setDateInterval(dateBegin, dateEnd);
        //         }
        //     },
        //     updateTemporalLayers: function(layers) {
        //         if (!this._calendar || !this.active) {return;}
        //         var layers = layers || nsGmx.gmxMap.layers,
        //             dateBegin = this._dateInterval.get('dateBegin'),
        //             dateEnd = this._dateInterval.get('dateEnd'),
        //             layersMaxDates = [],
        //             maxDate = null;
        //
        //         for (var i = 0, len = layers.length; i < len; i++) {
        //             var layer = layers[i],
        //                 props = layer.getGmxProperties(),
        //                 isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);
        //
        //             if (isTemporalLayer && !(props.name in this._unbindedTemporalLayers)) {
        //                 if (props.DateEnd) {
        //                     var localeDate = $.datepicker.parseDate('dd.mm.yy', props.DateEnd);
        //                     layersMaxDates.push(localeDate);
        //                 }
        //
        //                 this._updateOneLayer(layer, dateBegin, dateEnd);
        //             }
        //         }
        //
        //         if (layersMaxDates.length > 0) {
        //             layersMaxDates.sort(function(a, b) {
        //                 return b - a;
        //             });
        //
        //             maxDate = new Date(layersMaxDates[0]);
        //
        //             if (maxDate > new Date()) {
        //                 this._calendar.setDateMax(nsGmx.CalendarWidget.fromUTC(maxDate));
        //             } else {
        //                 this._calendar.setDateMax(new Date());
        //             }
        //         }
        //     }
        // }
        //
        // //устарело, используйте commonCalendar
        // nsGmx.widgets.getCommonCalendar = function() {
        //     nsGmx.widgets.commonCalendar.show();
        //     return nsGmx.widgets.commonCalendar.get();
        // }
        //
        // var initTemporalLayers = function(layers) {
        //     layers = layers || nsGmx.gmxMap.layers;
        //     for (var i = 0; i < layers.length; i++) {
        //         var props = layers[i].getGmxProperties();
        //         if (props.Temporal && nsGmx.widgets.commonCalendar._unbindedTemporalLayers && !(props.name in nsGmx.widgets.commonCalendar._unbindedTemporalLayers)) {
        //             nsGmx.widgets.commonCalendar.show();
        //             break;
        //         }
        //     }
        //
        //     nsGmx.widgets.commonCalendar.updateTemporalLayers(layers);
        // }
        //
        // _mapHelper.customParamsManager.addProvider({
        //     name: 'commonCalendar',
        //     loadState: function(state) {
        //         if (!('version' in state)) {
        //             var tmpDateInterval = new nsGmx.DateInterval({
        //                 dateBegin: new Date(state.dateBegin),
        //                 dateEnd: new Date(state.dateEnd)
        //             });
        //             nsGmx.widgets.commonCalendar.getDateInterval().loadState(tmpDateInterval.saveState());
        //         } else if (state.version === '1.0.0') {
        //             nsGmx.widgets.commonCalendar.getDateInterval().loadState(state.dateInterval);
        //         } else {
        //             throw 'Unknown params version';
        //         }
        //     },
        //     saveState: function() {
        //         return {
        //             version: '1.0.0',
        //             dateInterval: nsGmx.widgets.commonCalendar.getDateInterval().saveState()
        //         };
        //     }
        // });

    // }

        $('#flash').bind('dragover', function() {
            return false;
        });

        $('#flash').bind('drop', function(e) {
            if (!e.originalEvent.dataTransfer) {
                return;
            }

            _queryLoadShp.loadAndShowFiles(e.originalEvent.dataTransfer.files);

            return false;
        })

        if (state.dt) {
            try {
                var dateLocal = $.datepicker.parseDate('dd.mm.yy', state.dt);
                var dateBegin = nsGmx.CalendarWidget.fromUTC(dateLocal);
                var dateEnd = new Date(dateBegin.valueOf() + 24*3600*1000);
                var dateInterval = nsGmx.widgets.commonCalendar.getDateInterval();
                dateInterval.set({
                    dateBegin: dateBegin,
                    dateEnd: dateEnd
                });
            } catch(e) {}
        }

        nsGmx.pluginsManager.beforeViewer();

        //для каждого ответа сервера об отсутствии авторизации (Status == 'auth') сообщаем об этом пользователю или предлагаем залогиниться
        addParseResponseHook('auth', function() {
            if ( nsGmx.AuthManager.isLogin() ) {
                showErrorMessage(_gtxt('Недостаточно прав для совершения операции'), true);
            } else {
                nsGmx.widgets.authWidget.showLoginDialog();
            }

            return false;
        });

        initAuthWidget();

        //инициализация контролов пользовательских объектов
        //соответствующий модуль уже загружен
        var oDrawingObjectsModule = gmxCore.getModule('DrawingObjects');
        window.oDrawingObjectGeomixer = new oDrawingObjectsModule.DrawingObjectGeomixer();
        window.oDrawingObjectGeomixer.Init(nsGmx.leafletMap, nsGmx.gmxMap);

        //для всех слоёв должно выполняться следующее условие: если хотя бы одна групп-предков невидима, то слой тоже невидим.
        (function fixVisibilityConstrains (o) {
            o.content.properties.visible = o.content.properties.visible;

            if (o.type === 'group') {
                var a = o.content.children;

                var isAnyVisibleChild = false;

                for (var k = a.length - 1; k >= 0; k--) {
                    var childrenVisibility = fixVisibilityConstrains(a[k]);
                    isAnyVisibleChild = isAnyVisibleChild || childrenVisibility;
                }

                // если внутри группы есть включенные слои, группа тоже включается
                // если же ни одного включенного слоя нет, то группа выключается
                o.content.properties.visible = isAnyVisibleChild ? true: false;
            }
            return o.content.properties.visible;
        })({type: 'group', content: { children: data.children, properties: { visible: true } } });

        window.oldTree = JSON.parse(JSON.stringify(data));

        window.defaultLayersVisibility = {};

        for (var k = 0; k < gmxMap.layers.length; k++) {
            var props = gmxMap.layers[k].getGmxProperties();
            window.defaultLayersVisibility[props.name] = props.visible;
        }

        //основная карта всегда загружена с того-же сайта, что и серверные скрипты
        data.properties.hostName = window.serverBase.slice(7).slice(0, -1);

        //DEPRICATED. Do not use it!
        _mapHelper.mapProperties = data.properties;

        //DEPRICATED. Do not use it!
        _mapHelper.mapTree = data;

        if (window.copyright && typeof window.copyright === 'string') {
            lmap.gmxControlsManager.get('copyright').setMapCopyright(window.copyright);
        }

        var condition = false,
            mapStyles = false,
            LayersTreePermalinkParams = false;

        if (state.condition) {
            condition = state.condition;
        }

        if (state.mapStyles) {
            mapStyles = state.mapStyles;
        }
        if (state.LayersTreePermalinkParams) {
            LayersTreePermalinkParams = state.LayersTreePermalinkParams;
        }

        _queryMapLayers.addLayers(data, condition, mapStyles, LayersTreePermalinkParams);

        var headerDiv = $('<div class="mainmap-title">' + data.properties.title + '</div>').prependTo($('#leftMenu'));

        // special for steppe Project
        if (data.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
            $(headerDiv).toggle();
        }

        nsGmx.ContextMenuController.bindMenuToElem(headerDiv[0], 'Map', function()
            {
                return _queryMapLayers.currentMapRights() == 'edit';
            },
            function()
            {
                return {
                    div: $(_layersTree._treeCanvas).find('div[MapID]')[0],
                    tree: _layersTree
                }
            }
        );

        // _menuUp.defaultHash = 'layers';
        mapLayers.mapLayers.load();

        //создаём тулбар
        var iconContainer = _div(null, [['css', 'borderLeft', '1px solid #216b9c']]);

        var searchContainer = nsGmx.widgets.header.getSearchPlaceholder()[0];

        //инициализация контролов поиска (модуль уже загружен)
        var oSearchModule = gmxCore.getModule('search');
        window.oSearchControl = new oSearchModule.SearchGeomixer();

        // if (document.getElementById('searchCanvas')) {
        window.oSearchControl.Init({
            Menu: oSearchLeftMenu,
            ContainerInput: searchContainer,
            ServerBase: window.serverBase,
            layersSearchFlag: true,
            Map: lmap,
            gmxMap: gmxMap
        });

        _menuUp.createMenu = function() {
            createMenuNew();
        };

        _menuUp.go(nsGmx.widgets.header.getMenuPlaceholder()[0]);

        // Загружаем все пользовательские данные
        nsGmx.userObjectsManager.load();

        //выполняем мапплет карты нового формата
        nsGmx.mappletLoader.execute();

        //динамически добавляем пункты в меню. DEPRICATED.
        nsGmx.pluginsManager.addMenuItems(_menuUp);

        _mapHelper.gridView = false;

        var updateLeftPanelVis = function() {
            $('.leftCollapser-icon')
                .toggleClass('leftCollapser-right', !layersShown)
                .toggleClass('leftCollapser-left', !!layersShown);
            resizeAll();
        }

        $('#leftCollapser').click(function() {
            layersShown = !layersShown;
            updateLeftPanelVis();
        });
        updateLeftPanelVis();

        createToolbar();

        if (state.mode) {
            lmap.gmxBaseLayersManager.setCurrentID(lmap.gmxBaseLayersManager.getIDByAlias(state.mode) || state.mode);
        } else if (baseLayers.length && !lmap.gmxBaseLayersManager.getCurrentID()) {
            lmap.gmxBaseLayersManager.setCurrentID(baseLayers[0]);
        }

        if (state.drawings) {
            lmap.gmxDrawing.loadState(state.drawings);
        } else if (state.drawnObjects) {
            state.drawnObjects.forEach(function(objInfo) {
                //старый формат - число, новый - строка
                var lineStyle = {};

                if (objInfo.color) {
                    lineStyle.color = typeof objInfo.color === 'number' ? '#' + L.gmxUtil.dec2hex(objInfo.color) : objInfo.color;
                }

                if (objInfo.thickness) {lineStyle.weight = objInfo.thickness};
                if (objInfo.opacity) {lineStyle.opacity = objInfo.opacity/100};

                var featureOptions = $.extend(true, {}, objInfo.properties,  {
                    lineStyle: lineStyle
                });

                var drawingFeature = lmap.gmxDrawing.addGeoJSON(L.gmxUtil.geometryToGeoJSON(objInfo.geometry), featureOptions)[0];

                if (objInfo.isBalloonVisible) {
                    drawingFeature.openPopup();
                }
            });
        } else if (state.marker) {
            nsGmx.leafletMap.gmxDrawing.addGeoJSON({
                type: 'Feature',
                geometry: {type: 'Point', coordinates: [state.marker.mx, state.marker.my] },
                properties: { title: state.marker.mt }
            });
        }

        if (state.openPopups) {
            for (var l in state.openPopups) {
                var layer = nsGmx.gmxMap.layersByID[l];
                if (layer && layer.addPopup) {
                    state.openPopups[l].forEach(layer.addPopup.bind(layer));
                }
            }
        }

        _menuUp.checkView();

        if (nsGmx.AuthManager.isLogin()) {
            _queryMapLayers.addUserActions();
        }

        if (state.dateIntervals) {
            for (var lid in gmxMap.layersByID) {
                if (lid in state.dateIntervals) {
                    var l = gmxMap.layersByID[lid],
                        beginDate = new Date(state.dateIntervals[lid].beginDate),
                        endDate = new Date(state.dateIntervals[lid].endDate);

                    l.setDateInterval(beginDate, endDate);
                }
            }
        }

        initEditUI();
        initTemporalLayers();

        gmxMap.addLayersToMap(lmap);

        nsGmx.leafletMap.on('layeradd', function(event) {
            var layer = event.layer;

            if (layer.getGmxProperties) {
                var  layerProps = layer.getGmxProperties();

                initEditUI();
                initTemporalLayers([layer]);

            }
        });
        // if (mapProp.MapID !== 'ATTBP') {
        nsGmx.gmxMap.on('onRemoveLayer', function(event) {
            var layer = event.layer;
            if (!layer.getGmxProperties()) {
                return;
            }
            var props = layer.getGmxProperties(),
                isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

            if (isTemporalLayer && !(props.name in nsGmx.widgets.commonCalendar._unbindedTemporalLayers)) {
                nsGmx.widgets.commonCalendar.unbindLayer(props.name);
                nsGmx.widgets.commonCalendar.updateTemporalLayers();
                delete nsGmx.widgets.commonCalendar._unbindedTemporalLayers[props.name];
            }
        });
        // }

        // special for steppe project
        if (nsGmx.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
            nsGmx.widgets.commonCalendar.show();
        }

        nsGmx.pluginsManager.afterViewer();

        $('#leftContent').mCustomScrollbar();

        // экспорт карты

        if (state.exportMode) {
            _mapHelper.exportMap(state);
        }
    });
}

function mapExportMenu() {
    gmxCore.loadModule('MapExport', 'src/MapExport/MapExport.js').then(function (def) {
          var menu = new def.MapExportMenu();
          menu.Load();
  });
}

function indexGridMenu() {
    gmxCore.loadModule('IndexGrid', 'src/IndexGrid/IndexGrid.js').then(function (def) {
          var menu = new def.IndexGridMenu();
          menu.Load();
  });
}

function PhotoLayerDialog() {
    gmxCore.loadModule('PhotoLayer', 'src/PhotoLayer/PhotoLayer.js').then(function (def) {
          var dialog = new def.PhotoLayer();
          dialog.Load();
  });
}

function promptFunction(title, value) {
    var ui = $(Handlebars.compile(
            '<div class="gmx-prompt-canvas">' +
                '<input class="inputStyle gmx-prompt-input" value="{{value}}">' +
            '</div>')({value: value})
        );

    ui.find('input').on('keydown', function(e) {
        var evt = e || window.event;
        if (e.which === 13)
        {
            var coord = L.gmxUtil.parseCoordinates(this.value);
            nsGmx.leafletMap.panTo(coord);
            return false;
        }
    })

    showDialog(title, ui[0], 300, 80, false, false);
}

window.prompt = promptFunction;

};

})();

window.nsGmx = window.nsGmx || {};
window.nsGmx.GeomixerFrameworkVersion = '3.2.1';

/** GeoMixer virtual layer for standard tile raster layers (L.TileLayer)
*/
(function (){

'use strict';

//this function is copied from L.Utils and modified to allow missing data attributes
var template = function (str, data) {
    return str.replace(/\{ *([\w_]+) *\}/g, function (str, key) {
        var value = data[key];
        if (value === undefined) {
            value = '';
        } else if (typeof value === 'function') {
            value = value(data);
        }
        return value;
    });
};

var GmxVirtualTileLayer = function(/*options*/) {}

GmxVirtualTileLayer.prototype.initFromDescription = function(layerDescription) {
    var props = layerDescription.properties,
        meta = props.MetaProperties,
        urlTemplate = meta['url-template'] && meta['url-template'].Value,
        isMercator = !!meta['merc-projection'],
        options = {};

    if (!urlTemplate) {
        return new L.gmx.DummyLayer(props);
    }

    if (props.Copyright) {
        options.attribution = props.Copyright;
    }

    if (meta.minZoom) {
        options.minZoom = meta.minZoom.Value;
    }

    if (meta.maxZoom) {
        options.maxZoom = meta.maxZoom.Value;
    }

    if (meta.maxNativeZoom) {
        options.maxNativeZoom = meta.maxNativeZoom.Value;
    }

    var layer = (isMercator ? L.tileLayer.Mercator : L.tileLayer)(urlTemplate, options);

    layer.getGmxProperties = function() {
        return props;
    }

    return layer;
}

L.gmx.addLayerClass('TMS', GmxVirtualTileLayer);

//depricated - use "TMS" instead
L.gmx.addLayerClass('TiledRaster', GmxVirtualTileLayer);

var GmxVirtualWMSLayer = function(/*options*/) {}

GmxVirtualWMSLayer.prototype.initFromDescription = function(layerDescription) {
    var WMS_OPTIONS = ['layers', 'styles', 'format', 'transparent', 'version', 'minZoom', 'maxZoom', 'tileSize', 'f', 'bboxSR', 'imageSR', 'size'];
    var WMS_OPTIONS_PROCESSORS = {tileSize: parseInt};
    var props = layerDescription.properties,
        meta = props.MetaProperties,
        baseURL = meta['base-url'] && meta['base-url'].Value,
        options = {};

    if (!baseURL) {
        return new L.gmx.DummyLayer(props);
    }

    if (props.Copyright) {
        options.attribution = props.Copyright;
    }

    for (var p in meta) {
        if (WMS_OPTIONS.indexOf(p) !== -1) {
            options[p] = WMS_OPTIONS_PROCESSORS[p] ? WMS_OPTIONS_PROCESSORS[p](meta[p].Value) : meta[p].Value;
        }
    }

    var layer = L.tileLayer.wms(baseURL, options);

    layer.getGmxProperties = function() {
        return props;
    };

    var balloonTemplate = meta['balloonTemplate'] && meta['balloonTemplate'].Value;
    if (meta['clickable'] && balloonTemplate) {
        layer.options.clickable = true;

        layer.onRemove = function(map) {
            lastOpenedPopup && map.removeLayer(lastOpenedPopup);
            L.TileLayer.WMS.prototype.onRemove.apply(this, arguments);
        }

        var lastOpenedPopup;
        layer.gmxEventCheck = function(event) {
            if (event.type === 'click') {
                var p = this._map.project(event.latlng),
                    tileSize = layer.options.tileSize,
                    I = p.x % tileSize,
                    J = p.y % tileSize,
                    tilePoint = p.divideBy(tileSize).floor(),
                    url = this.getTileUrl(tilePoint);

                url = url.replace('=GetMap', '=GetFeatureInfo');
                url += '&X=' + I + '&Y=' + J + '&INFO_FORMAT=application/geojson&QUERY_LAYERS=' + options.layers;

				/*eslint-disable no-undef */
                $.getJSON(url).then(function(geoJSON) {
                    if (geoJSON.features[0]) {
                        var html = template(balloonTemplate, geoJSON.features[0].properties);
                        lastOpenedPopup = L.popup()
                            .setLatLng(event.latlng)
                            .setContent(html)
                            .openOn(this._map);
                    }
                }.bind(this));
				/*eslint-enable */
            }

            return 1;
        };
    }

    return layer;
}

L.gmx.addLayerClass('WMS', GmxVirtualWMSLayer);


var GmxPBXTileLayer = function(/*options*/) {}

GmxPBXTileLayer.prototype.initFromDescription = function(layerDescription) {
    var props = layerDescription.properties,
        meta = props.MetaProperties,
        urlTemplate = meta['url-template'] && meta['url-template'].Value,
        isMercator = !!meta['merc-projection'],
        options = {},
		mvtOptions = {};

    if (!urlTemplate) {
        return new L.gmx.DummyLayer(props);
    }

    if (props.Copyright) {
        options.attribution = props.Copyright;
    }

    if (meta.minZoom) {
        options.minZoom = meta.minZoom.Value;
    }

    if (meta.maxZoom) {
        options.maxZoom = meta.maxZoom.Value;
    }

	mvtOptions.url = urlTemplate;
	if (meta.debug) {
		mvtOptions.debug = meta.debug.Value === 'true';
    }
	if (meta.visibleLayers) {
		mvtOptions.visibleLayers = meta.visibleLayers.Value.split(',');
    }
	if (meta.clickableLayers) {
		mvtOptions.clickableLayers = meta.clickableLayers.Value.split(',');
    }
	if (meta.filter) {
	  /**
	   * The filter function gets called when iterating though each vector tile feature (vtf). You have access
	   * to every property associated with a given feature (the feature, and the layer). You can also filter
	   * based of the context (each tile that the feature is drawn onto).
	   *
	   * Returning false skips over the feature and it is not drawn.
	   *
	   * @param feature
	   * @returns {boolean}
	   */
		var filterLayers = meta.filter.Value.split(',');
		mvtOptions.filter = function(feature, context) {
			for (var i = 0, len = filterLayers.length; i < len; i++) {
				if (feature.layer.name === filterLayers[i]) {
				  return true;
				}
			}
			return false;
		};
    }
	var styleTypes = {
		1: {	//'Point'
			color: 'rgba(49,79,79,1)',
			radius: 5,
			selected: {
			  color: 'rgba(255,255,0,0.5)',
			  radius: 6
			}
		},
		2: {	//'LineString'
			color: 'rgba(161,217,155,0.8)',
			size: 3,
			selected: {
			  color: 'rgba(255,25,0,0.5)',
			  size: 4
			}
		},
		3: {	//'Polygon'
			color: 'rgba(149,139,255,0.4)',
			outline: {
			  color: 'rgb(20,20,20)',
			  size: 1
			},
			selected: {
			  color: 'rgba(255,140,0,0.3)',
				outline: {
				  color: 'rgba(255,140,0,1)',
				  size: 2
				}
			}
		}
	};
	if (meta.style) {
		styleTypes = JSON.parse(meta.style.Value);
	}
	mvtOptions.style = function (feature) {
		var type = feature.type;
		// var name = feature.layer.name;
		return styleTypes[type] || {};
    }

	var mvtSource = new L.TileLayer.MVTSource(Object.assign(mvtOptions, {
	  getIDForLayerFeature: function(feature) {
		return feature._id;
	  },

	  /**
	   * When we want to link events between layers, like clicking on a label and a
	   * corresponding polygon freature, this will return the corresponding mapping
	   * between layers. This provides knowledge of which other feature a given feature
	   * is linked to.
	   *
	   * @param layerName  the layer we want to know the linked layer from
	   * @returns {string} returns corresponding linked layer
	   */
	  layerLink: function(layerName) {
		if (layerName.indexOf('_label') > -1) {
		  return layerName.replace('_label','');
		}
		return layerName + '_label';
	  }

	}));

    mvtSource.getGmxProperties = function() {
        return props;
    }

    return mvtSource;
}

L.gmx.addLayerClass('PBX', GmxPBXTileLayer);

})();
